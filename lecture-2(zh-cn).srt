1
00:00:07,570 --> 00:00:11,230
我是Erik Demaine  叫我Erik就好

2
00:00:11,960 --> 00:00:14,530
欢迎回到6.046的课堂  这是第二讲

3
00:00:15,230 --> 00:00:20,030
今天我们要好好巩固一下

4
00:00:20,120 --> 00:00:24,360
在第一讲提到的数学基础

5
00:00:24,540 --> 00:00:27,060
第一讲  我们稍稍涉及到了

6
00:00:27,060 --> 00:00:29,040
一点算法分析

7
00:00:29,040 --> 00:00:30,430
插入排序和归并排序

8
00:00:30,720 --> 00:00:33,070
我们需要一些处理工具

9
00:00:33,200 --> 00:00:34,740
我们有了渐近的大局观

10
00:00:34,820 --> 00:00:36,350
就是忽略常数

11
00:00:36,410 --> 00:00:37,480
只关注打头那一项

12
00:00:38,010 --> 00:00:41,300
今天我们从数学的角度

13
00:00:41,300 --> 00:00:43,300
介绍渐近符号

14
00:00:43,710 --> 00:00:47,130
我们上次快结束时讲到了归并排序中的递归式

15
00:00:47,130 --> 00:00:48,180
用已计算归并排序的运行时间

16
00:00:48,240 --> 00:00:50,180
这样得先知道如何求解递归式

17
00:00:50,380 --> 00:00:52,550
今天就讲两件事

18
00:00:52,600 --> 00:00:53,330
有问题吗

19
00:00:54,730 --> 00:00:56,590
行  我大声点  谢谢

20
00:00:57,520 --> 00:01:01,290
虽然带了麦克风  但是功放没开

21
00:01:01,960 --> 00:01:05,000
好的  开始讲渐近符号

22
00:01:14,830 --> 00:01:17,350
有些基本的渐近符号

23
00:01:17,490 --> 00:01:19,260
你肯定在其他课见过

24
00:01:19,570 --> 00:01:21,030
比如大O符号

25
00:01:22,110 --> 00:01:27,130
今天  给它一个严格的定义

26
00:01:27,130 --> 00:01:29,650
这样才能了解什么成立　什么不成立

27
00:01:29,850 --> 00:01:31,980
以确什么合法　什么不合法

28
00:01:38,620 --> 00:01:40,860
我们定义

29
00:01:41,870 --> 00:01:45,360
不幸  今天讲的都是数学

30
00:01:45,700 --> 00:01:47,200
不涉及算法

31
00:01:47,210 --> 00:01:49,550
有点扫兴

32
00:01:49,610 --> 00:01:52,770
但是下一讲会完全讨论算法

33
00:01:52,850 --> 00:01:54,340
并应用到今天的内容

34
00:01:54,340 --> 00:01:55,970
到那些算法上

35
00:01:57,940 --> 00:02:01,610
这是大O符号  大写的O

36
00:02:01,810 --> 00:02:04,780
这是  f(n)=O(g(n))

37
00:02:04,940 --> 00:02:13,680
表示存在适当的常数

38
00:02:15,760 --> 00:02:19,700
c和n₀

39
00:02:24,600 --> 00:02:29,830
使得f(n)小于或等于c·g(n)

40
00:02:30,910 --> 00:02:33,810
对于充分大的n成立

41
00:02:36,710 --> 00:02:39,180
这个很符合直觉

42
00:02:39,220 --> 00:02:40,180
以前见过

43
00:02:40,200 --> 00:02:43,700
这里要假设f(n)非负

44
00:02:44,110 --> 00:02:47,390
我只是要使得f(n)以g(n)为上界

45
00:02:47,770 --> 00:02:50,740
有很多例子

46
00:02:50,770 --> 00:02:58,780
比如  2n²=O(n³)

47
00:02:59,360 --> 00:03:04,730
粗略的说  去掉首项系数

48
00:03:04,780 --> 00:03:07,750
和低阶项  剩下的小于或等于n³

49
00:03:07,880 --> 00:03:10,370
大O粗略地说就是小于或等于

50
00:03:11,130 --> 00:03:13,030
这是其公式化定义

51
00:03:13,450 --> 00:03:16,000
从另外一个角度来看

52
00:03:16,870 --> 00:03:19,320
这个符号有意思的地方在于　它并不对称

53
00:03:19,400 --> 00:03:21,900
一般来说  你会认为等号是对称的

54
00:03:21,960 --> 00:03:23,740
如果A等于B  则B等于A

55
00:03:23,740 --> 00:03:24,840
但是这里不是

56
00:03:25,130 --> 00:03:28,330
n³并非O(n²)

57
00:03:28,590 --> 00:03:31,620
甚至O(n³)也并不等于n²

58
00:03:31,700 --> 00:03:34,830
等下你就知道为什么了

59
00:03:36,150 --> 00:03:37,950
在这之前

60
00:03:40,720 --> 00:03:44,190
这是个有点奇怪的符号

61
00:03:44,370 --> 00:03:46,490
要时时想着它到底代表什么

62
00:03:48,000 --> 00:03:50,470
另一个反映它本质的想法是

63
00:03:50,470 --> 00:03:55,000
f(n)属于g(n)构成的函数集

64
00:03:55,350 --> 00:04:01,280
可以定义O(g(n))为一个函数集

65
00:04:01,370 --> 00:04:04,360
集合内的函数记作f(n)

66
00:04:06,610 --> 00:04:09,280
对于这些函数  存在常数

67
00:04:11,200 --> 00:04:12,880
同样的定义

68
00:04:13,330 --> 00:04:17,730
我觉得这个妙不可言  c和n₀

69
00:04:19,540 --> 00:04:25,840
使得f(n)以0和c·g(n)为界

70
00:04:32,140 --> 00:04:33,570
很长的定义

71
00:04:33,570 --> 00:04:35,360
这也是为什么要使用符号

72
00:04:35,370 --> 00:04:37,120
这样不用反复写这定义

73
00:04:37,790 --> 00:04:40,610
不能把它理解为

74
00:04:40,610 --> 00:04:42,600
n²等于O(n³)

75
00:04:42,600 --> 00:04:47,680
而只能理解为2n²属于函数集O(n³)

76
00:04:48,200 --> 00:04:50,300
我们写的是等于号

77
00:04:50,370 --> 00:04:55,060
但表达的意思是属于某个集合

78
00:04:55,520 --> 00:04:57,000
但我们还是照样写等于号

79
00:04:57,000 --> 00:04:57,900
这么写没问题

80
00:04:58,080 --> 00:04:59,990
偶尔能看到些论文这样写

81
00:04:59,990 --> 00:05:03,990
但是我们以后还是用这个符号

82
00:05:04,110 --> 00:05:06,590
由上可知  这个等号是不对称的

83
00:05:06,730 --> 00:05:09,960
就像这个属于集合符号

84
00:05:11,270 --> 00:05:14,950
我们还有一些大O符号的

85
00:05:15,000 --> 00:05:16,980
精妙用法

86
00:05:26,880 --> 00:05:28,440
这里  把它当做宏来用

87
00:05:31,030 --> 00:05:33,100
顺便说下  今天内容很多

88
00:05:33,260 --> 00:05:34,630
我相对要讲的快点

89
00:05:34,780 --> 00:05:35,470
如果哪儿不明白

90
00:05:35,650 --> 00:05:38,470
向我提问  我就停下来细说

91
00:05:38,520 --> 00:05:40,690
否则  我假设大家都明白了

92
00:05:40,720 --> 00:05:42,870
然后全速前进

93
00:05:44,780 --> 00:05:51,970
宏的用法很直观

94
00:05:51,970 --> 00:05:55,290
如果你写过带宏的程序的话

95
00:05:57,450 --> 00:05:59,650
但这里多点数学

96
00:06:07,710 --> 00:06:09,790
我们定义了大O符号

97
00:06:10,110 --> 00:06:12,600
某个函数等于某个大O符号

98
00:06:15,890 --> 00:06:17,680
但我们只定义了某个函数等于

99
00:06:17,920 --> 00:06:21,210
某个大O符号的用法

100
00:06:21,450 --> 00:06:23,700
但是如果有某些置于更一般的表达式右侧的

101
00:06:23,700 --> 00:06:25,720
大O符号　就会更有用处

102
00:06:25,840 --> 00:06:35,110
比如  f(n)=n³+O(n²)

103
00:06:37,400 --> 00:06:40,000
这里表示了一个误差界限

104
00:06:40,020 --> 00:06:42,450
意思是 f(n)主要是n³

105
00:06:42,500 --> 00:06:45,260
但是还有一些低阶项O(n²)

106
00:06:45,500 --> 00:06:51,190
具体来说 即存在某函数

107
00:06:56,450 --> 00:07:02,400
h(n)在函数集O(n²)中

108
00:07:03,010 --> 00:07:14,810
使得f(n)=n³+h(n)

109
00:07:16,510 --> 00:07:19,090
总的来说  有低阶项

110
00:07:19,150 --> 00:07:21,740
以某个常数乘以n²为上界

111
00:07:21,750 --> 00:07:23,060
对于足够大的n成立

112
00:07:23,560 --> 00:07:24,770
就是这个

113
00:07:25,290 --> 00:07:28,080
现在f(n)等于  现在是真正的等于

114
00:07:28,180 --> 00:07:30,020
n³加上那个误差项

115
00:07:30,310 --> 00:07:32,360
这很有用

116
00:07:32,480 --> 00:07:35,040
重点在于描述首项是什么

117
00:07:35,170 --> 00:07:36,020
然后说

118
00:07:36,020 --> 00:07:38,370
再加上至多为n²阶的项

119
00:07:38,710 --> 00:07:41,730
可以说f(n)因此是三阶的

120
00:07:41,750 --> 00:07:43,900
但这么说比较含糊

121
00:07:44,280 --> 00:07:45,740
加上代表低阶项的大O符号更完善

122
00:07:45,950 --> 00:07:48,410
这种表达式不会用的太多  但是用处很大

123
00:07:48,460 --> 00:07:49,420
有时我们看到

124
00:07:49,450 --> 00:07:52,100
像上讲课  大O符号出现在求和计算里

125
00:07:52,320 --> 00:07:53,570
很多地方都可以用

126
00:07:53,610 --> 00:07:57,170
符号代表其所在集合中的某个函数

127
00:07:59,190 --> 00:08:02,970
接下来的不太直观  更微妙一点

128
00:08:06,040 --> 00:08:08,540
如果大O符号出现在等号左边代表什么

129
00:08:09,050 --> 00:08:10,320
和之前一样

130
00:08:10,320 --> 00:08:16,160
但是等号不代表同一个意思

131
00:08:16,250 --> 00:08:19,310
这是为什么此处等号不对称

132
00:08:20,510 --> 00:08:24,110
不是相等  而是"是"

133
00:08:25,340 --> 00:08:30,080
"是"表示所有左边的就是右边的

134
00:08:30,250 --> 00:08:32,760
在这里等号左边隐含了一个任意量词

135
00:08:32,800 --> 00:08:34,380
等号的右边隐含了一个存在量词

136
00:08:34,440 --> 00:08:35,580
这个等式是正确的

137
00:08:35,610 --> 00:08:40,180
任何n²+O(n)都是O(n²)

138
00:08:40,510 --> 00:08:41,910
反之则不然

139
00:08:42,170 --> 00:08:44,320
所以不对称

140
00:08:47,750 --> 00:08:50,230
想想其实挺直观的

141
00:08:50,940 --> 00:08:56,370
但是很微妙  所以要小心

142
00:09:13,280 --> 00:09:16,580
对于任何在左边宏展开的表示式

143
00:09:17,810 --> 00:09:19,800
假设是f(n)

144
00:09:21,080 --> 00:09:22,850
都能在右边找到一个

145
00:09:22,870 --> 00:09:25,220
对应的展开  使得左右相等

146
00:09:27,970 --> 00:09:29,670
有了这个概念

147
00:09:29,700 --> 00:09:32,110
如果你有一个等式关系链

148
00:09:32,190 --> 00:09:33,040
通过"某是某"组成的链式表达式

149
00:09:33,130 --> 00:09:35,570
第一个就等于最后一个

150
00:09:35,640 --> 00:09:37,270
或者以最后一个为上界

151
00:09:37,330 --> 00:09:39,530
等式可以通过链从前往后传递下去

152
00:09:39,530 --> 00:09:43,220
但是不能反过来  从后往前

153
00:09:43,680 --> 00:09:48,410
以上就是大O符号  有问题吗

154
00:09:55,870 --> 00:09:58,380
大O符号很好的表示了上界

155
00:09:58,760 --> 00:10:01,520
但是我们还需要下界

156
00:10:02,440 --> 00:10:04,800
对于算法  通常考虑

157
00:10:04,800 --> 00:10:06,360
的是运行时间的上界

158
00:10:06,430 --> 00:10:09,830
运行时间最多是n²或nlgn

159
00:10:10,680 --> 00:10:12,600
但有时需要表示函数

160
00:10:12,600 --> 00:10:14,270
的最小值

161
00:10:15,190 --> 00:10:17,110
举例来说  之后会看到排序算法

162
00:10:17,110 --> 00:10:19,720
在一些模型中至少要nlgn的时间

163
00:10:19,870 --> 00:10:21,980
需要其他的符号

164
00:10:23,960 --> 00:10:28,150
就是大Ω符号

165
00:10:30,960 --> 00:10:33,950
和之前的挺相似

166
00:10:34,390 --> 00:10:37,550
我就只写集合版定义了

167
00:10:38,720 --> 00:10:42,200
f(n)等于Ω(g(n))意思是

168
00:10:42,200 --> 00:10:46,280
f(n)大于等于某个常数乘以g(n)

169
00:10:53,230 --> 00:10:54,880
对于足够大的n成立

170
00:11:06,710 --> 00:11:11,490
我只是颠倒了f和g的不等关系

171
00:11:11,500 --> 00:11:14,370
没什么特别的

172
00:11:15,410 --> 00:11:16,800
就写在这儿

173
00:11:19,340 --> 00:11:20,650
随便举个例子

174
00:11:20,680 --> 00:11:22,550
来个复杂点的

175
00:11:22,780 --> 00:11:25,790
n的平方根等于Ω(lgn)

176
00:11:25,790 --> 00:11:28,840
你应该这样理解  对于充分大的n

177
00:11:28,880 --> 00:11:31,780
根号n至少是lgn的常数倍

178
00:11:32,910 --> 00:11:37,480
所以  Ω基本上对应大于或者等于

179
00:11:37,600 --> 00:11:40,010
给你一些类比

180
00:11:43,500 --> 00:11:46,600
我们有大O  大Ω

181
00:11:46,970 --> 00:11:49,220
这是小于等于

182
00:11:49,450 --> 00:11:50,840
这是大于等于

183
00:11:50,880 --> 00:11:53,660
等会儿还有一些

184
00:12:08,770 --> 00:12:11,650
通常的符号这里都有

185
00:12:11,710 --> 00:12:12,980
通常的符号有小于

186
00:12:12,980 --> 00:12:14,940
大于还有等于

187
00:12:15,100 --> 00:12:18,850
我们希望在渐近世界里也有类似符号

188
00:12:18,890 --> 00:12:20,450
只是忽略了系数

189
00:12:20,560 --> 00:12:22,660
和低阶项

190
00:12:22,880 --> 00:12:26,330
比如  有大Θ

191
00:12:26,440 --> 00:12:27,930
大写的Θ

192
00:12:28,230 --> 00:12:31,050
所以在横线应该画在中间

193
00:12:31,050 --> 00:12:32,390
但别挨着圆圈

194
00:12:32,580 --> 00:12:35,900
希腊文可不是我发明的  它就是写成那个熊样

195
00:12:36,930 --> 00:12:39,310
Θ表示小于等于

196
00:12:39,320 --> 00:12:40,930
并且大于等于

197
00:12:41,720 --> 00:12:43,150
对于特定常数

198
00:12:44,010 --> 00:12:46,160
因此它是这两个集合的交集

199
00:12:46,180 --> 00:12:47,740
O和Ω

200
00:12:53,290 --> 00:12:54,700
因此它有点类似于等于号

201
00:12:54,790 --> 00:12:56,250
但显然它和等于号是不同的

202
00:12:56,450 --> 00:13:00,070
你可以看到n²=Θ(n²)

203
00:13:00,230 --> 00:13:02,270
因为你忽略了前面的常数系数

204
00:13:02,330 --> 00:13:04,760
但是其他所有的关系

205
00:13:04,770 --> 00:13:08,280
好  n²+O(n)=Θ(n²)

206
00:13:08,970 --> 00:13:10,540
但是这里对于Θ不成立

207
00:13:10,590 --> 00:13:12,650
因为n的平方根

208
00:13:12,700 --> 00:13:14,320
的确渐进地大于lgn

209
00:13:14,650 --> 00:13:16,320
此外对于其他的例子

210
00:13:16,390 --> 00:13:21,180
我们看到n²跟n³相比  它们对于Θ是不成立的

211
00:13:23,380 --> 00:13:28,650
我们介绍一下一些严格符号

212
00:13:32,200 --> 00:13:38,850
它们是o和ω

213
00:13:38,930 --> 00:13:41,530
没有相应的小Θ因为没有

214
00:13:41,530 --> 00:13:44,730
相对应的严格等号和不严格等号

215
00:13:44,990 --> 00:13:47,790
o大致相当于小于

216
00:13:48,020 --> 00:13:51,330
而ω大致相当于大于

217
00:13:51,490 --> 00:13:54,170
这个符号你们以后会常常用

218
00:13:54,920 --> 00:13:58,560
我这里就不给出精确定义了

219
00:13:58,770 --> 00:14:00,730
因为它们的含义几乎一样

220
00:14:00,930 --> 00:14:02,270
区别在于

221
00:14:02,270 --> 00:14:04,760
并不是“存在”某个常数c和n₀

222
00:14:04,850 --> 00:14:07,140
而是你们应该说对于“任意”常数c

223
00:14:07,310 --> 00:14:09,590
都存在一个常数 n₀

224
00:14:12,410 --> 00:14:14,340
函数f和g之间的关系

225
00:14:14,380 --> 00:14:24,740
不等式要对所有的c成立

226
00:14:29,100 --> 00:14:31,930
因此现在的n₀依赖于c

227
00:14:33,150 --> 00:14:36,900
你可以假设n可以足够大

228
00:14:36,940 --> 00:14:39,040
但这个是严格的不等于

229
00:14:39,070 --> 00:14:41,910
不管在函数g前设置多大的常数系数

230
00:14:42,200 --> 00:14:44,080
我们说的是小o

231
00:14:44,230 --> 00:14:45,990
不管在函数g前设置多大的常数系数

232
00:14:46,140 --> 00:14:47,920
当n足够大时 f仍然小于

233
00:14:48,020 --> 00:14:50,270
c乘以g

234
00:14:51,420 --> 00:14:54,920
我们随便举一些例子

235
00:15:03,280 --> 00:15:05,030
我们依然忽略常数系数

236
00:15:05,030 --> 00:15:08,870
n足够大时n²总是小于n³

237
00:15:09,040 --> 00:15:10,410
这里有些微妙之处

238
00:15:10,450 --> 00:15:13,490
为了证明类似这样的公式

239
00:15:13,650 --> 00:15:17,210
在你掌握这样一些后 它就会变成你直觉的一部分

240
00:15:17,300 --> 00:15:21,270
你得找出用c表示的n₀表达式

241
00:15:21,730 --> 00:15:25,520
我认为应该是2/c

242
00:15:29,780 --> 00:15:32,740
如果是小于或者等于 那应该是这样

243
00:15:32,740 --> 00:15:35,870
只要n至少这么大

244
00:15:36,120 --> 00:15:38,360
不管c有多小

245
00:15:38,440 --> 00:15:40,800
这里你可以将c当作ε

246
00:15:40,860 --> 00:15:42,620
在常规的ε-δ语言中

247
00:15:43,160 --> 00:15:45,610
不管c能达到多小

248
00:15:45,680 --> 00:15:50,170
我仍然能够用n³将n²的上界加以限定

249
00:15:50,620 --> 00:15:53,140
但是当在Θ情况时

250
00:15:53,170 --> 00:15:54,820
将不会有上面的这些关系

251
00:15:55,000 --> 00:16:04,970
比如 n²/2=Θ(n²) 但它不是小o

252
00:16:05,280 --> 00:16:08,080
同时也不是ω 因为它是严格的n²

253
00:16:08,230 --> 00:16:11,410
从这些例子上你会得到一些直观感觉

254
00:16:11,470 --> 00:16:15,690
虽然他们的呈现出来的行为比较杂乱

255
00:16:16,450 --> 00:16:17,840
正如你在习题集里看到的那样

256
00:16:18,760 --> 00:16:20,920
有关于渐进关系的问题吗

257
00:16:21,060 --> 00:16:22,470
这个知识我们就这样快速地扫一下

258
00:16:22,690 --> 00:16:25,550
现在我们将要用这个来解一些递归

259
00:16:26,740 --> 00:16:29,610
虽然今天我们用得不多

260
00:16:29,660 --> 00:16:31,820
星期三我们将大量应用

261
00:16:32,850 --> 00:16:33,690
好

262
00:16:51,600 --> 00:16:54,600
我们进入今天的第二个主题

263
00:16:54,620 --> 00:16:56,420
就是 解递归式

264
00:16:58,130 --> 00:16:59,960
你们可能已经会解一些递归

265
00:16:59,960 --> 00:17:05,710
在6.042里或者在离散数学课里你们掌握的

266
00:17:05,910 --> 00:17:08,680
我们今天将做更多这样的工作并且有更多的方法

267
00:17:08,720 --> 00:17:11,870
这对于分析递归算法尤其有用

268
00:17:12,410 --> 00:17:14,690
递归算法放在星期三讲

269
00:17:15,600 --> 00:17:18,370
这里我们主要有三种主要方法

270
00:17:18,380 --> 00:17:22,340
来解递归式

271
00:17:23,260 --> 00:17:25,390
第一个是代换法

272
00:17:27,720 --> 00:17:31,270
迄今还没有一个通用的方法来解递归问题

273
00:17:31,340 --> 00:17:34,440
不幸的是没有一个好的算法来解递归问题

274
00:17:34,440 --> 00:17:36,490
我们仅仅有一堆方法

275
00:17:36,500 --> 00:17:37,990
有的时候这些方法有用

276
00:17:38,200 --> 00:17:41,370
如果幸运你自己的方法可以解你遇到的递归

277
00:17:41,540 --> 00:17:43,720
这就有点类似于做积分

278
00:17:43,780 --> 00:17:45,280
积分也没有通用的方法

279
00:17:45,300 --> 00:17:47,500
你必须学习各种各样的方法才能做出积分

280
00:17:47,540 --> 00:17:51,110
但是一般来说　检查是否得到正确答案是容易的

281
00:17:51,110 --> 00:17:52,260
就像积分题目那样

282
00:17:52,290 --> 00:17:54,610
你仅仅需要求微分  然后说　嗨　我做出来了

283
00:17:54,890 --> 00:17:58,620
这个是代换法的主要思想

284
00:17:59,090 --> 00:18:01,140
代换法大多数情况下是有效的

285
00:18:02,510 --> 00:18:05,960
但是不幸的是第一步是猜答案

286
00:18:06,240 --> 00:18:08,730
你必须猜对它

287
00:18:09,630 --> 00:18:11,310
这造成了很大的困难

288
00:18:12,380 --> 00:18:14,780
你不需要完全猜出来

289
00:18:15,000 --> 00:18:18,620
你可以不需要知道常数系数确切是多少

290
00:18:18,620 --> 00:18:19,730
这很不错　因为我们

291
00:18:19,730 --> 00:18:21,420
并不十分在意常数系数

292
00:18:21,670 --> 00:18:25,420
你仅需要猜它的形式 你可以猜大概是n²

293
00:18:25,670 --> 00:18:28,540
因此它是n²乘上一个常数系数

294
00:18:29,100 --> 00:18:29,830
你这么猜

295
00:18:29,840 --> 00:18:31,450
然后我们再试图解出它的常数

296
00:18:31,550 --> 00:18:35,000
你试着去验证是否这个递归式

297
00:18:35,000 --> 00:18:39,370
按照数学归纳法满足条件

298
00:18:39,410 --> 00:18:40,070
而这个是问题关键

299
00:18:40,070 --> 00:18:41,830
代换法使用归纳

300
00:18:42,280 --> 00:18:45,500
然后从那里可以容易地获得常数系数

301
00:18:45,680 --> 00:18:47,380
你设法找出什么系数

302
00:18:47,460 --> 00:18:50,640
可以使问题成立

303
00:18:51,300 --> 00:18:52,570
好的 这是主要思想

304
00:18:52,730 --> 00:18:54,650
先看一些例子

305
00:18:54,680 --> 00:18:56,810
正确地说 一样的例子使用多次

306
00:18:58,560 --> 00:19:04,140
不幸的是 你们可以说这是

307
00:19:06,080 --> 00:19:07,150
这是一个算法

308
00:19:07,180 --> 00:19:09,780
但我们需要预知正确答案

309
00:19:09,820 --> 00:19:11,970
但是有时并不是很难猜对答案

310
00:19:13,100 --> 00:19:14,250
这要看情况

311
00:19:14,360 --> 00:19:19,380
请看这个递归式T=4T(n/2)+n

312
00:19:19,580 --> 00:19:22,440
这里总是需要含有一些基本情况

313
00:19:22,830 --> 00:19:26,920
T前面某项 通常是第一项 它是一个常数

314
00:19:26,990 --> 00:19:28,870
我不是非常在意这些基本情况

315
00:19:29,000 --> 00:19:31,000
对于算法来说通常都是这样的

316
00:19:32,460 --> 00:19:33,780
我们想解这个问题

317
00:19:34,550 --> 00:19:37,210
有人能猜一个答案吗

318
00:19:37,390 --> 00:19:38,870
一般还是有些人不知道

319
00:19:38,870 --> 00:19:40,420
怎么解这个递归式

320
00:19:41,280 --> 00:19:43,490
好的 有多少人知道怎么解这个递归式

321
00:19:43,800 --> 00:19:46,440
有一些 好的

322
00:19:46,620 --> 00:19:49,400
其他人呢 谁猜出来了

323
00:19:50,170 --> 00:19:52,240
如果你们看这个公式的形态

324
00:19:52,400 --> 00:19:55,970
这里你有T(n/2)项 我们先忽略这一项

325
00:19:57,180 --> 00:20:00,940
这里是n/2  当加倍得到T(n)时

326
00:20:01,050 --> 00:20:03,470
我们得到了乘数4

327
00:20:03,530 --> 00:20:04,430
然后是这个加法余项

328
00:20:04,430 --> 00:20:06,190
但是这一项不是很重要

329
00:20:06,280 --> 00:20:08,750
你知道哪一个函数在你对参数加倍时

330
00:20:08,840 --> 00:20:10,920
输出增加到4倍

331
00:20:12,530 --> 00:20:14,950
不好意思  n² 对的

332
00:20:15,040 --> 00:20:19,760
如果你认为是n²那么你是对的

333
00:20:19,890 --> 00:20:21,780
但我们现在还没有证明是n²

334
00:20:21,780 --> 00:20:23,940
我们先证明一些更简单的

335
00:20:24,050 --> 00:20:25,230
因为想要直接证明

336
00:20:25,230 --> 00:20:27,210
最多是n² 是很困难的

337
00:20:27,800 --> 00:20:29,750
接下来的几分钟里我们将会看到这些

338
00:20:30,030 --> 00:20:33,760
我们先猜想T=O(n³)

339
00:20:33,800 --> 00:20:37,200
因为这个更易通过归纳法来证明

340
00:20:37,200 --> 00:20:39,180
你们有多少人能看出在基本情况下怎么做

341
00:20:39,420 --> 00:20:42,850
然后　我们可以得到正确的答案 n²

342
00:20:43,210 --> 00:20:46,250
我需要去证明 我所做的是去猜出

343
00:20:46,250 --> 00:20:50,920
T至多n³乘以一个常数

344
00:20:51,010 --> 00:20:53,150
我会更精确一点

345
00:20:53,160 --> 00:20:56,850
在代换法中我不能用O符号

346
00:20:56,880 --> 00:21:02,790
因此我需要用常数来展开它

347
00:21:04,030 --> 00:21:07,480
我给你们展示一下为什么

348
00:21:09,880 --> 00:21:12,980
让我在较高层次上告诉你们

349
00:21:13,080 --> 00:21:14,990
没有使用O符号的关键之处在哪里

350
00:21:15,100 --> 00:21:16,510
大O符号很棒

351
00:21:16,640 --> 00:21:20,410
如果你有一个有穷的大O关系序列 比如

352
00:21:20,490 --> 00:21:25,650
n²　是O(n³)的　是O(n⁴)的　是O(n⁴)的　是O(n⁴)的

353
00:21:25,670 --> 00:21:29,210
这些都是对的 因此你得到n²是O(n⁴)

354
00:21:29,530 --> 00:21:32,470
但是如果你有一个无穷的大O关系序列

355
00:21:32,650 --> 00:21:35,490
那么第一项和最后一项的大O关系就不成立了

356
00:21:35,620 --> 00:21:37,310
你需要很小心仔细

357
00:21:37,530 --> 00:21:41,590
举个例子 这个完全超出了讲义的范围

358
00:21:41,740 --> 00:21:45,400
假设你想证明n=O(1)

359
00:21:45,700 --> 00:21:46,620
这是个很重要的关系

360
00:21:46,620 --> 00:21:49,640
如果这个是真的 那任何算法将是常数复杂度

361
00:21:49,850 --> 00:21:51,000
显然这是假的

362
00:21:52,910 --> 00:21:56,710
在这些符号里是假的

363
00:21:57,770 --> 00:22:01,130
你可以通过归纳假设来证明这个

364
00:22:01,130 --> 00:22:04,650
从完备性上 基本情况是1=O(1)

365
00:22:04,700 --> 00:22:06,780
这个是真的

366
00:22:06,890 --> 00:22:08,530
然后是归纳步骤

367
00:22:08,600 --> 00:22:14,290
如果我知道假设n-1=O(1)

368
00:22:15,130 --> 00:22:20,930
那可以推出n=(n-1)+1

369
00:22:21,220 --> 00:22:27,610
如果这个是O(1)并且 1=O(1) 所以总的是O(1)

370
00:22:27,820 --> 00:22:29,110
因此是真的

371
00:22:29,170 --> 00:22:33,890
如果你知道n-1=O(1)和1=O(1)然后它们的和是O(1)

372
00:22:34,110 --> 00:22:35,820
但是这个是错误的证明

373
00:22:35,820 --> 00:22:37,860
你不能在这些大O的符号上进行归纳

374
00:22:38,040 --> 00:22:39,740
这里出现的问题是这些常数

375
00:22:39,740 --> 00:22:41,480
它们其实是变化的

376
00:22:41,570 --> 00:22:42,530
这里你有一些O(1)

377
00:22:42,530 --> 00:22:44,110
这里你有一些O(1)

378
00:22:44,240 --> 00:22:47,000
你可能对这些常数加倍

379
00:22:47,040 --> 00:22:48,720
你每次做这些东西的时候

380
00:22:48,720 --> 00:22:50,680
如果你是有穷数量的常数加倍

381
00:22:50,720 --> 00:22:52,040
没大问题 它仍然是常数

382
00:22:52,070 --> 00:22:53,880
二的某个数幂次加倍

383
00:22:54,090 --> 00:22:56,880
但是当你进行n次加倍的时候就不对了

384
00:22:57,380 --> 00:23:00,710
现在　该是常数依赖于n变化的

385
00:23:00,780 --> 00:23:02,930
因此我们需要避免这类问题

386
00:23:03,110 --> 00:23:04,610
一旦我们写出常数

387
00:23:04,650 --> 00:23:06,830
我们需要保证这些常数不会变化

388
00:23:08,170 --> 00:23:08,990
好

389
00:23:10,860 --> 00:23:12,240
现在我已经写出了常数

390
00:23:12,240 --> 00:23:12,890
现在应该保险了

391
00:23:12,920 --> 00:23:16,810
我假设对于所有小于n的k

392
00:23:16,910 --> 00:23:19,290
现在我得证明对于k等于n的情况

393
00:23:19,670 --> 00:23:25,400
我要把T(n)拿出来展开

394
00:23:25,500 --> 00:23:26,660
我下面要做的很明显

395
00:23:26,660 --> 00:23:28,870
我可以根据这个递归算式展开T(n)

396
00:23:28,930 --> 00:23:30,010
而这有涉及到T(n/2)

397
00:23:30,010 --> 00:23:32,710
我又知道一些T(n/2)的条件

398
00:23:32,730 --> 00:23:35,040
因为n/2小于n

399
00:23:35,650 --> 00:23:42,080
于是我们一起把T(n)展开 T(n)=4T(n/2)+n

400
00:23:42,700 --> 00:23:44,890
现在我根据之前的归纳假设

401
00:23:45,020 --> 00:23:47,430
知道这部分的值域上界

402
00:23:48,290 --> 00:23:58,530
这就是T(n/2)小于等于4c(n/2)³加n

403
00:24:05,990 --> 00:24:08,960
我想 等我课上完了

404
00:24:09,510 --> 00:24:12,570
这黑板也就彻底卡住了

405
00:24:16,470 --> 00:24:18,380
推不上去了  好了

406
00:24:22,630 --> 00:24:24,360
行了  我就用半块黑板好了

407
00:24:31,800 --> 00:24:33,850
我倒希望是我的神力弄坏的

408
00:24:33,850 --> 00:24:36,460
不过我确信是黑板的质量问题

409
00:24:37,490 --> 00:24:38,780
或者是滑轨的问题

410
00:24:40,520 --> 00:24:43,390
我们接上面继续展开

411
00:24:44,320 --> 00:24:51,870
2的三次方分之n的三次方

412
00:24:52,000 --> 00:24:55,640
2的三次幂是8  4除以8是1/2

413
00:24:56,070 --> 00:25:03,420
也就是1/2·c·n³+n

414
00:25:05,100 --> 00:25:08,270
我想要把它化简成为

415
00:25:08,390 --> 00:25:10,160
最终的理想形式是

416
00:25:10,200 --> 00:25:13,990
小于等于c·n³

417
00:25:15,180 --> 00:25:17,630
这就是我想证明的

418
00:25:17,630 --> 00:25:19,480
能把它还原成为对n的归纳假设

419
00:25:19,840 --> 00:25:22,200
为了确定此结果成立的条件

420
00:25:22,290 --> 00:25:25,420
我先直接把理想的结果写上

421
00:25:25,800 --> 00:25:31,250
这是我想要的理想结果  c·n³

422
00:25:31,300 --> 00:25:32,810
减去我想化简掉的部分

423
00:25:32,810 --> 00:25:36,630
这部分是余项

424
00:25:41,110 --> 00:25:42,770
现在我得想办法凑出这个余项

425
00:25:42,870 --> 00:25:45,680
大家看  这里是c·n³但上面只有1/2cn³

426
00:25:45,680 --> 00:25:51,240
所以我这里要减去一个1/2cn³让第一项正确

427
00:25:51,240 --> 00:25:52,890
上面是加n  加上括号

428
00:25:52,890 --> 00:25:54,910
就变成减n

429
00:25:55,750 --> 00:25:57,480
这就是余项

430
00:25:57,580 --> 00:25:59,490
为了让cn³成为最大值

431
00:25:59,720 --> 00:26:02,530
我需要保证余项是非负的

432
00:26:02,770 --> 00:26:10,660
所以条件是  余项大于等于零

433
00:26:11,750 --> 00:26:15,470
这点很容易保证  因为我可以设定c的取值

434
00:26:15,650 --> 00:26:17,830
我可以赋予c任何我想要的数值

435
00:26:18,050 --> 00:26:22,560
而且只要不小于  我想想  2的话

436
00:26:22,660 --> 00:26:25,700
那这部分最小就是1

437
00:26:25,700 --> 00:26:28,590
我就得到了n³大于等于n

438
00:26:28,610 --> 00:26:30,130
此不等式永远成立

439
00:26:30,670 --> 00:26:38,250
比如  当c大于等于1时不等式成立

440
00:26:38,250 --> 00:26:41,250
n取多少应该关系不大

441
00:26:41,320 --> 00:26:45,990
不过我们还是写上n大于等于1

442
00:26:47,600 --> 00:26:50,590
那么  我们就证明了

443
00:26:50,590 --> 00:26:54,210
T(n)小于等于一个常数乘以n³

444
00:26:54,210 --> 00:26:56,680
诸如1之类的常量

445
00:26:58,700 --> 00:27:01,090
这就是上界   不过不是个严格的上界

446
00:27:01,160 --> 00:27:03,920
事实上我们认为n的平方也成立

447
00:27:04,160 --> 00:27:06,380
但是大家要注意一下

448
00:27:06,400 --> 00:27:07,900
这并不是指答案就是n³

449
00:27:07,900 --> 00:27:10,890
这只是表示至多是O(n³)

450
00:27:11,180 --> 00:27:13,000
这就是用归纳法的证明过程

451
00:27:13,000 --> 00:27:15,790
严格来讲  我该取一个基本值代入递归

452
00:27:16,050 --> 00:27:17,390
这一部分我没写

453
00:27:17,440 --> 00:27:21,360
基本情况代入很简单  因为T(1)是常数

454
00:27:22,310 --> 00:27:24,560
但还是可能有影响

455
00:27:24,650 --> 00:27:31,450
如果基本值T(1)是一常数

456
00:27:31,610 --> 00:27:34,950
我们要得到的就是≤c·1³

457
00:27:34,950 --> 00:27:36,200
也就是c

458
00:27:37,190 --> 00:27:38,530
此不等式永远成立

459
00:27:38,530 --> 00:27:40,950
条件是c的值足够大

460
00:27:41,170 --> 00:27:48,640
当c的值足够大时成立

461
00:27:48,700 --> 00:27:50,380
我们一般不用考虑常量的值

462
00:27:50,580 --> 00:27:53,220
但是在这里要注意下

463
00:27:53,330 --> 00:27:58,710
T(n)小于等于1·n²是不成立的

464
00:27:58,860 --> 00:28:01,000
尽管这里我们只需让c大于等于1

465
00:28:01,020 --> 00:28:01,880
为了让基本值代入成立

466
00:28:01,880 --> 00:28:05,770
c的值可能要取到100  起码要等于T(1)

467
00:28:06,290 --> 00:28:08,110
所以这里要注意下

468
00:28:09,590 --> 00:28:11,700
不太会影响结果  一般不会

469
00:28:11,830 --> 00:28:14,460
因为我们的基本值代入很简单

470
00:28:14,970 --> 00:28:24,500
好的  我们一起来证明紧界O(n²)

471
00:28:27,370 --> 00:28:28,630
Ω界限我就不证明了

472
00:28:28,630 --> 00:28:30,360
但你可以用代入法

473
00:28:30,360 --> 00:28:32,340
证明Ω(n²)

474
00:28:34,060 --> 00:28:35,770
这节课我只想证明

475
00:28:35,870 --> 00:28:39,900
上界n²

476
00:28:40,750 --> 00:28:48,780
求证T(n)  与之前一样的递归式

477
00:28:48,820 --> 00:28:50,810
我想证明它是O(n²)

478
00:28:52,780 --> 00:28:56,020
按照相同的证明步骤

479
00:28:56,100 --> 00:28:58,900
我就写快一点  因为都是原样照抄

480
00:29:04,550 --> 00:29:06,850
这里注意  不是立方了  是平方

481
00:29:07,450 --> 00:29:16,920
T(n)=4T(n/2)+n  我把T(n/2)展开

482
00:29:17,030 --> 00:29:23,780
代入后就是小于等于4c(n/2)²+n.

483
00:29:23,780 --> 00:29:25,960
之前算的是2的立方

484
00:29:25,960 --> 00:29:28,140
而现在是2的平方  就是4

485
00:29:28,450 --> 00:29:32,910
4就消掉了  得到cn²+n

486
00:29:33,480 --> 00:29:36,480
然后把它写成理想结果减去余项的形式

487
00:29:36,580 --> 00:29:39,570
我就得到cn²-(-n)

488
00:29:39,670 --> 00:29:43,910
我需要让-n非负

489
00:29:45,960 --> 00:29:48,850
要让-n成为非负的　相当难

490
00:29:48,850 --> 00:29:50,650
如果是0的话就好了

491
00:29:50,800 --> 00:29:52,520
很不幸这是n的递推式

492
00:29:52,520 --> 00:29:55,720
所以所有n的取值都要大于等于1

493
00:29:57,230 --> 00:30:03,240
所以这里不能是小于等于cn²

494
00:30:03,330 --> 00:30:08,030
注意我们的目的是让它等于O(n²)

495
00:30:09,420 --> 00:30:10,940
对于这一步来说是成立的

496
00:30:11,750 --> 00:30:15,270
cn²-(-n)  n是O(n)

497
00:30:15,470 --> 00:30:17,480
这个为O(n)  而这个为O(n²)

498
00:30:17,540 --> 00:30:19,840
当然相减同样为O(n²)

499
00:30:20,100 --> 00:30:22,050
但这是不能表示归纳完成

500
00:30:22,140 --> 00:30:23,660
为了完成归纳  你必须证明

501
00:30:23,740 --> 00:30:26,790
n时含常数c的归纳假设

502
00:30:27,020 --> 00:30:29,460
但这里得到的常量却是c+1之类的

503
00:30:30,640 --> 00:30:31,970
并不理想

504
00:30:31,970 --> 00:30:35,720
归纳到这一步虽正确但没有用

505
00:30:36,700 --> 00:30:40,070
无法完成归纳

506
00:30:40,200 --> 00:30:41,610
所以这个就不用看了

507
00:30:42,540 --> 00:30:43,830
这个证明不成立

508
00:30:43,900 --> 00:30:45,420
这很难以接受  因为我们

509
00:30:45,420 --> 00:30:47,800
有预感T(n)=n²

510
00:30:48,780 --> 00:30:52,750
为了能使证明成立  我们要将T(n)

511
00:30:52,750 --> 00:30:54,390
用一种不同的形式表达出来

512
00:30:54,440 --> 00:30:56,850
这是上帝给你们的启示

513
00:30:57,030 --> 00:30:59,110
如果你们能和神扯上点关系的话

514
00:30:59,220 --> 00:31:00,220
一切就能迎刃而解了

515
00:31:00,480 --> 00:31:06,260
不过对于在座的诸位凡人来说就有点难了

516
00:31:07,720 --> 00:31:11,130
我们可以试试这个作为猜想

517
00:31:13,030 --> 00:31:17,610
我们的思路是改进归纳假设

518
00:31:17,680 --> 00:31:19,950
我们之前用的这个相对弱的假设

519
00:31:20,000 --> 00:31:22,740
T(n)小于等于一个常数乘以k的平方

520
00:31:22,780 --> 00:31:24,660
我们不知道常量的取值  这倒无妨

521
00:31:24,710 --> 00:31:26,790
但是我们还假设了它没有低阶项

522
00:31:26,830 --> 00:31:28,500
现在我就要考虑低阶项了

523
00:31:28,810 --> 00:31:29,920
没准这能帮上忙

524
00:31:30,180 --> 00:31:33,230
如果你观察下这个计算的过程

525
00:31:33,320 --> 00:31:35,310
你会这些n²的项

526
00:31:35,390 --> 00:31:37,200
其常数真是消得太他丫的巧了

527
00:31:37,200 --> 00:31:40,370
4被约掉了只留下c 没一点多的

528
00:31:40,410 --> 00:31:42,990
我怎么才能去掉低阶项+n呢

529
00:31:43,290 --> 00:31:46,700
我也许可以从这个里面分出一个线性项来

530
00:31:46,790 --> 00:31:48,610
如果幸运的话  它就能与低阶项抵消

531
00:31:48,850 --> 00:31:51,330
这就是我们处理这个地方的思路

532
00:31:51,570 --> 00:31:52,660
结果证明可行

533
00:31:53,920 --> 00:32:00,590
这还是T(n)=4T(n/2)+n

534
00:32:00,870 --> 00:32:05,770
现在我们用稍微复杂的形式展开

535
00:32:05,880 --> 00:32:15,730
4[c₁·(n/2)²-c₂(n/2)]+n

536
00:32:16,430 --> 00:32:20,620
这一项还是一样的  4被消掉

537
00:32:20,720 --> 00:32:23,150
得到c₁·n²  这很理想

538
00:32:23,150 --> 00:32:25,280
因为这是我们想要的形式

539
00:32:25,500 --> 00:32:28,270
下一项是常数与n相乘  我们来看一下

540
00:32:28,340 --> 00:32:29,880
提取n 剩下+1

541
00:32:29,880 --> 00:32:37,870
这项是(1-c₂/2)n

542
00:32:38,040 --> 00:32:39,220
不对

543
00:32:39,220 --> 00:32:44,620
没把4乘进来  所以2应该到分子上去

544
00:32:48,250 --> 00:32:50,080
在检查下  正确

545
00:32:51,150 --> 00:32:54,700
好  现在我们可以写出想要的结果和余项

546
00:32:55,070 --> 00:32:56,650
不过我们要注意一下

547
00:32:56,650 --> 00:32:59,300
因为我们用了更强的归纳假设来证明

548
00:32:59,330 --> 00:33:01,610
不仅仅需要化简到只留下c₁·n²

549
00:33:01,610 --> 00:33:02,580
还需要保留其他项

550
00:33:02,630 --> 00:33:04,510
因为c₂可能是一个很大的值

551
00:33:04,790 --> 00:33:10,870
我们需要的形式是c₁·n²-c₂·n

552
00:33:11,730 --> 00:33:13,740
后面还要减去别的项

553
00:33:13,740 --> 00:33:16,440
这样  这里就又是理想结果减去余项

554
00:33:16,680 --> 00:33:18,360
我们来写出要减去的余项

555
00:33:27,840 --> 00:33:30,440
看着不太对

556
00:33:38,220 --> 00:33:40,710
加上c₂  谢谢

557
00:33:41,860 --> 00:33:43,460
差点又弄得都是负号了

558
00:33:43,540 --> 00:33:45,370
改为加上c₂  我就得到了我想要的符号

559
00:33:45,640 --> 00:33:49,490
这里一个负号  这还一个  所以得正

560
00:33:51,350 --> 00:33:56,200
同样  我需要我的余项非负

561
00:33:58,860 --> 00:34:00,360
如果我能成功

562
00:34:03,100 --> 00:34:06,980
我归纳的结论就得证了

563
00:34:12,160 --> 00:34:13,990
本周开始有答疑时间

564
00:34:15,140 --> 00:34:16,810
你们有问题就可以去问

565
00:34:17,930 --> 00:34:21,610
答疑都被安排在24号楼

566
00:34:21,640 --> 00:34:23,960
大概就是在这里与史塔塔中心的中点

567
00:34:24,200 --> 00:34:26,410
我就是随便一说

568
00:34:29,570 --> 00:34:32,270
答疑时间详情请参见网页

569
00:34:32,640 --> 00:34:33,680
我们继续

570
00:34:33,850 --> 00:34:39,300
何时c₂-1能大于等于0

571
00:34:39,650 --> 00:34:43,740
当c₂大于等于1时成立

572
00:34:44,220 --> 00:34:45,030
这个问题不大

573
00:34:45,030 --> 00:34:47,550
还是让常数等于我们想要的值

574
00:34:47,620 --> 00:34:49,480
只需对特定常数成立

575
00:34:49,630 --> 00:34:51,740
我们可以让c₂大于等于1

576
00:34:52,070 --> 00:34:53,720
这样就搞定了

577
00:34:53,770 --> 00:34:57,320
上一步写下来就是

578
00:34:57,390 --> 00:35:01,160
小于等于c₁·n²-c₂·n

579
00:35:01,260 --> 00:35:04,900
如果c₂大于等于1

580
00:35:05,120 --> 00:35:06,030
这里就有意思了

581
00:35:06,190 --> 00:35:11,890
归纳就完成了  起码完成了归纳步骤

582
00:35:12,480 --> 00:35:14,120
我们证明了  对任意c₁

583
00:35:14,370 --> 00:35:16,290
且c₂大于等于1成立

584
00:35:16,780 --> 00:35:19,700
我们要特别注意下 c₁

585
00:35:19,870 --> 00:35:22,170
必须足够大

586
00:35:22,230 --> 00:35:23,810
有人知道原因吗

587
00:35:30,100 --> 00:35:31,840
c₁须是非负的  没错

588
00:35:31,920 --> 00:35:34,010
c₁是正数 递归才能成立

589
00:35:34,440 --> 00:35:39,320
也许它还不仅仅需要是正数

590
00:35:39,750 --> 00:35:40,870
对不起我讲得有点快

591
00:35:40,960 --> 00:35:41,990
我没有提问

592
00:35:42,000 --> 00:35:43,390
你们快睡着了，是不是

593
00:35:43,930 --> 00:35:45,380
因为基本情况 正确

594
00:35:45,450 --> 00:35:55,070
基本情况是c₁·1²-c₂

595
00:35:56,170 --> 00:36:00,660
我们需要证明这是上界

596
00:36:00,790 --> 00:36:04,550
假设T(1)是常数

597
00:36:04,820 --> 00:36:06,470
我们需要选择c₁

598
00:36:06,530 --> 00:36:08,690
比c₂大

599
00:36:08,790 --> 00:36:10,160
而c₂至少是1

600
00:36:10,360 --> 00:36:13,470
c₁也许比1大100

601
00:36:13,750 --> 00:36:15,390
如果这个是100的话

602
00:36:15,960 --> 00:36:22,940
若c₁足够大  则算式成立

603
00:36:23,980 --> 00:36:28,660
足够大是相对于c₂来讲的

604
00:36:29,550 --> 00:36:31,110
你需要注意这一点

605
00:36:31,190 --> 00:36:33,320
但在这个例子中无关紧要

606
00:36:35,320 --> 00:36:38,130
对这个代换法有什么问题吗

607
00:36:38,200 --> 00:36:39,880
同一个例子我用了三次

608
00:36:40,170 --> 00:36:42,680
最后  我们得到了正确答案

609
00:36:43,080 --> 00:36:45,700
但我们求解时需要预先知道解

610
00:36:45,710 --> 00:36:46,880
这有点蛋疼

611
00:36:47,100 --> 00:36:48,700
大家肯定希望

612
00:36:48,800 --> 00:36:51,000
有什么方法能直接求出答案的

613
00:36:51,000 --> 00:36:53,810
这是我们将要讲的下两种方法

614
00:36:56,300 --> 00:36:59,080
如何确定下界呢

615
00:36:59,260 --> 00:37:01,400
我这次没有求

616
00:37:01,400 --> 00:37:03,920
你可以用相同方式求得

617
00:37:04,700 --> 00:37:12,560
证明T(n)比c₁·n²-c₂·n大

618
00:37:12,640 --> 00:37:14,950
我没有验证这个形式是否正确

619
00:37:15,000 --> 00:37:15,860
但我觉得是对的

620
00:37:18,630 --> 00:37:19,730
大家自己试下

621
00:37:21,250 --> 00:37:22,830
用别的方法也可以

622
00:37:22,850 --> 00:37:24,690
在某种意义上 得到上下界

623
00:37:24,850 --> 00:37:26,430
只要更认真一些

624
00:37:26,620 --> 00:37:27,960
若要验证正确性

625
00:37:27,960 --> 00:37:30,050
最好还是选择用代换法

626
00:37:30,120 --> 00:37:32,430
我们有用这方法的习题

627
00:37:32,540 --> 00:37:34,440
一般我们只关心上界

628
00:37:34,580 --> 00:37:37,560
找到上界是我们所关心的

629
00:37:37,610 --> 00:37:39,060
但偶尔也需要下界

630
00:37:40,010 --> 00:37:41,580
提供一个相应的下界

631
00:37:41,580 --> 00:37:43,760
得到正确答案总是好的

632
00:37:49,390 --> 00:37:51,930
我们要讲的下一种方法

633
00:37:53,560 --> 00:37:54,960
是递归树法

634
00:37:55,170 --> 00:37:58,820
这是一种解递归式的特别方法

635
00:37:59,540 --> 00:38:01,880
是我最喜欢的方法

636
00:38:02,080 --> 00:38:07,090
它总是能用  这是最棒的一点

637
00:38:07,250 --> 00:38:08,880
这给你一种直觉

638
00:38:09,000 --> 00:38:10,880
让你大概知道答案是多少

639
00:38:11,000 --> 00:38:13,250
只是有些不严谨

640
00:38:13,320 --> 00:38:14,520
这有点蛋疼

641
00:38:14,570 --> 00:38:16,330
所以用这方法时要特别小心

642
00:38:16,370 --> 00:38:18,140
不然  就可能得到错误答案

643
00:38:18,340 --> 00:38:20,510
因为它需要用到点 点 点

644
00:38:20,670 --> 00:38:23,670
我们最喜欢的符号

645
00:38:23,850 --> 00:38:26,770
但使用省略号总是有一点不严谨

646
00:38:26,930 --> 00:38:28,030
所以要小心

647
00:38:28,750 --> 00:38:30,780
严格来讲  我们应该

648
00:38:30,780 --> 00:38:32,590
用递归树法找到答案

649
00:38:32,740 --> 00:38:34,960
然后用代换法验证之

650
00:38:35,960 --> 00:38:37,660
但通常不必要这样

651
00:38:37,840 --> 00:38:39,350
不过至少你们应当知道

652
00:38:39,400 --> 00:38:41,620
递归树法有点不严谨

653
00:38:41,760 --> 00:38:43,580
至少在刚开始解递归的时候

654
00:38:43,580 --> 00:38:44,780
你们应当验证

655
00:38:44,880 --> 00:38:46,700
当你完全理解递归树法之后

656
00:38:46,700 --> 00:38:49,740
你可以省些事

657
00:38:49,920 --> 00:38:51,420
如果你确信自己得到了正确解

658
00:38:51,480 --> 00:38:53,750
我们来做个练习

659
00:38:53,810 --> 00:39:00,100
在讲归并排序时用过一点递归树法

660
00:39:00,420 --> 00:39:02,480
在介绍为何复杂度是nlgn时

661
00:39:03,880 --> 00:39:07,300
像刚才这个例子

662
00:39:07,310 --> 00:39:09,380
要是用递归树法解的话就太大材小用了

663
00:39:09,840 --> 00:39:11,780
我们来玩个复杂些的

664
00:39:11,930 --> 00:39:13,930
解个复杂些的递归

665
00:39:14,020 --> 00:39:15,970
假设有某个算法

666
00:39:15,970 --> 00:39:17,430
问题的规模为n

667
00:39:17,550 --> 00:39:19,940
先四等分地递归

668
00:39:20,180 --> 00:39:22,640
再二等分地递归

669
00:39:22,830 --> 00:39:28,140
再做一个非递归的n²复杂度的工作

670
00:39:28,680 --> 00:39:32,110
这是什么  我只是想让答案不显而易见

671
00:39:34,250 --> 00:39:37,550
我们先画个图

672
00:39:40,550 --> 00:39:44,830
用树的形式展开递归

673
00:39:54,110 --> 00:39:55,650
再把所有东西加起来

674
00:39:57,560 --> 00:40:00,620
我们要画个框架图

675
00:40:02,390 --> 00:40:05,820
递归树法的基本原理

676
00:40:05,820 --> 00:40:07,420
就是画成这样一张图

677
00:40:07,440 --> 00:40:18,800
如题所述  T(n)=n²+T(n/4)+T(n/2)

678
00:40:19,920 --> 00:40:22,480
这种求和的写法很奇怪

679
00:40:22,550 --> 00:40:23,770
但还是要这么写

680
00:40:24,030 --> 00:40:25,750
这可以构成树

681
00:40:26,910 --> 00:40:28,370
构成树的方法是

682
00:40:28,400 --> 00:40:31,820
递归地展开这两个叶节点

683
00:40:31,970 --> 00:40:33,920
我先将T(n)展开成这样

684
00:40:34,120 --> 00:40:36,680
然后继续展开  全部展开

685
00:40:36,890 --> 00:40:38,630
再进行一步

686
00:40:39,470 --> 00:40:46,270
我们从n²  T(n/4) T(n/2)开始

687
00:40:46,270 --> 00:40:47,830
再展开一次

688
00:40:48,140 --> 00:40:52,440
得到n²和另两个东西

689
00:40:52,800 --> 00:40:56,470
第一个是(n/4)²

690
00:40:56,470 --> 00:40:59,350
第二个是(n/2)²

691
00:40:59,380 --> 00:41:01,920
以及它们的递归分支

692
00:41:01,960 --> 00:41:08,200
得到T(n/16)和T(n/8)

693
00:41:08,400 --> 00:41:10,590
我算术学得不太好

694
00:41:11,070 --> 00:41:13,220
这也是T(n/8)

695
00:41:13,220 --> 00:41:16,220
这个是T(n/4)  我觉得

696
00:41:16,590 --> 00:41:18,540
你可以一直往下写

697
00:41:18,610 --> 00:41:22,270
直到到达基本情况  T是常数

698
00:41:23,170 --> 00:41:26,210
我略掉下面的步骤 点 点 点

699
00:41:26,430 --> 00:41:28,540
这是你们要小心的地方

700
00:41:30,440 --> 00:41:37,970
已求得n²  (n/4)²  (n/2)²

701
00:41:38,060 --> 00:41:40,730
我们已经求出这些

702
00:41:40,920 --> 00:41:46,480
(n/16)²  (n/8)²  又是(n/8)²

703
00:41:48,280 --> 00:41:54,010
(n/4)²及其他省略掉的内容 点 点 点

704
00:41:54,220 --> 00:41:55,950
递归的不同层次

705
00:41:56,050 --> 00:41:59,000
最后  我们会到达一堆常数

706
00:41:59,000 --> 00:41:59,990
这些是叶节点

707
00:42:03,210 --> 00:42:05,740
我们需要知道这里有多少叶节点

708
00:42:07,350 --> 00:42:10,330
求叶节点数目是个难题

709
00:42:10,410 --> 00:42:11,530
这有些难解

710
00:42:11,740 --> 00:42:14,550
不像归并排序或我们之前解过的递归

711
00:42:14,780 --> 00:42:16,430
叶节点数有点不一样

712
00:42:16,510 --> 00:42:18,650
因为递归速度不同

713
00:42:18,780 --> 00:42:21,350
这棵子树比那棵子树小

714
00:42:21,560 --> 00:42:22,940
子树的高度较小

715
00:42:23,000 --> 00:42:25,870
这棵已经减到n/16

716
00:42:25,870 --> 00:42:28,040
这棵才减到n/4

717
00:42:28,860 --> 00:42:31,040
但这递归树中到底有多少叶节点呢

718
00:42:33,980 --> 00:42:36,570
我需要一个上界

719
00:42:37,410 --> 00:42:39,140
一个合理的上界

720
00:42:39,260 --> 00:42:41,110
我可以说最多是n¹⁰

721
00:42:41,110 --> 00:42:42,990
但这有些不合理

722
00:42:48,860 --> 00:42:50,410
它应该小于n  很好

723
00:42:50,500 --> 00:42:51,800
为什么会小于n呢

724
00:42:55,440 --> 00:42:58,590
很对 最开始的问题大小是n

725
00:42:58,790 --> 00:43:02,500
递归成一个n/4的问题和一个n/2的问题

726
00:43:02,540 --> 00:43:04,100
递归到1为止

727
00:43:04,470 --> 00:43:09,500
n/4+n/2=3n/4  显然比n小

728
00:43:09,670 --> 00:43:12,040
所以  显然

729
00:43:12,040 --> 00:43:13,370
叶节点数不超过n

730
00:43:13,670 --> 00:43:16,300
若初始规模是n

731
00:43:16,450 --> 00:43:19,710
每次递归减少1/4

732
00:43:19,800 --> 00:43:22,730
递归结束时必然少于n个

733
00:43:24,470 --> 00:43:26,430
严格小于n个叶节点

734
00:43:28,220 --> 00:43:30,650
到这一点  一切都还很乏味

735
00:43:31,080 --> 00:43:35,300
递归树的第二个亮点是

736
00:43:35,350 --> 00:43:37,950
你不必要展开看整个树的样子

737
00:43:38,020 --> 00:43:40,390
然后说  天啊  这玩意怎么求和

738
00:43:40,620 --> 00:43:42,760
你一层一层地求和

739
00:43:42,970 --> 00:43:44,310
这是第二个思想

740
00:43:44,520 --> 00:43:46,330
这通常很正确

741
00:43:46,430 --> 00:43:48,190
这里有一点复杂

742
00:43:48,820 --> 00:43:52,260
我们算出的n²就是n²

743
00:43:52,410 --> 00:43:54,200
这是第一层  很简单

744
00:43:54,430 --> 00:43:57,420
第二层相对难一些

745
00:43:57,440 --> 00:43:59,710
搞数学的人有三种

746
00:43:59,710 --> 00:44:01,470
会计算的和不会的

747
00:44:02,290 --> 00:44:05,720
我是后一种  所以需要你们帮助

748
00:44:07,250 --> 00:44:09,080
你们会把这些加起来吗

749
00:44:09,190 --> 00:44:10,650
得到n²除以什么

750
00:44:13,380 --> 00:44:20,750
什么  5/16  好  谢谢

751
00:44:20,750 --> 00:44:22,470
现在真的需要你们帮助了

752
00:44:22,520 --> 00:44:23,470
上一个我还会做

753
00:44:23,500 --> 00:44:25,290
这个更难了

754
00:44:25,290 --> 00:44:27,340
你们先算着  我去看一下讲稿

755
00:44:33,390 --> 00:44:39,440
有答案了吗  73/256

756
00:44:39,570 --> 00:44:40,930
有人确认一下吗

757
00:44:41,990 --> 00:44:44,510
这个有点大了

758
00:44:45,610 --> 00:44:48,880
73听上去不太对 因为我有答案

759
00:44:49,600 --> 00:44:52,020
64吗  比较接近了

760
00:44:54,330 --> 00:44:56,780
我们必须把这个算对

761
00:44:56,930 --> 00:44:58,590
256这个数是对的

762
00:44:58,680 --> 00:45:03,230
我也知道  谁都知道16²=256

763
00:45:03,230 --> 00:45:04,300
毕竟我们是搞计算机的

764
00:45:05,990 --> 00:45:08,970
25  好的  有两个人算得25

765
00:45:09,030 --> 00:45:10,820
民主地讲 这就是答案

766
00:45:11,810 --> 00:45:14,950
我的讲稿上也是25  我在家算的

767
00:45:15,230 --> 00:45:16,380
25这个数是对的

768
00:45:16,380 --> 00:45:20,230
有人看出其中的玄妙了吗

769
00:45:24,360 --> 00:45:26,080
它每次都会平方  很好

770
00:45:26,630 --> 00:45:29,640
要想把这数列加起来  我们称之为什么

771
00:45:32,610 --> 00:45:34,460
几何级数[等比级数]  非常好

772
00:45:34,520 --> 00:45:36,790
原来它是个几何级数

773
00:45:37,260 --> 00:45:39,240
我们会几何级数的求和

774
00:45:39,240 --> 00:45:40,380
至少你们应该会

775
00:45:57,190 --> 00:45:58,420
我们从n²开始

776
00:45:58,480 --> 00:45:59,820
显然在最后的地方

777
00:46:00,030 --> 00:46:03,070
高度不是一样的  对于n

778
00:46:03,320 --> 00:46:05,330
它以几何级数递减

779
00:46:06,300 --> 00:46:12,260
最终  我是说这个递归的解

780
00:46:12,260 --> 00:46:14,180
就是把这个树里的所有数加起来

781
00:46:14,230 --> 00:46:16,700
我们一层一层地加  再把所有层加起来

782
00:46:16,720 --> 00:46:18,220
就能得到最终答案

783
00:46:18,610 --> 00:46:21,720
一层一层地加出总和

784
00:46:21,780 --> 00:46:23,710
这是个很聪明的计算方法

785
00:46:23,940 --> 00:46:27,370
通常会得到类似几何级数的结果

786
00:46:27,620 --> 00:46:32,280
这里有  n²(1+5/16+...)

787
00:46:32,420 --> 00:46:38,260
如果相信命运的话  看到前3个数

788
00:46:38,440 --> 00:46:40,280
我们就知道结果肯定是对的

789
00:46:40,330 --> 00:46:44,720
通项是5 /16

790
00:46:44,720 --> 00:46:46,680
至少希望是这样

791
00:46:46,880 --> 00:46:48,150
k不断变大

792
00:46:48,290 --> 00:46:49,990
但它不是无穷的

793
00:46:50,170 --> 00:46:52,020
但可以假设它是无穷的

794
00:46:52,020 --> 00:46:55,780
这样它就是上界

795
00:46:56,650 --> 00:46:58,560
这些都要乘以n²

796
00:46:59,590 --> 00:47:03,760
几何级数有一个性质

797
00:47:03,790 --> 00:47:08,840
大家应该知道 1+1/2+1/4+...  加起来

798
00:47:09,970 --> 00:47:15,000
结果是2

799
00:47:15,290 --> 00:47:16,310
作为计算机科学家

800
00:47:16,310 --> 00:47:18,360
我们至少得知道二进制的例子

801
00:47:18,390 --> 00:47:22,850
这就是在二进制里的0.1111111

802
00:47:23,000 --> 00:47:24,700
准确的说  1.1111111

803
00:47:24,800 --> 00:47:28,780
无限的0.1111等于1  所以结果是2

804
00:47:29,960 --> 00:47:31,300
这里会更小

805
00:47:31,320 --> 00:47:33,230
因为  5/16小于1/2

806
00:47:33,230 --> 00:47:34,320
然后等比增长

807
00:47:34,400 --> 00:47:36,480
所以这里比2还小

808
00:47:39,090 --> 00:47:40,960
如果你想  有精确的公式

809
00:47:40,960 --> 00:47:43,670
你可以对几何级数求和

810
00:47:43,670 --> 00:47:45,230
但我们只需要它是常数就够了

811
00:47:45,390 --> 00:47:51,420
答案是O(n²)  也是Ω(n²)

812
00:47:51,840 --> 00:47:53,240
其实很显然它是Ω(n²)

813
00:47:53,300 --> 00:47:55,080
因为递归式里就有n²

814
00:47:55,470 --> 00:47:57,880
所以n²也是下界

815
00:47:57,920 --> 00:48:01,320
这里的系数是2  很好

816
00:48:01,320 --> 00:48:02,950
其实还可以得到一个更好的系数

817
00:48:03,090 --> 00:48:04,500
这就是递归树方法

818
00:48:04,590 --> 00:48:05,800
不是太严谨

819
00:48:05,890 --> 00:48:07,230
因为过程中有省略的地方

820
00:48:07,230 --> 00:48:09,840
而且 还是等比还是假设出来的

821
00:48:09,850 --> 00:48:11,440
实际中很多时候它都是等比的

822
00:48:11,520 --> 00:48:12,340
这里是没问题的

823
00:48:12,390 --> 00:48:15,340
如果是我  我会用代换法检查一遍

824
00:48:15,380 --> 00:48:16,620
因为我没有明显看出

825
00:48:16,740 --> 00:48:18,390
这是一个几何级数

826
00:48:18,820 --> 00:48:20,790
在我们马上要看到的例子里

827
00:48:20,970 --> 00:48:22,240
求解会更加清晰

828
00:48:27,040 --> 00:48:29,170
以至于可以得出一个定理

829
00:48:29,270 --> 00:48:31,090
那时一切都好办了

830
00:48:31,940 --> 00:48:34,480
还有时间  很好

831
00:48:37,810 --> 00:48:39,410
上面讲的是递归树方法

832
00:48:41,770 --> 00:48:43,900
接下来我们还要介绍一种方法[主方法]

833
00:48:44,640 --> 00:48:46,350
你可以认识它本质上是

834
00:48:46,400 --> 00:48:48,720
递归树方法的一个应用

835
00:48:48,910 --> 00:48:51,380
但是它更精确

836
00:48:58,390 --> 00:49:02,140
不同于递归树含有省略  有待证明

837
00:49:02,240 --> 00:49:04,720
主方法基于一个定理[主定理]

838
00:49:07,100 --> 00:49:10,980
遗憾的是  主方法限制颇多

839
00:49:10,990 --> 00:49:15,780
只能应用到特定的递归式上

840
00:49:25,560 --> 00:49:34,750
这些递归式符合T(n) = aT(n/b) + f(n)

841
00:49:35,150 --> 00:49:38,800
是叫f吗  对的

842
00:49:39,080 --> 00:49:41,830
因此  它不包含我刚才解的递归式

843
00:49:41,930 --> 00:49:44,440
因为那个递归式有两个不同的子问题

844
00:49:44,500 --> 00:49:45,680
子问题的规模也不同

845
00:49:45,830 --> 00:49:47,310
在主方法中  每个子问题

846
00:49:47,330 --> 00:49:48,870
的规模应该相等

847
00:49:48,920 --> 00:49:49,990
有a个相同的子问题

848
00:49:50,120 --> 00:49:51,830
适用于主方法的递归算法

849
00:49:51,890 --> 00:49:52,820
有a个相同的子问题

850
00:49:52,900 --> 00:49:55,420
每个子问题的规模都是 n/b

851
00:49:55,500 --> 00:49:57,020
因此递归的总代价是这个

852
00:49:57,160 --> 00:49:59,330
剩下的是非递归的代价 f(n)

853
00:50:00,180 --> 00:50:03,770
一些约束条件  a要大于或等于1

854
00:50:04,360 --> 00:50:06,020
至少递归一次

855
00:50:06,170 --> 00:50:08,200
b要严格大于1

856
00:50:08,270 --> 00:50:09,640
你得让子问题规模减小

857
00:50:09,700 --> 00:50:11,710
不然结果是无限大

858
00:50:13,820 --> 00:50:17,580
f(n)函数要满足一些性质

859
00:50:19,650 --> 00:50:25,640
f(n) 渐近趋正

860
00:50:30,170 --> 00:50:32,960
有多少人知道渐近趋正是什么意思

861
00:50:34,460 --> 00:50:38,000
没人  看来你们没看教材

862
00:50:38,060 --> 00:50:40,190
我也没看  可别告诉Charles

863
00:50:40,420 --> 00:50:42,710
不过他会发现的

864
00:50:42,820 --> 00:50:47,820
你觉得渐近趋正是什么意思

865
00:50:47,910 --> 00:50:49,280
这样会好点

866
00:50:52,360 --> 00:50:53,270
能再说一遍吗

867
00:50:56,370 --> 00:50:59,650
它表示对足够大的n  f(n)是正的

868
00:51:00,350 --> 00:51:08,210
存在某特定n₀ 当n≥n₀时  f(n)大于0

869
00:51:08,280 --> 00:51:10,060
对于某个常数n₀

870
00:51:10,120 --> 00:51:11,410
f(n)最终是正的

871
00:51:11,480 --> 00:51:12,590
由此可见  如果当n=1时

872
00:51:12,660 --> 00:51:15,640
f(n)=-1  不用担心  无所谓

873
00:51:16,260 --> 00:51:17,430
不影响结果

874
00:51:17,480 --> 00:51:19,750
因为我们只考虑渐近的情况

875
00:51:26,060 --> 00:51:29,350
当你得到这种形式的递归式

876
00:51:29,460 --> 00:51:30,830
使用主方法可以得出结果

877
00:51:31,070 --> 00:51:32,850
这是主方法很棒的地方

878
00:51:32,970 --> 00:51:34,690
比较烦的是

879
00:51:34,690 --> 00:51:35,800
主方法有三种情况

880
00:51:35,850 --> 00:51:36,870
内容很多

881
00:51:38,440 --> 00:51:40,870
相对前两种方法  需要更长的时间记忆

882
00:51:40,870 --> 00:51:41,970
因为之前的都只是思路

883
00:51:42,090 --> 00:51:44,760
这里却要记忆一堆东西

884
00:51:46,570 --> 00:51:48,500
我把定理写出来

885
00:51:49,530 --> 00:51:50,560
也不尽然

886
00:51:50,810 --> 00:51:52,560
主方法有个简单的思路

887
00:51:52,740 --> 00:51:56,090
就是去比较  非递归的函数f(n)

888
00:51:56,120 --> 00:52:01,380
和  函数n^logba

889
00:52:02,950 --> 00:52:07,010
为什么是n^logba  等会儿就知道了

890
00:52:08,380 --> 00:52:11,670
它是递归树叶节点的数量

891
00:52:11,860 --> 00:52:13,960
埋个伏笔

892
00:52:14,920 --> 00:52:18,120
三种情况分别是小于  等于  大于

893
00:52:18,470 --> 00:52:20,240
我们只考虑渐近情况

894
00:52:20,340 --> 00:52:22,470
而且还更确切地关注

895
00:52:22,470 --> 00:52:24,090
小于 等于 或大于

896
00:52:24,140 --> 00:52:27,950
你可能会想到  小o  大Θ  小ω

897
00:52:28,100 --> 00:52:30,870
若定理对上述条件都成立  那当然好

898
00:52:30,950 --> 00:52:33,200
但是中间存在一些真空地带

899
00:52:34,430 --> 00:52:36,590
情况1

900
00:52:36,970 --> 00:52:38,880
情况1是f(n)较小的情况

901
00:52:39,780 --> 00:52:41,680
不只是小o符号

902
00:52:42,730 --> 00:52:45,430
实际上还要更小些

903
00:52:45,480 --> 00:52:49,820
它得多项式地小于n^logba

904
00:52:58,950 --> 00:53:03,250
对于正的ε  运行时间是

905
00:53:03,320 --> 00:53:06,620
n^(logba–ε)

906
00:53:06,660 --> 00:53:10,140
所以它多项式地小于n^logba

907
00:53:11,040 --> 00:53:13,070
我们不能用小o符号

908
00:53:13,120 --> 00:53:14,120
那玩意太强了

909
00:53:14,170 --> 00:53:16,270
这里比小o符号要更小

910
00:53:19,220 --> 00:53:26,150
但结果很简单  T(n)=Θ(n^logba)

911
00:53:27,850 --> 00:53:30,250
好的  这就是情况1

912
00:53:32,110 --> 00:53:40,070
情况2  当f(n)基本上等于n^logba

913
00:53:42,190 --> 00:53:43,620
基本等于的意思是

914
00:53:43,620 --> 00:53:46,320
在把lg多项式作为因式的基础上

915
00:53:48,470 --> 00:53:52,800
这是以2为底n的对数的k次幂

916
00:53:52,960 --> 00:53:55,340
你应该知道这个符号

917
00:53:56,360 --> 00:53:58,500
比如  k可以是0

918
00:53:58,900 --> 00:54:01,440
所以它就是常数了

919
00:54:01,530 --> 00:54:04,410
这里k必须要大于或等于0

920
00:54:07,250 --> 00:54:08,490
小于0不行

921
00:54:08,550 --> 00:54:10,480
所以k是非负的

922
00:54:10,630 --> 00:54:12,140
它可能应该是一个整数

923
00:54:12,640 --> 00:54:14,780
不  是不是整数无所谓

924
00:54:16,050 --> 00:54:19,100
在这里  可以是n^logba乘以lgn

925
00:54:19,100 --> 00:54:21,450
或者  乘以1

926
00:54:22,200 --> 00:54:24,820
同样  结果很简单

927
00:54:24,820 --> 00:54:33,850
T(n)=Θ(n^logba…)

928
00:54:33,850 --> 00:54:36,480
大概至少是  乘以lg^k

929
00:54:36,520 --> 00:54:41,230
实际是  (lgn)^(k+1)

930
00:54:46,550 --> 00:54:47,610
这是情况2

931
00:54:48,730 --> 00:54:52,770
剩下的情况3稍微复杂一点

932
00:54:55,040 --> 00:54:57,660
需要做更多的假设

933
00:54:58,010 --> 00:54:59,840
情况3粗略的讲是

934
00:54:59,840 --> 00:55:04,430
f(n)比n^logba增长的快

935
00:55:04,480 --> 00:55:06,820
所以是  大Ω符号

936
00:55:07,040 --> 00:55:09,110
这就是用Ω的地方

937
00:55:09,900 --> 00:55:17,210
n^logba  加上正的ε

938
00:55:20,000 --> 00:55:22,730
f(n)不仅要大于  且要多项式地大于

939
00:55:22,910 --> 00:55:25,780
情况2是大一个lg多项式因式

940
00:55:25,960 --> 00:55:28,280
情况3则是大一个多项式因式

941
00:55:29,390 --> 00:55:32,540
同时  还对f(n)有要一个假设

942
00:55:33,250 --> 00:55:36,360
因为我们考虑f(n)如何增长

943
00:55:37,460 --> 00:55:39,340
我们要确保

944
00:55:39,340 --> 00:55:42,530
在递归的过程中  f不断变小

945
00:55:42,620 --> 00:55:44,940
在递归中f不断变小就好

946
00:55:46,080 --> 00:55:47,280
不然

947
00:55:47,280 --> 00:55:49,340
在相加后  得到无限大就麻烦了

948
00:55:54,620 --> 00:56:03,880
这里应该写ε' 存在ε'大于0

949
00:56:04,070 --> 00:56:07,950
我想要这种效果  对于递归式

950
00:56:08,010 --> 00:56:12,080
把T(n)全部替换成f(n)

951
00:56:12,080 --> 00:56:17,880
f(n)一定要和af(n/b)有这种关系

952
00:56:18,050 --> 00:56:18,900
我希望这样

953
00:56:18,900 --> 00:56:21,470
f(n)即递归树的最高层

954
00:56:21,730 --> 00:56:25,920
应该大于下一层

955
00:56:26,060 --> 00:56:28,600
大于下一层所有值之和

956
00:56:28,660 --> 00:56:31,600
需要大某个常数因子

957
00:56:31,690 --> 00:56:36,280
在这里  下一层至多等于(1-ε)f

958
00:56:36,310 --> 00:56:38,030
(1-ε)严格小于1

959
00:56:38,460 --> 00:56:40,530
这个系数要严格小于1

960
00:56:40,580 --> 00:56:42,640
至多是这个系数乘以上一层

961
00:56:43,010 --> 00:56:46,060
我需要此条件保证每层的数量越来越小

962
00:56:46,720 --> 00:56:52,300
结果  T(n)=Θ(f(n))

963
00:56:54,130 --> 00:56:55,330
这就是定理

964
00:56:55,420 --> 00:56:58,090
你可以叫它主定理

965
00:56:58,120 --> 00:56:59,920
不是以某个人名来命名的

966
00:56:59,980 --> 00:57:02,490
而是因为它是最主要的方法

967
00:57:02,550 --> 00:57:04,510
应用起来很方便

968
00:57:09,480 --> 00:57:11,340
我们来练习几个

969
00:57:11,540 --> 00:57:14,660
一次练习完可能有点多

970
00:57:15,460 --> 00:57:18,170
练习之后我简略的证明一下主定理

971
00:57:18,980 --> 00:57:21,630
如果你看了它的递归树的话

972
00:57:21,830 --> 00:57:23,530
会发现 它的正确性显而易见

973
00:57:24,060 --> 00:57:25,930
但首先  我们先用一用它

974
00:57:28,530 --> 00:57:35,370
比如  T(n)=4T(n/2)+n

975
00:57:36,440 --> 00:57:42,330
这是a  这是b  这是f(n)

976
00:57:45,450 --> 00:57:49,460
先计算一下n^logba

977
00:57:50,040 --> 00:57:51,720
连我都会算

978
00:57:52,360 --> 00:57:55,420
底数为2的4的对数  我算算

979
00:57:55,490 --> 00:57:57,760
就是n²

980
00:57:59,700 --> 00:58:02,640
f(n)比n²大还是小

981
00:58:02,820 --> 00:58:03,890
f(n)=n

982
00:58:03,980 --> 00:58:06,920
n²当然比n 大一个多项式因式

983
00:58:07,010 --> 00:58:08,270
所以是情况1

984
00:58:14,080 --> 00:58:15,190
答案是什么

985
00:58:22,140 --> 00:58:23,620
n的平方  对

986
00:58:28,000 --> 00:58:31,420
这是Θ(n^logba)  这就刚好是 n²

987
00:58:33,950 --> 00:58:39,720
我们稍微改一下题目

988
00:58:39,720 --> 00:58:44,190
我将保持a和b不变  只改变f的值

989
00:58:46,540 --> 00:58:53,010
T(n)=4T(n/2)+n²

990
00:58:53,490 --> 00:58:55,360
这有点像是拼字练习

991
00:58:55,480 --> 00:59:01,330
n²渐近地等于n² 相差只有一些常数

992
00:59:01,430 --> 00:59:04,440
答案是什么呢  这是情况2

993
00:59:10,940 --> 00:59:11,820
这个稍微有点难

994
00:59:20,090 --> 00:59:24,850
这个例子里k等于多少?  零

995
00:59:28,190 --> 00:59:31,890
所以答案是什么? 调查结果表明?

996
00:59:32,660 --> 00:59:33,710
n²lgn

997
00:59:42,350 --> 00:59:45,120
好  再来几个

998
00:59:46,790 --> 00:59:52,360
T(n)=4T(n/2)+n³  结果是什么

999
00:59:54,460 --> 00:59:56,560
n的立方

1000
00:59:59,320 --> 01:00:00,430
这是情况3

1001
01:00:02,590 --> 01:00:04,020
我知道这挺无聊的

1002
01:00:04,040 --> 01:00:06,600
这种情况下我们正好使用这个愚蠢的定理

1003
01:00:09,720 --> 01:00:13,060
n²/lgn的结果是什么

1004
01:00:14,510 --> 01:00:16,320
答案是什么?

1005
01:00:21,110 --> 01:00:24,230
好  这种情况下没人回答

1006
01:00:24,930 --> 01:00:27,400
很棘手的问题  我恰好忘了答案

1007
01:00:27,700 --> 01:00:33,580
我想这就类似于 n²lglgn/lgn吗

1008
01:00:34,070 --> 01:00:37,060
哦  不  n²lglgn  好

1009
01:00:37,910 --> 01:00:39,050
但是你不应该知道那些

1010
01:00:39,080 --> 01:00:40,930
这不是从主方法中得出的

1011
01:00:41,050 --> 01:00:42,740
你们得自己解了

1012
01:00:42,790 --> 01:00:43,900
或许通过递归树可以

1013
01:00:43,900 --> 01:00:45,300
是解的好办法

1014
01:00:45,620 --> 01:00:47,840
你得知道一些对数的性质

1015
01:00:48,140 --> 01:00:50,180
知道它的运算方法

1016
01:00:50,240 --> 01:00:52,410
但是这里主方法并不适用

1017
01:01:03,160 --> 01:01:04,960
所以你还是要使用其他的方法

1018
01:01:09,470 --> 01:01:10,950
好  最后我想

1019
01:01:10,950 --> 01:01:12,470
告诉你们为什么主方法是正确的

1020
01:01:13,020 --> 01:01:14,650
那会让它更有直观

1021
01:01:14,650 --> 01:01:16,680
我要用递归树证明

1022
01:01:17,740 --> 01:01:19,330
它为什么成立

1023
01:01:33,420 --> 01:01:37,210
这只是证明的一个梗概  还不是全部的

1024
01:01:37,750 --> 01:01:40,060
详细的证明大家可以看书

1025
01:01:40,550 --> 01:01:42,510
倒不是说书上比我这里证明得容易

1026
01:01:42,510 --> 01:01:44,910
但是了解正式证明中的细节对你们有好处

1027
01:01:44,910 --> 01:01:47,910
这里我没有时间给大家演示所有的细节

1028
01:01:48,120 --> 01:01:50,360
我只能告诉大家重要的部分

1029
01:01:50,370 --> 01:01:54,300
这是证明的梗概 或者说思路

1030
01:01:56,400 --> 01:01:58,610
关于主方法的由来

1031
01:02:03,210 --> 01:02:06,270
我们接下来要做的只是运用递归树法

1032
01:02:06,350 --> 01:02:07,730
来解递归

1033
01:02:08,280 --> 01:02:11,840
然后将每一层加起来 再层层相加

1034
01:02:12,040 --> 01:02:13,130
再看看我们得出什么

1035
01:02:16,340 --> 01:02:20,000
从最顶端的f开始展开第一层

1036
01:02:20,210 --> 01:02:27,080
展开为a个规模为n/b的问题

1037
01:02:27,340 --> 01:02:33,400
在我展开它们之后  每一个都是f(n/b)

1038
01:02:33,790 --> 01:02:35,250
它们规模相同

1039
01:02:35,520 --> 01:02:37,340
然后我们能继续展开所有的f(n/b)

1040
01:02:37,540 --> 01:02:41,590
然后我们能从这里得到其他的子问题

1041
01:02:41,780 --> 01:02:46,960
我们将得到 f(n/b²)

1042
01:02:49,170 --> 01:02:52,360
规模呈几何级数递减

1043
01:02:52,570 --> 01:02:54,500
等等  等等

1044
01:02:54,650 --> 01:02:58,080
直到我们在底部得出常数规模的问题

1045
01:02:58,150 --> 01:03:00,650
这有点特殊  因为这是基本情况

1046
01:03:00,840 --> 01:03:02,820
我们在底部得到别的常量

1047
01:03:03,390 --> 01:03:05,410
我们想知道有多少叶节点

1048
01:03:06,210 --> 01:03:08,220
但是这时候稍微有些棘手

1049
01:03:08,240 --> 01:03:11,600
我们首先计算树的高度

1050
01:03:14,130 --> 01:03:16,230
我在这边画出来

1051
01:03:17,190 --> 01:03:18,500
树的高度是多少

1052
01:03:18,570 --> 01:03:20,160
我从问题n开始

1053
01:03:20,330 --> 01:03:22,600
我想一直向下直到问题规模为1

1054
01:03:24,010 --> 01:03:25,380
高度是多少

1055
01:03:28,670 --> 01:03:29,610
有多少层

1056
01:03:36,480 --> 01:03:38,530
对于部分同学可能很简单

1057
01:03:38,550 --> 01:03:42,250
但对于其他同学还不是触手可及

1058
01:03:48,490 --> 01:03:50,050
logbn  好

1059
01:03:50,630 --> 01:03:53,590
树的高度是 logbn

1060
01:03:53,600 --> 01:03:54,900
因为这正是一直除以b

1061
01:03:54,910 --> 01:03:56,770
直到降到1 所需要的次数

1062
01:03:57,540 --> 01:03:58,690
好极了

1063
01:03:58,940 --> 01:04:00,720
现在应该就可以计算叶节点的数量了

1064
01:04:00,800 --> 01:04:02,820
因为我有一个分支因子 a

1065
01:04:03,020 --> 01:04:04,540
还有高度 h

1066
01:04:04,710 --> 01:04:11,320
所以叶节点的数量是 a^h a^logbn

1067
01:04:13,960 --> 01:04:16,100
我展开来写

1068
01:04:16,330 --> 01:04:20,100
a^logbn  跟对数的性质

1069
01:04:20,130 --> 01:04:23,940
我们能把n放在下边  把a放在上边

1070
01:04:24,150 --> 01:04:28,770
我们就得到了logba  老朋友 logba

1071
01:04:28,770 --> 01:04:30,910
所以  这就是logba

1072
01:04:30,970 --> 01:04:32,310
在主方法中这么重要的原因

1073
01:04:32,410 --> 01:04:34,630
我们要做的是比较

1074
01:04:34,650 --> 01:04:35,540
在最顶层的f

1075
01:04:35,730 --> 01:04:39,580
和最底层的 logba

1076
01:04:39,810 --> 01:04:41,630
现在所有的叶节点在同一层

1077
01:04:41,710 --> 01:04:44,430
因为每一个分支上都以同样的速度递减

1078
01:04:44,770 --> 01:04:48,200
将底层的代价加起来

1079
01:04:48,280 --> 01:04:51,450
得到 Θ(logba)

1080
01:04:53,260 --> 01:04:54,890
把顶层的加起来

1081
01:04:54,970 --> 01:04:58,720
得到是f(n)  有点无聊

1082
01:04:58,840 --> 01:05:00,230
但是在下一级

1083
01:05:00,260 --> 01:05:03,820
这就有点意思  是af(n/b)

1084
01:05:04,270 --> 01:05:05,630
看起来很熟悉吧

1085
01:05:05,630 --> 01:05:09,320
如果你已经熟记了主方法  这个就是

1086
01:05:09,900 --> 01:05:15,670
我们知道 af(n/b) 已经减少了某常量倍

1087
01:05:15,890 --> 01:05:17,430
1-ε'

1088
01:05:18,180 --> 01:05:19,240
计算到这

1089
01:05:19,410 --> 01:05:22,000
这个比这个小某常数倍

1090
01:05:22,500 --> 01:05:24,340
然后对下一层求和

1091
01:05:24,390 --> 01:05:28,840
会得出a²f(n/b²)这样的结果

1092
01:05:31,770 --> 01:05:34,330
我看到我把这个写错了  括号里的内容

1093
01:05:34,330 --> 01:05:35,700
对不起

1094
01:05:35,960 --> 01:05:39,160
不是(n/b)²  而是n/b²

1095
01:05:41,910 --> 01:05:47,200
所以这个数列  至少在情况3中

1096
01:05:47,240 --> 01:05:48,990
是呈几何级数递减的

1097
01:05:49,640 --> 01:05:52,570
如果它以几何级数递减

1098
01:05:52,570 --> 01:05:57,310
最大项f(n)就会占据主导

1099
01:05:57,360 --> 01:05:59,800
因此  在情况3中  我们得到 Θ(f(n))

1100
01:06:00,680 --> 01:06:03,500
我们看看其他的情况

1101
01:06:03,570 --> 01:06:06,540
根据剩下的时间的情况 看讲多少

1102
01:06:06,560 --> 01:06:07,310
太多时间了

1103
01:06:09,010 --> 01:06:10,690
五分钟  太多时间了

1104
01:06:11,270 --> 01:06:15,550
做些什么  我把它写下来

1105
01:06:15,800 --> 01:06:21,420
情况3  代价逐渐降低

1106
01:06:21,450 --> 01:06:22,750
这里我需要说明

1107
01:06:22,750 --> 01:06:24,740
这里的省略是很显然的

1108
01:06:25,200 --> 01:06:29,700
这些无比简单的  (a^k)f(n/b^k)

1109
01:06:29,900 --> 01:06:37,510
情况3中  我们假设成本呈几何级数降低

1110
01:06:44,000 --> 01:06:46,560
顺着树向下

1111
01:06:47,990 --> 01:06:50,570
从情况3开始往回讨论

1112
01:06:50,630 --> 01:06:52,590
让我们来看看情况1

1113
01:06:53,000 --> 01:06:56,350
这是一种直观的简单情况

1114
01:06:56,620 --> 01:07:04,780
在情况1中  我们知道f(n) 多项式地小于这个

1115
01:07:06,160 --> 01:07:07,890
我们可以说是

1116
01:07:07,890 --> 01:07:10,490
从中间改变了这个的顺序

1117
01:07:10,580 --> 01:07:12,050
如果大家想要正式的证明

1118
01:07:12,050 --> 01:07:13,490
我是不会做的

1119
01:07:13,730 --> 01:07:16,700
我敢说这将会呈几何级数增长

1120
01:07:17,170 --> 01:07:19,770
它必须呈几何级数增长  因为这f(n)

1121
01:07:19,800 --> 01:07:23,310
多项式地 比这个小

1122
01:07:23,440 --> 01:07:25,580
你将在中间得到很多种多项式

1123
01:07:25,790 --> 01:07:29,110
必然需要从小到大 呈几何级数上升

1124
01:07:29,150 --> 01:07:31,300
因此  大的占主导地位  但它还是

1125
01:07:31,380 --> 01:07:32,710
几何级数

1126
01:07:33,110 --> 01:07:39,100
正如我所说  这是直觉  不能算正式的证明

1127
01:07:39,150 --> 01:07:41,180
上面这个证明就很正式了  因为我们进行了假设

1128
01:07:41,430 --> 01:07:43,940
但是这里我们需要更多地论证

1129
01:07:44,080 --> 01:07:45,830
它们不一定非要呈几何级数增长

1130
01:07:45,880 --> 01:07:47,470
它们也许会增长的更快

1131
01:07:47,650 --> 01:07:50,420
这也有可能

1132
01:07:51,090 --> 01:07:53,840
所以  在情况3中  占主导的

1133
01:07:56,330 --> 01:07:57,300
我是说 占主导的总是

1134
01:07:57,340 --> 01:08:00,220
几何级数中的最大项

1135
01:08:00,450 --> 01:08:02,530
情况3中是f(n)

1136
01:08:05,170 --> 01:08:10,870
而这里  占主导的是logba

1137
01:08:10,900 --> 01:08:13,230
底层那个  写上Θ

1138
01:08:15,650 --> 01:08:16,940
情况2

1139
01:08:19,900 --> 01:08:22,400
这里这个非常简单

1140
01:08:22,420 --> 01:08:24,270
但是你需要知道一些对数的性质

1141
01:08:24,480 --> 01:08:25,260
在情况2中

1142
01:08:25,300 --> 01:08:27,600
我们假设所有的这些是基本相同的

1143
01:08:27,720 --> 01:08:30,710
我是说  我们假设顶层与底层相等

1144
01:08:30,940 --> 01:08:33,830
由于中间的过程很有规律

1145
01:08:33,900 --> 01:08:35,760
因此  所有的中间的这些

1146
01:08:35,800 --> 01:08:37,140
必须基本一致

1147
01:08:38,410 --> 01:08:41,440
不完全一致  因为这里没有lg因式

1148
01:08:41,710 --> 01:08:43,320
而这里有一个lg的k次方

1149
01:08:43,320 --> 01:08:47,030
logba乘以(lg^k)n

1150
01:08:47,220 --> 01:08:48,800
这里则没有lg的k次方

1151
01:08:48,900 --> 01:08:50,560
lg在过程中没有了

1152
01:08:50,650 --> 01:08:53,100
消失的方式是很缓慢的

1153
01:08:53,270 --> 01:08:59,110
如果你观察这上半部分

1154
01:08:59,300 --> 01:09:00,970
它们都含有lg的k次方

1155
01:09:01,350 --> 01:09:03,270
在下半部分它们将开始消失

1156
01:09:03,470 --> 01:09:07,280
我给你们一些令人来自神灵的信息

1157
01:09:07,360 --> 01:09:12,220
如果你算对数  你不把参数改变得太厉害

1158
01:09:12,330 --> 01:09:13,800
对数值不变

1159
01:09:14,750 --> 01:09:16,610
也许半路有点太远

1160
01:09:17,500 --> 01:09:20,560
要求是每一级都大致相同

1161
01:09:20,740 --> 01:09:25,220
特别是上面的大部分层都渐进地相等

1162
01:09:28,090 --> 01:09:30,560
大致相同

1163
01:09:32,340 --> 01:09:35,940
因此  总代价是其中一层

1164
01:09:35,950 --> 01:09:45,650
比如f乘以树的高度h

1165
01:09:46,000 --> 01:09:47,830
h也就是logbn

1166
01:09:47,930 --> 01:09:49,590
b是一个常量我们不用在意

1167
01:09:49,740 --> 01:09:52,140
因此得到Θ(lgn)

1168
01:09:55,430 --> 01:10:05,570
因此  我们得到T(n)=logba·(lg^k)n乘以另一个lgn

1169
01:10:06,130 --> 01:10:08,220
所以我们得出f(n)·lgn

1170
01:10:08,970 --> 01:10:10,780
那是非常粗略的证明

1171
01:10:10,790 --> 01:10:13,010
抱歉  情况1和2都讲得太模糊了

1172
01:10:13,080 --> 01:10:15,300
记得回去看证明  你们必须看

1173
01:10:15,350 --> 01:10:17,740
某些时刻  需要那样处理对数

1174
01:10:18,010 --> 01:10:20,070
就到这里  有什么问题吗?

1175
01:10:20,160 --> 01:10:22,280
你们都渴望下课了  好吧

1176
01:10:22,460 --> 01:10:24,630
谢谢  周三见

