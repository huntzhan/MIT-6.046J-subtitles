1
00:00:05,580 --> 00:00:08,460
早上好  今天我们要讨论

2
00:00:08,560 --> 00:00:10,890
一种新的平衡搜索结构

3
00:00:10,950 --> 00:00:13,260
这种数据结构可以维护动态数据集

4
00:00:13,310 --> 00:00:15,090
支持插入 删除

5
00:00:15,160 --> 00:00:17,410
还有搜索  称为跳跃表

6
00:00:19,630 --> 00:00:23,230
它是个动态搜索结构

7
00:00:23,320 --> 00:00:24,350
因为这个数据结构

8
00:00:24,410 --> 00:00:28,680
它支持搜索 而且它是动态的 即支持插入和删除

9
00:00:31,460 --> 00:00:34,100
好 我们还知道有什么动态搜索结构呢？

10
00:00:34,150 --> 00:00:38,220
作个对比  唤醒一下大家的记忆

11
00:00:39,910 --> 00:00:42,950
知道的说一下  高效的 我补充一点

12
00:00:43,050 --> 00:00:48,390
而且是良好的  每个操作只需对数级的时间

13
00:00:53,200 --> 00:00:57,830
这个问题真的弱爆了

14
00:01:00,540 --> 00:01:01,970
这些结构你们上周都见过了

15
00:01:02,070 --> 00:01:05,040
这不难吧

16
00:01:05,140 --> 00:01:08,250
树堆 很好 在习题里我们见过树堆

17
00:01:08,310 --> 00:01:09,860
这可以说是

18
00:01:09,950 --> 00:01:12,470
我们用基本概念构造出来的

19
00:01:12,570 --> 00:01:13,740
最简单的动态搜索结构

20
00:01:13,800 --> 00:01:16,630
因为我们只是想给

21
00:01:16,740 --> 00:01:18,860
随机化二叉搜索树找一个限界

22
00:01:18,950 --> 00:01:20,440
而且树堆运作得不错

23
00:01:21,800 --> 00:01:23,940
大概 你们最先接触到是它

24
00:01:24,030 --> 00:01:28,060
当然 这取决于你做习题的时间  还有什么

25
00:01:32,750 --> 00:01:34,020
查哥！

26
00:01:34,130 --> 00:01:35,700
红黑树

27
00:01:35,790 --> 00:01:39,020
红黑树  答得好

28
00:01:40,660 --> 00:01:45,100
这个刚好是一周前的内容  我希望大家还记得

29
00:01:45,210 --> 00:01:46,930
红黑树的性能为 O(log n)

30
00:01:47,080 --> 00:01:48,790
树堆是有一个期望限界

31
00:01:48,850 --> 00:01:51,850
而红黑树则是最坏情况复杂度为O(log n)

32
00:01:51,980 --> 00:01:53,610
对插入 删除 搜索都成立

33
00:01:53,730 --> 00:01:55,690
还有一个

34
00:02:00,660 --> 00:02:06,760
周五的习题课上提到的  B树 很好

35
00:02:07,680 --> 00:02:10,660
提到B树 我还想提一下 2-3-树

36
00:02:10,760 --> 00:02:12,720
2-3-4-树 等等

37
00:02:12,810 --> 00:02:14,110
也就是说 无论B是一个常数

38
00:02:14,200 --> 00:02:17,700
还是你B树选得更为灵活

39
00:02:17,760 --> 00:02:21,380
它们都保证有 O(log n) 的性能

40
00:02:21,480 --> 00:02:23,280
也就是说 它的最坏情况也是O(log n）

41
00:02:23,340 --> 00:02:24,800
这是大家应该了解的

42
00:02:24,860 --> 00:02:28,550
这些都是平衡搜索结构

43
00:02:28,650 --> 00:02:30,920
它们是动态的 支持插入和删除

44
00:02:31,020 --> 00:02:33,710
它们支持特定键值的搜索

45
00:02:33,810 --> 00:02:36,590
如果你要找的不是键值本身

46
00:02:36,700 --> 00:02:39,510
你也能很容易找到它前前后后的元素

47
00:02:39,610 --> 00:02:41,530
假如说 我们想扩张某个数据结构

48
00:02:41,630 --> 00:02:44,950
我们首先思考哪种结构是最容易扩张的

49
00:02:45,040 --> 00:02:46,640
这是周一课上的内容

50
00:02:46,740 --> 00:02:51,300
现在问题是

51
00:02:51,410 --> 00:02:55,140
假如我现在送你一台本本  爽吧

52
00:02:55,240 --> 00:02:57,000
然后我说

53
00:02:57,060 --> 00:02:59,680
送给你的条件是

54
00:02:59,740 --> 00:03:04,930
你要实现这里其中一种结构  就在这节课上完成

55
00:03:05,040 --> 00:03:07,660
你觉得你能做到吗？

56
00:03:07,760 --> 00:03:09,620
有多少人觉得自己可以做到？

57
00:03:09,680 --> 00:03:14,820
有一些人觉得可以 都是我们的前排部队 很好

58
00:03:14,910 --> 00:03:18,130
我应该可以做到 我偏向于实现B树

59
00:03:18,190 --> 00:03:20,380
我觉得它是最简单的了

60
00:03:20,430 --> 00:03:22,140
当然是不让翻书的哈

61
00:03:22,290 --> 00:03:24,730
这是闭卷考试

62
00:03:24,780 --> 00:03:27,660
很不幸的是 我没有那么多台本本来考验你们

63
00:03:27,770 --> 00:03:30,910
总之实现B树是比较合理的

64
00:03:31,020 --> 00:03:32,790
做删除时  你要记得

65
00:03:32,870 --> 00:03:35,600
从邻近结点处转移元素 等等

66
00:03:35,700 --> 00:03:36,850
删除是有技巧的

67
00:03:36,950 --> 00:03:38,890
红黑树我怎么也记不住

68
00:03:38,950 --> 00:03:41,520
我总要查查书 或者再推导一遍那三种情况

69
00:03:41,570 --> 00:03:44,180
树堆的实现更花哨一点

70
00:03:44,270 --> 00:03:47,420
所以 要花点时间

71
00:03:47,480 --> 00:03:48,760
才能记住怎么弄

72
00:03:48,820 --> 00:03:50,510
你可能得再做一次习题集的题

73
00:03:50,530 --> 00:03:51,940
如果你不记得的话

74
00:03:52,050 --> 00:03:53,840
但是 跳跃表

75
00:03:53,860 --> 00:03:56,580
却是一种你一定忘不了的数据结构

76
00:03:56,580 --> 00:04:00,300
你可以在一个小时内实现它 没有问题

77
00:04:00,400 --> 00:04:03,740
这话我以前讲过很多遍

78
00:04:03,830 --> 00:04:07,580
但是我从未做到过 搞得我很有挫败感

79
00:04:07,640 --> 00:04:09,920
所以今天早上 我把跳跃表做出来了

80
00:04:09,970 --> 00:04:14,060
我花了10分钟实现了链表

81
00:04:14,160 --> 00:04:16,220
然后花30分钟实现了跳跃表

82
00:04:16,280 --> 00:04:21,840
最后花了30分钟调试  鉴定完毕

83
00:04:21,940 --> 00:04:24,480
这是可以做到的 跳跃表真的很简单

84
00:04:24,560 --> 00:04:27,180
而且在写代码的时候  我都不需要深入思考

85
00:04:27,270 --> 00:04:30,410
但写其他结构时 我总是要想想

86
00:04:30,510 --> 00:04:33,950
有些时候我总要停下来 想想我该怎么抛硬币呢

87
00:04:34,050 --> 00:04:36,730
然后脑袋就堵塞了

88
00:04:36,790 --> 00:04:39,260
所以 跳跃表是一个随机化的结构

89
00:04:39,370 --> 00:04:42,560
我们在这里多加点形容词

90
00:04:45,490 --> 00:04:48,410
加个“简单”吧

91
00:04:49,820 --> 00:04:52,390
我们得到的是一个简单的、高效的、动态的

92
00:04:52,500 --> 00:04:55,420
随机化搜索结构 集合了各种优点

93
00:04:55,510 --> 00:04:57,650
它有点像树堆

94
00:04:57,740 --> 00:05:00,570
它的界是随机化的

95
00:05:00,670 --> 00:05:01,670
但是今天我们会看到

96
00:05:01,770 --> 00:05:04,050
一个比期望界限还要强得多的界

97
00:05:04,100 --> 00:05:05,180
特别地

98
00:05:05,280 --> 00:05:08,020
跳跃表期望的运行时间为 O(log n)

99
00:05:13,190 --> 00:05:15,270
所以 每一个操作的运行时间的

100
00:05:15,380 --> 00:05:17,390
期望均为 O(log n)

101
00:05:19,940 --> 00:05:21,800
但我们要证明一个更强大的结果

102
00:05:21,900 --> 00:05:24,760
不单是O(log n)  而且发生概率很高

103
00:05:33,940 --> 00:05:39,880
这种说法其实很强大  它意味着

104
00:05:39,980 --> 00:05:41,640
每次操作的运行时间

105
00:05:41,740 --> 00:05:43,920
每一步操作的运行时间

106
00:05:43,970 --> 00:05:48,000
几乎总是 O(log n)

107
00:05:49,390 --> 00:05:51,840
更进一步地 我剧透一下

108
00:05:55,900 --> 00:06:01,530
出现O(log n) 时间的概率是 比如说

109
00:06:01,630 --> 00:06:05,560
至少是 1 减去某个 n 的多项式的倒数

110
00:06:05,670 --> 00:06:08,320
而且 我们可以令多项式充分大

111
00:06:08,440 --> 00:06:12,260
这也就是说 几乎所有情况下

112
00:06:12,360 --> 00:06:13,570
操作跳跃表

113
00:06:13,690 --> 00:06:15,740
假设操作次数是多项式级的

114
00:06:15,850 --> 00:06:18,010
假设我们在运行一个时间是多项式级的算法

115
00:06:18,110 --> 00:06:19,180
它用到了这个数据结构

116
00:06:19,310 --> 00:06:21,520
那么做多项式次的插入 删除或搜索操作

117
00:06:21,520 --> 00:06:23,440
每一个操作的时间

118
00:06:23,500 --> 00:06:26,600
几乎可以保证均为 O(log n)

119
00:06:26,690 --> 00:06:30,550
这给概率分布的尾部加了一个很强的界

120
00:06:30,620 --> 00:06:33,470
平均运行时间是 O(log n)  貌似这没什么大不了

121
00:06:33,620 --> 00:06:34,810
而实际上

122
00:06:34,820 --> 00:06:37,440
几乎所有的概率分布的权值

123
00:06:37,540 --> 00:06:40,390
都落在log n的邻域内 只有非常小量的

124
00:06:40,390 --> 00:06:44,000
在极小概率情况下会超过 log n

125
00:06:45,520 --> 00:06:49,900
我们的目的是证明这个

126
00:06:50,000 --> 00:06:55,280
这是1989年由 Pugh 提出的数据结构

127
00:06:55,370 --> 00:06:56,900
这个是最新的成果

128
00:06:56,990 --> 00:07:00,110
噢 抱歉 树堆才是最新的结果

129
00:07:00,210 --> 00:07:02,290
它大概是93年左右做出来的

130
00:07:03,380 --> 00:07:05,450
不过跳跃表还是一个很新的数据结构

131
00:07:06,950 --> 00:07:08,460
实现了插入 删除和搜索功能

132
00:07:08,470 --> 00:07:13,090
而且它很简单 你甚至能把它推导出来

133
00:07:13,090 --> 00:07:14,690
即使你对数据结构一无所知

134
00:07:14,750 --> 00:07:17,280
几乎不需要准备知识

135
00:07:17,380 --> 00:07:20,730
分析它的性能的界是 O(log n)

136
00:07:20,820 --> 00:07:22,930
才是我们证明的关键

137
00:07:22,980 --> 00:07:25,240
这种数据结构本身是简单的

138
00:07:26,540 --> 00:07:27,870
我们现在从零开始

139
00:07:33,920 --> 00:07:37,160
假设我们不知道什么是红黑树

140
00:07:37,260 --> 00:07:38,650
不知道什么是B树

141
00:07:39,840 --> 00:07:42,020
假设我们连树是什么都不知道

142
00:07:42,540 --> 00:07:44,610
那么 存储一堆动态数据的

143
00:07:44,670 --> 00:07:49,820
最简单的数据结构是什么？

144
00:07:51,290 --> 00:07:53,770
表 很好 特别地 是一个链表

145
00:07:53,870 --> 00:07:57,190
现在假设它是一个排好序的链表

146
00:07:57,300 --> 00:07:59,100
这里我们用一点高级点的东西哈

147
00:08:02,790 --> 00:08:06,190
现在 我们有一个链表

148
00:08:06,290 --> 00:08:09,170
为了好玩 定义它为一个双向链表吧

149
00:08:11,350 --> 00:08:14,520
搜索一个排好序的链表需要多长时间

150
00:08:22,480 --> 00:08:25,960
我听到一个答案是 O(log n) 还有 O(n)

151
00:08:26,060 --> 00:08:29,300
哪个是对的？  O(n)是对的

152
00:08:29,400 --> 00:08:31,500
即便链表已经排好序了 我们也没法做二分查找

153
00:08:31,550 --> 00:08:33,810
因为我们不能随机访问链表元素

154
00:08:33,870 --> 00:08:36,350
假设我只给出一个指向表头的指针

155
00:08:36,410 --> 00:08:38,570
反过来 假设这是一个数组的话

156
00:08:38,690 --> 00:08:41,010
在排序数组里 搜索时间就可以是O(log n)

157
00:08:41,040 --> 00:08:42,410
对于排序链表

158
00:08:42,470 --> 00:08:43,830
我们就得遍历整个破玩意儿

159
00:08:43,920 --> 00:08:49,070
所以 最坏情况时间为 Θ(n)

160
00:08:49,170 --> 00:08:54,290
这个不是很好 但如果我们逐步改进它

161
00:08:54,400 --> 00:08:56,600
我们就能自然而然地推出跳跃表

162
00:08:58,050 --> 00:09:03,090
这就是我们的起点 排序链表 Θ(n) 的时间

163
00:09:03,200 --> 00:09:04,440
现在我暂不考虑插入和删除

164
00:09:04,490 --> 00:09:06,130
现在我暂不考虑插入和删除

165
00:09:06,230 --> 00:09:10,960
我们先来改进搜索 然后再来操心结构的更新

166
00:09:11,460 --> 00:09:13,490
因为更新的时候才会出现随机化

167
00:09:13,490 --> 00:09:14,810
搜索的思想很简单的

168
00:09:14,900 --> 00:09:16,920
那么 我们如何去改进链表？

169
00:09:16,970 --> 00:09:20,440
假设我们已知的链表的所有性质

170
00:09:20,540 --> 00:09:22,670
怎么样才能让它更快

171
00:09:23,680 --> 00:09:25,050
这时 我们就需要

172
00:09:25,140 --> 00:09:28,350
一点创新 一点创造力

173
00:09:30,100 --> 00:09:34,620
加入更多的链接？ 这个想法不错

174
00:09:34,720 --> 00:09:40,490
比如说 我再加几个指向后面元素的指针

175
00:09:40,630 --> 00:09:44,690
只要加log n个指针 我就可以实现2的幂次的访问

176
00:09:44,780 --> 00:09:48,680
这是一个很好的搜索结构 有些人现在就在用

177
00:09:49,030 --> 00:09:51,540
比如说某些点对点网络就是这个原理

178
00:09:51,600 --> 00:09:53,570
不过就这个东西太花哨了

179
00:09:53,570 --> 00:09:58,750
[学生]。。。

180
00:09:58,840 --> 00:10:03,160
嗯 好 我们可以从这个线性结构里构造出一棵树

181
00:10:03,270 --> 00:10:05,040
我们其实正要这么做

182
00:10:05,100 --> 00:10:07,750
我们可以把根节点的下一位

183
00:10:07,870 --> 00:10:10,290
指向链表的中位元素

184
00:10:10,350 --> 00:10:12,290
然后下一步从这里开始搜索  又或者

185
00:10:12,350 --> 00:10:16,080
首先我们指向中位 然后我们再比较大小

186
00:10:16,140 --> 00:10:18,160
决定是搜索前半部分 还是后半

187
00:10:18,220 --> 00:10:20,320
方向是正确的

188
00:10:20,380 --> 00:10:21,920
但是这还是太复杂了

189
00:10:25,020 --> 00:10:28,590
使用另一个链表 对 对 非常好

190
00:10:28,700 --> 00:10:30,500
我们准备使用两个链表

191
00:10:30,590 --> 00:10:35,040
这也许是我们能够做到的第二容易的事

192
00:10:38,080 --> 00:10:39,450
好 就像你说的

193
00:10:39,520 --> 00:10:41,910
我们用指针连接两个链表

194
00:10:41,960 --> 00:10:44,420
然后 有些元素在下面

195
00:10:44,480 --> 00:10:46,990
有些元素在上面

196
00:10:47,090 --> 00:10:49,980
链表之间用指针相连

197
00:10:50,090 --> 00:10:55,760
这个做法看起来有点疯狂

198
00:10:55,810 --> 00:10:57,430
不过现在还好

199
00:10:57,430 --> 00:10:58,820
现在 这是链表L1

200
00:10:58,910 --> 00:11:01,190
这是另一个链表L2

201
00:11:01,250 --> 00:11:02,820
现在 为了给大家一点直观的启示

202
00:11:09,830 --> 00:11:12,950
我先讲一个 额 我们来玩一个游戏

203
00:11:14,180 --> 00:11:15,980
游戏是 数列猜猜猜

204
00:11:20,480 --> 00:11:23,070
这个数列是 14。。。

205
00:11:23,160 --> 00:11:25,480
如果你知道答案 那就吼出来

206
00:11:36,240 --> 00:11:39,840
有人知道么 哈 这个问题有点奇葩

207
00:11:52,340 --> 00:11:54,200
我们这是个小班

208
00:11:54,250 --> 00:11:56,500
我希望有人知道答案

209
00:12:07,510 --> 00:12:09,840
有多少助教知道答案

210
00:12:11,100 --> 00:12:13,630
只有几个 没关系 如果你们看过幻灯片

211
00:12:13,730 --> 00:12:15,400
可能会知道答案

212
00:12:15,490 --> 00:12:18,420
那是作弊哦亲 我给一点提示

213
00:12:18,470 --> 00:12:20,050
这不是一个数学上的数列

214
00:12:20,160 --> 00:12:26,500
这是一个现实生活中的数列 请说

215
00:12:29,230 --> 00:12:33,260
对 什么城市的 纽约 正确 这是第七大道线

216
00:12:33,350 --> 00:12:36,570
我最喜欢的纽约地铁线

217
00:12:36,670 --> 00:12:41,500
纽约地铁有什么很酷的性质呢

218
00:12:43,500 --> 00:12:46,130
它是一个跳跃表 答得好

219
00:12:46,230 --> 00:12:47,740
[笑声]

220
00:12:47,840 --> 00:12:54,530
它确实是一个跳跃表 跳跃表是非常实用的

221
00:12:54,620 --> 00:12:59,740
地铁线路就实现了跳跃表 酷爆了

222
00:12:59,830 --> 00:13:06,820
这样说吧 波士顿的地铁很棒 因为它是全美最老的地铁

223
00:13:06,930 --> 00:13:10,520
可能还是全球最老的 

224
00:13:11,240 --> 00:13:13,340
纽约地铁的历史同样悠久

225
00:13:13,510 --> 00:13:16,420
更不错的是 它还是24小时运营的

226
00:13:16,510 --> 00:13:17,800
这也是它的优势之一

227
00:13:17,920 --> 00:13:20,930
但它有一个很重要的特点就是有快线

228
00:13:21,030 --> 00:13:23,380
这样讲可能有点抽象

229
00:13:23,450 --> 00:13:26,240
第七大道线有两种列车

230
00:13:26,330 --> 00:13:28,630
顺便讲一句这是街道编号

231
00:13:28,690 --> 00:13:33,310
这是宾州广场站 时代广场站 等等

232
00:13:36,790 --> 00:13:38,090
它实际上有两条线

233
00:13:38,180 --> 00:13:39,000
快线在14 34 42 72和96街设有车站

234
00:13:39,100 --> 00:13:42,320
快线在14 34 42 72和96街设有车站

235
00:13:42,420 --> 00:13:46,370
慢线则站站停车

236
00:13:46,460 --> 00:13:49,660
这是通过四条轨道实现的

237
00:13:49,770 --> 00:13:52,850
也就是说 快车在单独的轨道上运行

238
00:13:52,950 --> 00:13:57,320
比如说 现在我们从宾州广场站 想去往59街

239
00:13:57,410 --> 00:14:00,680
不 还是从城西出发吧

240
00:14:00,780 --> 00:14:03,050
首先我们上快线

241
00:14:03,100 --> 00:14:05,470
很快地我们来到42街

242
00:14:05,530 --> 00:14:07,640
然后换乘慢车

243
00:14:07,690 --> 00:14:10,980
再到59街或者随便什么站

244
00:14:11,070 --> 00:14:17,610
这就是快线和慢线

245
00:14:17,710 --> 00:14:20,640
我们可以用一些链表来表示它们

246
00:14:20,730 --> 00:14:22,230
首先我们有一层链表

247
00:14:24,050 --> 00:14:27,710
首先我们有一层底链表

248
00:14:29,360 --> 00:14:30,980
上面留点地方

249
00:14:32,570 --> 00:14:35,760
这是慢线L2

250
00:14:35,860 --> 00:14:58,620
34 42 50 59 66 72 79等等

251
00:15:00,170 --> 00:15:02,460
上面是快线

252
00:15:04,130 --> 00:15:15,490
只停14 34 42 72等等

253
00:15:16,530 --> 00:15:20,140
我就不把整个链表画出来了 你懂的

254
00:15:20,240 --> 00:15:22,610
然后我们把快线和慢线...

255
00:15:22,660 --> 00:15:28,540
它们都停的车站 给链接起来

256
00:15:28,660 --> 00:15:34,920
这就是我们得到的双链表结构

257
00:15:35,020 --> 00:15:36,740
我就是这个意思

258
00:15:36,840 --> 00:15:38,620
就是这里画的这个图

259
00:15:38,740 --> 00:15:40,400
注意 这里有一个性质

260
00:15:40,500 --> 00:15:43,130
这一个底链表  它包含了所有元素

261
00:15:43,190 --> 00:15:46,450
而在顶链表中只包含了其中几个元素

262
00:15:46,540 --> 00:15:49,200
我们将会保持这个性质

263
00:15:49,300 --> 00:15:53,600
即L2存储全部元素

264
00:15:59,890 --> 00:16:03,000
L1只存某些子集

265
00:16:03,100 --> 00:16:06,400
至于存的是哪些元素  现在还是未定

266
00:16:06,950 --> 00:16:09,280
这也是我们需要考虑的一点

267
00:16:09,330 --> 00:16:13,500
我们的灵感是来自纽约地铁系统

268
00:16:14,890 --> 00:16:17,120
好的 这是我们的出发点

269
00:16:17,210 --> 00:16:19,530
当然 我们会用到不止两个链表

270
00:16:19,590 --> 00:16:23,600
对了 我们还有链接

271
00:16:25,180 --> 00:16:38,980
L1和L2中 键值相同的元素之间有链接

272
00:16:43,060 --> 00:16:46,170
好的  为了课程的完整性

273
00:16:46,220 --> 00:16:48,710
因为等会才会用到这个 我们首先讨论搜索

274
00:16:48,800 --> 00:16:51,540
稍候再考虑链表如何构造

275
00:16:56,980 --> 00:16:59,390
换个黑板先

276
00:17:00,560 --> 00:17:07,090
比如说 我们要查找一个元素x 应该怎么做

277
00:17:07,830 --> 00:17:09,900
这是坐地铁算法哈

278
00:17:10,010 --> 00:17:12,090
假设我们总是在

279
00:17:12,150 --> 00:17:14,070
左上角入站

280
00:17:14,150 --> 00:17:18,030
也就是在城西的14街

281
00:17:18,160 --> 00:17:22,120
我不知道准确的方位在哪

282
00:17:22,220 --> 00:17:24,680
总之是在曼哈顿地下某处

283
00:17:24,740 --> 00:17:28,800
假设我们要去往某个特定的车站 比如59街

284
00:17:28,850 --> 00:17:32,340
那我们在快线上 肯定是能坐多远坐多远

285
00:17:32,430 --> 00:17:34,830
因为我们一开始就在快线上

286
00:17:34,880 --> 00:17:36,090
然后我们往下走

287
00:17:36,160 --> 00:17:38,370
坐慢车到59街

288
00:17:38,470 --> 00:17:39,920
这当然是正确的做法

289
00:17:40,050 --> 00:17:43,310
假设我们从左上角开始的话

290
00:17:43,410 --> 00:17:49,350
现在我把步骤总结成算法

291
00:17:49,410 --> 00:17:50,950
因为我们要推广它

292
00:17:52,250 --> 00:17:56,730
目前的情况是很显然的 往后的情形也很简单

293
00:17:58,970 --> 00:18:02,650
现在我要在顶链表上一直往右跑

294
00:18:03,820 --> 00:18:06,060
直到跑过头

295
00:18:13,390 --> 00:18:16,160
想像一下你在告诉一个

296
00:18:16,280 --> 00:18:18,800
从未坐过地铁的人如何搭乘地铁

297
00:18:18,910 --> 00:18:21,650
你会说 嗯 从14街入站 坐快线

298
00:18:21,750 --> 00:18:24,560
如果坐到了72街站 你就坐过头了

299
00:18:24,610 --> 00:18:27,950
往回坐一个站 然后换乘慢线

300
00:18:28,050 --> 00:18:29,570
但问路的人就被气死了

301
00:18:29,670 --> 00:18:31,140
不过算法必须要这样

302
00:18:31,200 --> 00:18:32,750
因为计算机从未坐过地铁

303
00:18:32,870 --> 00:18:38,780
现在我们跟着这个图过一遍 写在这儿吧

304
00:18:40,680 --> 00:18:43,560
假设我要去59街

305
00:18:44,310 --> 00:18:47,740
我从14街入站 首先我坐到34街

306
00:18:47,840 --> 00:18:50,480
然后坐到42街

307
00:18:50,580 --> 00:18:53,000
还好 因为59大于42

308
00:18:53,060 --> 00:18:58,410
我再坐一个站 然后 哦噢 72太大了 我坐过站了

309
00:19:00,450 --> 00:19:02,890
然后我往回坐一个站

310
00:19:02,960 --> 00:19:05,990
然后我跑下来继续往右跑

311
00:19:06,110 --> 00:19:07,570
直到我找到想找的元素

312
00:19:07,680 --> 00:19:09,330
或者发现它不在底链表中

313
00:19:09,430 --> 00:19:10,940
因为底链表中已经包括了所有元素

314
00:19:14,880 --> 00:19:15,760
这就是整个算法

315
00:19:15,870 --> 00:19:18,000
一直往右跑直到跑过头

316
00:19:18,050 --> 00:19:19,820
判断有没有跑过头 只须比较一下大小就行了

317
00:19:19,880 --> 00:19:25,560
然后下到L2

318
00:19:27,160 --> 00:19:38,240
继续在L2上往右跑直到找到x

319
00:19:39,640 --> 00:19:41,220
或者找到一个元素大于x

320
00:19:41,290 --> 00:19:43,560
那就表明x不在表中

321
00:19:43,610 --> 00:19:45,470
不过我们能找出它的前后的元素

322
00:19:45,530 --> 00:19:47,390
这也可能是我们需要的

323
00:19:47,450 --> 00:19:48,440
如果我们找不到x

324
00:19:48,530 --> 00:19:50,850
我们可以找出x应该处在的位置

325
00:19:50,910 --> 00:19:52,240
因为插入的时候应该就摆在那儿

326
00:19:52,340 --> 00:19:55,390
我们在插入的时候就会用到这个算法

327
00:19:57,440 --> 00:20:00,150
先讲这么多 总之搜索是很简单的

328
00:20:00,250 --> 00:20:03,060
现在我们还没讨论

329
00:20:03,160 --> 00:20:05,090
搜索能有多快

330
00:20:05,140 --> 00:20:06,810
当然这取决于

331
00:20:06,920 --> 00:20:09,270
我们把什么元素存在L1里

332
00:20:09,330 --> 00:20:11,590
L1的元素子集包含了什么

333
00:20:13,060 --> 00:20:15,970
在地铁系统里

334
00:20:16,060 --> 00:20:19,230
我们把人流量最大的车站放在L1中

335
00:20:19,330 --> 00:20:21,630
但在这里 我们是要保证最坏情况性能

336
00:20:21,680 --> 00:20:24,290
而这些结点也不存在什么概率分布

337
00:20:24,390 --> 00:20:26,670
我们希望访问每个结点的速度

338
00:20:26,720 --> 00:20:29,540
都能尽可能地快

339
00:20:29,640 --> 00:20:34,790
也就是 我们希望把最大的查询时间降到最小

340
00:20:35,890 --> 00:20:39,000
那L1应该怎么设计呢

341
00:20:42,230 --> 00:20:44,830
是不是把所有的结点都放进L1呢？

342
00:20:44,940 --> 00:20:47,450
我们要的是一个真子集吧

343
00:20:47,560 --> 00:20:50,030
假设L1的大小已知

344
00:20:50,120 --> 00:20:52,200
现在告诉你 我可以出资建造多少个快线车站

345
00:20:52,300 --> 00:20:57,020
那么应该如何在L2中加设车站呢？

346
00:20:58,040 --> 00:21:07,990
均匀设站 很好 那么 什么结点 额..什么键值

347
00:21:08,040 --> 00:21:11,580
要放进L1呢

348
00:21:13,280 --> 00:21:17,460
最佳的选择当然是

349
00:21:17,510 --> 00:21:19,920
把它们均匀分布

350
00:21:28,490 --> 00:21:32,860
当然这跟第七大道线的情况大不一样

351
00:21:32,980 --> 00:21:35,870
想像我们现在重新设计这一切吧

352
00:21:35,980 --> 00:21:37,480
现在我们想

353
00:21:37,580 --> 00:21:39,630
把快线车站分得再开一点

354
00:21:39,730 --> 00:21:41,710
比如说 34街站和42街站离得太近了

355
00:21:41,770 --> 00:21:43,680
我们把它们挪开一点

356
00:21:43,740 --> 00:21:47,520
现在我们开始分析

357
00:21:47,580 --> 00:21:50,670
用一个关于L1长度的函数

358
00:21:51,830 --> 00:22:01,600
那么搜索的代价大约为——

359
00:22:01,720 --> 00:22:03,910
我们的函数 和L1长度有关

360
00:22:03,970 --> 00:22:06,550
也和L2的长度有关 即元素的个数n

361
00:22:09,160 --> 00:22:10,470
如果我把L1均匀分布

362
00:22:10,570 --> 00:22:16,740
搜索的代价是多少？

363
00:22:16,840 --> 00:22:24,030
[学生]。。。

364
00:22:25,080 --> 00:22:27,340
[教授]对 顶链表的元素个数

365
00:22:27,400 --> 00:22:30,690
加上底链表的一节的长度

366
00:22:30,790 --> 00:22:33,010
也就是

367
00:22:33,060 --> 00:22:37,840
|L1|+|L2|/|L1|

368
00:22:37,900 --> 00:22:39,750
这是一个粗略的估计

369
00:22:39,810 --> 00:22:41,800
这儿可能要再加1 什么的

370
00:22:41,860 --> 00:22:45,240
因为 最坏情况下我要遍历整个L1

371
00:22:45,320 --> 00:22:48,510
因为我可能要坐到终点站

372
00:22:49,300 --> 00:22:50,850
更倒霉的是

373
00:22:50,960 --> 00:22:52,980
终点站不在快线上

374
00:22:53,090 --> 00:22:55,090
然后我下来换乘慢车

375
00:22:55,150 --> 00:22:57,500
在慢车上我还要坐多少站？

376
00:22:57,550 --> 00:23:00,510
因为L1在L2中均匀分布

377
00:23:00,620 --> 00:23:03,870
所以这是相邻快线车站之间的慢线车站数

378
00:23:03,930 --> 00:23:06,110
所以这是相邻快线车站之间的慢线车站数

379
00:23:06,170 --> 00:23:09,720
因此我乘快线 大概这么长

380
00:23:09,820 --> 00:23:16,580
然后换乘慢车 大概这么长  这是在L1中的时间

381
00:23:16,620 --> 00:23:19,490
这是在L2中的时间 这里加个常数

382
00:23:19,590 --> 00:23:21,330
考虑到换乘也需要时间

383
00:23:21,390 --> 00:23:25,520
但这大概就是我一共访问到的结点数

384
00:23:25,610 --> 00:23:28,120
然后我取它的最小值

385
00:23:28,810 --> 00:23:31,550
现在我把|L2|换成n

386
00:23:32,530 --> 00:23:33,890
因为它等于元素的个数

387
00:23:33,950 --> 00:23:36,130
L1是任意选择的

388
00:23:41,260 --> 00:23:43,470
好的 我们换张板子

389
00:23:59,720 --> 00:24:09,670
现在我要取|L1|+n/|L1|的最小值

390
00:24:09,730 --> 00:24:12,590
也就是求此时的|L1|

391
00:24:12,640 --> 00:24:16,620
我可以对它求导 令导数为0  傻瓜式推导

392
00:24:16,730 --> 00:24:20,270
又或者直接看出 额 虽然并不是很复杂

393
00:24:20,390 --> 00:24:23,140
不过这种程度也求导 太夸张了

394
00:24:23,240 --> 00:24:27,510
首先这项要求|L1|小一点

395
00:24:27,620 --> 00:24:30,070
这项则要求|L1|大一点

396
00:24:30,130 --> 00:24:31,450
这是一个权衡的因素

397
00:24:31,550 --> 00:24:35,560
所以整个东西大概就

398
00:24:35,660 --> 00:24:38,400
在两项相等的时候达到最小值

399
00:24:38,500 --> 00:24:40,700
也就是在两项之间

400
00:24:40,750 --> 00:24:43,320
刚好达到的平衡的时候

401
00:24:43,420 --> 00:24:51,320
这跟常数n有关

402
00:24:54,710 --> 00:25:02,180
我令|L1|等于n/|L1|

403
00:25:02,180 --> 00:25:04,080
因为当这两项相等时  上面这条式

404
00:25:04,090 --> 00:25:06,290
至多等于两倍的|L1|

405
00:25:06,870 --> 00:25:09,470
现在我来解这个 这个好简单

406
00:25:09,560 --> 00:25:13,800
先推出 |L1|^2=n

407
00:25:13,890 --> 00:25:17,750
即|L1|等于n的平方根

408
00:25:20,510 --> 00:25:23,270
好的 那么这边的代价算出来

409
00:25:23,370 --> 00:25:28,350
就是√n + n /√n

410
00:25:28,440 --> 00:25:29,560
后项也就是√n

411
00:25:29,610 --> 00:25:36,260
然后得到2√n  所以搜索代价是

412
00:25:37,340 --> 00:25:39,320
注意 我关心这个常数系数

413
00:25:39,390 --> 00:25:40,860
因为一会就要用到

414
00:25:40,960 --> 00:25:42,840
搜索代价是2√n

415
00:25:42,900 --> 00:25:45,400
后面加的常数无关紧要

416
00:25:45,460 --> 00:25:47,140
我只关心和n有关的系数

417
00:25:48,430 --> 00:25:52,340
这看上去不错

418
00:25:52,430 --> 00:25:55,990
我们从一个搜索时间 Θ(n) 的链表出发

419
00:25:56,090 --> 00:25:57,480
每个操作 Θ(n) 的时间

420
00:25:57,580 --> 00:26:01,430
现在我们做成两个链表 搜索时间 Θ(√n)

421
00:26:01,540 --> 00:26:04,790
这看上去很好 整个结构就是这样的

422
00:26:04,880 --> 00:26:11,330
我们这有个√n  这是慢线上的一段路

423
00:26:11,390 --> 00:26:14,890
这整段对应一个快线车站

424
00:26:14,990 --> 00:26:22,670
在慢线上又有一段√n的路程

425
00:26:22,780 --> 00:26:25,490
对应一个快线车站

426
00:26:25,580 --> 00:26:27,880
它们俩是链接的 如此类推

427
00:26:38,670 --> 00:26:42,800
我在这加些点哈

428
00:26:43,850 --> 00:26:47,380
好 每个慢线路段的长度是√n

429
00:26:47,490 --> 00:26:50,910
上面对应的车站个数是√n

430
00:26:50,960 --> 00:26:53,280
快线车站的个数是√n

431
00:26:53,340 --> 00:26:54,700
现在整套东西很均衡

432
00:26:54,800 --> 00:26:56,590
在这儿我至多要找过√n个元素

433
00:26:56,650 --> 00:26:58,160
然后在这样的一段里

434
00:26:58,270 --> 00:26:59,140
至多找过√n个元素

435
00:26:59,230 --> 00:27:01,310
所以每次搜索至多花费2√n的时间

436
00:27:03,710 --> 00:27:05,570
很酷吧 接着我们还能做什么

437
00:27:07,090 --> 00:27:08,300
我们继续无视插入和删除

438
00:27:08,410 --> 00:27:09,490
我还想让搜索再快一点

439
00:27:09,580 --> 00:27:12,230
因为√n还不够过瘾

440
00:27:18,230 --> 00:27:20,050
请说？

441
00:27:20,160 --> 00:27:22,670
更多的快线 我们在这加条特快

442
00:27:22,760 --> 00:27:25,330
也就是另一个链表

443
00:27:25,440 --> 00:27:29,010
好 现在有两条 为什么不开三条呢

444
00:27:36,620 --> 00:27:38,960
我们从一个排序链表出发

445
00:27:39,020 --> 00:27:40,750
然后做成两个链表

446
00:27:44,170 --> 00:27:46,580
它们带来了2√n的搜索时间

447
00:27:47,480 --> 00:27:53,600
现在我准备搞三个排序链表 这里加个s哈

448
00:27:55,340 --> 00:27:57,360
谁来猜猜运行时间是什么

449
00:27:58,180 --> 00:28:00,360
纯猜测 不用仔细想

450
00:28:01,980 --> 00:28:07,990
从2√n出发 你能猜到多少？ 嗯嗯？

451
00:28:07,990 --> 00:28:14,930
[学生]。。。

452
00:28:15,020 --> 00:28:16,730
[教授]2√2*4√n

453
00:28:16,860 --> 00:28:18,100
方向对了

454
00:28:18,200 --> 00:28:22,770
常数和根式都变了 但没那么复杂

455
00:28:24,650 --> 00:28:26,690
3³√n 很好

456
00:28:27,900 --> 00:28:29,350
这里直觉很重要

457
00:28:30,000 --> 00:28:31,780
对不对并不要紧

458
00:28:31,840 --> 00:28:33,130
重要的是运用你的直觉

459
00:28:33,230 --> 00:28:34,900
这是可以证明的 证明并不困难

460
00:28:34,970 --> 00:28:36,560
现在我们有三个表

461
00:28:36,700 --> 00:28:39,960
我们要做的是平衡顶链表的长度

462
00:28:40,060 --> 00:28:42,350
和上两个链表的长度比

463
00:28:42,400 --> 00:28:44,080
以及下两个链表的长度比

464
00:28:44,140 --> 00:28:48,850
然后我们令三项相乘为n

465
00:28:50,130 --> 00:28:53,300
因为顶链表长*上长度比*下长度比

466
00:28:53,390 --> 00:28:54,750
=底元素数n

467
00:28:54,850 --> 00:28:57,270
³√n就是这样来的

468
00:28:57,370 --> 00:28:58,840
三项应该相等

469
00:28:58,890 --> 00:29:01,290
然后因为总代价

470
00:29:01,410 --> 00:29:02,900
等于三项相加

471
00:29:03,020 --> 00:29:04,740
然后令三项均为³√n

472
00:29:04,840 --> 00:29:05,830
然后有三个 就是3³√n

473
00:29:05,890 --> 00:29:09,730
好 如果你们想搞明白的话回去再想一下

474
00:29:12,100 --> 00:29:14,160
显然 我们想要多加几条线

475
00:29:14,230 --> 00:29:15,830
现在考虑k个排序链表

476
00:29:15,900 --> 00:29:19,350
k个链表的效率是 k·k√n

477
00:29:19,480 --> 00:29:21,520
现在能猜出来了吧

478
00:29:21,580 --> 00:29:24,020
我们应该令k等于什么

479
00:29:30,720 --> 00:29:32,610
我不需要一个确切的最小值

480
00:29:32,700 --> 00:29:36,120
什么才是一个好的k值？

481
00:29:36,250 --> 00:29:39,200
我能让它等于n吗 n还不太糟

482
00:29:39,300 --> 00:29:40,560
因为n的n次方根趋近于1

483
00:29:40,660 --> 00:29:45,480
所以结果为n  这就是我关注常系数的原因

484
00:29:45,580 --> 00:29:47,800
因为我多加几个表的时候它会增长

485
00:29:54,090 --> 00:29:56,810
k值到最大多少才合理？

486
00:29:58,450 --> 00:30:02,860
log n 因为外面有个k

487
00:30:02,970 --> 00:30:04,580
我当然不想让它大于 log n

488
00:30:04,630 --> 00:30:08,830
所以效率为 log n 乘以 n的log n次方根

489
00:30:08,940 --> 00:30:11,550
有点难写哈

490
00:30:11,660 --> 00:30:13,960
n的log n次方根 等于多少

491
00:30:14,820 --> 00:30:17,040
大家都在想这个吧

492
00:30:24,920 --> 00:30:27,690
n的log n次方根 减2 等于多少

493
00:30:32,460 --> 00:30:34,800
这是我的经典问题哦亲 答案是

494
00:30:39,420 --> 00:30:43,200
噢不会吧 记得根式的定义么

495
00:30:43,260 --> 00:30:46,700
这根式就等于n的 1/log n 次幂

496
00:30:48,020 --> 00:30:51,920
那么 记得A的B次幂的定义么

497
00:30:52,020 --> 00:30:54,810
是不是长得有点像 2^(B * log A)

498
00:30:54,900 --> 00:30:56,690
有没有很眼熟的感觉

499
00:30:56,750 --> 00:31:02,420
所以它等于 2^(log n / log n)

500
00:31:03,280 --> 00:31:11,490
你们都懂的 它等于2

501
00:31:13,170 --> 00:31:17,290
哇噢 所以 n的log n次方根 减2  等于0

502
00:31:17,390 --> 00:31:18,820
我最喜欢的答案

503
00:31:18,920 --> 00:31:25,750
所以这个等于2 整个式子就等于 2 log n 很帅吧

504
00:31:25,850 --> 00:31:28,900
当然你可以用更高级的技巧 把这个化得更好看一点

505
00:31:29,000 --> 00:31:30,910
不过我觉得 2 log n 已经足够好了

506
00:31:30,970 --> 00:31:34,140
我们显然不需要更多的表

507
00:31:34,230 --> 00:31:36,060
log n 个表刚刚好

508
00:31:36,150 --> 00:31:38,830
我们现在有对数级的搜索时间了 实验下吧

509
00:31:38,940 --> 00:31:40,880
我们前面的结果都是从直观导出来的

510
00:31:40,940 --> 00:31:46,810
先把表画下来 不过它真的有效

511
00:31:57,110 --> 00:32:01,300
我先把这个例子重画一遍吧

512
00:32:01,390 --> 00:32:03,600
因为你们也要重新画

513
00:32:05,810 --> 00:32:08,800
现在我们重新设计纽约地铁系统

514
00:32:08,890 --> 00:32:13,300
请大家在上面留出三个空行

515
00:32:17,190 --> 00:32:22,160
大家现在都记得了吧 我就记不住

516
00:32:30,110 --> 00:32:32,430
慢线是不变的

517
00:32:34,800 --> 00:32:37,520
虽然变一下也不会怀孕 多画几个站吧

518
00:32:40,540 --> 00:32:44,620
就画到79街 这足够了

519
00:32:44,720 --> 00:32:47,830
我们有 log n 个表

520
00:32:48,040 --> 00:32:49,740
这里 log n 等于4

521
00:32:49,840 --> 00:32:52,690
这里一会儿还要画一堆表

522
00:32:52,790 --> 00:32:55,100
特别地 14街出现在每个表中

523
00:32:55,740 --> 00:32:58,220
先画上吧

524
00:33:02,240 --> 00:33:04,600
现在问题是 哪些元素会出现在这里

525
00:33:04,650 --> 00:33:07,340
我们有 log n 个表

526
00:33:07,430 --> 00:33:09,960
我的目的是平衡这儿的元素个数

527
00:33:10,050 --> 00:33:16,200
以及这两个表的个数比

528
00:33:16,260 --> 00:33:17,950
我想要它们都调平衡

529
00:33:18,000 --> 00:33:19,470
我们有 log n 个表

530
00:33:19,560 --> 00:33:25,050
所以各项比值的乘积等于n

531
00:33:25,140 --> 00:33:26,910
即底链表元素的个数

532
00:33:26,970 --> 00:33:29,650
各项比值的乘积为n

533
00:33:29,750 --> 00:33:33,430
有 log n 个项 每个比值为多少？

534
00:33:36,750 --> 00:33:39,630
设这个比值为r

535
00:33:39,720 --> 00:33:43,090
那么有 r^(log n) = n

536
00:33:43,960 --> 00:33:54,040
r等于多少？   r - 2 等于多少？

537
00:33:56,400 --> 00:34:02,620
0 所以它等于 2^(log n)

538
00:34:02,710 --> 00:34:05,210
所以头两个表的个数比是2

539
00:34:05,300 --> 00:34:07,210
下面也全是2

540
00:34:07,310 --> 00:34:10,710
比值全部相乘就得到底链表的元素个数 即为所求

541
00:34:10,800 --> 00:34:12,440
换句话说  我在这里要放一半的元素

542
00:34:12,540 --> 00:34:14,060
这里要放1/4的元素

543
00:34:14,160 --> 00:34:15,690
这里要放1/8的元素 以此类推

544
00:34:15,750 --> 00:34:19,090
现在我把一半的元素均匀分布

545
00:34:20,600 --> 00:34:27,030
34 50 66 79 以此类推

546
00:34:28,620 --> 00:34:33,200
这里我们得到了半快线 它不是很快

547
00:34:33,290 --> 00:34:35,620
但节约了一半的访问量

548
00:34:37,640 --> 00:34:41,460
在半快线上走到以后 就往下走

549
00:34:41,550 --> 00:34:42,550
你最多也只需要多走一步

550
00:34:42,640 --> 00:34:44,440
然后就能找到你要找的元素

551
00:34:44,440 --> 00:34:48,510
然后再重复上面的步骤

552
00:34:48,610 --> 00:34:54,120
直到把元素都写完  我都看不清我在写什么了

553
00:34:54,210 --> 00:35:10,840
这是79 如果我举一个复杂点的例子

554
00:35:10,930 --> 00:35:11,970
上面还会多几层

555
00:35:12,030 --> 00:35:13,680
不过现在也够了

556
00:35:13,770 --> 00:35:15,470
我们说最终得到一个表只含两个元素

557
00:35:16,670 --> 00:35:17,580
这看起来不错

558
00:35:17,680 --> 00:35:18,790
大家觉不觉得它

559
00:35:18,880 --> 00:35:25,140
似乎很像我们某个见过的结构呢？  请说？

560
00:35:25,240 --> 00:35:28,220
树 正确 它看起来很像一棵二叉树

561
00:35:28,310 --> 00:35:31,820
关于这点我就提一提 大家在做习题集的时候

562
00:35:31,910 --> 00:35:34,130
就会明白为什么跳跃表十分像树

563
00:35:34,190 --> 00:35:37,440
其实它多多少少就是一棵树

564
00:35:37,530 --> 00:35:41,660
这么看搜索跳跃表就好像二分查找

565
00:35:41,760 --> 00:35:44,180
我们先找到14 然后找到50

566
00:35:44,230 --> 00:35:45,590
然后你再决定

567
00:35:45,680 --> 00:35:47,220
是从左半还是右半开始搜索

568
00:35:47,310 --> 00:35:49,020
这很像一棵树

569
00:35:49,080 --> 00:35:50,360
它在形式上不是树

570
00:35:50,450 --> 00:35:52,790
因为这儿有一大堆重复的元素

571
00:35:52,840 --> 00:35:55,980
不过 它差不多就是一棵二叉树

572
00:35:56,070 --> 00:35:59,280
在第i层有 2^i 个结点

573
00:35:59,380 --> 00:36:02,890
这就像一棵树 一棵平衡的树

574
00:36:02,980 --> 00:36:06,030
我称这个结构为理想跳跃表

575
00:36:08,160 --> 00:36:10,230
在搜索的时候

576
00:36:10,330 --> 00:36:13,110
理想跳跃表很好使

577
00:36:14,480 --> 00:36:17,680
它可能没有二叉树那么好

578
00:36:17,770 --> 00:36:20,490
这跟常数项有关 但总的来说差不多好

579
00:36:23,000 --> 00:36:25,720
比如说 额 我们可以总结一下搜索的算法

580
00:36:25,810 --> 00:36:27,840
注意到这里是 log n

581
00:36:28,860 --> 00:36:31,400
搜索过程是 首先从左上角开始

582
00:36:31,490 --> 00:36:33,650
比如说 我们要找72

583
00:36:35,650 --> 00:36:39,040
首先从左上角开始 14小于72

584
00:36:39,130 --> 00:36:41,820
往右 79太大了

585
00:36:41,910 --> 00:36:46,040
我跟着这箭头跑 然后 哦噢 太大了

586
00:36:46,150 --> 00:36:49,180
我从14这里下吧

587
00:36:49,270 --> 00:36:52,630
往右 50 还好

588
00:36:52,720 --> 00:36:55,770
继续往右 79 太大了

589
00:36:55,860 --> 00:37:00,000
不行 往下 从50这里

590
00:37:00,100 --> 00:37:03,060
如此类推

591
00:37:03,150 --> 00:37:05,130
继续往右 66 还好

592
00:37:05,220 --> 00:37:08,380
再往右 79 太大了 往下

593
00:37:08,480 --> 00:37:11,040
再往右 72 搜索完毕

594
00:37:11,140 --> 00:37:13,990
要不然 我又跑过头了 还想往下

595
00:37:14,080 --> 00:37:15,830
然后就发现元素肯定不在表中

596
00:37:15,890 --> 00:37:19,100
这是一个很简单的搜索算法 跟上面写的一样

597
00:37:19,190 --> 00:37:21,550
只要把L1和L2擦了就好

598
00:37:21,610 --> 00:37:24,020
一直往右跑直到跑过头 然后往下

599
00:37:24,110 --> 00:37:26,220
再一直往右跑直到跑过头 然后往下

600
00:37:26,270 --> 00:37:27,510
这可能要重复 log n 次

601
00:37:27,600 --> 00:37:30,950
在每一层 我们都只需要走几步

602
00:37:31,040 --> 00:37:34,370
因为每两层的元素数比是2

603
00:37:35,870 --> 00:37:39,090
所以搜索的代价是 2 log n

604
00:37:39,180 --> 00:37:41,120
很好 如所欲证

605
00:37:41,210 --> 00:37:44,280
因为我们这里是用直觉来证的 有点险哈

606
00:37:47,290 --> 00:37:49,490
现在我们做好了理想跳跃表

607
00:37:49,580 --> 00:37:51,620
接下来还要支持插入和删除

608
00:37:51,670 --> 00:37:53,440
一旦做了插入和删除

609
00:37:53,500 --> 00:37:55,230
我们就没法维护这个结构

610
00:37:55,290 --> 00:37:58,630
这个结构太特殊了

611
00:37:58,710 --> 00:37:59,620
这只是众多组合中

612
00:37:59,720 --> 00:38:03,570
所有东西都能完美排布的一种

613
00:38:03,660 --> 00:38:06,940
所有东西都很完美 所以我们做不出来

614
00:38:07,030 --> 00:38:11,590
我们只能大致上尽量地维护这个结构

615
00:38:14,590 --> 00:38:15,830
额 如果有谁认识

616
00:38:15,920 --> 00:38:19,670
纽约地铁规划的人

617
00:38:19,760 --> 00:38:23,580
你就可以跟他讲这一套啦 好 这是跳跃表

618
00:38:33,220 --> 00:38:36,000
这基本上就是我们的数据结构

619
00:38:36,090 --> 00:38:37,430
我们可以把它作为出发点

620
00:38:37,530 --> 00:38:39,860
但是我们才要真正使用跳跃表

621
00:38:42,410 --> 00:38:46,760
我们必须要实现插入和删除

622
00:38:49,210 --> 00:38:52,120
并且尽量好地维护这个结构

623
00:38:52,210 --> 00:38:56,560
使搜索的代价仍为 O(log n)

624
00:39:01,620 --> 00:39:03,440
现在我们先来研究插入

625
00:39:04,290 --> 00:39:05,970
只要把插入做好了

626
00:39:06,060 --> 00:39:08,680
我们就会发现删除是相当普通的

627
00:39:26,360 --> 00:39:27,910
首先 我们仍然从最初的原理出发

628
00:39:28,000 --> 00:39:29,680
不去用其他花哨的东西

629
00:39:32,030 --> 00:39:34,130
不过换支好粉笔还是不错的哈

630
00:39:34,990 --> 00:39:36,620
这支看起来不错

631
00:39:39,330 --> 00:39:41,550
假设我们要插入元素x

632
00:39:41,610 --> 00:39:44,730
我们已经讲过怎么搜索元素了 但怎么插入呢

633
00:39:46,230 --> 00:39:48,430
首先 我们要找出插入点在哪里

634
00:39:48,520 --> 00:39:55,140
我们先查找x  调用搜索方法来找出

635
00:39:55,250 --> 00:40:00,630
x在底链表中的位置 而不是任意一个表

636
00:40:00,720 --> 00:40:03,130
要找到x在顶链表中的位置很容易

637
00:40:03,180 --> 00:40:06,260
这只花费常数的时间 我们想知道的是——

638
00:40:06,360 --> 00:40:09,040
因为顶链表的长度恒定

639
00:40:09,140 --> 00:40:12,210
——我们想知道的是x在底链表中的位置

640
00:40:12,270 --> 00:40:15,230
比如说我们想插入80

641
00:40:15,330 --> 00:40:19,280
哦噢 好像有点大 我们来找75吧

642
00:40:19,360 --> 00:40:21,720
我们发现75正好

643
00:40:21,810 --> 00:40:24,320
在同一段路上  72和79之间

644
00:40:26,630 --> 00:40:30,330
好 如果它已经在表中了 那我吐个槽吧

645
00:40:30,420 --> 00:40:31,910
因为我假设所有的键值都是相异的

646
00:40:32,010 --> 00:40:34,350
为了简单起见 其实没问题

647
00:40:34,400 --> 00:40:37,880
即使你不断插入同样的键值也没问题

648
00:40:41,090 --> 00:40:43,080
嗯 看起来很好

649
00:40:43,180 --> 00:40:48,570
我们要做的显然是把x插入到底链表中

650
00:40:49,410 --> 00:40:54,840
我们现在知道要插入到哪儿了 应该插入到这里

651
00:40:56,540 --> 00:40:59,300
因为我们要保持结构的不变性

652
00:40:59,360 --> 00:41:04,670
即底链表包含了所有元素

653
00:41:04,670 --> 00:41:07,120
于是我们保持了不变性

654
00:41:16,120 --> 00:41:19,740
底链表中包含所有元素 然后我们找75

655
00:41:19,840 --> 00:41:22,800
额 75在这里 然后就插入75

656
00:41:22,900 --> 00:41:24,820
我想大家都会插入链表了吧

657
00:41:25,550 --> 00:41:27,080
让我把这指针擦掉

658
00:41:27,180 --> 00:41:28,850
其实所有的跳跃表操作

659
00:41:28,900 --> 00:41:30,930
都是链表操作

660
00:41:33,810 --> 00:41:38,190
这就足够了吗 不 现在看起来还好

661
00:41:38,290 --> 00:41:40,700
因为现在这段路现在

662
00:41:40,790 --> 00:41:41,710
也只有三个结点给你走

663
00:41:41,770 --> 00:41:44,270
如果说在这一块搜索的话

664
00:41:44,360 --> 00:41:48,470
但如果我不断插入75 76 76+ε

665
00:41:48,560 --> 00:41:50,600
76+2ε 等等

666
00:41:50,650 --> 00:41:52,390
插入一大坨元素

667
00:41:52,440 --> 00:41:53,660
这一段就会变得很长

668
00:41:53,760 --> 00:41:56,670
这时 平衡突然就被打破了 我在搜索时

669
00:41:56,770 --> 00:42:01,220
在这一段查找 可能就要花费任意长的时间

670
00:42:01,320 --> 00:42:03,050
如果我插入了k个元素 在这里就要花费k个单位时间

671
00:42:03,100 --> 00:42:05,390
我希望它保持为 log n

672
00:42:06,250 --> 00:42:08,970
如果我只插入 log n 个元素 那么现在还好

673
00:42:09,060 --> 00:42:14,330
现在我要决定的是 哪几个表中要包含75

674
00:42:14,420 --> 00:42:16,820
首先 显然它要在底链表中

675
00:42:16,870 --> 00:42:18,090
每个元素都出现在底链表中

676
00:42:18,150 --> 00:42:24,840
它要不要往上进一级呢 可能吧 看情况 现在还不清楚

677
00:42:24,940 --> 00:42:26,050
如果我在这儿多插几个元素

678
00:42:26,140 --> 00:42:28,390
当然有一些要进入下一级链表

679
00:42:28,440 --> 00:42:33,070
那要不要继续升级呢 可能吧 不过可能性更小

680
00:42:33,170 --> 00:42:36,990
那么我应该怎么做

681
00:42:48,350 --> 00:42:58,310
请说  [学生]。。。

682
00:42:58,400 --> 00:43:01,030
没错 我们要保持理想的分节大小

683
00:43:01,120 --> 00:43:02,680
也就是大概这段的长度

684
00:43:02,770 --> 00:43:05,050
然后发现 如果它变得太长了

685
00:43:05,140 --> 00:43:07,760
我就应该把从它中间分割开

686
00:43:07,840 --> 00:43:09,270
把中位元素提升到上一级

687
00:43:09,360 --> 00:43:11,240
并往上重复这一步骤

688
00:43:11,290 --> 00:43:12,380
如果相邻两个快线车站

689
00:43:12,470 --> 00:43:14,940
它们之间的路段太长

690
00:43:15,030 --> 00:43:17,840
我就提升中位元素

691
00:43:17,920 --> 00:43:20,430
这在你们习题册里面有

692
00:43:20,530 --> 00:43:25,830
这个方法稍微有点复杂  我不需要做什么计数

693
00:43:29,760 --> 00:43:31,270
我还能怎么做呢

694
00:43:37,770 --> 00:43:44,170
[学生]。。。

695
00:43:44,460 --> 00:43:47,310
我可以试着保持理想跳跃表结构

696
00:43:47,410 --> 00:43:48,380
不过这样更新跳跃表代价太高

697
00:43:48,430 --> 00:43:50,740
比如说 75被提升了

698
00:43:50,790 --> 00:43:52,930
而这个则相应地被降下来

699
00:43:52,990 --> 00:43:55,140
但这就要影响到后面的所有元素

700
00:43:55,190 --> 00:43:59,590
这要耗费线性时间来更新 还有什么想法

701
00:43:59,930 --> 00:44:02,140
[学生]。。。

702
00:44:02,240 --> 00:44:04,680
[教授]如果我只想让一半的元素获得提升 我可以抛硬币决定

703
00:44:04,770 --> 00:44:11,490
这是一个好主意 很好 五毛请拿好

704
00:44:11,580 --> 00:44:19,440
这个硬币很值钱的哦亲 它产自红色革命根据地马里兰州

705
00:44:19,550 --> 00:44:24,870
这是赏给你的  但是

706
00:44:24,960 --> 00:44:26,850
你也要帮忙干点活

707
00:44:26,900 --> 00:44:29,530
那就是抛硬币

708
00:44:29,620 --> 00:44:33,690
你会抛硬币吧 很好 抛出什么来了

709
00:44:33,780 --> 00:44:36,890
反面 好 这是我们得到的第一个随机数

710
00:44:38,870 --> 00:44:40,520
噢 我们现在要构造跳跃表

711
00:44:40,600 --> 00:44:43,990
我先讲一讲应该怎么做

712
00:44:44,080 --> 00:44:46,600
主要的思想就是抛硬币

713
00:44:46,700 --> 00:44:50,120
如果抛出的是正面 哦噢现在不是 如果是正面

714
00:44:50,210 --> 00:44:54,920
我们就提升这个元素 然后再抛一次

715
00:44:56,530 --> 00:44:59,040
这就是刚才问题的答案

716
00:44:59,140 --> 00:45:07,950
x要存在其余的哪个表里

717
00:45:09,450 --> 00:45:11,710
存在多少个表里

718
00:45:11,770 --> 00:45:14,160
我们的算法是 先抛硬币

719
00:45:16,920 --> 00:45:22,990
如果结果是正面 就提升x

720
00:45:23,080 --> 00:45:33,560
并再抛一次

721
00:45:33,660 --> 00:45:36,440
这就是问题的关键

722
00:45:36,530 --> 00:45:38,850
因为我们想把新元素提升到任意的高度

723
00:45:38,850 --> 00:45:40,980
首先我们要抛硬币

724
00:45:41,080 --> 00:45:42,340
现在 它没有被提升

725
00:45:42,430 --> 00:45:44,370
我们希望让它

726
00:45:44,460 --> 00:45:46,170
被提升概率是一半

727
00:45:46,270 --> 00:45:49,550
因为我们想让两线的长度比是1:2

728
00:45:49,650 --> 00:45:53,100
或者2:1 看谁比谁

729
00:45:53,190 --> 00:45:55,730
我要提升大约一半的元素  所以我就抛硬币

730
00:45:55,830 --> 00:45:57,590
如果抛出正面 我就提升它

731
00:45:57,710 --> 00:46:01,380
所以要用一枚公正的硬币 我让它的概率是50-50

732
00:46:01,470 --> 00:46:06,570
那么 被提升的元素中有多少应被继续提升呢

733
00:46:06,670 --> 00:46:09,770
又是50%喽 我再抛一次硬币

734
00:46:09,860 --> 00:46:11,720
如果抛出正面 我就继续提升

735
00:46:11,780 --> 00:46:14,220
这样就保持了

736
00:46:14,320 --> 00:46:16,720
两线长度之比大约为2

737
00:46:16,770 --> 00:46:18,840
我们正期望这个比值

738
00:46:18,930 --> 00:46:21,140
一路往上都约等于2

739
00:46:21,190 --> 00:46:23,310
如果跑到顶层后我再抛硬币

740
00:46:23,400 --> 00:46:25,660
出来的还是正面的话 我就再造一层

741
00:46:25,710 --> 00:46:29,220
这就是插入算法 太简单了

742
00:46:31,460 --> 00:46:33,970
刚才说的较复杂的方法 在习题册上有

743
00:46:37,240 --> 00:46:38,730
我们动手吧

744
00:46:47,620 --> 00:46:51,120
我需要有人来产生随机数

745
00:46:51,210 --> 00:46:52,780
谁能生成随机数

746
00:46:53,850 --> 00:46:56,960
伪随机哈 我也赏你五毛

747
00:46:58,400 --> 00:47:00,300
我这儿有 来来来 来来来

748
00:47:00,350 --> 00:47:01,850
老是给五毛太无趣了

749
00:47:01,940 --> 00:47:03,180
谁想生成随机数嘛

750
00:47:05,580 --> 00:47:07,820
哈哈 推荐别人

751
00:47:07,880 --> 00:47:10,660
这解决方法真好 给你

752
00:47:10,750 --> 00:47:12,740
给你五毛 但不是让你抛

753
00:47:14,270 --> 00:47:17,400
不是让你这样搞随机哈 不过你可以先生成随机位

754
00:47:17,400 --> 00:47:18,550
再算出一个数

755
00:47:19,190 --> 00:47:21,890
反正给个数字吧 44 很好

756
00:47:22,910 --> 00:47:25,930
我们已经抛过硬币得到反面了

757
00:47:26,030 --> 00:47:28,880
插入完毕 这就是插入算法

758
00:47:28,980 --> 00:47:32,190
我要多留点位置 写这儿吧

759
00:47:33,120 --> 00:47:35,800
44不能提升 因为我们抛出了反面

760
00:47:35,900 --> 00:47:37,630
再给个数字

761
00:47:37,760 --> 00:47:41,530
9 先在表中查找9

762
00:47:41,620 --> 00:47:52,450
哦对 我还要说明一点 我在这儿做了一点小小的改动

763
00:47:53,140 --> 00:47:56,310
这是为了保持原有的搜索过程能正常工作

764
00:47:56,400 --> 00:48:00,160
我们担心的是 比如说我插入了一个比较大的元素

765
00:48:00,250 --> 00:48:01,680
然后提升了它

766
00:48:01,770 --> 00:48:04,970
这个跳跃表的结构就坑爹了

767
00:48:05,070 --> 00:48:06,140
因为我总要从左上角开始搜索

768
00:48:06,230 --> 00:48:07,750
但是左上角没有元素

769
00:48:07,840 --> 00:48:12,440
所以我做点小小的改动 记得刚刚报的是9吧

770
00:48:14,230 --> 00:48:15,500
改动就是 我要把

771
00:48:15,590 --> 00:48:19,510
一个特殊值负无穷存到每个表里

772
00:48:20,580 --> 00:48:25,160
也就是说负无穷被一路提升到顶部

773
00:48:25,250 --> 00:48:26,930
无论顶部在哪里

774
00:48:29,390 --> 00:48:32,170
这样左上角就一直存在了

775
00:48:32,910 --> 00:48:34,480
忘了提这个 不好意思哈

776
00:48:34,580 --> 00:48:36,540
所以我一开始先插入一个负无穷

777
00:48:36,620 --> 00:48:40,600
然后插入44 那好 44跑到这里 没有提升 插入完毕

778
00:48:40,690 --> 00:48:44,010
现在我们插入9 9在这儿

779
00:48:47,360 --> 00:48:53,830
现在负无穷指向9 抛个硬币吧 正面

780
00:48:56,400 --> 00:48:58,090
他真抛了没有

781
00:48:58,180 --> 00:49:01,330
好好好 他之前肯定抛了的

782
00:49:01,890 --> 00:49:04,910
如果抛了我不想要的我就惨了 现在我们把9提升到这儿

783
00:49:05,000 --> 00:49:07,160
我们要保持负无穷在表头

784
00:49:07,220 --> 00:49:11,300
保证它跟着被提升的元素一同提升

785
00:49:11,390 --> 00:49:12,340
现在这个跳跃表看起来很和谐

786
00:49:12,440 --> 00:49:15,890
再抛一次硬币 反面 好

787
00:49:15,980 --> 00:49:20,450
现在它看上去就是理想跳跃表哈 这方法不赖吧

788
00:49:20,540 --> 00:49:24,160
每次结果包你满意 再给一个数字 26

789
00:49:24,250 --> 00:49:27,350
好 那我查找26 26应该跑到这儿

790
00:49:27,440 --> 00:49:29,510
显然它要在底链表里

791
00:49:31,110 --> 00:49:37,870
写上26 然后是44 抛吧

792
00:49:37,970 --> 00:49:46,690
反面 好 再给个数字 50 额有点大

793
00:49:46,780 --> 00:49:51,880
我要花点时间来搜索 然后跑到这 50

794
00:49:51,970 --> 00:49:59,510
抛 正面 好 50被提升了 再抛

795
00:50:02,750 --> 00:50:05,610
反面 好 这个结果不错哈

796
00:50:05,700 --> 00:50:09,330
再给个数字 12  还要再过一会儿才会变得更好玩

797
00:50:09,420 --> 00:50:12,080
好 12插在9和26中间

798
00:50:16,100 --> 00:50:20,880
你这是在给我制造难度哈 抛吧

799
00:50:22,640 --> 00:50:24,850
正面 好 12被提升了

800
00:50:24,900 --> 00:50:26,910
我知道按着程序走还要多走几步

801
00:50:26,960 --> 00:50:28,960
反正现在我们知道12要放在这里

802
00:50:29,010 --> 00:50:31,770
我们知道9是在往下之前访问的最后一个结点

803
00:50:31,870 --> 00:50:36,150
现在我们提升12 插入到这里

804
00:50:36,240 --> 00:50:39,320
这里我们只是把它插入上面这个链表中

805
00:50:39,420 --> 00:50:40,890
没有什么复杂的东西

806
00:50:40,980 --> 00:50:42,740
然后我们把两个12链接起来

807
00:50:42,790 --> 00:50:43,990
这看起来还是像一个链表哈

808
00:50:44,080 --> 00:50:55,030
再抛 好 反面 再给个数字 37 额

809
00:50:58,660 --> 00:51:03,250
这在考验我的记忆力 37 然后是 额 44和50

810
00:51:05,810 --> 00:51:08,220
还有50跑到了下一级

811
00:51:08,320 --> 00:51:10,670
我觉得我还是一直往表尾加元素

812
00:51:10,760 --> 00:51:11,840
只让你抛抛硬币更好

813
00:51:11,940 --> 00:51:17,790
好 我们刚刚插入了37 反面

814
00:51:17,890 --> 00:51:20,670
这条链变得有点长

815
00:51:20,770 --> 00:51:21,610
看上去不妙

816
00:51:21,710 --> 00:51:28,030
给我一个大于50的数吧 51 很好

817
00:51:31,480 --> 00:51:43,450
多谢 再抛（正面） 再抛 反面 再给个数

818
00:51:43,550 --> 00:51:47,080
等一下 换一个人报数字吧  剧本不是这样写的啊

819
00:51:47,170 --> 00:51:57,350
你说啥 52 很好 抛 反面 见怪不怪啦

820
00:51:57,440 --> 00:51:59,000
肯定是因为正面太多了

821
00:51:59,090 --> 00:52:01,620
再给个数 53 多谢

822
00:52:01,680 --> 00:52:16,560
抛 正面吧 正面吧 很好 正面 正面 你都没抛

823
00:52:16,650 --> 00:52:20,610
好好好 53 你懂的

824
00:52:20,700 --> 00:52:23,310
如果连续抛出两个正面

825
00:52:23,410 --> 00:52:24,720
就把元素提升两级

826
00:52:25,960 --> 00:52:27,480
现在真的抛一个

827
00:52:30,570 --> 00:52:36,160
正面 盼星星盼月亮终于等到了

828
00:52:36,250 --> 00:52:39,210
如果连续抛出三个正面 就把元素提升三级

829
00:52:39,300 --> 00:52:41,220
注意每次都要提升负无穷

830
00:52:43,320 --> 00:52:49,190
再抛 正面 额滴神啊 你们刚刚都跑哪儿去了

831
00:52:50,790 --> 00:52:58,330
再抛 这次最好是反面 反面 太好了

832
00:52:58,380 --> 00:53:00,760
大家都懂了 最后我们都画到黑板外面去了

833
00:53:00,850 --> 00:53:03,090
注意 升到很高的可能性是很小的

834
00:53:03,150 --> 00:53:05,400
高于 log n 的概率是多少呢

835
00:53:08,600 --> 00:53:10,380
还是简单的对数运算

836
00:53:12,880 --> 00:53:16,170
每次我都有50%的提升概率

837
00:53:16,260 --> 00:53:19,630
提升 log n 的概率是1/n

838
00:53:19,730 --> 00:53:23,230
因为(1/2)^(log n)=1/n

839
00:53:23,320 --> 00:53:28,430
所以它跟n有关 当然我不想它跑太高

840
00:53:28,520 --> 00:53:34,270
直观上 这个结果并不坏 这就是跳跃表

841
00:53:41,560 --> 00:53:44,440
提升概率与期望相符

842
00:53:45,290 --> 00:53:46,790
但这只是一个很弱的结论

843
00:53:46,880 --> 00:53:48,890
它不涉及生成的这些区段的长度

844
00:53:48,980 --> 00:53:52,530
但直观上还是很不错的

845
00:53:56,210 --> 00:53:58,110
我们说它平均来看还挺好的

846
00:53:58,900 --> 00:54:02,570
在插入的时候 发生了两个半随机过程

847
00:54:02,660 --> 00:54:04,730
一个是选数的过程

848
00:54:04,780 --> 00:54:06,270
对此我不作任何假设

849
00:54:06,360 --> 00:54:08,310
输入数列可以凌乱的 也可以是顺序的

850
00:54:08,360 --> 00:54:11,360
可以是逆序的 可以是随机的 我也不知道

851
00:54:12,370 --> 00:54:14,030
所以他报什么数都无所谓

852
00:54:14,120 --> 00:54:15,460
至少不应该跟它有关

853
00:54:16,110 --> 00:54:19,050
当然上课的时候要你帮忙啦 别担心 我还是很疼你滴

854
00:54:19,050 --> 00:54:20,550
你可以留着那两毛五

855
00:54:20,650 --> 00:54:23,360
但是算法真正关心的是

856
00:54:23,440 --> 00:54:24,790
抛硬币的结果

857
00:54:24,880 --> 00:54:26,290
还有概率 这个命题——

858
00:54:26,360 --> 00:54:29,280
“这个数据结构执行速度快是有高概率的”

859
00:54:29,330 --> 00:54:30,690
——只对随机抛硬币的情况成立

860
00:54:30,750 --> 00:54:32,940
对方选择任何输入数据都无所谓

861
00:54:33,000 --> 00:54:34,840
只要抛硬币结果是随机的

862
00:54:34,890 --> 00:54:36,320
对方不知道抛硬币的结果

863
00:54:37,050 --> 00:54:38,530
算法在抛之前不知道结果

864
00:54:39,260 --> 00:54:41,470
这样平均来看

865
00:54:41,530 --> 00:54:44,120
在大量抛硬币的情况下 它还是好用的

866
00:54:46,270 --> 00:54:50,220
但按我们的说法 它不只是平均来看挺好

867
00:54:50,320 --> 00:54:54,710
而是几乎总是很好很好

868
00:55:00,310 --> 00:55:05,660
即有高概率为 O(log n)

869
00:55:06,240 --> 00:55:10,330
举个例子 有1-1/n的概率

870
00:55:10,420 --> 00:55:12,340
1-1/n的概率 它是O(log n)

871
00:55:12,400 --> 00:55:15,310
或者有1-1/n^2的概率  它是O(log n)

872
00:55:15,400 --> 00:55:18,870
或者有1-1/n^100的概率 它是O(log n)

873
00:55:18,960 --> 00:55:22,060
这一命题对100以内任意幂次都成立

874
00:55:22,160 --> 00:55:27,980
这是我们要证明的

875
00:55:29,710 --> 00:55:33,430
额 我还没讲怎么从跳跃表中删除元素

876
00:55:33,520 --> 00:55:36,120
找到这个元素 把它从出现的链表中一路删上去

877
00:55:36,210 --> 00:55:40,300
删除操作没有什么高级的东西

878
00:55:40,400 --> 00:55:42,710
因为前面的所有操作都是独立的随机的

879
00:55:42,760 --> 00:55:45,080
所有元素都相互独立

880
00:55:45,170 --> 00:55:49,350
我们不用操心太多 所以删除元素就直接扔掉它

881
00:55:49,450 --> 00:55:52,660
有技巧的部分是插入 插入的时候

882
00:55:52,750 --> 00:55:55,130
我要随机地确定它能跑多高

883
00:55:55,190 --> 00:55:57,960
它有 1/2^i 的概率跑到第i层

884
00:56:00,700 --> 00:56:06,800
好 我看看时间 前面我们太欢乐了

885
00:56:08,050 --> 00:56:11,970
后面我们要讲快点

886
00:56:22,470 --> 00:56:25,050
下面是要证的定理

887
00:56:25,880 --> 00:56:28,030
我们看看要证明什么

888
00:56:29,400 --> 00:56:31,450
有高概率——

889
00:56:32,680 --> 00:56:36,650
这是一个正式的概念 我一会儿就来定义它

890
00:56:38,600 --> 00:56:51,820
——使在有n个元素的跳跃表里 每次搜索时间为 O(log n)

891
00:56:57,510 --> 00:56:59,230
这就是定理

892
00:56:59,330 --> 00:57:01,210
现在我来定义“有高概率”

893
00:57:03,480 --> 00:57:05,460
那么 “有高概率”

894
00:57:10,540 --> 00:57:14,600
这个词儿有点长 我们常常

895
00:57:14,690 --> 00:57:17,200
缩写为W.H.P.

896
00:57:22,090 --> 00:57:26,300
假如有一个随机事件 在这里随机事件就是

897
00:57:26,390 --> 00:57:29,460
在有n个元素的跳跃表里 每次搜索时间为 O(log n)

898
00:57:30,140 --> 00:57:31,030
我们来看看

899
00:57:31,080 --> 00:57:33,640
这一事件E“有高概率”发生是什么意思

900
00:57:45,250 --> 00:57:46,660
这是定义

901
00:57:53,630 --> 00:57:55,360
“有高概率”是指

902
00:57:55,450 --> 00:57:58,750
对于任意大于等于1的α

903
00:57:59,440 --> 00:58:01,240
存在适宜的常数

904
00:58:14,900 --> 00:58:17,660
使事件E的概率

905
00:58:17,760 --> 00:58:20,950
为我之前一直提到的

906
00:58:29,830 --> 00:58:35,480
概率至少为1-O(1/n^α)

907
00:58:44,070 --> 00:58:46,840
这个定义不是很准确

908
00:58:46,930 --> 00:58:48,550
但对我们的证明来说够用了

909
00:58:48,650 --> 00:58:50,940
如果你想要更正式的定义

910
00:58:50,990 --> 00:58:52,490
可以阅读课程注记

911
00:58:52,580 --> 00:58:53,710
我们官网上

912
00:58:53,800 --> 00:58:57,850
有我们课程的特别注释

913
00:58:58,030 --> 00:59:00,460
SMA课程网站上也有 PowerPoint 格式的注记

914
00:59:02,060 --> 00:59:05,040
好 这个常数的选择

915
00:59:05,130 --> 00:59:06,720
是一件很微妙的事

916
00:59:06,840 --> 00:59:08,330
这个常数是可以任意选取的

917
00:59:08,430 --> 00:59:10,740
这个常数也是可以任意选取的

918
00:59:10,820 --> 00:59:13,100
当然它们是相关的

919
00:59:13,150 --> 00:59:16,520
α我们可以取到任意一个值

920
00:59:16,610 --> 00:59:17,990
但我们的底线是

921
00:59:18,180 --> 00:59:21,690
我们要选择一个能让定理成立的概率

922
00:59:21,780 --> 00:59:23,930
如果我希望

923
00:59:24,020 --> 00:59:27,200
它的成功概率是1-1/n^100 这是可以做到的

924
00:59:28,180 --> 00:59:34,020
我只要令α=100 再选取适宜的常数

925
00:59:34,110 --> 00:59:36,980
使它的增长速度远远慢于n^α

926
00:59:37,070 --> 00:59:39,740
由此我得到失败概率

927
00:59:39,840 --> 00:59:41,810
这叫失败概率

928
00:59:41,860 --> 00:59:48,630
失败概率就会多项式级地小

929
00:59:48,730 --> 00:59:50,520
多项式阶数可以任意小

930
00:59:50,580 --> 00:59:54,080
对于同一个数据结构

931
00:59:54,170 --> 00:59:55,870
固定一个数据结构 它与α无关

932
00:59:55,960 --> 00:59:59,580
无论输入是什么 无论α等于多少

933
00:59:59,690 --> 01:00:02,990
数据结构都要花费 O(log n) 的时间

934
01:00:03,090 --> 01:00:05,070
现在这个常数是跟α有关的

935
01:00:05,120 --> 01:00:08,520
比如说 我们想让失败概率为 1/n^100

936
01:00:08,610 --> 01:00:12,400
那就是 100 O(log n) 那还是 O(log n) 嘛

937
01:00:12,490 --> 01:00:16,010
好 这是一个很强的断言

938
01:00:16,110 --> 01:00:20,040
控制了搜索时间分布的末端

939
01:00:20,100 --> 01:00:21,730
非常强

940
01:00:21,820 --> 01:00:24,520
我来告诉大家很强是什么概念

941
01:00:30,410 --> 01:00:34,380
有多少人知道布尔不等式

942
01:00:36,820 --> 01:00:39,750
多少人知道并事件的概率上界

943
01:00:42,770 --> 01:00:47,700
你们应该会的 这些内容在附录c里

944
01:00:48,660 --> 01:00:51,430
可能你从定理里就看出来了

945
01:00:52,530 --> 01:00:54,160
它从字面上很容易理解

946
01:00:54,260 --> 01:00:56,260
它有点像期望的线性性

947
01:00:56,320 --> 01:00:58,130
讲这个别人更容易明白

948
01:00:59,540 --> 01:01:01,580
一提到期望的线性性

949
01:01:01,670 --> 01:01:03,070
你就会想到

950
01:01:03,160 --> 01:01:04,940
事件期望之和

951
01:01:05,030 --> 01:01:06,920
等于总事件的期望

952
01:01:06,980 --> 01:01:09,550
讲期望的线性性省事多了

953
01:01:11,740 --> 01:01:14,920
现在我换个方式来问

954
01:01:17,290 --> 01:01:18,570
我来取一堆事件

955
01:01:18,660 --> 01:01:19,860
然后取它的并

956
01:01:19,950 --> 01:01:23,270
这个事件发生或这个事件发生或等等

957
01:01:23,370 --> 01:01:26,510
这是k个事件的并

958
01:01:26,610 --> 01:01:28,910
另一方面 考察

959
01:01:29,000 --> 01:01:31,600
这些事件期望之和

960
01:01:35,130 --> 01:01:37,090
一个简单的问题 它们相等吗

961
01:01:38,900 --> 01:01:40,690
不等 除非事件相互独立

962
01:01:41,420 --> 01:01:45,390
但我能断定它们的关系吗

963
01:01:46,800 --> 01:01:51,650
小于等于 对 上边小于等于下边

964
01:01:52,130 --> 01:01:53,980
这直观上是正确的

965
01:01:54,040 --> 01:01:55,370
用概率的观点看

966
01:01:55,470 --> 01:01:56,550
翻书去吧

967
01:01:56,650 --> 01:02:00,150
这是一个基本的结果 挺普通的

968
01:02:03,080 --> 01:02:04,520
这说明什么

969
01:02:04,580 --> 01:02:07,680
假设 E_i 是某个失败事件

970
01:02:07,780 --> 01:02:09,120
我们不希望它发生

971
01:02:09,800 --> 01:02:14,490
i这里可能又用混了

972
01:02:14,580 --> 01:02:16,340
假设我有一堆事件

973
01:02:16,390 --> 01:02:17,800
是有高概率的

974
01:02:19,330 --> 01:02:21,740
额 把它叫做 E_i 的对立

975
01:02:22,400 --> 01:02:27,100
我们最后可以推出

976
01:02:27,200 --> 01:02:32,100
E_i 的对立是有高概率的

977
01:02:34,040 --> 01:02:35,930
所以 E_i 的概率很小

978
01:02:35,980 --> 01:02:39,450
多项式级地小

979
01:02:39,540 --> 01:02:42,060
小于O(1/n^α) 对任意α成立

980
01:02:42,150 --> 01:02:45,580
现在 假设我取一大堆这样的事件

981
01:02:45,670 --> 01:02:48,930
k个事件 k是n的多项式

982
01:02:50,020 --> 01:02:53,330
取一大堆我想要发生的事件

983
01:02:53,420 --> 01:02:55,070
它们都是有高概率的

984
01:02:55,160 --> 01:02:57,000
它们只有多项式那么多个

985
01:02:57,050 --> 01:03:00,260
现在我们明确地定义这个常数 设它为c

986
01:03:00,350 --> 01:03:03,050
我们说取 n^c 个事件

987
01:03:03,150 --> 01:03:06,260
那么 所有事件同时发生

988
01:03:06,360 --> 01:03:07,970
——这概率是多少？

989
01:03:08,080 --> 01:03:11,190
因为 额 它们大多数情况下同时发生

990
01:03:11,280 --> 01:03:13,780
因为任意一个在大多数情况下都会发生

991
01:03:13,870 --> 01:03:15,230
是有高概率的

992
01:03:15,330 --> 01:03:23,610
也就是 我想考察 E_1— 交 E_2— 等等等等

993
01:03:24,210 --> 01:03:25,720
每个事件都有高概率

994
01:03:25,780 --> 01:03:27,690
它们同时发生的概率是多少

995
01:03:28,640 --> 01:03:33,130
它们同时发生也是有高概率的 我取不同的α

996
01:03:33,230 --> 01:03:35,150
因此 并事件的概率告诉我们

997
01:03:35,200 --> 01:03:38,390
任意一个事件失败的概率

998
01:03:38,490 --> 01:03:39,820
它失败的概率

999
01:03:39,910 --> 01:03:41,440
它失败的概率 或它失败的概率

1000
01:03:41,490 --> 01:03:43,480
也就是它 至多

1001
01:03:43,540 --> 01:03:46,070
是它们各自失败的概率之和

1002
01:03:46,160 --> 01:03:47,570
这就是失败概率

1003
01:03:47,660 --> 01:03:49,540
我知道任意一个的失败概率

1004
01:03:49,630 --> 01:03:52,250
至多是 1/n^α 带个常数

1005
01:03:52,330 --> 01:03:56,430
如果我把它们加起来 至多有 n^c 个

1006
01:03:56,520 --> 01:04:01,870
我取一个失败概率 然后乘上 n^c

1007
01:04:01,960 --> 01:04:04,450
得到 n^c/n^α

1008
01:04:04,550 --> 01:04:07,820
即 1/n^(α-c)

1009
01:04:07,920 --> 01:04:10,020
α可任意大

1010
01:04:10,070 --> 01:04:12,800
我就让它远远大于c

1011
01:04:12,900 --> 01:04:15,750
所以这一事件是有高概率的

1012
01:04:16,680 --> 01:04:20,240
这儿写得有点乱

1013
01:04:20,330 --> 01:04:25,300
总之 因此 这一事件是有高概率的

1014
01:04:25,390 --> 01:04:29,180
不管这常数是啥 不管我取多少事件

1015
01:04:29,270 --> 01:04:31,990
我取α比它大就行了

1016
01:04:32,080 --> 01:04:35,060
并事件也是有高概率的

1017
01:04:35,150 --> 01:04:37,860
所以 当我说

1018
01:04:37,950 --> 01:04:40,910
每次搜索耗费 O(log n) 是有高概率的时候

1019
01:04:41,010 --> 01:04:43,230
我不仅是指考察一次搜索

1020
01:04:43,290 --> 01:04:45,100
它耗费 O(log n) 有高概率

1021
01:04:45,190 --> 01:04:46,230
再考察另一次搜索

1022
01:04:46,330 --> 01:04:48,010
它耗费 O(log n) 也有高概率

1023
01:04:48,100 --> 01:04:49,920
而是 考察每一次搜索

1024
01:04:49,970 --> 01:04:54,510
全部搜索都耗费 O(log n) 也有高概率

1025
01:04:54,610 --> 01:04:59,420
从而 每次搜索都花费 O(log n)

1026
01:05:00,480 --> 01:05:02,830
是有高概率的

1027
01:05:02,830 --> 01:05:05,540
假设搜索的次数为n的多项式

1028
01:05:05,590 --> 01:05:08,930
也就是说 我假设我不是要把这数据结构用无数次

1029
01:05:09,020 --> 01:05:11,100
只是使用多项式级的时间而已

1030
01:05:11,160 --> 01:05:14,930
但又有谁有比多项式级还多的时间呢？

1031
01:05:15,020 --> 01:05:19,430
这里可是 MIT  那就没问题了

1032
01:05:19,530 --> 01:05:21,130
我们以后还会见到它 请提问

1033
01:05:21,130 --> 01:05:23,890
[学生]。。。

1034
01:05:23,980 --> 01:05:26,360
[教授]这个算法并不依赖α

1035
01:05:26,450 --> 01:05:28,420
问题是在分析算法时如何选择α

1036
01:05:28,470 --> 01:05:32,510
所以我们不需要考虑它 它只是一个分析的工具

1037
01:05:32,600 --> 01:05:34,230
它的意思是多项式增长得越大

1038
01:05:34,330 --> 01:05:37,840
比如说 额 大于 10 log n 的概率是多少

1039
01:05:37,930 --> 01:05:42,020
打个比方 大概是 1/n^10 假设概率是线性增长的

1040
01:05:42,110 --> 01:05:44,930
也就是说 大于 20 log n 的概率是多少

1041
01:05:45,020 --> 01:05:46,670
比方说 那就成了 1/n^20

1042
01:05:47,020 --> 01:05:48,540
意思就是说 在概率分布的尾部

1043
01:05:48,630 --> 01:05:50,370
概率会非常迅速地收敛到非常小

1044
01:05:50,420 --> 01:05:53,060
引入α只是为了

1045
01:05:53,160 --> 01:05:55,290
方便论述和证明

1046
01:05:55,350 --> 01:06:01,100
你可以令α=100 然后要求n至少为2

1047
01:06:01,190 --> 01:06:06,370
那失败概率大概只有 1/2^100

1048
01:06:06,460 --> 01:06:09,670
那小得不得了 如果你有个真随机数生成器

1049
01:06:09,760 --> 01:06:10,870
生成一个大于 2^100 的数

1050
01:06:10,960 --> 01:06:13,870
概率是很小的 对吧

1051
01:06:15,040 --> 01:06:18,640
再如 令α=256

1052
01:06:18,730 --> 01:06:19,920
256是个好数字

1053
01:06:20,020 --> 01:06:21,940
2^256 远远大于

1054
01:06:22,030 --> 01:06:24,350
宇宙中已知粒子的总数

1055
01:06:24,410 --> 01:06:26,530
除了暗物质哈

1056
01:06:26,590 --> 01:06:28,600
其实我想

1057
01:06:28,700 --> 01:06:30,590
把暗物质也包括进来也未必有这个数

1058
01:06:30,650 --> 01:06:32,410
所以这个数非常非常非常大

1059
01:06:32,460 --> 01:06:35,500
也就是说 你在宇宙中随机挑出一个粒子

1060
01:06:35,590 --> 01:06:38,450
正好是你最喜欢的那个粒子的概率 这个哈

1061
01:06:38,550 --> 01:06:42,180
应该大于 1/2^256  或者更小

1062
01:06:42,270 --> 01:06:48,140
所以 令α=256 此时我们的算法

1063
01:06:48,240 --> 01:06:50,900
花费的时间长于 O(log n)的概率

1064
01:06:50,990 --> 01:06:53,090
远远小于一颗流星

1065
01:06:53,150 --> 01:06:56,140
正好砸在你的电脑上 而且同时

1066
01:06:56,230 --> 01:06:57,940
电脑出了个浮点运算错误 又同时

1067
01:06:58,050 --> 01:07:01,270
地球君爆炸了

1068
01:07:01,380 --> 01:07:04,940
因为不知道谁要修条高速公路

1069
01:07:05,040 --> 01:07:06,950
正好路过太阳系 又同时

1070
01:07:07,000 --> 01:07:08,470
我可以继续讲一大堆

1071
01:07:08,580 --> 01:07:10,950
总之时间超过 O(log n) 的机会是非常非常小的

1072
01:07:11,000 --> 01:07:13,100
至于有多小 任君选择

1073
01:07:13,160 --> 01:07:16,370
但这只是在分析中用到 算法并不依赖于α

1074
01:07:16,460 --> 01:07:18,440
算法还是那个算法 犀利不？

1075
01:07:18,490 --> 01:07:21,480
有时 某些有高概率的定理 时间的界与α有关

1076
01:07:21,570 --> 01:07:24,820
也就是说算法依赖于α 不过这里不是

1077
01:07:26,440 --> 01:07:35,500
我们继续 现在大家都明白这个说法是什么意思

1078
01:07:40,160 --> 01:07:44,780
先做点准备 我们需要如下事实

1079
01:07:46,450 --> 01:07:51,260
很简单的 引理是 有高概率——

1080
01:07:52,560 --> 01:07:57,180
——使跳跃表的层数为 O(log n)

1081
01:08:02,000 --> 01:08:05,670
是 O(log n) 没错吧 就是它了

1082
01:08:09,090 --> 01:08:13,020
怎么证明一个事件发生是有高概率的

1083
01:08:14,700 --> 01:08:17,750
计算它的概率 说明它很高

1084
01:08:17,840 --> 01:08:21,290
就算我们不懂什么叫有高概率

1085
01:08:21,380 --> 01:08:24,360
其实 我刚才应该先问的

1086
01:08:26,130 --> 01:08:29,310
也就是说 计算它不发生的概率

1087
01:08:29,400 --> 01:08:31,020
失败概率

1088
01:08:31,140 --> 01:08:35,470
然后成功概率就等于用一去减它

1089
01:08:36,260 --> 01:08:38,610
所以 我说

1090
01:08:38,700 --> 01:08:40,800
它至多有 c log n 层

1091
01:08:40,860 --> 01:08:43,960
它的失败概率是多少

1092
01:08:44,870 --> 01:08:46,610
这是个随机事件

1093
01:08:46,670 --> 01:08:50,090
加个花括号 表示全体事件的集合

1094
01:08:50,180 --> 01:08:51,340
这就是层数

1095
01:08:51,430 --> 01:08:54,550
严格大于 c log n 的概率

1096
01:08:54,640 --> 01:08:56,400
我想证明的是

1097
01:08:56,490 --> 01:09:00,020
这个概率很小 多项式级地小

1098
01:09:02,550 --> 01:09:05,280
那么 分层是怎么产生的呢

1099
01:09:05,370 --> 01:09:08,260
当我插入元素的时候 大概有一半的概率被提升

1100
01:09:09,500 --> 01:09:11,590
并且 跳跃表的层数

1101
01:09:11,680 --> 01:09:14,200
是所有元素可能达到的高度的最大值

1102
01:09:14,930 --> 01:09:17,820
不过 说到最大值 那可乱套了

1103
01:09:17,910 --> 01:09:19,940
还好 我们可以计算最大值的期望

1104
01:09:19,990 --> 01:09:22,030
如果我们有一大堆未知变量

1105
01:09:22,120 --> 01:09:24,990
算出期望 带上常数 然后取最大值

1106
01:09:25,080 --> 01:09:27,140
期望我们知道是 O(log n)

1107
01:09:27,230 --> 01:09:29,520
但是我们想要一个更强的结果

1108
01:09:29,570 --> 01:09:31,080
我们用布尔不等式

1109
01:09:31,170 --> 01:09:33,660
来描述一堆元素

1110
01:09:33,760 --> 01:09:36,190
多项式多个元素 比如说有n个元素

1111
01:09:36,280 --> 01:09:39,780
它们相互独立 甚至我不关心它们有没有依赖关系

1112
01:09:39,880 --> 01:09:42,780
但每个都有被提升的可能

1113
01:09:42,880 --> 01:09:44,380
如果某一个升了多于 c log n 级

1114
01:09:44,470 --> 01:09:46,480
那跳跃表的层数就大于 c log n

1115
01:09:46,570 --> 01:09:51,440
然后这个小于等于 额 然后我想知道

1116
01:09:51,540 --> 01:09:55,740
这n个元素中是否有被提升的

1117
01:09:55,830 --> 01:09:57,530
所以我乘上n

1118
01:09:57,630 --> 01:09:59,190
这个当然小于等于

1119
01:09:59,290 --> 01:10:02,940
n乘上x的提升概率

1120
01:10:09,090 --> 01:10:12,160
提升多少呢 提升大于等于 log n层

1121
01:10:16,510 --> 01:10:18,260
对于任意的元素x

1122
01:10:18,350 --> 01:10:19,470
因为所有的元素都一样

1123
01:10:19,560 --> 01:10:20,660
它们的提升是相互独立的

1124
01:10:20,750 --> 01:10:22,490
即 我只是对x求和

1125
01:10:22,580 --> 01:10:25,490
得到因子n 明白吧

1126
01:10:25,590 --> 01:10:26,830
这用到布尔不等式

1127
01:10:26,880 --> 01:10:29,920
那么 x被提升 c log n 次的概率是多少

1128
01:10:30,020 --> 01:10:33,260
我们已经对 log n 的情况推导过了 1/n

1129
01:10:33,350 --> 01:10:40,410
对于c log n 那就是 1/n^c 那就是n乘上2

1130
01:10:42,720 --> 01:10:46,250
写清楚一点 (1/2)^(c log n)

1131
01:10:46,340 --> 01:10:50,440
(1/2)^(c log n)=1/2^(c log n)

1132
01:10:50,540 --> 01:10:53,930
log n 提出来 分子变成n  得到n^c

1133
01:10:54,030 --> 01:10:59,870
即 n/n^c

1134
01:10:59,970 --> 01:11:02,710
即 n^(c-1)

1135
01:11:03,690 --> 01:11:06,730
c是任意选择的

1136
01:11:06,830 --> 01:11:17,310
令 c-1=α 我想是这样吧

1137
01:11:18,480 --> 01:11:22,300
哦 抱歉 这里是1/n^(c-1) 多谢

1138
01:11:22,400 --> 01:11:27,020
它最好是个很小的数哈 因为这可是上界

1139
01:11:27,110 --> 01:11:30,450
所以 概率是多项式地小的 我只要取适宜的常数就好了

1140
01:11:30,560 --> 01:11:31,450
这里稍微有一点技巧

1141
01:11:31,550 --> 01:11:35,810
我令这个常数对α足够大

1142
01:11:35,910 --> 01:11:39,320
关键是 随着c增长 α也增长

1143
01:11:39,410 --> 01:11:41,170
所以 我令α取定任意一个值时

1144
01:11:41,170 --> 01:11:42,720
c可以相应取值满足条件

1145
01:11:42,770 --> 01:11:45,400
这里还有点文字表述

1146
01:11:45,500 --> 01:11:47,620
它们都在课堂注记里了

1147
01:11:47,680 --> 01:11:51,270
我可以让α任意大

1148
01:11:51,360 --> 01:11:52,850
从而我可以让概率

1149
01:11:52,950 --> 01:11:54,760
在多项式集合内任意小

1150
01:11:56,150 --> 01:11:59,060
证毕 层数为 O(log n) 很简单吧

1151
01:11:59,150 --> 01:12:01,460
基本规则和等式推导 关键是

1152
01:12:01,560 --> 01:12:03,530
处理“有高概率”的时候 运用布尔不等式

1153
01:12:03,590 --> 01:12:05,390
还有 对某一个元素成立的结论

1154
01:12:05,450 --> 01:12:07,750
对所有的元素也成立 就是这样

1155
01:12:08,450 --> 01:12:11,240
只是放大一下 乘上因子n 那只是α次幂里的一次啊

1156
01:12:11,330 --> 01:12:15,110
α是一个很大的常数 非常大

1157
01:12:15,880 --> 01:12:19,110
下面我们来证明定理

1158
01:12:20,680 --> 01:12:23,040
有高概率使搜索代价为 O(log n)

1159
01:12:23,130 --> 01:12:24,500
我们现在知道跳跃表的高度是 O(log n)

1160
01:12:24,590 --> 01:12:27,070
不过这取决于链表是否均衡

1161
01:12:27,170 --> 01:12:29,200
它取决于一节的长度有多少

1162
01:12:29,260 --> 01:12:31,270
才能确定一次搜索的代价是 O(log n)

1163
01:12:31,320 --> 01:12:33,390
仅仅知道高度的界是不够的

1164
01:12:33,480 --> 01:12:35,330
不像二叉树

1165
01:12:37,820 --> 01:12:42,110
现在 我们有一个很酷的想法完成这个分析

1166
01:12:47,810 --> 01:12:50,750
称为回溯分析

1167
01:12:55,180 --> 01:12:56,450
一般来讲 我们说搜索

1168
01:12:56,550 --> 01:12:58,090
是从左上角开始

1169
01:12:58,180 --> 01:13:00,530
向右向下前进

1170
01:13:00,630 --> 01:13:02,300
直到找到查找的元素

1171
01:13:02,390 --> 01:13:03,880
我现在反过来看

1172
01:13:03,970 --> 01:13:05,480
我们从要查找的元素开始

1173
01:13:05,540 --> 01:13:10,690
向左向上前进 直到到达左上角

1174
01:13:12,030 --> 01:13:14,390
两种路径经过的步数应该是一样的

1175
01:13:14,490 --> 01:13:16,500
我这里不是实现算法

1176
01:13:16,600 --> 01:13:17,740
只是做分析

1177
01:13:17,830 --> 01:13:20,570
这是两个相同的过程 只是反过来而已

1178
01:13:21,510 --> 01:13:24,970
所以是这样的 我们做一次搜索

1179
01:13:25,060 --> 01:13:27,940
从底链表上某结点开始

1180
01:13:28,030 --> 01:13:35,580
实际上是搜索结束

1181
01:13:39,350 --> 01:13:44,600
然后 每一次访问新的结点

1182
01:13:44,700 --> 01:13:46,830
都是向左或向上访问得到的

1183
01:13:50,230 --> 01:13:51,820
那么什么时候往左 什么时候往上呢

1184
01:13:51,910 --> 01:13:53,830
那就取决于抛硬币的结果

1185
01:13:55,660 --> 01:13:59,060
也就是说 如果结点在这一层没有被提升

1186
01:14:01,320 --> 01:14:03,670
没有被提升到更高

1187
01:14:05,880 --> 01:14:08,600
那是我们抛出反面时发生的事情

1188
01:14:11,270 --> 01:14:19,680
那我们就向左 因为搜索的时候是从左边过来的

1189
01:14:21,470 --> 01:14:24,210
反过来 如果我们抛出正面

1190
01:14:25,630 --> 01:14:29,080
那结点被提升到下一级

1191
01:14:31,180 --> 01:14:34,850
这是我们抛出正面时发生的事情

1192
01:14:35,540 --> 01:14:38,460
我们是在原先插入的时候抛的硬币

1193
01:14:38,550 --> 01:14:47,310
正面我们就向上走 或者说搜索的时候是从上面来 最终回到根结点

1194
01:14:48,460 --> 01:14:52,320
那是我们搜索的起点 那是一个意思

1195
01:14:55,460 --> 01:14:59,590
我们停在根结点 或者说

1196
01:14:59,690 --> 01:15:01,330
停在负无穷

1197
01:15:01,850 --> 01:15:05,130
写得有点乱 我们重新过一遍

1198
01:15:05,230 --> 01:15:07,220
通常来说我们是从这儿开始的

1199
01:15:07,280 --> 01:15:08,720
我们倒推整个过程

1200
01:15:08,770 --> 01:15:10,800
括号里面的是真正的搜索过程

1201
01:15:10,860 --> 01:15:14,870
搜索结束在要查找的结点上

1202
01:15:14,960 --> 01:15:16,220
它总是在底链表里

1203
01:15:18,340 --> 01:15:20,570
然后我们考虑 这个结点被提升了吗

1204
01:15:20,660 --> 01:15:24,240
若是 我是从上边来的 若不是 我是从左边来的

1205
01:15:24,330 --> 01:15:26,310
它一定是在底链表的某处

1206
01:15:26,370 --> 01:15:28,390
这对任意一个被访问过的结点都成立

1207
01:15:28,440 --> 01:15:30,740
取决于抛硬币的结果是正面还是反面

1208
01:15:30,840 --> 01:15:33,870
注意是在这一层做结点插入的时候抛的那次

1209
01:15:33,970 --> 01:15:40,040
因为我们一堆事件 我现在考虑

1210
01:15:40,130 --> 01:15:42,380
正面的概率是多少

1211
01:15:42,470 --> 01:15:43,560
反面的概率是多少

1212
01:15:43,660 --> 01:15:45,860
总是一半对一半 每次抛硬币的时候

1213
01:15:45,960 --> 01:15:47,460
硬币被抛出的时候

1214
01:15:47,560 --> 01:15:49,550
自然就有一半对一半的概率

1215
01:15:50,890 --> 01:15:52,940
很神奇吧

1216
01:15:54,700 --> 01:15:58,180
这里我没有用到事件的独立性

1217
01:15:58,270 --> 01:15:59,460
对于我搜索的任一个元素

1218
01:15:59,530 --> 01:16:03,260
任一个值x 都是单一一次搜索

1219
01:16:03,360 --> 01:16:06,580
这些事件可能不是独立的

1220
01:16:06,680 --> 01:16:08,790
我仍然可以使用布尔不等式推出

1221
01:16:08,850 --> 01:16:11,740
它们都是 O(log n)的情况 是有高概率的

1222
01:16:11,840 --> 01:16:12,750
只要我能证明

1223
01:16:12,840 --> 01:16:15,310
任意一个事件发生是有高概率的

1224
01:16:15,400 --> 01:16:19,110
我不需要每次搜索之间的独立性

1225
01:16:19,210 --> 01:16:21,560
我知道给定一次搜索 全部抛硬币的结果是相互独立的

1226
01:16:21,610 --> 01:16:24,780
但对其他的东西 对不同的搜索来看 我不需要什么条件

1227
01:16:41,480 --> 01:16:43,560
那么 这个搜索过程能持续多长呢

1228
01:16:43,620 --> 01:16:45,940
我们想知道搜索过程要走几步

1229
01:16:45,990 --> 01:16:48,170
注意只要我回到根结点 搜索就结束

1230
01:16:49,940 --> 01:16:52,030
那么我回到根结点要多久呢

1231
01:16:52,130 --> 01:16:54,680
在每一步向上走的概率是一半

1232
01:16:54,780 --> 01:16:57,030
我向上走的次数

1233
01:16:57,120 --> 01:17:00,020
至多为层数减1

1234
01:17:00,820 --> 01:17:02,510
层数有高概率为 O(log n)

1235
01:17:02,600 --> 01:17:05,400
这是我们用到的另一个条件

1236
01:17:05,500 --> 01:17:07,570
现在我们来证明定理

1237
01:17:13,500 --> 01:17:17,150
证明 在一次搜索时向上走的次数

1238
01:17:17,250 --> 01:17:19,190
实际是向下走 一样啦

1239
01:17:19,800 --> 01:17:21,670
小于层数

1240
01:17:23,410 --> 01:17:24,450
这是自然的 我们不能

1241
01:17:24,540 --> 01:17:26,220
在搜索中跑得比总层数还高

1242
01:17:26,320 --> 01:17:27,820
在插入的时候 我们才能跑到任意高

1243
01:17:27,920 --> 01:17:30,400
但在搜索时 最高不能超过层数

1244
01:17:30,490 --> 01:17:33,010
那就是 有高概率至多为 c log n 层

1245
01:17:33,100 --> 01:17:34,660
这是我们在引理中已经证明了的

1246
01:17:41,840 --> 01:17:44,380
所以 我们得到了上行次数的上界

1247
01:17:44,870 --> 01:17:47,040
大约有一半的访问是上行访问

1248
01:17:47,100 --> 01:17:48,850
这大致给出了总步数的界

1249
01:17:48,950 --> 01:17:53,580
但这不是严格的 是有高概率的

1250
01:17:53,680 --> 01:17:55,660
上行和左行有同样的概率

1251
01:17:55,750 --> 01:17:57,020
但我在搜索中可以跑得足够高

1252
01:17:57,120 --> 01:17:58,780
只要我令c充分大

1253
01:18:00,250 --> 01:18:02,500
总访问数 换句话说 搜索的代价

1254
01:18:04,660 --> 01:18:08,490
至多是我们累计抛出 c log n 个正面时

1255
01:18:10,150 --> 01:18:17,510
总的抛硬币的次数

1256
01:18:17,610 --> 01:18:20,230
因为在搜索的每一步 我移动一个结点

1257
01:18:20,320 --> 01:18:22,170
正好对应一次抛硬币

1258
01:18:22,230 --> 01:18:24,700
每次抛的硬币是相互独立的

1259
01:18:24,800 --> 01:18:27,270
要么是正面要么是反面 是相互独立的

1260
01:18:27,370 --> 01:18:29,620
那么我要抛多少次硬币

1261
01:18:29,680 --> 01:18:31,210
才能抛出 c log n 个正面呢

1262
01:18:31,320 --> 01:18:35,820
我们断言它有高概率为 O(log n)

1263
01:18:35,910 --> 01:18:41,830
这是需要证明的 这是我们的断言

1264
01:18:46,900 --> 01:18:48,810
现在假设你就坐在那儿拿着个硬币

1265
01:18:48,860 --> 01:18:51,070
你想知道要抛多少次

1266
01:18:51,130 --> 01:18:58,510
才能得出 c log n 个正面 而我们的断言是

1267
01:18:58,610 --> 01:19:01,910
有高概率是 O(log n)

1268
01:19:02,720 --> 01:19:04,280
只要我证明了这个

1269
01:19:04,380 --> 01:19:07,750
我就知道搜索的总步数

1270
01:19:07,840 --> 01:19:11,880
也就是正面和反面的总数是 O(log n)

1271
01:19:11,980 --> 01:19:14,230
因为我已经知道正面的数目是

1272
01:19:14,330 --> 01:19:15,610
至多 c log n

1273
01:19:15,710 --> 01:19:18,150
我们断言 反面的个数不可能多出太多

1274
01:19:18,250 --> 01:19:21,550
注意 这里我不能只写上c

1275
01:19:21,650 --> 01:19:25,250
有个 log n 是很重要的 为什么

1276
01:19:25,350 --> 01:19:27,810
因为“有高概率”依赖于n

1277
01:19:27,910 --> 01:19:29,850
这个概念是依赖于n的

1278
01:19:29,940 --> 01:19:35,210
对log n 这是对的 对于大于 log n 的表达式它也成立 比如 n

1279
01:19:35,310 --> 01:19:37,150
我在这放上n 那也是对的

1280
01:19:37,270 --> 01:19:40,060
但是 如果我写的是常数 或者 log log n 那就不对了

1281
01:19:40,160 --> 01:19:43,060
log n 是很重要的

1282
01:19:43,150 --> 01:19:45,640
因为“有高概率”的定义

1283
01:19:45,740 --> 01:19:48,380
依赖于这个式子是什么

1284
01:19:49,600 --> 01:19:53,930
这个断言解释明白了 我们马上要证出来了

1285
01:19:54,020 --> 01:19:56,340
太好了 因为我快要没时间了

1286
01:19:56,390 --> 01:19:59,430
不好意思 我们要拖堂几分钟

1287
01:20:02,000 --> 01:20:05,420
现在我来计算失败概率

1288
01:20:05,510 --> 01:20:07,950
我想计算一下

1289
01:20:08,050 --> 01:20:10,400
抛出少于 c log n 个正面的概率

1290
01:20:14,560 --> 01:20:17,670
这步骤我就跳过了 大致上 我是说

1291
01:20:17,760 --> 01:20:22,420
至多有 c log n 个正面的概率是多少

1292
01:20:30,080 --> 01:20:32,890
我需要知道总共抛了多少次硬币

1293
01:20:32,990 --> 01:20:35,390
对应这一事件

1294
01:20:35,440 --> 01:20:37,000
所以我要明确给出这个常数

1295
01:20:37,100 --> 01:20:43,070
我们说 总共抛了 10c log n 个硬币

1296
01:20:43,700 --> 01:20:46,780
现在我来考虑它的失败概率

1297
01:20:47,580 --> 01:20:51,430
在 10c log n 次抛硬币中

1298
01:20:52,640 --> 01:20:56,760
至多 c log n 个正面的概率为

1299
01:20:56,850 --> 01:20:58,650
我们断言它很小

1300
01:20:58,710 --> 01:21:00,050
其实跟这里的10有关

1301
01:21:00,150 --> 01:21:01,880
然后我令10这个位置的常数任意大

1302
01:21:01,980 --> 01:21:05,000
然后证完 接下来的工作就简单些了

1303
01:21:05,950 --> 01:21:10,630
我应该提问的 但这是6.042课程的内容

1304
01:21:17,760 --> 01:21:19,430
那么至多有那么多正面的

1305
01:21:19,520 --> 01:21:21,210
这个概率是多少？

1306
01:21:21,320 --> 01:21:25,260
也就是说 有 9c log n 的硬币

1307
01:21:25,350 --> 01:21:28,660
因为一共 10c log n 个硬币 至多 c log n 个正面

1308
01:21:28,750 --> 01:21:31,330
至少 9c log n 个反面

1309
01:21:31,420 --> 01:21:34,650
这是那么多个硬币是反面的概率

1310
01:21:35,120 --> 01:21:36,390
这已经很小了

1311
01:21:36,480 --> 01:21:39,090
然后这里还有个组合数

1312
01:21:39,180 --> 01:21:42,070
如果我要求正好有 c log n 个正面

1313
01:21:42,160 --> 01:21:44,170
有这么多种方式

1314
01:21:44,220 --> 01:21:47,410
从 10c log n 中选择 c log n 个为正面

1315
01:21:48,120 --> 01:21:49,960
这个是组合数

1316
01:21:50,550 --> 01:21:52,320
数字有点大 很烦人

1317
01:21:52,410 --> 01:21:53,710
这一项又很小很小

1318
01:21:53,810 --> 01:21:55,960
我们断言这项的减小远远快于这项的增大

1319
01:22:13,390 --> 01:22:16,030
这都是数学推导 我很快地过一下

1320
01:22:16,120 --> 01:22:19,200
大家不会等太久 但还是过一下

1321
01:22:19,300 --> 01:22:22,730
我们知道 组合数(y,x)

1322
01:22:22,820 --> 01:22:27,650
不大于 (ey/x)^x 这个事实很好用

1323
01:22:27,740 --> 01:22:33,030
因此 这个不大于 10c log n/c log n

1324
01:22:34,450 --> 01:22:36,190
也就是10

1325
01:22:36,780 --> 01:22:40,050
消掉这些 这里还有个e

1326
01:22:40,150 --> 01:22:42,190
然后写上 c log n 次幂

1327
01:22:43,010 --> 01:22:47,020
除上 2^(9c log n)

1328
01:22:47,120 --> 01:22:49,480
这是啥

1329
01:22:49,530 --> 01:22:53,900
这是 (10e)^(c log n)

1330
01:22:53,990 --> 01:22:56,720
除以 2^(9c log n)

1331
01:22:57,780 --> 01:23:01,160
我们说 这个很大 这个不那么大

1332
01:23:01,260 --> 01:23:04,570
因为这里有个9 我们推一下

1333
01:23:04,660 --> 01:23:09,910
这是 10e 这个数字很好 放在乘幂上面

1334
01:23:10,620 --> 01:23:16,040
我们得到 log (10e) 然后是 c log n

1335
01:23:16,820 --> 01:23:20,720
除以 2^(9c log n)

1336
01:23:21,230 --> 01:23:26,130
分子分母都有 2^(c log n)

1337
01:23:27,980 --> 01:23:32,310
得到 2^((log(10e)-9)c log n)

1338
01:23:32,890 --> 01:23:41,860
这是基本的运算哈

1339
01:23:42,730 --> 01:23:46,850
现在我让 额 先不搞这个

1340
01:23:47,530 --> 01:23:52,610
这等于 1/2^(9-log...）

1341
01:23:54,370 --> 01:23:57,170
反过来写 变个号

1342
01:23:58,470 --> 01:24:03,860
然后就可以令这个为α 因为剩下的就是n

1343
01:24:03,950 --> 01:24:06,480
这就是1/n^α

1344
01:24:06,600 --> 01:24:08,860
我已经令α为

1345
01:24:08,910 --> 01:24:12,420
(9-log(10e))c

1346
01:24:12,520 --> 01:24:16,260
这看起来有点怪 但关键是

1347
01:24:16,360 --> 01:24:18,420
随着10这里的常数趋于无穷

1348
01:24:19,720 --> 01:24:23,850
9=10-1 对吧

1349
01:24:23,950 --> 01:24:25,910
这是上面某步约去1得到的

1350
01:24:25,970 --> 01:24:27,450
随着10变成无穷 [c'→∞]

1351
01:24:27,550 --> 01:24:29,560
这里大概是10-1 [c'-1]

1352
01:24:29,610 --> 01:24:33,170
这大概是 log(10e) [log(c'e)] e是无所谓的

1353
01:24:33,270 --> 01:24:35,000
关键是 这是对数增长的

1354
01:24:35,050 --> 01:24:36,670
这是线性增长的

1355
01:24:36,770 --> 01:24:39,010
10的线性项远远大于

1356
01:24:39,070 --> 01:24:40,780
10的对数项

1357
01:24:40,840 --> 01:24:42,080
这不是正式的表示法

1358
01:24:42,690 --> 01:24:44,420
好 随着10趋于无穷

1359
01:24:44,480 --> 01:24:47,850
这个也趋于无穷

1360
01:24:47,940 --> 01:24:49,530
这还有个c

1361
01:24:49,630 --> 01:24:51,300
但对于任意一个c

1362
01:24:51,390 --> 01:24:53,610
在断言中无论c等于多少

1363
01:24:53,670 --> 01:24:56,740
我都可以令α任意大

1364
01:24:56,830 --> 01:25:00,140
通过改变大O记号的常数 这里是10

1365
01:25:01,410 --> 01:25:04,200
所以有高概率使断言成立

1366
01:25:04,290 --> 01:25:07,410
无论要求什么概率 也就是给出α

1367
01:25:07,500 --> 01:25:12,710
只要选取它为 log n 前的常数

1368
01:25:12,810 --> 01:25:16,690
随着n的增长 就可以达到

1369
01:25:16,790 --> 01:25:18,560
从而可以得到

1370
01:25:18,650 --> 01:25:20,870
O(log n) 次抛硬币中有 O(log n) 个正面有高概率

1371
01:25:20,970 --> 01:25:22,220
一次搜索的步数为

1372
01:25:22,310 --> 01:25:23,820
O(log n) 是有高概率的

1373
01:25:23,910 --> 01:25:26,010
很酷吧 请阅读课后的注记

1374
01:25:26,100 --> 01:25:27,790
后面讲得有点快 不好意思哈

