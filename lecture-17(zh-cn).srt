1
00:00:05,710 --> 00:00:10,070
我们今天讲最短路径算法

2
00:00:14,180 --> 00:00:17,970
我们大概要讲它三次课

3
00:00:18,010 --> 00:00:19,910
最短路径三部曲

4
00:00:19,980 --> 00:00:22,250
今天讲最短路径第一部

5
00:00:22,310 --> 00:00:26,590
这个星期我看了太多个版本的星球大战了

6
00:00:26,620 --> 00:00:29,440
我昨天看的是音乐剧 白天场的

7
00:00:29,510 --> 00:00:31,020
那是MIT自己的音乐剧

8
00:00:31,090 --> 00:00:33,170
很有意思 一共三场

9
00:00:33,280 --> 00:00:36,180
三场加起来四个小时 时间略长

10
00:00:36,250 --> 00:00:39,120
然后我星期五看的是个人秀

11
00:00:39,120 --> 00:00:43,010
一个人的星战 一个小时内演了三场

12
00:00:43,080 --> 00:00:46,020
那熊孩子真会玩儿

13
00:00:46,090 --> 00:00:47,530
两场都很过瘾

14
00:00:47,630 --> 00:00:51,220
现在开始我的三部曲

15
00:00:51,320 --> 00:00:57,140
我们先从《新希望》开始

16
00:00:57,220 --> 00:01:00,530
我们会介绍 什么是最短路径问题

17
00:01:00,600 --> 00:01:02,800
然后讲解其中的一部分问题

18
00:01:02,800 --> 00:01:04,750
一些非常有趣的问题

19
00:01:04,830 --> 00:01:06,620
然后我们会慢慢地接触到

20
00:01:06,690 --> 00:01:08,400
更多的、更一般化的问题

21
00:01:08,470 --> 00:01:12,700
最短路径算法是一种动态规划的应用

22
00:01:12,700 --> 00:01:14,820
就是我们上周讲的 还有贪...

23
00:01:14,860 --> 00:01:17,650
还有贪心算法 我们上周也讲过的

24
00:01:17,720 --> 00:01:19,990
我们一会要实现它 用一些很有趣的算法

25
00:01:20,000 --> 00:01:23,310
来解决一些重要的问题 例如

26
00:01:23,340 --> 00:01:27,320
如果从奥德隆出发...

27
00:01:27,350 --> 00:01:32,910
呃...怎么走才能最快到剑桥？

28
00:01:32,950 --> 00:01:35,600
好吧 假设是在地图上走的话

29
00:01:35,640 --> 00:01:39,590
几何学上有几种最短路径 那比较复杂

30
00:01:39,730 --> 00:01:42,990
但这里 我们只关注图的最短路径

31
00:01:43,030 --> 00:01:47,270
我想你们都应该知道 图的路径是什么了

32
00:01:47,310 --> 00:01:50,260
但还是简单地回顾下

33
00:01:50,360 --> 00:01:53,450
因为我们准备研究加权的图

34
00:01:55,430 --> 00:01:59,570
那一般前提是 假设我们有个有向图G

35
00:01:59,710 --> 00:02:02,090
有一些顶点 一些边

36
00:02:03,670 --> 00:02:12,430
已知边的权重 这会使得图更加有趣

37
00:02:12,500 --> 00:02:15,870
权重就是每条边上的一个实数

38
00:02:17,500 --> 00:02:27,640
权重可以用函数W来表示

39
00:02:27,810 --> 00:02:31,050
对于每条边 都有一个实数

40
00:02:37,940 --> 00:02:41,630
然后 当我们观察图的路径时

41
00:02:41,700 --> 00:02:45,580
我们会用一些简单的符号来表示路径

42
00:02:45,590 --> 00:02:47,750
比如路径p 起点是某个顶点

43
00:02:47,820 --> 00:02:50,980
经过另一个顶点 等等

44
00:02:51,080 --> 00:02:52,940
最后一个顶点是v_k

45
00:02:53,010 --> 00:02:56,930
这些都是有向图里面的有向边

46
00:02:56,970 --> 00:02:58,390
所以 这是一条有向的路径

47
00:02:58,420 --> 00:03:01,590
它由对应的这些边组成

48
00:03:03,210 --> 00:03:05,770
然后 一条路径的总权值

49
00:03:05,800 --> 00:03:09,250
等于路径上的各边的权值的总和

50
00:03:09,360 --> 00:03:12,120
我们令此为w(p)

51
00:03:12,230 --> 00:03:22,910
它等于∑w(v_i, v_(i+1)) i从1到k-1

52
00:03:23,940 --> 00:03:27,670
好的 把它画出来

53
00:03:29,010 --> 00:03:31,270
那在这里 它一般会是这个样子

54
00:03:31,340 --> 00:03:34,990
我们有一条路径 它从某个顶点开始

55
00:03:35,060 --> 00:03:37,940
它经过的每条边上有一些权值

56
00:03:38,050 --> 00:03:41,990
这代表图里任意一条路径

57
00:03:42,530 --> 00:03:45,520
在某一幅假想图里的路径

58
00:03:56,390 --> 00:03:57,960
好 这里主要想讲的是

59
00:03:58,000 --> 00:03:59,490
有些边的权值可能是负值

60
00:03:59,560 --> 00:04:01,010
也有一些可能等于0

61
00:04:01,080 --> 00:04:04,260
这里的和等于-2

62
00:04:04,740 --> 00:04:07,830
所以这路径的权值为-2

63
00:04:07,900 --> 00:04:09,420
这幅图可能比这儿要大得多

64
00:04:09,460 --> 00:04:11,430
这只是图里面的一条路径

65
00:04:11,470 --> 00:04:14,580
我们通常考虑的简单路径不会重复经过一个顶点

66
00:04:14,590 --> 00:04:17,640
但有时候 我们又允许有这种情况

67
00:04:17,910 --> 00:04:21,120
然后 我们关心的是最短的路径

68
00:04:21,180 --> 00:04:24,980
或者是某一条最短路径 因为可能不止一条

69
00:04:25,050 --> 00:04:28,670
但我们通常会称之为最短路径

70
00:04:28,770 --> 00:04:33,760
我们想求从A点到B点的最短路径

71
00:04:33,830 --> 00:04:36,670
我们设这两点为u和v

72
00:04:36,780 --> 00:04:44,780
我们想让路径的总权值尽可能地小

73
00:04:47,060 --> 00:04:52,530
使得从u到v的路径最短

74
00:04:54,120 --> 00:04:56,140
好的 这就是我们想要的

75
00:04:56,220 --> 00:04:58,790
一般来说 给你起点u和终点v

76
00:04:58,840 --> 00:05:01,910
如果要最快地找出最短路径

77
00:05:01,940 --> 00:05:03,510
有什么好的算法？

78
00:05:03,580 --> 00:05:07,490
这就是接下来三次课要讲的内容

79
00:05:08,440 --> 00:05:11,400
我们通常会思考一个简单一点的问题

80
00:05:11,440 --> 00:05:13,990
就是如何计算路径的权值

81
00:05:14,060 --> 00:05:18,550
说白了就是计算从A到B的距离

82
00:05:18,970 --> 00:05:25,650
我们把从u到v的最短路径的权值

83
00:05:26,220 --> 00:05:33,720
用δ(u,v)来表示 这个小写的δ

84
00:05:34,010 --> 00:05:37,200
那么 它等于最短路径的权值

85
00:05:37,270 --> 00:05:38,750
或者说 每条最短路径的权值

86
00:05:38,780 --> 00:05:39,590
也就是说

87
00:05:39,610 --> 00:05:50,440
它等于所有从u到v的路径中的最小值

88
00:05:52,320 --> 00:05:54,280
这里的p是一条路径

89
00:05:56,230 --> 00:05:58,320
你只要这么想

90
00:05:58,400 --> 00:06:00,280
这里可能有许多不同的路径

91
00:06:00,320 --> 00:06:02,470
理论上 这有无数条路径

92
00:06:02,540 --> 00:06:04,330
如果允许重复经过顶点的话

93
00:06:04,400 --> 00:06:06,250
假设 你把所有这些路径都算一遍

94
00:06:06,280 --> 00:06:08,170
然后取最小的权值

95
00:06:08,250 --> 00:06:09,260
有问题？

96
00:06:09,280 --> 00:06:14,840
[学生]：...

97
00:06:14,910 --> 00:06:17,870
[教授]:问得好 我的下一个问题是

98
00:06:17,910 --> 00:06:20,250
什么时候 这条最短路径会不存在?

99
00:06:20,320 --> 00:06:22,990
你们已经遇到一次这种情况了

100
00:06:23,060 --> 00:06:27,400
就是出现负权值的边的时候

101
00:06:34,750 --> 00:06:38,510
原则上 当你有负值的边时

102
00:06:38,580 --> 00:06:41,780
最短路径就可能不存在

103
00:06:41,890 --> 00:06:44,840
也就是不存在最短路径

104
00:06:46,950 --> 00:06:48,520
我们找不到最短路径

105
00:06:48,590 --> 00:06:51,620
u和v之间没有最短路径

106
00:06:54,960 --> 00:07:00,580
但实际上 如果我有两个顶点u和v

107
00:07:00,590 --> 00:07:04,650
我想得到它们之间的最短路径

108
00:07:05,340 --> 00:07:06,780
而其中又有带负值的边

109
00:07:06,850 --> 00:07:08,010
这其实也是可行的

110
00:07:08,080 --> 00:07:09,240
因为我还是能够计算...

111
00:07:09,280 --> 00:07:11,750
一条带负值的路径的权值

112
00:07:11,850 --> 00:07:15,900
但什么情况下 才会真正地...

113
00:07:15,930 --> 00:07:19,170
没有一条从u到v的最短路径？

114
00:07:19,380 --> 00:07:20,540
所以 想想看

115
00:07:20,560 --> 00:07:23,870
[学生]：...

116
00:07:23,970 --> 00:07:25,010
[教授]:好

117
00:07:25,820 --> 00:07:30,580
如果我在某处找到了一个环

118
00:07:30,620 --> 00:07:32,380
它总的权值是...

119
00:07:32,450 --> 00:07:35,890
这些权值的总和是负的

120
00:07:35,950 --> 00:07:40,220
如果我在这里 不断地跑这个环

121
00:07:40,290 --> 00:07:41,430
这样总权值就会不断减少

122
00:07:41,500 --> 00:07:42,770
因为这条环是负的

123
00:07:42,840 --> 00:07:45,040
我每走一次就减一个定值

124
00:07:45,110 --> 00:07:46,550
然后我再走到v

125
00:07:46,590 --> 00:07:49,530
只要是在从u到v的路径中

126
00:07:49,560 --> 00:07:52,070
经过了一个负环

127
00:07:52,140 --> 00:07:57,040
这样便不存在最短路径

128
00:07:57,120 --> 00:07:59,020
因为无论我选择哪条路径

129
00:07:59,090 --> 00:08:02,170
我都可以不断走负环来变得更短

130
00:08:02,280 --> 00:08:05,850
所以在某种程度上 这不是真的最小值

131
00:08:05,920 --> 00:08:09,480
对于某些数学痴来说

132
00:08:09,520 --> 00:08:11,090
这更应该说是一个下确界

133
00:08:11,160 --> 00:08:14,140
但在这里 我们会记δ(u,v)

134
00:08:14,180 --> 00:08:16,040
为负无穷

135
00:08:16,070 --> 00:08:19,670
因为u和v之间有一个负环

136
00:08:19,810 --> 00:08:24,400
所以 这种情况是我们需要注意的

137
00:08:24,470 --> 00:08:27,550
然而 只要没有负环的话

138
00:08:27,620 --> 00:08:32,310
δ(u,v)就会是大于负无穷的值

139
00:08:32,380 --> 00:08:35,050
有一个有限的...有一个有限的下界

140
00:08:35,090 --> 00:08:36,700
就算你有负权的边

141
00:08:36,770 --> 00:08:38,710
但没有形成负环的话

142
00:08:38,750 --> 00:08:41,150
比如说 你的图里没有任何的环

143
00:08:41,220 --> 00:08:43,820
那这问题就还值得探讨

144
00:08:43,890 --> 00:08:45,580
而且 我觉得这样想会更好懂

145
00:08:45,630 --> 00:08:49,220
如果你从A到B花的时间是负无穷

146
00:08:49,260 --> 00:08:51,440
恭喜你 你穿越了

147
00:08:51,440 --> 00:08:54,320
假如权值表示的是时间的话

148
00:08:56,200 --> 00:08:58,770
还有什么情况下最短路径不存在？

149
00:08:58,840 --> 00:09:01,250
刚才讲的是一种情况

150
00:09:01,320 --> 00:09:06,080
但还有另一种简单的情况

151
00:09:07,700 --> 00:09:10,370
顶点没有连起来 从u到v可能一条路径都没有

152
00:09:10,450 --> 00:09:12,590
路径集合为空

153
00:09:12,650 --> 00:09:14,590
可能一条从u到v的路径都没有

154
00:09:14,660 --> 00:09:16,180
这里我们要下一个定义

155
00:09:16,250 --> 00:09:19,330
当u到v之间没有路径时

156
00:09:19,440 --> 00:09:26,220
我们设它为无穷大

157
00:09:26,290 --> 00:09:28,480
以上就是特殊情况

158
00:09:28,480 --> 00:09:30,940
一个正无穷 一个负无穷 显而易见

159
00:09:30,990 --> 00:09:32,750
因为它真的要花超长的时间

160
00:09:32,860 --> 00:09:35,890
来从u到达v

161
00:09:36,030 --> 00:09:38,000
你没法从这儿去到那儿

162
00:09:38,070 --> 00:09:40,290
好的 定义完了

163
00:09:40,340 --> 00:09:43,750
当然 在很多时候 我们都要留意这些情况

164
00:09:43,830 --> 00:09:46,470
但通常它是一个有限集

165
00:09:47,940 --> 00:09:51,610
好的 这是我们给的定义

166
00:09:51,610 --> 00:09:52,730
现在我说

167
00:09:52,770 --> 00:09:55,950
接下来 我们要学习一些

168
00:09:56,020 --> 00:09:59,080
最短路径的基本特征

169
00:09:59,150 --> 00:10:04,090
以此来构造好的算法 找出存在的最短路径

170
00:10:04,110 --> 00:10:05,260
特别是

171
00:10:05,320 --> 00:10:08,630
我们想用上动态规划的思想

172
00:10:08,710 --> 00:10:10,830
所以 如果我想用到动态规划

173
00:10:10,900 --> 00:10:12,400
来解决最短路径问题

174
00:10:12,470 --> 00:10:13,800
我要确定些什么？

175
00:10:13,840 --> 00:10:16,950
我首先要注意的是什么？

176
00:10:17,310 --> 00:10:19,790
你们都试过写动态规划

177
00:10:19,860 --> 00:10:22,940
应该都有一个全面的理解

178
00:10:23,120 --> 00:10:26,320
至少比前几周没接触过的时候要好

179
00:10:26,380 --> 00:10:29,230
上一周 我们都学过了

180
00:10:29,370 --> 00:10:32,300
动态规划的学习是要积累的

181
00:10:32,370 --> 00:10:36,750
每一年我都觉得 自己对它有了更好的理解

182
00:10:38,640 --> 00:10:40,830
但有一点

183
00:10:40,930 --> 00:10:44,250
当你在课堂上学习了动态规划

184
00:10:44,750 --> 00:10:48,470
你们要注意到一个关键的性质

185
00:10:49,030 --> 00:10:53,630
什么？ 最优子结构  有见地

186
00:10:55,570 --> 00:10:59,710
这个短语你们要牢记

187
00:11:00,650 --> 00:11:04,440
虽然这个还不足以令动态规划

188
00:11:04,510 --> 00:11:06,110
得到有效利用

189
00:11:06,110 --> 00:11:07,670
但至少告诉你你该干什么

190
00:11:07,740 --> 00:11:10,190
你们应该能试着用上它

191
00:11:10,220 --> 00:11:12,740
这虽然是个很弱的命题 但是

192
00:11:12,820 --> 00:11:14,780
也是你们要注意的一点

193
00:11:14,810 --> 00:11:17,610
这对于动态规划的有效性而言

194
00:11:17,680 --> 00:11:20,010
绝对是一个必要条件

195
00:11:22,850 --> 00:11:24,910
那么 最优结构表示的是

196
00:11:24,950 --> 00:11:26,600
当我选定一条最短路径时

197
00:11:26,630 --> 00:11:28,970
我再观察这条最短路径的子路径

198
00:11:29,040 --> 00:11:33,200
我肯定它也是一条最短路径

199
00:11:34,020 --> 00:11:35,630
子路径对应的两个端点

200
00:11:35,700 --> 00:11:37,910
显然不都是原路径的两端点

201
00:11:37,940 --> 00:11:40,110
但如果两端点间 有一条最短路径的话

202
00:11:40,140 --> 00:11:43,380
我取的任意一条子路径 都是最短子路径

203
00:11:43,420 --> 00:11:46,250
这个最优子结构的一个版本

204
00:11:46,330 --> 00:11:50,370
这对于这里的前提条件是成立的

205
00:11:51,310 --> 00:11:56,950
那么 我们该怎么证明一个最优子结构的性质？

206
00:11:57,580 --> 00:11:59,520
剪贴法

207
00:11:59,590 --> 00:12:02,420
在这里也用得上

208
00:12:02,460 --> 00:12:04,230
我的意思是 它不是总是有用

209
00:12:04,270 --> 00:12:06,900
但这里它是一个好方法

210
00:12:06,970 --> 00:12:10,610
好 让我们想想看

211
00:12:10,650 --> 00:12:13,380
然后我准备画幅图来证明

212
00:12:14,020 --> 00:12:18,030
好的 假如你有一些最短路径的子路径

213
00:12:18,100 --> 00:12:21,400
我们设子路径从x到y

214
00:12:21,470 --> 00:12:25,920
最优路径是从u到v的

215
00:12:26,000 --> 00:12:28,760
所以我们假设(u,v)是最短路径

216
00:12:28,830 --> 00:12:31,230
我们要证明(x,y)也是最短路径

217
00:12:31,300 --> 00:12:34,500
好的 假设(x,y)不是最短路径

218
00:12:34,570 --> 00:12:38,270
那么x到y之间就有一条更短的路径

219
00:12:38,930 --> 00:12:42,680
但如果你在x到y之间有一条更短的路径

220
00:12:42,750 --> 00:12:45,010
那么我只要把这一部分子路径

221
00:12:45,080 --> 00:12:47,490
从u到v的最短路径中擦掉

222
00:12:47,560 --> 00:12:48,840
然后将它替换为更短的路径

223
00:12:48,910 --> 00:12:53,830
假设说这里有一些更短路径

224
00:12:55,860 --> 00:13:00,480
假设它存在 存在的话

225
00:13:00,510 --> 00:13:03,290
那么我只需要剪掉x到y的这段旧路径

226
00:13:03,360 --> 00:13:06,360
然后将这条新路径粘贴上去 它绝对会更短

227
00:13:06,430 --> 00:13:08,550
因此 我得到了一条从u到v的更短的路径

228
00:13:08,620 --> 00:13:12,120
但我一开始就假设它是u到v的最短路径: 矛盾了

229
00:13:12,150 --> 00:13:14,870
所以 这里没有更短的路径

230
00:13:14,910 --> 00:13:18,850
然后这里证明了一个引理

231
00:13:18,920 --> 00:13:21,280
最短路径的子路径都是最短路径

232
00:13:21,490 --> 00:13:25,710
现在这个证明技巧已经是我们的老友记了

233
00:13:25,750 --> 00:13:30,230
除此之外 还有别的剪切与粘贴的例子在等着我们

234
00:13:32,560 --> 00:13:36,880
看来求出最短路径 已经指日可待了

235
00:13:36,910 --> 00:13:38,630
我的意思是 就动态规划而言

236
00:13:38,670 --> 00:13:40,630
我们不会直接对动态规划展开攻略

237
00:13:40,660 --> 00:13:44,470
因为我们要采用贪心策略 它更为强大

238
00:13:44,510 --> 00:13:47,870
但在下周一 我们会看到动态规划的方法的

239
00:13:47,900 --> 00:13:50,610
直观上看  这里很自然地会有一些子问题

240
00:13:50,640 --> 00:13:52,990
从u到v

241
00:13:53,030 --> 00:13:54,860
当我想找从u到v的最短路径时

242
00:13:54,890 --> 00:13:56,920
这只是个特殊化的问题

243
00:13:56,960 --> 00:13:58,710
它可能包括了

244
00:13:58,780 --> 00:14:00,540
求从u到某个中间点x的最短路径

245
00:14:00,580 --> 00:14:02,730
然后再从x到u的最短路径 诸如此类

246
00:14:02,800 --> 00:14:04,140
挺带感嘛

247
00:14:04,210 --> 00:14:06,000
这好像能分成很多子问题

248
00:14:06,080 --> 00:14:09,180
V^2个子问题

249
00:14:09,240 --> 00:14:11,450
感觉应该是往动态规划的方向走

250
00:14:11,520 --> 00:14:12,550
你可以实现它

251
00:14:12,620 --> 00:14:15,140
只不过要有点小技巧

252
00:14:16,020 --> 00:14:18,040
我们下周一会看到

253
00:14:18,180 --> 00:14:21,620
但是现在想一下中间点

254
00:14:21,690 --> 00:14:25,320
我们知道有三角形不等式

255
00:14:33,710 --> 00:14:37,190
你们可能已经听说过三角形不等式的某些形式

256
00:14:37,270 --> 00:14:39,760
它在所有的几何空间内都是成立的

257
00:14:39,830 --> 00:14:42,130
对最短路径来说也是成立的

258
00:14:42,210 --> 00:14:48,940
可能不那么明显 也可能更明显

259
00:14:49,010 --> 00:14:51,300
可能跟倾角有关 我猜的

260
00:14:51,410 --> 00:14:55,150
如果你有三个点

261
00:14:55,470 --> 00:14:58,620
从u到v的最短路径 最大不超过

262
00:14:58,660 --> 00:15:01,700
u到x的最短路径加上

263
00:15:01,700 --> 00:15:05,750
x到v的最短路径

264
00:15:05,820 --> 00:15:08,330
当然 我们需要知道 从u到x的最短路径的权值

265
00:15:08,400 --> 00:15:10,480
和从x到v的最短路径的权值

266
00:15:10,580 --> 00:15:16,490
这个命题看起来就相当顺理成章

267
00:15:16,530 --> 00:15:18,740
画个图出来的话 更加好理解

268
00:15:18,810 --> 00:15:20,830
我们有个点u

269
00:15:20,920 --> 00:15:24,490
我用曲线来表示那些可能更长的路径

270
00:15:24,490 --> 00:15:25,490
与边相对

271
00:15:25,490 --> 00:15:28,550
我们有个中间点x

272
00:15:28,620 --> 00:15:32,640
还有个目的点v

273
00:15:32,680 --> 00:15:35,200
然后我们考虑这三条最短路径

274
00:15:35,230 --> 00:15:36,990
这条是从u到v的最短路径

275
00:15:37,030 --> 00:15:38,460
这是路径的权值

276
00:15:38,500 --> 00:15:42,140
这里是u到x的最短路径和它的权值

277
00:15:42,180 --> 00:15:44,660
还有x到v的最短路径以及它的权值

278
00:15:44,700 --> 00:15:46,600
重点是

279
00:15:46,640 --> 00:15:51,880
这应该是u到v的一条最短路径

280
00:15:51,910 --> 00:15:55,610
特别的 这里有一条从u到x的路径

281
00:15:55,680 --> 00:15:58,330
然后再从x到v 我的意思是

282
00:15:58,360 --> 00:16:01,830
这个和表示的是这一条路径的长度

283
00:16:01,900 --> 00:16:04,310
这里一个最短路径 那里一个最短路径

284
00:16:04,440 --> 00:16:07,060
而这一个 则是所有路径中的最小值

285
00:16:07,100 --> 00:16:08,920
所以这当然不超过

286
00:16:08,990 --> 00:16:12,200
这一条路径 这两个最短路径的和

287
00:16:12,230 --> 00:16:16,110
又一个图证 清楚了吗？

288
00:16:17,430 --> 00:16:21,190
这个很简单

289
00:16:21,260 --> 00:16:25,200
我想很快 我们就要接触一些更有趣的算法了

290
00:16:25,270 --> 00:16:29,120
而且会是 相当意思的算法

291
00:16:31,540 --> 00:16:36,150
今天 我们准备看看最短路径的一个特殊的版本

292
00:16:39,860 --> 00:16:42,170
称为..或者说一种最短路径问题

293
00:16:42,240 --> 00:16:46,630
叫作单源最短路径问题

294
00:16:48,730 --> 00:16:52,280
它比从A到B的定义要更广泛些

295
00:16:53,590 --> 00:16:58,080
问题是 给你一个顶点作为源点

296
00:16:58,150 --> 00:16:59,010
你想要知道

297
00:16:59,080 --> 00:17:02,270
怎么从源顶点到达所有的点

298
00:17:07,660 --> 00:17:11,220
好的 我们叫这个为源点S

299
00:17:11,290 --> 00:17:14,980
从源点出发 我们想找出

300
00:17:15,050 --> 00:17:19,980
从源点s 到其他所有点的最短路径

301
00:17:20,050 --> 00:17:22,550
尤其是 我们想知道最短路径是什么

302
00:17:22,620 --> 00:17:25,210
不过这并不会难很多

303
00:17:28,660 --> 00:17:35,760
那么 这是对于所有v求δ(s,v)

304
00:17:39,840 --> 00:17:41,710
好吧 这个问题确实会难一点

305
00:17:41,780 --> 00:17:44,920
相比于刚开始的从奥德隆到剑桥的问题来说

306
00:17:44,960 --> 00:17:48,040
因为现在 我们想从奥德隆到全宇宙

307
00:17:48,110 --> 00:17:49,940
好吧 事实上

308
00:17:49,980 --> 00:17:52,650
这也是最短路径的奇特之处之一

309
00:17:52,720 --> 00:17:56,430
根据我们当今的研究水平

310
00:17:56,700 --> 00:17:59,910
好像...接下来的命题看起来

311
00:17:59,980 --> 00:18:03,000
总会是成立的 但也可能是真实的谎言

312
00:18:03,000 --> 00:18:06,170
解决A到B最短路径问题的最佳算法——

313
00:18:06,240 --> 00:18:08,980
已知s和t 从s到t

314
00:18:09,030 --> 00:18:12,880
——不会比这个问题简单

315
00:18:13,000 --> 00:18:15,740
我们所知道的 求A到B最短路径的最佳算法

316
00:18:15,810 --> 00:18:19,560
就是求从A到任意地方的最短路径

317
00:18:20,170 --> 00:18:22,080
好像除了这么做以外

318
00:18:22,150 --> 00:18:24,980
也没什么更好的办法了

319
00:18:25,740 --> 00:18:28,240
今天 我们要给这个问题加一些限制条件

320
00:18:28,310 --> 00:18:30,060
因为这儿有点小技巧

321
00:18:30,130 --> 00:18:31,670
剩下的我们留到下次课

322
00:18:31,740 --> 00:18:34,560
但是 今天我们先不管

323
00:18:34,590 --> 00:18:37,760
负权值环的问题

324
00:18:37,770 --> 00:18:40,750
所以禁止负权值的存在

325
00:18:41,550 --> 00:18:43,470
所以 我们先假设

326
00:18:43,470 --> 00:18:46,790
所有的边都是非负的

327
00:18:46,860 --> 00:18:49,850
对于所有的u和v

328
00:18:50,720 --> 00:18:52,330
也就是说

329
00:18:52,420 --> 00:18:57,950
最短路径存在 只要路径存在

330
00:19:10,590 --> 00:19:13,500
那么我们就不用担心负无穷的情况

331
00:19:13,570 --> 00:19:18,040
δ(u,v)总是大于负无穷

332
00:19:18,110 --> 00:19:20,810
虽然没有路径的话 还会有正无穷的情况

333
00:19:20,880 --> 00:19:22,960
但至少能给我们省点脑细胞

334
00:19:23,030 --> 00:19:26,220
我们今天讲的这个算法真的很依赖这个条件

335
00:19:26,260 --> 00:19:29,000
没它不行

336
00:19:29,060 --> 00:19:32,600
下节课 我们就可以去掉这个条件

337
00:19:34,810 --> 00:19:38,200
用一个酷炫但较慢的算法

338
00:19:43,820 --> 00:19:48,780
之前剧透过了

339
00:19:48,850 --> 00:19:54,990
我们今天的算法思想是 贪心

340
00:19:56,270 --> 00:19:59,240
它一般比动态规划要快

341
00:19:59,310 --> 00:20:01,130
但有技巧的部分是

342
00:20:01,240 --> 00:20:04,390
如何证明贪心算法确实有效

343
00:20:05,110 --> 00:20:12,130
所以 我觉得大概只有一种合适的方法来证明

344
00:20:12,200 --> 00:20:16,670
可能只有一种方法适合贪心算法

345
00:20:16,710 --> 00:20:19,160
但这可能不容易想得到

346
00:20:19,640 --> 00:20:22,100
我先给你们一些前提条件

347
00:20:22,500 --> 00:20:26,100
我们要维持一个不变量

348
00:20:26,170 --> 00:20:30,570
在任意时刻 我们都要

349
00:20:30,670 --> 00:20:34,760
估算从源点到每个点的距离

350
00:20:34,830 --> 00:20:37,150
我所说的距离 指的是最短路径的权值

351
00:20:37,220 --> 00:20:40,720
我说的权值和距离可以互换的

352
00:20:41,130 --> 00:20:42,690
听起来更顺耳

353
00:20:45,490 --> 00:20:48,440
而且 我还想要维持那些

354
00:20:48,500 --> 00:20:52,090
估算距离已经是最短距离的顶点

355
00:21:08,330 --> 00:21:10,180
这个是小写s 这个是大写S

356
00:21:10,250 --> 00:21:13,950
大写S是所有已知最短路径的顶点的集合

357
00:21:13,990 --> 00:21:15,710
小写s到大写S集合中每个点

358
00:21:15,780 --> 00:21:19,640
最短距离分别是多少？

359
00:21:19,720 --> 00:21:23,110
一开始时 我们知道的是哪些距离？

360
00:21:25,290 --> 00:21:28,660
没听清？s

361
00:21:28,730 --> 00:21:32,040
我知道的是s到s的最短距离

362
00:21:32,120 --> 00:21:36,910
因为前提是所有边的权值都是非负的

363
00:21:36,980 --> 00:21:41,580
啥都不做总要比有任何动作都要快吧

364
00:21:41,620 --> 00:21:43,540
好吧 如果有负环的话 可能不一样

365
00:21:43,670 --> 00:21:46,170
s到s的距离等于负无穷

366
00:21:46,640 --> 00:21:49,900
好的 但是我没有负权值

367
00:21:49,980 --> 00:21:52,910
所以这里我没法比0还要更快

368
00:21:52,980 --> 00:21:55,860
可能有条路绕多几个点 但费用还是0

369
00:21:55,920 --> 00:21:58,480
不过没有比0更快的了

370
00:21:58,590 --> 00:22:03,140
所以 我知道

371
00:22:03,440 --> 00:22:06,190
一开始S里面肯定有一个s

372
00:22:07,790 --> 00:22:08,980
好的 按这种思路 我们要

373
00:22:09,050 --> 00:22:11,100
不断地增加我们已知的点

374
00:22:11,170 --> 00:22:14,970
某种程度上 我们知道到某些点的距离

375
00:22:15,040 --> 00:22:18,560
我们这里有一堆东西

376
00:22:18,630 --> 00:22:21,020
这是S 然后这是其他的东西

377
00:22:21,060 --> 00:22:22,660
这个就是图G

378
00:22:22,740 --> 00:22:25,890
这个是顶点的子集合

379
00:22:25,960 --> 00:22:29,500
然后这些是从集合S里连出来的边

380
00:22:30,540 --> 00:22:34,440
我们有 到外面一些点的距离估算

381
00:22:34,440 --> 00:22:36,200
但其中一些点 我们可能无法得知

382
00:22:36,270 --> 00:22:39,490
它们可能没有跟S里的点相连

383
00:22:39,560 --> 00:22:40,500
我是指：无法直连

384
00:22:40,500 --> 00:22:42,510
可能要通过更长的路才能相连

385
00:22:42,590 --> 00:22:46,030
它们可能处于完全不同的连通分量里

386
00:22:46,240 --> 00:22:47,090
我们暂时不知道

387
00:22:47,160 --> 00:22:48,670
我们已经估算出它们其中一部分

388
00:22:48,710 --> 00:22:51,830
因为我们已经知道怎么从连到那儿了

389
00:22:51,970 --> 00:22:53,400
然后 思路是

390
00:22:53,440 --> 00:22:55,730
在这些已经估算好的点之中

391
00:22:55,810 --> 00:22:58,220
然后从小写s出发的

392
00:22:58,290 --> 00:23:01,720
也就是里面的某个点 到外面的这些点

393
00:23:01,890 --> 00:23:06,430
我们准备取它们中距离最小的那个

394
00:23:06,490 --> 00:23:09,690
这就是贪心的策略

395
00:23:11,880 --> 00:23:14,440
然后 我们就把那一点加入到S中

396
00:23:14,520 --> 00:23:18,370
那么 S每一步都增加一个点

397
00:23:18,800 --> 00:23:24,340
每一步 我们加到S的点

398
00:23:24,450 --> 00:23:26,550
当然 可能不止一个点

399
00:23:26,610 --> 00:23:30,560
它是一个点v 在V减S的集合中

400
00:23:30,670 --> 00:23:34,730
所以 这是一个还没经过验算的...

401
00:23:38,250 --> 00:23:50,840
离S的距离最短的点

402
00:23:52,470 --> 00:23:54,880
所以 我们观察所有还没加进S的点

403
00:23:54,900 --> 00:23:57,840
然后从中选出距离最小的一个点

404
00:23:57,880 --> 00:24:01,590
直觉告诉我 这是一个好的选择

405
00:24:01,660 --> 00:24:05,180
如果我选的这一个离小s最近

406
00:24:05,180 --> 00:24:06,120
在所有我看到的顶点之中

407
00:24:06,190 --> 00:24:08,010
在所有我看到的路径之中

408
00:24:08,080 --> 00:24:10,860
我会认为这样能选出好的路径

409
00:24:10,970 --> 00:24:13,640
但是 我想说 可能还有些我们没看到的路径

410
00:24:13,710 --> 00:24:15,040
或者当你走到这儿

411
00:24:15,110 --> 00:24:16,740
然后你另选一条新路径

412
00:24:16,770 --> 00:24:18,550
去一个曾经看过的点

413
00:24:18,630 --> 00:24:20,770
好的 我们担心

414
00:24:20,840 --> 00:24:22,520
这个可能并不是最短路径

415
00:24:22,590 --> 00:24:24,790
因为可能有别的路径能到那儿去

416
00:24:24,870 --> 00:24:26,790
好的 当我往S里加入某个点 我就说

417
00:24:26,860 --> 00:24:28,730
关于这个点的问题已经解决了

418
00:24:28,800 --> 00:24:31,000
我后面不会再改动它了

419
00:24:31,040 --> 00:24:34,070
在被加入到S之前 估算距离可能会变

420
00:24:34,140 --> 00:24:35,780
所以 我不想把这个点加到S中

421
00:24:35,860 --> 00:24:37,560
因为我还没考虑过这条路径

422
00:24:37,630 --> 00:24:40,740
那么 如果权值是非负的话

423
00:24:40,780 --> 00:24:48,310
然后 我选取离S估算距离最短的点

424
00:24:48,460 --> 00:24:51,970
让我们假设这个是最短路径

425
00:24:52,040 --> 00:24:54,050
那这条路就不可能比它更短

426
00:24:54,120 --> 00:24:57,790
因为S到这个顶点的估算距离 至少

427
00:24:57,820 --> 00:25:00,620
要比S到那个点的大

428
00:25:00,680 --> 00:25:05,270
所以 不可能路绕远了 距离反而短了

429
00:25:05,310 --> 00:25:06,360
这是直觉的推断

430
00:25:06,400 --> 00:25:07,450
好的 这个地方有点混乱

431
00:25:07,520 --> 00:25:09,750
因为我没有建立任何归纳假设

432
00:25:09,790 --> 00:25:11,700
而且要证明它 好像要花很多功夫

433
00:25:11,740 --> 00:25:15,700
但这个推断说明这个方法是行的

434
00:25:15,840 --> 00:25:19,250
你还需要对估算距离证明一些东西

435
00:25:19,320 --> 00:25:20,650
来证明它是可行的

436
00:25:21,640 --> 00:25:23,910
但根据剧情发展 这肯定是可行的

437
00:25:23,910 --> 00:25:26,440
至少这个开局还挺顺的

438
00:25:28,560 --> 00:25:31,290
可想而知 我们需要维护这些估算的距离

439
00:25:31,320 --> 00:25:34,700
这个算法的核心就是更新估算距离

440
00:25:34,750 --> 00:25:38,140
我是说 选出最好的点加入到S中 这是第一步

441
00:25:38,210 --> 00:25:41,740
然后 更新估算距离

442
00:25:41,840 --> 00:25:45,040
这是最主要的一步

443
00:25:45,450 --> 00:25:46,260
事实上

444
00:25:46,280 --> 00:25:49,740
我们只需要更新某些点的估算距离

445
00:25:49,810 --> 00:25:53,460
就那些与v相连的点

446
00:25:53,570 --> 00:25:56,260
v是指 刚刚加进S中的顶点

447
00:25:56,330 --> 00:25:58,790
一旦我们往S里加入某些点

448
00:25:58,830 --> 00:26:00,750
S就扩大了一点点

449
00:26:00,790 --> 00:26:04,280
然后我们观察最新连入S的那些边

450
00:26:04,320 --> 00:26:07,360
那个顶点连什么 我们就更新什么

451
00:26:07,670 --> 00:26:11,990
这就是主要思路

452
00:26:24,540 --> 00:26:27,280
这就是怎么运用贪心策略的思路

453
00:26:27,350 --> 00:26:29,920
现在我给出这个算法

454
00:26:31,970 --> 00:26:37,380
它的名字叫Dijkstra算法

455
00:26:43,350 --> 00:26:50,140
Dijkstra是近代著名的

456
00:26:51,330 --> 00:26:59,370
计算机科学家 来自荷兰 如果没记错的话

457
00:26:59,690 --> 00:27:03,570
而且 这个可能是他最著名的算法

458
00:27:07,720 --> 00:27:11,170
这个算法一开始只是初始化

459
00:27:11,240 --> 00:27:12,930
没什么特别

460
00:27:26,800 --> 00:27:30,010
好的 我先来告诉你们这些变量代表什么

461
00:27:30,080 --> 00:27:36,080
好的 d是一个以顶点为下标的数组

462
00:27:36,150 --> 00:27:48,570
而d[x]则是起点到x的距离的估算距离

463
00:27:48,640 --> 00:27:54,860
也就是从s到x 而且

464
00:27:54,930 --> 00:28:00,590
它将会是从s到x的真正的最短路径权值

465
00:28:00,660 --> 00:28:05,890
仅当我们把x加入到大写S集合中时

466
00:28:05,990 --> 00:28:07,580
好的 也就是说

467
00:28:07,620 --> 00:28:09,650
这就是这个算法的输出结果

468
00:28:09,730 --> 00:28:10,670
你在举手提问吗？

469
00:28:10,700 --> 00:28:12,570
噢 原来你是奥特曼同学

470
00:28:12,600 --> 00:28:16,360
所以 当我们完成时 d[x]就是输出

471
00:28:16,430 --> 00:28:17,800
对于每个顶点 它最后都会给出

472
00:28:17,800 --> 00:28:20,090
从S到那个顶点的最短路径的权重

473
00:28:20,190 --> 00:28:21,110
一路下来

474
00:28:21,140 --> 00:28:23,660
它都是从S到某一点的估算距离

475
00:28:23,730 --> 00:28:25,300
然后 我们每次都更新它

476
00:28:25,380 --> 00:28:26,730
这个等于正无穷

477
00:28:26,800 --> 00:28:29,520
一开始时 我们知道这个距离等于..

478
00:28:29,630 --> 00:28:33,230
点s到点s的距离为0

479
00:28:33,300 --> 00:28:34,950
我们把它作为估算距离

480
00:28:34,990 --> 00:28:36,110
虽然肯定是对的

481
00:28:36,150 --> 00:28:37,940
其他的点 我们只需要设为正无穷

482
00:28:38,010 --> 00:28:39,990
因为它们跟s可能不相连

483
00:28:40,060 --> 00:28:42,000
刚开始时 我们知道得不多

484
00:28:42,070 --> 00:28:43,740
S一开始是正无穷

485
00:28:43,780 --> 00:28:46,660
马上 我们就往S里加入小写s

486
00:28:46,730 --> 00:28:49,430
然后 最有趣的是这里有个Q

487
00:28:50,200 --> 00:28:51,710
Q将会包括有

488
00:28:51,750 --> 00:28:54,850
一开始是图中所有的点

489
00:28:54,990 --> 00:28:58,860
这个Q不单说明了它是队列Queue

490
00:28:58,930 --> 00:29:01,380
它还是一个优先队列

491
00:29:01,480 --> 00:29:05,720
特别地 它还要维护...

492
00:29:05,790 --> 00:29:09,150
有着最小估算距离的顶点

493
00:29:09,220 --> 00:29:12,440
那么 它是一个优先队列

494
00:29:13,640 --> 00:29:17,950
这个确实是数据结构符号的滥用

495
00:29:19,780 --> 00:29:22,090
好吧 这个可能是一个堆什么的

496
00:29:22,200 --> 00:29:29,000
这些顶点以d为键 也就是估算距离

497
00:29:29,070 --> 00:29:29,960
注意一点

498
00:29:30,030 --> 00:29:33,550
S会有...这应该是一个最小堆

499
00:29:33,590 --> 00:29:35,520
S将要获得那个最小的值

500
00:29:35,560 --> 00:29:38,510
一开始每个人的键都相同

501
00:29:38,550 --> 00:29:39,550
然后 我们不断地

502
00:29:39,560 --> 00:29:44,640
从这队列中取出最小值 然后做下一步

503
00:29:45,680 --> 00:29:50,130
好的 这就是初始化

504
00:29:50,720 --> 00:29:53,930
好的 然后我进行初始化

505
00:29:54,080 --> 00:29:55,830
相当简单的东西

506
00:29:55,900 --> 00:29:58,330
只需要线性时间 没有什么特别

507
00:29:58,370 --> 00:30:05,570
这个算法的核心全在这六行里

508
00:30:09,850 --> 00:30:13,480
这实际上还不算一步

509
00:30:13,550 --> 00:30:16,930
我们要做的第一步是

510
00:30:17,040 --> 00:30:19,610
我们取出估算距离最小的顶点

511
00:30:19,680 --> 00:30:22,520
所以 在所有顶点中....

512
00:30:22,590 --> 00:30:25,070
当前的S为空集 Q有所有顶点

513
00:30:25,140 --> 00:30:27,740
一般来说 Q有除S外的所有顶点

514
00:30:27,810 --> 00:30:29,640
那么 我们取顶点u

515
00:30:29,670 --> 00:30:33,860
它对应优先队列里 键值最小的顶点

516
00:30:33,970 --> 00:30:37,100
所以 从Q中取出最小值

517
00:30:57,770 --> 00:31:00,940
我们把u加入S中

518
00:31:01,160 --> 00:31:02,760
我们说 现在有

519
00:31:02,800 --> 00:31:04,650
我指的是 就像我们这里讲的那样

520
00:31:04,690 --> 00:31:09,280
我们往S里加入估算距离最小的顶点

521
00:31:09,310 --> 00:31:11,630
而现在 我们需要更新估算距离

522
00:31:11,700 --> 00:31:14,500
我们观察所有跟u邻接的点

523
00:31:14,570 --> 00:31:19,390
在u的邻接表里的每个顶点v

524
00:31:25,260 --> 00:31:29,420
我们要更新这些距离

525
00:31:45,680 --> 00:31:49,230
这个算法差不多就是这样

526
00:31:51,950 --> 00:31:53,170
这个是键值

527
00:31:53,240 --> 00:31:56,740
我应该说明下这里发生了什么

528
00:31:56,810 --> 00:31:59,020
我们上次主要说了无向图

529
00:31:59,050 --> 00:32:00,550
这里 我们考虑一下有向图

530
00:32:00,590 --> 00:32:04,250
然后这个u的邻接表 它表示的是

531
00:32:04,320 --> 00:32:08,570
给出从u到v有边相连的所有顶点v

532
00:32:08,600 --> 00:32:10,290
所以 这就是连出的邻接表

533
00:32:10,300 --> 00:32:13,160
而不是连入的邻接表

534
00:32:13,230 --> 00:32:16,100
在无向图里 你要列出所有东西

535
00:32:16,170 --> 00:32:18,640
有向图里 我们只需要关心那一些

536
00:32:18,720 --> 00:32:21,700
所以对于每一条边(u,v) 也就是这个

537
00:32:21,770 --> 00:32:25,350
我们要拿v当前的估算距离

538
00:32:25,420 --> 00:32:27,890
和这个候选的估算值比较

539
00:32:27,970 --> 00:32:31,670
说白了就是 你先从s到达了u

540
00:32:31,710 --> 00:32:34,640
路程是d[u] 因为我们已知正确答案了

541
00:32:34,680 --> 00:32:37,660
这个实际上等于

542
00:32:37,940 --> 00:32:40,490
我们先假设这个算法是正确的

543
00:32:40,560 --> 00:32:45,450
这应该就是从s到u 最短路径的权值

544
00:32:45,490 --> 00:32:46,780
因为我们把u加进了S中

545
00:32:46,850 --> 00:32:49,880
每当我们往S里加入某些东西 它就应该是最小的值

546
00:32:50,450 --> 00:32:51,900
所以 我们说

547
00:32:51,980 --> 00:32:53,460
你先从S选最短的路径到达u

548
00:32:53,530 --> 00:32:55,380
然后你再顺着从u到v的边走

549
00:32:55,420 --> 00:32:57,110
(u,v)的权值为w

550
00:32:57,150 --> 00:33:02,570
这就是从S到达v的一条可能的路径

551
00:33:02,640 --> 00:33:03,960
如果这一条路径

552
00:33:04,030 --> 00:33:05,670
比当前集合中的估算距离更短话

553
00:33:05,740 --> 00:33:07,190
如果这个比那个要小

554
00:33:07,220 --> 00:33:09,890
那我们就应该把估算值更新为那个和

555
00:33:09,930 --> 00:33:11,470
因为这条路径更好

556
00:33:11,530 --> 00:33:15,440
然后 把它加入我们路径的集合中

557
00:33:15,480 --> 00:33:18,390
好的 很直观的操作

558
00:33:18,520 --> 00:33:22,190
很明显这样做没有错

559
00:33:22,300 --> 00:33:25,410
我的意思是 选这条路是有道理的

560
00:33:25,480 --> 00:33:27,490
我们待会儿再证明

561
00:33:27,530 --> 00:33:29,640
这是成功的第一步 而它从不出错

562
00:33:29,680 --> 00:33:30,660
然后 巧妙的地方是

563
00:33:30,730 --> 00:33:33,960
要证明这样能把我们所要的所有路径找出来

564
00:33:34,030 --> 00:33:36,850
这一步的操作叫作松弛

565
00:33:41,320 --> 00:33:46,190
要教MIT的孩子学松弛总是很困难

566
00:33:46,270 --> 00:33:47,480
这方法并不是那么的自然

567
00:33:47,520 --> 00:33:50,870
但它是一个非常简单的操作

568
00:33:51,380 --> 00:33:55,210
它来自最优化方法的一个术语

569
00:33:55,250 --> 00:33:58,510
也可说是一个编程术语

570
00:33:58,580 --> 00:34:03,720
这条不等式看起来是不是很眼熟？

571
00:34:03,760 --> 00:34:06,870
尤其是当你写成这种形式的时候?

572
00:34:06,900 --> 00:34:08,970
你说 这个从S到v的最短路径

573
00:34:09,040 --> 00:34:14,130
和S到u最短路径 再走u到v的边

574
00:34:14,200 --> 00:34:16,380
是不是似曾相似?

575
00:34:16,420 --> 00:34:18,800
实际上 它刚刚还写在黑板上 后来被我擦掉了

576
00:34:18,840 --> 00:34:20,460
三角形不等式 对了

577
00:34:20,500 --> 00:34:23,120
所以 这就是想要让三角形不等式成立

578
00:34:23,180 --> 00:34:25,070
当然 S到v的最短路径

579
00:34:25,140 --> 00:34:28,190
应该小于等于 也就是不大于

580
00:34:28,230 --> 00:34:29,880
S到u的最短路径

581
00:34:29,950 --> 00:34:34,070
加上u到v的任意路径

582
00:34:34,140 --> 00:34:36,610
这个最短路径不大于右边的

583
00:34:36,640 --> 00:34:41,130
所以 这是一条更广义的三角形不等式

584
00:34:41,200 --> 00:34:44,410
然后我们想...当然它是真的

585
00:34:44,560 --> 00:34:46,540
如果不成立的话 我们就修正它

586
00:34:46,600 --> 00:34:48,610
如果它大于右边 我们令它相等

587
00:34:48,650 --> 00:34:49,740
但不会令它小于右边

588
00:34:49,760 --> 00:34:51,180
因为这不一定成立

589
00:34:51,220 --> 00:34:53,050
但肯定 它应该小于等于右边

590
00:34:53,080 --> 00:34:55,390
这个就是修正三角形不等式

591
00:34:55,430 --> 00:34:58,000
要让这个约束条件变得更可靠

592
00:34:58,070 --> 00:35:01,440
在最优化方法里 这样称为对约束的松弛

593
00:35:01,480 --> 00:35:04,230
好的 我们要对这个三角形不等式进行松弛

594
00:35:04,240 --> 00:35:05,740
一次 一次 又一次

595
00:35:05,810 --> 00:35:08,120
到最后 我们会得出所有的最短路径

596
00:35:08,190 --> 00:35:10,400
这是一个断言 好的 非常简单的算法

597
00:35:10,430 --> 00:35:11,980
我们在图上实测一下

598
00:35:12,010 --> 00:35:14,970
这样能更直白地解释 它为什么有用

599
00:35:15,050 --> 00:35:18,220
剩下的课 就是要证明它是有用的

600
00:35:27,610 --> 00:35:30,320
好的 够地方写了

601
00:35:32,330 --> 00:35:36,240
那么..我还要提到另外一样东西 不好意思

602
00:35:36,280 --> 00:35:39,010
每当我改变d[v]

603
00:35:39,050 --> 00:35:42,650
这是在改变v在优先队列里对应的键值

604
00:35:42,690 --> 00:35:46,360
所以 这条赋值语句也意味着

605
00:35:46,410 --> 00:35:47,870
这写得有点乱

606
00:35:48,040 --> 00:35:51,040
它是一个降低键值的操作

607
00:35:55,710 --> 00:35:58,580
好的 我们上一节课简单讲过

608
00:35:58,650 --> 00:36:00,670
就在讲最小生成树的时候

609
00:36:00,710 --> 00:36:02,140
当时也是要降低键值

610
00:36:02,210 --> 00:36:05,120
重点是要在这个优先队列的松弛操作中

611
00:36:05,150 --> 00:36:07,610
降低某个对应元素的键值

612
00:36:07,650 --> 00:36:11,960
所以如果它变成了最小值 下一个取出的就是它

613
00:36:12,040 --> 00:36:14,270
而且 我们只会降低键值

614
00:36:14,310 --> 00:36:17,390
因为我们总是用大数 来替换小数

615
00:36:17,430 --> 00:36:21,730
那么 稍后分析运行时间时 我们会再讨论它

616
00:36:21,800 --> 00:36:24,220
但这儿又有一些数据结构的问题

617
00:36:24,230 --> 00:36:27,240
我们又在滥用符号了

618
00:36:27,720 --> 00:36:35,640
好的 这里有个带权值的图

619
00:37:04,450 --> 00:37:07,710
好的 这里是我的优先队列

620
00:37:14,220 --> 00:37:16,840
然后 我也把估算距离画出来

621
00:37:16,880 --> 00:37:19,230
好的 我不想作假

622
00:37:20,290 --> 00:37:23,520
那么 我们要在这个图上运行这个算法

623
00:37:23,550 --> 00:37:26,040
s就是A

624
00:37:26,110 --> 00:37:28,910
然后 我想知道A到任意一点的最短距离

625
00:37:28,980 --> 00:37:31,640
好的 你看到 路径是存在的

626
00:37:31,680 --> 00:37:34,060
所以 每个点都应该得到一个有限的值

627
00:37:34,130 --> 00:37:35,530
所有的权值都是非负的

628
00:37:35,590 --> 00:37:37,540
所以 这个算法应该有用

629
00:37:38,460 --> 00:37:40,190
这个算法甚至不要求连通性

630
00:37:40,270 --> 00:37:42,760
但是它要求每个权值都是非负的

631
00:37:43,800 --> 00:37:45,270
那么 我们运行这个算法

632
00:37:45,310 --> 00:37:46,380
在初始化过程中

633
00:37:46,410 --> 00:37:49,530
我们设起点的距离等于0

634
00:37:49,600 --> 00:37:51,530
因为实际上 从A到A只有一条路径

635
00:37:51,600 --> 00:37:54,370
那就是不用走 空路径

636
00:37:54,410 --> 00:37:56,760
所以我要设它的键值为零

637
00:37:56,790 --> 00:37:57,770
然后 对于其他每个顶点

638
00:37:57,840 --> 00:37:59,230
我们都设为正无穷

639
00:37:59,300 --> 00:38:02,610
因为这时 我们不知道怎么到那里

640
00:38:06,880 --> 00:38:10,120
所以 我会设其它的键值全为∞

641
00:38:10,420 --> 00:38:13,490
好的 现在你看到这个算法要做的就是..

642
00:38:13,560 --> 00:38:15,250
从队列中取出最小值

643
00:38:15,320 --> 00:38:17,820
然后 根据已知设定 我们当然会选择s

644
00:38:17,890 --> 00:38:19,520
在例子里就是A

645
00:38:19,570 --> 00:38:20,500
所以 它的权值就等于0

646
00:38:20,530 --> 00:38:23,290
其它的每个点的权值都比它大

647
00:38:23,540 --> 00:38:28,300
好的 我们观察s 或者这里用A表示

648
00:38:28,370 --> 00:38:30,990
我们观察A 我们把A加到集合S中

649
00:38:30,990 --> 00:38:32,760
我用个框框来做标记

650
00:38:32,800 --> 00:38:35,200
它现在从队列中移除了 不会再回去了

651
00:38:35,230 --> 00:38:37,000
因为我们从来不会向队列里加任何东西

652
00:38:37,040 --> 00:38:38,030
它一开始就有所有顶点

653
00:38:38,090 --> 00:38:39,250
我们只会提取最小值和降低键值

654
00:38:39,260 --> 00:38:42,390
但是我们从不插入 所以A不在了

655
00:38:43,530 --> 00:38:45,270
好的 现在我们想要更新

656
00:38:45,340 --> 00:38:47,420
所有其他顶点的键值

657
00:38:47,490 --> 00:38:48,690
那么我只要

658
00:38:48,740 --> 00:38:50,810
观察那些跟A有边连着的点

659
00:38:50,850 --> 00:38:52,470
好的 从A到B有条边

660
00:38:52,540 --> 00:38:54,040
它的权值等于10

661
00:38:54,110 --> 00:38:55,080
然后我就比较

662
00:38:55,140 --> 00:38:58,170
好的 从A到A是一个好选择 因为没有任何花费

663
00:38:58,180 --> 00:39:01,010
然后沿着AB边走  费用为10

664
00:39:01,050 --> 00:39:02,810
好的 看上去还不错

665
00:39:02,880 --> 00:39:06,020
因为它的总权值等于0+10 也就是10

666
00:39:06,090 --> 00:39:08,060
比正无穷要小得多

667
00:39:08,130 --> 00:39:10,590
所以 我要擦掉这个无穷

668
00:39:10,670 --> 00:39:13,740
写上10 在队列里也改掉

669
00:39:13,770 --> 00:39:15,880
这就是降低键值的操作

670
00:39:15,950 --> 00:39:18,920
而现在 我知道A到B之间有一条路径 好

671
00:39:18,990 --> 00:39:21,400
从A到C是另外一条边

672
00:39:21,470 --> 00:39:24,460
0+3小于无穷大

673
00:39:24,470 --> 00:39:30,960
很好 我给C写一个3 C在这里

674
00:39:31,060 --> 00:39:32,930
好的 另外一些顶点我没访问过

675
00:39:33,000 --> 00:39:33,800
我把它们重新写一遍

676
00:39:33,870 --> 00:39:36,050
但在算法里 我们并不用复制它

677
00:39:36,090 --> 00:39:37,450
这些键值已经在那里了

678
00:39:37,530 --> 00:39:39,190
我们只接触到这两个点

679
00:39:40,280 --> 00:39:42,220
好吧 这会有点无聊

680
00:39:42,290 --> 00:39:46,270
现在我们观察我们的队列 然后提取最小值

681
00:39:46,340 --> 00:39:47,680
A已经不在里面了

682
00:39:47,790 --> 00:39:50,590
所以 这里的最小值是3

683
00:39:50,660 --> 00:39:54,400
所以 说明这里的最短路径是：从A到C

684
00:39:54,620 --> 00:39:56,170
这是从A到C的最短路径

685
00:39:56,240 --> 00:39:57,130
没有别的更短的路径了

686
00:39:57,190 --> 00:40:00,690
你们先记一下 我们过会儿再证明它

687
00:40:01,510 --> 00:40:04,660
很好 我们从列表上删除C 它不在了

688
00:40:04,730 --> 00:40:07,360
然后 我们看到所有从C出来的边

689
00:40:07,430 --> 00:40:09,640
这里有一条是到B的

690
00:40:09,710 --> 00:40:12,860
权值为4 4加上3

691
00:40:12,900 --> 00:40:14,780
3是从A到C的最短路径

692
00:40:14,850 --> 00:40:17,020
所以从A到C 从C到B

693
00:40:17,080 --> 00:40:18,250
这些费用为3加4

694
00:40:18,320 --> 00:40:19,890
也就是7 比10要小

695
00:40:19,940 --> 00:40:22,360
所以 我们发现从这条路径到B会更好

696
00:40:22,430 --> 00:40:25,320
它这么走 比它那么走要好

697
00:40:25,800 --> 00:40:29,350
所以 我们给B写上7

698
00:40:30,060 --> 00:40:32,800
这里还有一条从C到D 费用为8的边

699
00:40:32,900 --> 00:40:35,530
3加上8等于11

700
00:40:35,600 --> 00:40:38,450
11小于正无穷 很显然

701
00:40:38,490 --> 00:40:42,260
所以 我们给D一个11 然后我们观察E

702
00:40:42,330 --> 00:40:44,790
我们有3所加2等于5

703
00:40:44,860 --> 00:40:47,150
小于正无穷

704
00:40:47,230 --> 00:40:50,260
所以 E的新键值为5

705
00:40:50,300 --> 00:40:53,190
到现在 所有顶点都有一条有限的路径相连了

706
00:40:53,270 --> 00:40:54,740
但它们可能不是最好的那个

707
00:40:54,840 --> 00:40:56,750
所以 我们继续观察

708
00:40:56,820 --> 00:40:59,420
好的 算法的下一轮里

709
00:40:59,460 --> 00:41:01,550
我们再从这里取出最小值

710
00:41:01,620 --> 00:41:04,760
好的 不是B 我们都已经知道答案是什么了

711
00:41:04,830 --> 00:41:08,420
它是E E的键值最小

712
00:41:08,490 --> 00:41:11,800
现在 我们宣称这是最短路径

713
00:41:11,870 --> 00:41:15,550
我们到达E的方法是 沿着这条路径

714
00:41:15,620 --> 00:41:19,000
A到C C到E 我们称这是最短的

715
00:41:19,040 --> 00:41:20,450
我们说我们搞定E了

716
00:41:20,520 --> 00:41:22,470
但是 我们还要继续更新

717
00:41:22,540 --> 00:41:24,600
哪些是从E点出发的边？

718
00:41:24,630 --> 00:41:25,750
这里只有一条

719
00:41:25,820 --> 00:41:28,680
它的费用是5+9 等于14

720
00:41:28,750 --> 00:41:30,340
比11要大

721
00:41:30,370 --> 00:41:33,010
所以不走这里 这不是我们想要的

722
00:41:33,080 --> 00:41:35,690
之前的路径 它是这么走 费用为11

723
00:41:35,700 --> 00:41:38,200
比我们正在考虑这条的要好

724
00:41:38,270 --> 00:41:39,110
我画出了这整条路径

725
00:41:39,160 --> 00:41:41,860
但这个算法只需要把这两个数加起来

726
00:41:42,260 --> 00:41:46,240
好的 我什么都不用改

727
00:41:47,280 --> 00:41:51,340
剩下7和11  5也就是E被删除了

728
00:41:51,450 --> 00:41:53,360
我们新的键值是7和11

729
00:41:53,430 --> 00:41:56,350
所以 我们取出7

730
00:41:56,890 --> 00:41:59,670
也就是顶点B

731
00:41:59,740 --> 00:42:04,030
我们称现在从A到B的最短路径...

732
00:42:04,100 --> 00:42:05,530
刚好是这一条

733
00:42:05,570 --> 00:42:07,500
这个算法实际上不会告诉你

734
00:42:07,540 --> 00:42:09,150
但我们还是把它画出来吧

735
00:42:09,250 --> 00:42:14,090
这条路径A C B 是候选的最短路径

736
00:42:14,160 --> 00:42:16,100
它事实上就是最短的

737
00:42:16,170 --> 00:42:17,620
现在我们观察这些所有向外连的边

738
00:42:17,690 --> 00:42:21,230
这里有一条边走回C 费用为7加1

739
00:42:21,280 --> 00:42:24,820
等于8 比3要大 好的

740
00:42:24,890 --> 00:42:26,700
我们已经可以说C也搞定了

741
00:42:26,740 --> 00:42:28,850
但是这个算法还是会检查 然后说

742
00:42:28,920 --> 00:42:30,770
哦 没有更好的了

743
00:42:31,390 --> 00:42:33,640
接着我们观察B到D的这条边

744
00:42:33,710 --> 00:42:37,330
费用为7加2 等于9

745
00:42:37,910 --> 00:42:39,080
比11要好

746
00:42:39,150 --> 00:42:41,800
所以 我们其实找到了一条更短的路径

747
00:42:43,970 --> 00:42:47,230
所以 当前D的最短路径的权值是9

748
00:42:47,300 --> 00:42:50,860
因为这条经A C B D的路径

749
00:42:50,930 --> 00:42:54,010
总费用为3+4+2=9

750
00:42:55,080 --> 00:42:57,180
爽啊 现在队列里只剩下一个元素

751
00:42:57,220 --> 00:42:58,570
我们移除它

752
00:42:58,640 --> 00:43:01,670
D 我们观察这些向外的边

753
00:43:01,700 --> 00:43:04,170
这条的费用是9+7

754
00:43:04,220 --> 00:43:06,830
等于16 比5要大

755
00:43:06,900 --> 00:43:09,360
所以 完成了 什么都不用干

756
00:43:09,430 --> 00:43:11,140
这个时候 队列是空的

757
00:43:11,220 --> 00:43:13,430
我们说 所有写在这里的数字

758
00:43:13,500 --> 00:43:17,720
最终的值就是最短路径的权值

759
00:43:18,080 --> 00:43:21,330
它看起来超级像5 其实它是s

760
00:43:21,810 --> 00:43:23,240
它的权值等于0

761
00:43:23,350 --> 00:43:28,200
我这里也画出了所有最短路径

762
00:43:28,300 --> 00:43:31,690
这个不难

763
00:43:31,720 --> 00:43:33,810
关于这个 我们这次课不会讲太多

764
00:43:33,850 --> 00:43:37,960
书上面会讲得更清楚

765
00:43:38,620 --> 00:43:40,870
它叫做最短路径树

766
00:43:40,940 --> 00:43:42,840
当你真的想求出最短路径时

767
00:43:42,920 --> 00:43:45,320
它确实值得你去了解

768
00:43:45,510 --> 00:43:47,460
这节课里面 我们主要关心的是权值

769
00:43:47,530 --> 00:43:49,770
因为它差不多都是一样的问题

770
00:43:50,490 --> 00:43:53,690
最短路径树就是所有最短路径的集合

771
00:43:53,760 --> 00:44:02,300
尤其是 当你观察图中的每个点时

772
00:44:03,230 --> 00:44:08,090
你考虑到所有的点u中

773
00:44:08,090 --> 00:44:15,380
最后一条被松弛的边

774
00:44:16,260 --> 00:44:17,780
看到这条边(u,v)

775
00:44:17,850 --> 00:44:19,040
只要问 这是最后被松弛的边吗？

776
00:44:19,110 --> 00:44:21,270
那么 只需要留意最后一条被松弛的边

777
00:44:21,340 --> 00:44:24,260
把它们放在一起 这就叫做最短路径树

778
00:44:24,340 --> 00:44:27,270
它有一个性质就是从s出发到所有的点

779
00:44:27,310 --> 00:44:29,370
从根到叶的路径是唯一的

780
00:44:29,400 --> 00:44:31,500
而且是最短路径

781
00:44:31,570 --> 00:44:33,560
它就是我们要找的最短路径

782
00:44:34,040 --> 00:44:36,280
实际上 你已经用这算法找到了所有最短路径

783
00:44:36,350 --> 00:44:38,040
尽管它没有显式地说明是哪一条

784
00:44:38,100 --> 00:44:42,470
但我们主要讨论的是最短路径的权

785
00:44:44,600 --> 00:44:46,220
现在这个算法都清楚吗？

786
00:44:46,290 --> 00:44:47,270
都觉得它不水吧？

787
00:44:47,340 --> 00:44:50,840
你可以验证下 所有数字都是最佳的路径

788
00:44:51,590 --> 00:44:53,980
现在我们准备去证明它

789
00:45:11,080 --> 00:45:13,730
它的正确性

790
00:45:23,810 --> 00:45:25,110
那第一件我要证明的事情是

791
00:45:25,170 --> 00:45:27,810
松弛操作是不会出错的

792
00:45:27,880 --> 00:45:30,130
如果它设d[v]为某值

793
00:45:30,200 --> 00:45:34,690
我想证明d[v]总是δ的一个上界

794
00:45:35,470 --> 00:45:39,090
所以 我们有一个不变式

795
00:45:41,110 --> 00:45:50,200
对于所有v d[v]大于等于δ(s,v)

796
00:45:52,770 --> 00:45:58,390
这个不变式总是成立的

797
00:45:58,460 --> 00:46:00,430
在初始化以后

798
00:46:00,500 --> 00:46:01,800
初始化之前 它并不成立

799
00:46:01,870 --> 00:46:04,030
因为那时d还没被定义好

800
00:46:04,500 --> 00:46:07,390
而初始化就是将s设为0

801
00:46:07,460 --> 00:46:09,050
其它的设为正无穷

802
00:46:09,080 --> 00:46:15,050
然后你进行任意一个松弛操作

803
00:46:21,910 --> 00:46:26,710
每一步松弛后 这个不变式都成立

804
00:46:26,780 --> 00:46:28,790
这其实是非常普通的引理

805
00:46:28,860 --> 00:46:30,220
而且很容易证明

806
00:46:30,290 --> 00:46:32,360
不仅仅对Dijkstra算法来说是成立的

807
00:46:32,400 --> 00:46:34,580
对许多别的算法也是成立的

808
00:46:34,690 --> 00:46:37,970
我们将会接触到许多带有松弛操作的算法

809
00:46:38,230 --> 00:46:41,490
而这就是说 无论你做了什么松弛操作

810
00:46:41,530 --> 00:46:44,230
你的估算总是合理的 那是因为

811
00:46:44,270 --> 00:46:48,630
它总会大于或等于最短路径的权重

812
00:46:48,640 --> 00:46:51,410
那么 它应该可以从上往下收敛

813
00:46:53,620 --> 00:46:56,610
我们来证明这个引理

814
00:46:56,930 --> 00:47:00,500
你们有什么好点子来证明这个引理？

815
00:47:03,090 --> 00:47:05,340
可以用到什么技巧？

816
00:47:06,120 --> 00:47:08,570
什么？ 剪贴法？

817
00:47:08,640 --> 00:47:10,650
这个对最优子结构有用

818
00:47:10,950 --> 00:47:14,020
剪贴法 好像跟这儿有点关系

819
00:47:14,090 --> 00:47:17,040
但不确切是

820
00:47:17,350 --> 00:47:19,790
要更加广义一点的东西

821
00:47:20,300 --> 00:47:21,270
这只是测测人品

822
00:47:21,340 --> 00:47:23,050
不一定要给出正确答案

823
00:47:23,120 --> 00:47:26,360
实际上 很多答案都是对的

824
00:47:26,900 --> 00:47:28,740
有各种合理的证明

825
00:47:30,790 --> 00:47:33,390
数学归纳 对了

826
00:47:33,420 --> 00:47:35,540
那么 我不会特地写上数学归纳

827
00:47:35,570 --> 00:47:37,580
但实际上 我们用的是数学归纳

828
00:47:37,620 --> 00:47:39,440
这个是我们一直期待的答案

829
00:47:39,480 --> 00:47:42,780
其实 这就差不多是归纳法了

830
00:47:42,850 --> 00:47:44,960
我们说 在初始化之后 这个应该为真

831
00:47:45,030 --> 00:47:46,240
这是我们的基础命题

832
00:47:46,310 --> 00:47:48,920
接下来 每一次松弛之后 它仍然为真

833
00:47:48,990 --> 00:47:50,170
我们用归纳来假设

834
00:47:50,240 --> 00:47:52,390
前面的松弛都起效了

835
00:47:52,460 --> 00:47:54,080
我们来证明 这个最后的松弛

836
00:47:54,150 --> 00:47:56,080
无论如何都是有效的

837
00:47:56,150 --> 00:47:59,160
我们先看基础命题

838
00:47:59,700 --> 00:48:02,450
这个是初始化之后

839
00:48:02,550 --> 00:48:04,640
一开始...

840
00:48:05,150 --> 00:48:09,310
一开始我们有d[s]等于0

841
00:48:09,410 --> 00:48:16,900
对于其它的顶点v d[v]为正无穷

842
00:48:16,970 --> 00:48:21,180
所有的顶点v 除了s以外

843
00:48:21,270 --> 00:48:24,090
好的 我们得要检查这个不等式是否成立

844
00:48:24,160 --> 00:48:27,450
我们有δ(s,s)

845
00:48:27,520 --> 00:48:29,410
我们已经讨论过这个为0

846
00:48:29,480 --> 00:48:30,950
你没法得到负值

847
00:48:31,020 --> 00:48:33,940
因为这里只有非负权值的边

848
00:48:34,050 --> 00:48:35,230
那么 这样是最好的

849
00:48:35,300 --> 00:48:37,970
0是大于等于0的

850
00:48:38,560 --> 00:48:40,660
然后 我们还有其它全部

851
00:48:40,720 --> 00:48:45,410
我的意思是 δ(s,v)

852
00:48:45,470 --> 00:48:48,200
肯定是小于等于正无穷

853
00:48:48,310 --> 00:48:49,940
这个是成立的

854
00:48:50,020 --> 00:48:52,190
每一个数都是小于等于正无穷的

855
00:48:52,270 --> 00:48:53,760
基础命题就这样

856
00:48:53,830 --> 00:48:56,210
现在我们进行归纳

857
00:48:57,230 --> 00:49:00,920
那么 我准备用反证法来证明它

858
00:49:00,980 --> 00:49:01,970
那么 我们有——

859
00:49:02,040 --> 00:49:06,960
假设这个对某些点来说是不成立的

860
00:49:16,390 --> 00:49:22,750
假设这个不变式在某时候是不成立的

861
00:49:25,980 --> 00:49:30,080
我们要指证这个反例有矛盾

862
00:49:30,690 --> 00:49:32,030
那么 它是不成立的

863
00:49:32,100 --> 00:49:34,060
我们看看第一个出错地方

864
00:49:34,100 --> 00:49:36,450
第一次它出错时

865
00:49:37,160 --> 00:49:40,170
实际上 这又是一个数学归纳法的证明

866
00:49:42,420 --> 00:49:44,600
当第一次违反不变式的时候

867
00:49:44,670 --> 00:49:49,690
d[v]<δ(s,v) 这就糟糕了

868
00:49:49,760 --> 00:49:53,060
如果估算距离比最短路径更小的时候

869
00:49:53,920 --> 00:49:57,520
呃 我在想这是第一次出错

870
00:49:57,590 --> 00:50:03,470
根据归纳假设 之前其它的值都应该是对的

871
00:50:03,530 --> 00:50:06,280
好 d[v]就是第一个我们出错的地方

872
00:50:06,350 --> 00:50:08,600
那么 这个不变式在哪里都是成立的

873
00:50:08,660 --> 00:50:10,430
导致它出错的

874
00:50:10,500 --> 00:50:15,090
使不变式不成立的 是某步松弛操作

875
00:50:16,570 --> 00:50:17,850
好的 对于d[v]

876
00:50:17,920 --> 00:50:19,400
我们有个d[v]的值

877
00:50:19,470 --> 00:50:23,530
然后我们用别的值d[u]

878
00:50:23,600 --> 00:50:28,530
加上(u,v)来代替它

879
00:50:28,600 --> 00:50:32,450
然后这时 这个不成立了

880
00:50:35,050 --> 00:50:39,030
d[v]不知为何 比它要小

881
00:50:39,100 --> 00:50:41,360
我们设d[v]等于这个

882
00:50:41,430 --> 00:50:48,100
那么这个肯定小于δ(s,v)

883
00:50:48,650 --> 00:50:53,720
但这个命题不可能成立

884
00:50:54,310 --> 00:50:56,570
让我来把它改写一下

885
00:50:57,110 --> 00:51:02,170
我们有d[u]加上w(u,v)

886
00:51:03,660 --> 00:51:08,470
我们有归纳假设

887
00:51:08,540 --> 00:51:11,080
在u上是成立的 u和别的一些顶点

888
00:51:11,120 --> 00:51:14,580
我们知道d[u]最小等于δ(s,u)

889
00:51:14,650 --> 00:51:30,500
所以 这个不小于δ(s,u)加上w(u,v)

890
00:51:30,530 --> 00:51:32,460
w(u,v)是多少？

891
00:51:32,540 --> 00:51:35,840
从u到v有一些路径

892
00:51:36,470 --> 00:51:40,690
它大于或等于最短路径的

893
00:51:40,830 --> 00:51:45,590
所以当然它大于等于δ(u,v)

894
00:51:49,050 --> 00:51:51,960
好的 如果这有较小权值的多边路径的话

895
00:51:52,030 --> 00:51:54,940
它还能更大

896
00:51:55,330 --> 00:52:00,620
但是它当然是不会小于δ(u,v)

897
00:52:00,690 --> 00:52:03,480
这个和看起来正合我意

898
00:52:03,550 --> 00:52:11,770
δ(s,u)加上δ(u,v)就是三角形不等式 耶

899
00:52:11,840 --> 00:52:14,090
就是说 它反过来了

900
00:52:14,170 --> 00:52:16,970
三角形不等式 δ(s,u) δ(u,v)

901
00:52:17,040 --> 00:52:21,370
所以这个只能大于δ(s,v)

902
00:52:25,380 --> 00:52:27,180
好的 我们有了这个式子

903
00:52:27,210 --> 00:52:28,940
同一时间 它大于等于

904
00:52:29,010 --> 00:52:30,590
s到v的最短路径的权值

905
00:52:30,660 --> 00:52:34,040
又严格小于s到v的最短路径的权值

906
00:52:34,150 --> 00:52:36,190
那么 这里出现了矛盾

907
00:52:37,240 --> 00:52:39,590
也许反证法不是最直观的方法

908
00:52:39,660 --> 00:52:44,800
这里的直观推断是 当你给出d[v]

909
00:52:44,870 --> 00:52:46,640
你脑海里就有了一条路径

910
00:52:46,680 --> 00:52:49,060
你用归纳方法想 s和u之间有一条路径

911
00:52:49,130 --> 00:52:50,050
然后你加上这条边

912
00:52:50,090 --> 00:52:51,110
而这条路径真实存在

913
00:52:51,150 --> 00:52:54,300
我们知道每条路径的权值

914
00:52:54,310 --> 00:52:56,310
总是大于或等于最短路径

915
00:52:56,370 --> 00:53:00,770
而它应该为真 这就是归纳法的证明

916
00:53:00,930 --> 00:53:04,440
好的 我们继续

917
00:53:04,480 --> 00:53:06,120
这只是简单的热身运动

918
00:53:06,150 --> 00:53:07,480
我们有大于等于

919
00:53:07,550 --> 00:53:09,280
现在我们要证明在算法最后

920
00:53:09,320 --> 00:53:11,090
它是小于等于的

921
00:53:11,160 --> 00:53:12,420
这个总是成立的

922
00:53:12,490 --> 00:53:15,440
小于等于只会在最后才会成立

923
00:53:33,250 --> 00:53:36,630
那么 我们现在不准备证明小于等于是对的

924
00:53:37,300 --> 00:53:41,210
我们接下来证明另一个引理 再有

925
00:53:41,280 --> 00:53:44,210
这些引理对其它的算法也是有用的

926
00:53:44,210 --> 00:53:48,410
那么 我们建立起最短路径的理论

927
00:53:48,450 --> 00:53:50,390
我们以后会用到的

928
00:53:50,920 --> 00:53:53,860
而这个则会让你直观地理解为什么要松弛

929
00:53:53,940 --> 00:53:58,360
不仅是它并不水 而是相当虎

930
00:53:58,440 --> 00:54:00,060
它不仅没有拖后腿

931
00:54:00,130 --> 00:54:04,180
而且还能造福社会

932
00:54:04,680 --> 00:54:11,760
所以 假设你知道s到某个顶点的最短路径

933
00:54:12,840 --> 00:54:14,790
那好 那你从s到其它某个顶点

934
00:54:14,860 --> 00:54:16,040
然后你走到u 走到v

935
00:54:16,110 --> 00:54:24,610
假设s到v有一条最短路径

936
00:54:26,860 --> 00:54:30,900
好的 再假设我们已知

937
00:54:30,940 --> 00:54:35,390
d[u]是从s到u最短路径的权值

938
00:54:35,420 --> 00:54:37,700
那么 假设我们有这么一个等式

939
00:54:37,730 --> 00:54:39,710
虽然它应该总是大于等于的

940
00:54:39,740 --> 00:54:42,760
但假设对u是相等的 好吧

941
00:54:42,830 --> 00:54:47,240
在v的前一个点时 它是最短路径

942
00:54:47,590 --> 00:54:52,600
好的 假设我们松弛了这条边(u,v)

943
00:54:57,890 --> 00:55:01,030
好的 刚好是这一步

944
00:55:01,100 --> 00:55:02,920
松弛了这条边(u,v)

945
00:55:02,980 --> 00:55:05,330
但我们叫它为松了个弛

946
00:55:09,380 --> 00:55:15,410
在松了个弛后 d[v]等于δ(s,v)

947
00:55:15,460 --> 00:55:18,340
那么 如果我们u是正确答案 我们松弛(u,v)

948
00:55:18,410 --> 00:55:20,920
那么我们也会得到v的正确答案

949
00:55:27,660 --> 00:55:29,150
好的 这是个好消息

950
00:55:29,180 --> 00:55:32,720
这说明 归纳地看 如果能给u找到正确答案

951
00:55:32,790 --> 00:55:35,380
那么 我们就知道怎么得到v的正确答案

952
00:55:35,500 --> 00:55:37,290
在这个算法里 我们实际上不知道

953
00:55:37,360 --> 00:55:40,970
v在最短路径上的前一个点是什么

954
00:55:41,040 --> 00:55:44,960
但是在分析过程中我们很清楚

955
00:55:45,940 --> 00:55:47,960
所以 我们需要证明这个引理

956
00:55:48,000 --> 00:55:51,790
这个实际上比上一个证明要简单

957
00:55:51,830 --> 00:55:53,780
甚至还用不着数学归纳法

958
00:55:53,830 --> 00:55:56,650
因为你只是研究松弛的过程

959
00:55:56,720 --> 00:55:57,650
而且它是成立的

960
00:55:57,830 --> 00:56:00,160
那么 我们继续

961
00:56:00,560 --> 00:56:06,040
我们注意这个数 δ(s,v)

962
00:56:07,120 --> 00:56:08,580
我们知道最短路径是什么

963
00:56:08,630 --> 00:56:12,700
那么最短路径的权值 就是这条路径的权值

964
00:56:12,740 --> 00:56:14,600
好的 我们这里可以写下这个等式

965
00:56:14,670 --> 00:56:16,770
我打算把这条路径的第一部分截出来

966
00:56:16,840 --> 00:56:18,440
还有路径的最后一部分

967
00:56:18,510 --> 00:56:22,990
那么 我们有 权值从s到...

968
00:56:23,020 --> 00:56:25,570
这部分就等于s到u的值

969
00:56:26,020 --> 00:56:29,520
加上w(u,v)

970
00:56:29,990 --> 00:56:31,710
记住 我们记路径的w

971
00:56:31,780 --> 00:56:33,790
它等于所有这些边的权值的总和

972
00:56:33,860 --> 00:56:41,310
所以 这个是多少 从s到u的权值？

973
00:56:48,160 --> 00:56:52,430
或者说 这个值能用什么性质算出来？

974
00:56:55,970 --> 00:56:56,830
什么？

975
00:56:56,900 --> 00:57:00,190
[学生]:...

976
00:57:00,220 --> 00:57:01,870
[教授]:s到v是最短路径吧？

977
00:57:01,940 --> 00:57:03,670
根据最优子结构

978
00:57:03,710 --> 00:57:05,500
s到u也是一个最短路径

979
00:57:05,580 --> 00:57:09,260
所以 这个是δ(s,v)

980
00:57:12,520 --> 00:57:14,460
漂亮！

981
00:57:18,050 --> 00:57:21,360
我们先这么认为 这就是我们要说的

982
00:57:21,370 --> 00:57:23,040
另一方面 我们知道

983
00:57:23,080 --> 00:57:25,890
由引理可知无论我们在做什么

984
00:57:25,960 --> 00:57:29,340
d[v]总是大于等于δ(s,v)

985
00:57:29,410 --> 00:57:30,900
那么 我们记下这点

986
00:57:32,610 --> 00:57:34,170
这里有几种情况

987
00:57:34,210 --> 00:57:36,780
而且其中一些情况要除去

988
00:57:36,850 --> 00:57:39,140
根据那个证明了的引理

989
00:57:39,170 --> 00:57:44,430
我们知道d[v]大于等于δ(s,v)

990
00:57:44,470 --> 00:57:47,440
所以 它总是大于等于的

991
00:57:47,500 --> 00:57:51,560
我想到在我们做松弛之前的那一次

992
00:57:51,560 --> 00:57:54,650
这个(u,v)

993
00:57:54,690 --> 00:57:57,260
在这个点上 这个肯定是对的

994
00:57:57,330 --> 00:58:04,880
不管它在松弛之前是大于还是等于

995
00:58:14,890 --> 00:58:17,980
好的 如果它们是等于的话 我们就爽了

996
00:58:18,020 --> 00:58:20,580
因为松弛每次都只会减少之前确定的值

997
00:58:20,650 --> 00:58:22,120
它没法比它还小

998
00:58:22,160 --> 00:58:25,110
所以松弛之后它会是相等的

999
00:58:25,260 --> 00:58:27,120
好的 我们证明完这种情况

1000
00:58:27,200 --> 00:58:30,010
这种情况意义不大

1001
00:58:30,180 --> 00:58:31,230
现在我们假设

1002
00:58:31,270 --> 00:58:38,680
d[v]在松弛前是大于δ(s,v)

1003
00:58:38,750 --> 00:58:40,550
这个肯定可以有

1004
00:58:40,590 --> 00:58:42,990
我们现在想要证明它

1005
00:58:45,430 --> 00:58:48,210
好的 有一点就是 我们知道δ(s,v)

1006
00:58:48,280 --> 00:58:54,930
它就是这个和 好的 我们知道这点

1007
00:58:56,320 --> 00:58:59,940
那么 我们把它代入 我们知道δ(s,u)就等于d[u]

1008
00:59:00,010 --> 00:59:01,780
然后 我们有这个w(u,v)

1009
00:59:01,860 --> 00:59:08,940
所以 δ(s,v)等于d[u]加上w(u,v)

1010
00:59:09,010 --> 00:59:10,700
因为我们假设我们有这个最短路径结构

1011
00:59:10,770 --> 00:59:11,970
就是你先从s走到u

1012
00:59:12,050 --> 00:59:13,670
然后再走(u,v)这条边

1013
00:59:13,740 --> 00:59:15,180
我们知道这个

1014
00:59:15,240 --> 00:59:18,480
我们知道d[v]大于d[u]加上w(u,v)的和

1015
00:59:18,550 --> 00:59:22,270
哎哟喂 这就是松弛的条件来的

1016
00:59:22,340 --> 00:59:25,470
好好回想下吧 松弛在这儿做了些什么

1017
00:59:25,540 --> 00:59:27,730
好的 如果你估算了一个错误距离

1018
00:59:27,800 --> 00:59:29,340
如果满足了这个条件

1019
00:59:29,410 --> 00:59:30,710
那么 我们会这么做

1020
00:59:30,780 --> 00:59:35,680
在这种情况下 我们使用松弛

1021
00:59:37,550 --> 00:59:39,550
我只要松弛一下

1022
00:59:39,660 --> 00:59:43,270
那么 我们就令d[v]等于d[u]加上w(u,v)

1023
00:59:43,330 --> 00:59:45,490
也就是我们想要的

1024
00:59:45,560 --> 00:59:55,290
好的 我们令d[v]等于d[u]加上w(u,v)

1025
00:59:55,360 --> 01:00:00,680
而它就等于 我们这里说的δ(s,v)

1026
01:00:00,750 --> 01:00:02,490
这正是我们想证明的

1027
01:00:05,950 --> 01:00:07,420
搞定

1028
01:00:07,490 --> 01:00:09,920
好的 我现在越来越兴奋了

1029
01:00:09,960 --> 01:00:12,320
因为我们已经看到证明的主线了

1030
01:00:12,360 --> 01:00:14,310
有什么问题吗？

1031
01:00:16,340 --> 01:00:19,420
好 接下来讲最难的那部分

1032
01:00:19,530 --> 01:00:22,300
这两个都是非常简单的引理 对吧？

1033
01:00:30,470 --> 01:00:33,550
我待会儿要用到这两面黑板

1034
01:00:35,100 --> 01:00:37,840
我们现在不需要这些证明了

1035
01:00:39,250 --> 01:00:40,220
我们只留下这些命题

1036
01:00:40,260 --> 01:00:43,480
第一个正确性和正确性引理

1037
01:00:44,290 --> 01:00:46,370
好名字

1038
01:00:51,610 --> 01:00:56,860
现在 终于轮到第二个正确性

1039
01:00:58,660 --> 01:01:02,010
我们这儿有一个和一个半

1040
01:01:02,800 --> 01:01:04,750
我觉得正确性 它本身

1041
01:01:04,820 --> 01:01:08,330
就是个迷你三部曲 是一个迷你系列

1042
01:01:09,150 --> 01:01:14,360
第二个正确性讲的就是 当这个算法结束时

1043
01:01:14,360 --> 01:01:16,090
我们就得出正确答案

1044
01:01:16,370 --> 01:01:17,590
这就是真正的正确性

1045
01:01:17,660 --> 01:01:22,550
但是 它还要基于第一个正确性和正确性引理

1046
01:01:30,160 --> 01:01:36,020
在算法结束时 我们要有对于所有v

1047
01:01:36,110 --> 01:01:37,730
d[v]等于δ(s,v)

1048
01:01:37,830 --> 01:01:39,680
很明显 这就是我们的目标

1049
01:01:39,750 --> 01:01:41,820
这个定理先假设了...

1050
01:01:41,860 --> 01:01:44,270
所有的边的权值都是非负的

1051
01:01:44,350 --> 01:01:45,150
除此之外没有别的条件

1052
01:01:45,190 --> 01:01:46,740
所以 出现正无穷是合理的

1053
01:01:46,810 --> 01:01:49,750
但是如果出现负无穷 那一切都是无用功了

1054
01:01:49,860 --> 01:01:52,600
如果有负权值 即便是哪里都好

1055
01:01:52,670 --> 01:01:56,180
它都一定不会有好事

1056
01:01:57,680 --> 01:01:59,550
但是 假设所有的边都是非负的

1057
01:01:59,620 --> 01:02:03,350
用它们来表示时间代价就很合理了

1058
01:02:03,420 --> 01:02:07,740
通常要这些边走是要花费金钱的

1059
01:02:07,850 --> 01:02:10,890
没人会给你过路费 但还说不定

1060
01:02:15,360 --> 01:02:18,880
我现在需要讲一点东西

1061
01:02:21,810 --> 01:02:24,230
其中一个 我们一路过来都有提及的

1062
01:02:24,300 --> 01:02:28,110
当你把一个顶点加到S中时 你不用改变它的权值

1063
01:02:28,380 --> 01:02:29,570
好的 这其实是要证明的

1064
01:02:29,610 --> 01:02:31,300
我只是想在这里说明一下

1065
01:02:31,370 --> 01:02:38,580
其实不难发现 d[v]不会改变

1066
01:02:38,590 --> 01:02:46,110
当v被加进S里时 这其实也是归纳结果

1067
01:02:50,590 --> 01:02:54,980
好的 这个跟待会儿要讲的东西有关

1068
01:02:55,800 --> 01:02:59,890
我所关心的是 当一个点被加入到S中时

1069
01:02:59,960 --> 01:03:02,200
我们最好有一个正确的估算 因为之后

1070
01:03:02,270 --> 01:03:04,760
我们不会改变它了

1071
01:03:04,870 --> 01:03:06,760
好的 我们可以这样了定义算法

1072
01:03:06,830 --> 01:03:10,070
虽然可以 但我们不这么做

1073
01:03:11,250 --> 01:03:13,910
这个等下会再详细讲

1074
01:03:14,720 --> 01:03:22,320
所以 我们所关心的是d[v]等于δ(s,v)

1075
01:03:22,390 --> 01:03:23,350
这就是我们想证明的

1076
01:03:23,450 --> 01:03:26,170
很明显 它在最后应该是真的

1077
01:03:26,240 --> 01:03:28,690
但是 我们足以证明

1078
01:03:28,760 --> 01:03:36,270
当v被加入大写S里的时候它是成立的

1079
01:03:36,680 --> 01:03:39,570
好的 这暗示了第一个命题

1080
01:03:39,640 --> 01:03:41,010
它其实暗示了一些东西

1081
01:03:41,080 --> 01:03:43,950
但是 如果我们能证明d[v]等于δ(s,v)

1082
01:03:44,030 --> 01:03:48,000
当你(把v)加到S时 我们知道松弛只会把权值降低

1083
01:03:48,070 --> 01:03:49,790
那么它没法变得更小

1084
01:03:49,860 --> 01:03:50,770
这点从第一个正确性得出的

1085
01:03:50,840 --> 01:03:53,560
第一个正确性表明 我们没有比δ(s,v)更小的了

1086
01:03:53,630 --> 01:03:55,400
所以 如果我们在那个点上得出了等式

1087
01:03:55,440 --> 01:03:56,840
那之后 我们还是有这个等式的

1088
01:03:56,910 --> 01:04:00,970
所以 这说明那点松弛过后 d[v]不会再改变了

1089
01:04:01,230 --> 01:04:03,900
好的 我们准备证明这个

1090
01:04:04,890 --> 01:04:08,990
好的 假设它不成立

1091
01:04:09,060 --> 01:04:12,140
这又是一个反证法

1092
01:04:12,330 --> 01:04:23,880
假设出现了矛盾 使命题不成立

1093
01:04:23,950 --> 01:04:26,370
然后 我们看到第一个出错点

1094
01:04:26,520 --> 01:04:35,460
假设u是第一个点

1095
01:04:39,200 --> 01:04:43,100
正准备要加到S里去的

1096
01:04:43,810 --> 01:04:47,230
我想研究 它还没被加入到S前的那一刻

1097
01:04:52,550 --> 01:04:56,380
那时 我们没有想要的结果

1098
01:04:56,440 --> 01:04:58,680
这些是不相等的

1099
01:04:58,820 --> 01:05:06,100
d[u]不等于δ(s,u)

1100
01:05:06,280 --> 01:05:08,520
好的 如果它们不相等

1101
01:05:08,670 --> 01:05:11,760
我们从第一个正确性得知

1102
01:05:11,790 --> 01:05:15,080
d[v]是严格大于δ(s,u)

1103
01:05:15,100 --> 01:05:17,440
说错了 是d[u]

1104
01:05:18,360 --> 01:05:27,620
我们有d[u]是严格大于δ(s,u)

1105
01:05:29,020 --> 01:05:32,230
这就是证明的开始部分

1106
01:05:32,300 --> 01:05:36,060
没有什么特别 只算是准备工夫

1107
01:05:36,500 --> 01:05:39,620
好的 这已经用到了第一个正确性

1108
01:05:39,770 --> 01:05:44,020
我想在这个证明中 只会用到它一次

1109
01:05:50,220 --> 01:05:52,810
我想用画图来解释这个过程

1110
01:05:52,910 --> 01:05:56,130
但我还得加上一点描述

1111
01:05:56,200 --> 01:05:59,070
我们看到这条最短路径

1112
01:05:59,140 --> 01:06:01,330
因为某种原因 d[u]大于最短路径

1113
01:06:01,400 --> 01:06:04,060
所以 考虑到某条 或某一条最短路径

1114
01:06:04,100 --> 01:06:10,770
设p为其中一条最短路径 而不是任意一条

1115
01:06:10,840 --> 01:06:15,500
它是从s到u的最短路径

1116
01:06:18,550 --> 01:06:20,150
好的 这说明

1117
01:06:20,180 --> 01:06:23,150
这条路径的权值等于最短路径的权值

1118
01:06:23,220 --> 01:06:26,570
所以 我们可以写下一些方程

1119
01:06:26,640 --> 01:06:28,600
那么 我们关心的是δ(s,u)

1120
01:06:28,630 --> 01:06:30,070
这条路径的权值是这个数

1121
01:06:30,110 --> 01:06:34,510
它肯定会有 因为最短路径存在

1122
01:06:34,580 --> 01:06:36,860
有个例外就是当它为正无穷时

1123
01:06:36,940 --> 01:06:39,930
但是我们不用担心这个

1124
01:06:41,700 --> 01:06:47,340
所以 让我们把图画出来

1125
01:07:02,180 --> 01:07:06,090
我们有s跟u

1126
01:07:07,280 --> 01:07:13,420
这是从s到u的的最短路径 这就是p

1127
01:07:13,530 --> 01:07:15,790
现在 还不知道它长什么样的

1128
01:07:15,940 --> 01:07:20,230
好的 我们还有一个大写S符号

1129
01:07:20,700 --> 01:07:23,860
我把大写S画出来

1130
01:07:27,810 --> 01:07:29,990
那么 这个是大写S

1131
01:07:30,100 --> 01:07:32,670
我们知道小写s是在大写S集合里的

1132
01:07:32,920 --> 01:07:35,220
u暂时还不在大写S里

1133
01:07:35,300 --> 01:07:38,080
目前 我还没做错事吧？

1134
01:07:38,120 --> 01:07:42,000
这条路径从S里面开始 到某个点时会离开S

1135
01:07:42,080 --> 01:07:44,410
因为最后 我们要将u加入S中之前

1136
01:07:44,440 --> 01:07:47,600
但现在还没 暂时u还没在S中

1137
01:07:48,160 --> 01:07:52,450
好的 我想观察的第一个地方是这里

1138
01:07:52,520 --> 01:07:57,060
路径p离开S的地方

1139
01:07:57,390 --> 01:08:00,390
那么 这里有一个顶点 我设它为x

1140
01:08:00,500 --> 01:08:03,160
这里又有一个点 我设它为y

1141
01:08:03,490 --> 01:08:05,450
好的 x可能等于s

1142
01:08:05,530 --> 01:08:06,780
y可能等于u

1143
01:08:06,840 --> 01:08:08,130
但可以肯定 路径p是在某处离开S的

1144
01:08:08,190 --> 01:08:10,120
因为它是从里面开始 在外面结束的

1145
01:08:10,190 --> 01:08:11,650
而且这是一个有限的图

1146
01:08:12,000 --> 01:08:14,660
那考虑第一次离开的时候

1147
01:08:14,690 --> 01:08:17,510
而不是第二次 是第一次

1148
01:08:18,130 --> 01:08:32,390
好的 考虑p第一次离开S时 是通过边(x,y)

1149
01:08:32,460 --> 01:08:39,250
这是从s到u的最短路径 它离开了大写S

1150
01:08:39,570 --> 01:08:41,150
它肯定会离开的

1151
01:08:43,400 --> 01:08:50,840
好的 现在我们知道什么？x是在S里面

1152
01:08:50,950 --> 01:08:53,590
所以它是正确的  因为u...

1153
01:08:53,630 --> 01:08:55,000
我们准备将u加到S中

1154
01:08:55,040 --> 01:08:57,470
而那是第一个出错的地方

1155
01:08:57,540 --> 01:09:02,100
它的估算距离是错误的

1156
01:09:02,170 --> 01:09:06,170
所以d[x]等于δ(s,x)

1157
01:09:06,840 --> 01:09:08,560
因为我们考虑的是第一个出错的地方

1158
01:09:08,630 --> 01:09:11,050
x是之前就加进S里的

1159
01:09:12,190 --> 01:09:14,390
所以 根据归纳法上的时间

1160
01:09:14,390 --> 01:09:17,850
或者说 因为这是第一个出错点

1161
01:09:17,930 --> 01:09:23,460
d[x]依然是s到x的最短路径的权值

1162
01:09:23,570 --> 01:09:25,270
这是个好消息

1163
01:09:25,340 --> 01:09:26,730
现在我们想要运用这个引理

1164
01:09:26,800 --> 01:09:28,260
这个是剩下唯一要做的事情

1165
01:09:28,330 --> 01:09:29,910
我们到目前还没用过这个引理

1166
01:09:29,970 --> 01:09:31,210
我们有了这个引理

1167
01:09:31,280 --> 01:09:35,570
如果已经知道某个d值是正确的

1168
01:09:35,650 --> 01:09:37,800
我们松弛那条边 然后往下走

1169
01:09:37,900 --> 01:09:39,430
就会得到另外一个正确答案

1170
01:09:39,500 --> 01:09:41,650
这里是我想讨论的地方

1171
01:09:41,950 --> 01:09:44,600
我们知道d[x]等于这个权值因为

1172
01:09:44,670 --> 01:09:47,890
再一次 最短路径的子路径也是最短路径

1173
01:09:47,920 --> 01:09:49,040
我们有最优子结构

1174
01:09:49,080 --> 01:09:51,590
所以这个是从s到x的最短路径

1175
01:09:51,660 --> 01:09:53,870
它可能不止一个 但它是其中一个

1176
01:09:54,360 --> 01:09:56,160
那么 我们知道它没错了

1177
01:09:56,230 --> 01:10:01,650
现在我想松弛这条边(x,y)

1178
01:10:02,860 --> 01:10:06,970
呃 x在大写S里

1179
01:10:07,270 --> 01:10:08,740
然后 这个算法说

1180
01:10:08,810 --> 01:10:13,690
当你把顶点u加入到集合S中时

1181
01:10:13,760 --> 01:10:16,670
你都要把它所有外连的边松弛一遍

1182
01:10:17,580 --> 01:10:20,030
好的 但我们把x加入S中时

1183
01:10:20,140 --> 01:10:21,260
我们看看之后会如何

1184
01:10:21,330 --> 01:10:22,920
我们准备加入别的一些的顶点

1185
01:10:22,990 --> 01:10:26,800
就在我们把x加入S以后 我们松弛这条边(x,y)

1186
01:10:26,870 --> 01:10:30,340
因为我们要松弛每一条从x出来的边

1187
01:10:30,490 --> 01:10:32,180
无论是哪一条 它们有一些是在S里面的

1188
01:10:32,250 --> 01:10:35,350
有一些跑到外面去 这就是其中一条

1189
01:10:35,420 --> 01:10:44,980
但我们往S里加入x时 我们有x在S里

1190
01:10:46,170 --> 01:10:53,170
当我们往S里加入x后 我们松弛这条边(x,y)

1191
01:10:54,780 --> 01:10:57,580
好的 现在我们要用到这个引理

1192
01:10:58,610 --> 01:11:08,580
于是 根据正确性引理

1193
01:11:14,190 --> 01:11:15,700
可以得出什么？

1194
01:11:15,810 --> 01:11:18,720
我们将这个正确的最短路径的权值 赋给x

1195
01:11:18,790 --> 01:11:20,370
然后 将(x,y)松弛

1196
01:11:20,440 --> 01:11:23,910
现在我们应该得到了 y的正确的最短路径权值

1197
01:11:24,090 --> 01:11:31,450
d[y]等于δ(s,y)

1198
01:11:31,750 --> 01:11:33,440
好的 它在某个时候点是成立的

1199
01:11:33,510 --> 01:11:35,550
而现在它仍为真

1200
01:11:35,620 --> 01:11:38,470
因为一旦你得到了正确答案 你就不能改变它了

1201
01:11:41,190 --> 01:11:45,100
好的 我们已经证明完了 为什么就完了？

1202
01:11:46,630 --> 01:11:50,710
我们还知道什么东西？

1203
01:11:50,820 --> 01:11:52,850
我们假设某些东西要矛盾

1204
01:11:52,890 --> 01:11:54,990
所以 我们要反驳这点

1205
01:11:55,070 --> 01:11:59,760
我们假设因为某种原因 d[u]严格大于δ(s,u)

1206
01:11:59,830 --> 01:12:00,770
所以这里的d[u]

1207
01:12:00,810 --> 01:12:03,440
是严格大于这条（最短）路径的权值的

1208
01:12:04,110 --> 01:12:07,260
我们实际上不知道u是否就是y

1209
01:12:07,330 --> 01:12:08,980
可能是 可能不是

1210
01:12:10,370 --> 01:12:15,760
但是我们关心的是S到y的最短路径是什么？

1211
01:12:17,950 --> 01:12:20,500
它只可能比S到u要短

1212
01:12:20,720 --> 01:12:21,880
因为它是一条子路径

1213
01:12:21,950 --> 01:12:22,800
而且它是一条最短路径

1214
01:12:22,870 --> 01:12:24,580
因为它就是最短路径的子路径

1215
01:12:24,650 --> 01:12:27,820
从S到y的最短路径

1216
01:12:27,890 --> 01:12:31,800
必须小于或等于S到u的最短路径

1217
01:12:34,080 --> 01:12:40,290
好的 S到y 小于或者等于s到u

1218
01:12:40,960 --> 01:12:42,700
好的 因为它是子路径

1219
01:12:43,620 --> 01:12:48,610
越来越接近了 我有一个δ(s,u)

1220
01:12:48,720 --> 01:12:51,740
但我想跟d[u]扯上关系

1221
01:12:52,440 --> 01:12:55,300
而我想将d[y]和d[u]联系起来

1222
01:12:55,440 --> 01:12:57,460
关于d[u]我知道什么？

1223
01:13:04,510 --> 01:13:06,040
什么？

1224
01:13:06,110 --> 01:13:08,760
[学生]:...

1225
01:13:08,800 --> 01:13:12,580
d[u]会更小 因为我们用的是最小堆

1226
01:13:12,650 --> 01:13:17,220
我们选择的是u 好像擦掉了 噢 它在这儿

1227
01:13:17,280 --> 01:13:19,550
我们选择的是u 这是算法的中间部分

1228
01:13:19,620 --> 01:13:22,810
这就是为什么我保留的是最小的键值

1229
01:13:22,880 --> 01:13:26,340
键值对应的是d值 在这个时候

1230
01:13:26,410 --> 01:13:28,580
当我们是要将u加到S 好的

1231
01:13:28,690 --> 01:13:31,760
y不再S里 u也不在S里

1232
01:13:31,830 --> 01:13:33,120
实际上 它们可能是同一个顶点

1233
01:13:33,190 --> 01:13:36,870
但这俩点 相同或不相同 都在S外面

1234
01:13:36,940 --> 01:13:44,440
我们选择u因为d[u]的估算值最小

1235
01:13:44,510 --> 01:13:47,910
所以d[y]必须大于等于d[u]

1236
01:13:47,950 --> 01:13:49,870
如果它们是同一点的话它们相等

1237
01:13:49,900 --> 01:13:52,050
但是它是大于或等于

1238
01:13:52,110 --> 01:13:57,890
所以 d[y]是大于或等于d[u]

1239
01:13:59,900 --> 01:14:02,600
事实上 我们这里采取了贪心策略

1240
01:14:02,640 --> 01:14:05,380
它是我们使用贪心策略的地方

1241
01:14:05,450 --> 01:14:07,170
这么用的好处是

1242
01:14:07,240 --> 01:14:10,690
你不能随便选一个点 然后说这个点已经搞定了

1243
01:14:10,790 --> 01:14:12,480
你必须要贪心地选择最好的

1244
01:14:12,590 --> 01:14:16,490
因为我们已经有d[u]小于等于δ(s,u)了

1245
01:14:16,560 --> 01:14:18,600
所以跟它矛盾了

1246
01:14:19,480 --> 01:14:22,040
好的 这样就全部完成了 果然有点科幻

1247
01:14:22,110 --> 01:14:23,550
但就像前面的证明

1248
01:14:23,620 --> 01:14:27,680
你只需看它到底发生了什么

1249
01:14:28,270 --> 01:14:30,040
好的 这就是估算过程

1250
01:14:30,110 --> 01:14:34,100
重要的思想是观察这条边

1251
01:14:34,220 --> 01:14:39,300
实际上 你也可以观察这条边

1252
01:14:39,340 --> 01:14:44,410
但是我们观察的是从S里出来又走出S的边

1253
01:14:44,480 --> 01:14:46,800
并讨论 当x是正确时

1254
01:14:46,870 --> 01:14:49,050
我们令x正确的话 y也是正确的

1255
01:14:49,120 --> 01:14:51,720
那我们还追着u不放干什么？

1256
01:14:51,760 --> 01:14:53,460
y才是你们需要注意的地方

1257
01:14:53,530 --> 01:14:55,500
这样 你就发现了矛盾

1258
01:14:55,570 --> 01:14:57,380
因为y有了正确答案

1259
01:14:57,450 --> 01:14:59,160
如果u等于y 那很好

1260
01:14:59,230 --> 01:15:01,210
或如果u和y都差不多好

1261
01:15:01,250 --> 01:15:03,030
这样也不错 如果权值都为0的话

1262
01:15:03,070 --> 01:15:05,740
那么 这幅图可能真的会是这样子

1263
01:15:05,790 --> 01:15:10,580
但是 这种情况下 d[u]就是正确答案

1264
01:15:10,650 --> 01:15:13,580
它等于δ(s,u) 而我们假设它不是

1265
01:15:13,650 --> 01:15:16,080
这就是我们找到的矛盾的地方

1266
01:15:17,140 --> 01:15:19,770
清楚了没？重温一下这个证明

1267
01:15:19,840 --> 01:15:25,250
有点复杂也理所当然

1268
01:15:25,880 --> 01:15:29,980
好的 我们还要讲一点简单的东西

1269
01:15:30,650 --> 01:15:34,180
第一个是 这个算法的运行时间是多少？

1270
01:15:34,250 --> 01:15:36,000
我要快速解决

1271
01:15:36,040 --> 01:15:39,840
因为实际上 我们已经在上次课之前见过很多遍了

1272
01:15:39,910 --> 01:15:41,070
它有个初始化

1273
01:15:41,130 --> 01:15:44,260
初始化 但现在擦掉了 它是线性时间的

1274
01:15:44,310 --> 01:15:45,680
不是大问题

1275
01:15:45,940 --> 01:15:47,230
好的 选取最小值

1276
01:15:47,300 --> 01:15:49,490
好 这里有个数据结构

1277
01:15:49,840 --> 01:15:52,880
我们有个大小为V的东西

1278
01:15:52,920 --> 01:15:55,590
对每个顶点我们取出最小值 这里就是

1279
01:15:55,660 --> 01:15:58,680
V大小的东西 选最小值

1280
01:16:01,980 --> 01:16:03,840
好的 这个相当简单

1281
01:16:11,570 --> 01:16:13,760
好的 这个是主循环

1282
01:16:13,820 --> 01:16:16,650
这完全是概念上的操作

1283
01:16:16,720 --> 01:16:18,200
这个算法实际上没用到S

1284
01:16:18,270 --> 01:16:20,130
只是作为一个思路

1285
01:16:20,240 --> 01:16:22,020
好的 那么这里耗时为0

1286
01:16:22,640 --> 01:16:24,190
免费什么的最喜欢了

1287
01:16:24,200 --> 01:16:26,660
好的 核心部分是这里

1288
01:16:26,730 --> 01:16:29,540
这个循环需要迭代多少次？

1289
01:16:29,840 --> 01:16:32,510
它等于u的度数

1290
01:16:34,030 --> 01:16:36,590
所以 我们花在松弛操作上的

1291
01:16:36,630 --> 01:16:38,590
总时间是多少？

1292
01:16:38,650 --> 01:16:39,970
它并不是代表我们真的做了这一步

1293
01:16:40,040 --> 01:16:42,850
但我们至少执行了这部分

1294
01:16:50,220 --> 01:16:54,140
整个算法里 我们一共做了这步多少次？

1295
01:16:54,220 --> 01:16:58,660
对每个顶点 我们都观察它连出来的边

1296
01:16:58,900 --> 01:17:01,150
那么总数会是多少？

1297
01:17:09,020 --> 01:17:11,060
等于边的数目 好

1298
01:17:14,460 --> 01:17:17,640
总共有边数次的迭代

1299
01:17:19,180 --> 01:17:21,840
好的 这实际上是我们上次学到的握手引理

1300
01:17:21,950 --> 01:17:23,280
但这是在有向图上

1301
01:17:23,350 --> 01:17:25,190
而且我们只是观察外连的边

1302
01:17:25,260 --> 01:17:26,950
所以它这里不是系数2

1303
01:17:27,500 --> 01:17:29,500
因为你只从一个方向出来

1304
01:17:30,520 --> 01:17:33,150
我们有这么多次的迭代

1305
01:17:33,220 --> 01:17:35,980
在最坏情况下 我们要减小每一个键值

1306
01:17:36,450 --> 01:17:41,520
所以最多会有E次减小键值的操作

1307
01:17:46,940 --> 01:17:55,430
好的 所以运行时间是 我们还有v次取最小值

1308
01:17:55,500 --> 01:18:00,400
取出最小值耗费的时间 不管多少

1309
01:18:00,940 --> 01:18:10,170
减小键值耗费的时间 也不管多少

1310
01:18:10,610 --> 01:18:13,620
这个就刚好是我们上次

1311
01:18:13,740 --> 01:18:18,150
讲的Prim最小生成树算法的运行时间

1312
01:18:18,190 --> 01:18:20,100
然后 根据你用的数据结构

1313
01:18:20,170 --> 01:18:22,240
运行时间也有所变化

1314
01:18:29,680 --> 01:18:33,760
那么 我准备要跳过这整个表

1315
01:18:33,870 --> 01:18:39,650
但是 如果你用一个数组 最后的运行时间等于V^2

1316
01:18:39,720 --> 01:18:41,720
因为有v阶的取最小数的操作

1317
01:18:41,800 --> 01:18:44,820
然后你们要用常数时间来降低的键值

1318
01:18:44,890 --> 01:18:47,330
如果你用的是二叉堆 也就是我们的最爱

1319
01:18:48,340 --> 01:18:50,710
每次操作就便成了log v了

1320
01:18:50,780 --> 01:18:56,100
然后 这个是V+E的和乘以log v

1321
01:18:56,880 --> 01:19:00,880
然后 这就是我们所知道要做的

1322
01:19:00,950 --> 01:19:04,570
如果你用的是一个叫做斐波那契堆 这种高档货的话

1323
01:19:04,810 --> 01:19:07,540
降低键值操作可以平摊为常数级

1324
01:19:07,610 --> 01:19:12,340
你得到E＋vlog v

1325
01:19:12,340 --> 01:19:13,900
作为最坏情况的运行时间

1326
01:19:13,960 --> 01:19:17,080
那么 这就是我所知道的最好方法

1327
01:19:17,150 --> 01:19:20,060
来解决无条件的最短路径算法

1328
01:19:20,130 --> 01:19:26,960
也就是单源无负边的情况

1329
01:19:27,000 --> 01:19:28,980
一般来说

1330
01:19:29,170 --> 01:19:31,490
好的 这个基本上算好的 这个有时候比那个要好

1331
01:19:31,560 --> 01:19:33,240
但这些实际上是无关的

1332
01:19:33,300 --> 01:19:34,360
除非你知道怎么做这些了

1333
01:19:34,430 --> 01:19:36,390
你不知道怎么去建立一个斐波那契堆

1334
01:19:36,460 --> 01:19:38,210
除非你读过书上面的那一章

1335
01:19:38,280 --> 01:19:41,290
这就是为什么我要说上面两个的运行时间

1336
01:19:41,360 --> 01:19:46,020
好的 我想谈谈一个简单的情况

1337
01:19:46,890 --> 01:19:48,610
你们之前可能已经见过

1338
01:19:48,680 --> 01:19:50,930
有件很有趣的事情是 将这个算法

1339
01:19:51,000 --> 01:19:55,170
跟广度优先搜索关联起来

1340
01:19:58,420 --> 01:20:03,600
我的意思是Dijkstra结束时 就是说

1341
01:20:03,700 --> 01:20:06,240
假设有一个特殊情况

1342
01:20:06,340 --> 01:20:08,760
图上的边都是没有权值的

1343
01:20:09,170 --> 01:20:15,820
意味着w(u,v)都等于1

1344
01:20:18,140 --> 01:20:19,720
好的 假设有这样的条件

1345
01:20:19,790 --> 01:20:21,390
我们怎么做得比Dijkstra要好？

1346
01:20:21,430 --> 01:20:24,140
我们还能比这个时间更快吗？

1347
01:20:24,250 --> 01:20:26,340
好的 我们可能要看看所有的边和所有的点

1348
01:20:26,410 --> 01:20:29,500
那么 唯一一个疑问就是log v

1349
01:20:29,900 --> 01:20:31,970
我怎么避免这个？

1350
01:20:32,040 --> 01:20:33,740
我剧透了一点答案了

1351
01:20:34,340 --> 01:20:41,860
这个答案就是用广度优先搜索 即BFS

1352
01:20:43,300 --> 01:20:47,310
你们可能之前就见过了 跟在深度搜索后面

1353
01:20:47,380 --> 01:20:50,560
它是遍历图的标准方法之一

1354
01:20:50,680 --> 01:20:54,720
但我们会说得比之前多一点

1355
01:20:55,760 --> 01:20:58,970
广度优先搜索实际上就是Dijkstra算法

1356
01:20:59,690 --> 01:21:02,320
有点俏皮 它有两个改动

1357
01:21:02,390 --> 01:21:03,260
第一个改动是

1358
01:21:03,330 --> 01:21:06,220
广度优先搜索不使用优先队列

1359
01:21:07,480 --> 01:21:10,490
我来告诉你 它用的是什么

1360
01:21:12,240 --> 01:21:14,780
你可以用一个队列

1361
01:21:15,250 --> 01:21:19,260
先进先出的队列

1362
01:21:19,710 --> 01:21:23,170
来代替优先队列

1363
01:21:30,190 --> 01:21:31,430
好的 它实测可行

1364
01:21:31,510 --> 01:21:33,050
每次取队列的第一个值

1365
01:21:33,120 --> 01:21:35,080
来代替取最小值

1366
01:21:35,180 --> 01:21:37,260
它不需要减小键值

1367
01:21:37,290 --> 01:21:39,000
好的 这地方有些微妙

1368
01:21:39,070 --> 01:21:42,630
但是命题要改变的就是这一点

1369
01:21:42,770 --> 01:21:45,330
那么 这是松弛操作

1370
01:21:45,820 --> 01:21:53,870
这样松弛就变得更简单了

1371
01:21:53,940 --> 01:21:55,830
如果说我们还没遇到过v

1372
01:21:56,370 --> 01:22:00,650
那一旦接触到它时 它就是最短路径的权值了

1373
01:22:00,720 --> 01:22:05,150
也就是说 d[v]=d[u]+1

1374
01:22:05,190 --> 01:22:07,990
也就是这条边的权值(u,v)

1375
01:22:08,100 --> 01:22:19,000
然后我们把v加到队列的末尾

1376
01:22:19,080 --> 01:22:22,360
现在 我们从空队列开始

1377
01:22:22,760 --> 01:22:25,430
实际上 它包含了起点s

1378
01:22:25,500 --> 01:22:27,680
因为这是唯一已知的最短路径

1379
01:22:27,750 --> 01:22:29,270
那么 这个队列是用来

1380
01:22:29,310 --> 01:22:31,050
当我知道这样一个最短路径时

1381
01:22:31,890 --> 01:22:33,620
那就对它下手

1382
01:22:33,660 --> 01:22:35,810
观察它连到外面的边

1383
01:22:35,850 --> 01:22:38,020
所以一开始这里只有s

1384
01:22:38,060 --> 01:22:40,140
对于所有向外连的边 s为0

1385
01:22:40,180 --> 01:22:43,170
所有连到外面的边的权值为1

1386
01:22:43,200 --> 01:22:45,440
所以从源点到这里的最短路径的权值为1

1387
01:22:45,510 --> 01:22:48,080
你肯定没法找到比1更好的了

1388
01:22:48,120 --> 01:22:50,480
好的 那么我们把这些顶点都加到队列的尾部

1389
01:22:50,520 --> 01:22:52,790
然后 我们按顺序来处理

1390
01:22:52,860 --> 01:22:57,010
然后不断加1 如果它等于d[u]

1391
01:22:57,090 --> 01:22:58,880
给它加上一 那就是d[v]

1392
01:22:58,920 --> 01:23:01,120
然后我们接下来把v加到S里

1393
01:23:01,190 --> 01:23:03,650
每当我们在队列里读到它的时候

1394
01:23:03,830 --> 01:23:06,950
好的 广度优先搜索 非常简单

1395
01:23:08,560 --> 01:23:14,430
然后 你可以看看算法的下一步

1396
01:23:14,870 --> 01:23:17,500
我直接举例子了 因为没时间讲它了

1397
01:23:17,530 --> 01:23:21,020
但是关键是运行时间更小了

1398
01:23:21,640 --> 01:23:27,340
时间等于O(V+E)因为

1399
01:23:27,380 --> 01:23:30,250
跟以前一样 每条边我们都只看到过一次

1400
01:23:30,330 --> 01:23:33,010
我们观察所有从顶点出来的边

1401
01:23:33,050 --> 01:23:37,930
一旦设d[v]为某个值 它就不会改变

1402
01:23:37,970 --> 01:23:39,720
我再也不会改动它 我们直接它加入到S中

1403
01:23:39,760 --> 01:23:41,710
而这也只发生一次

1404
01:23:41,780 --> 01:23:44,230
所以这个if语句 还有其他的

1405
01:23:44,270 --> 01:23:47,450
队列插入操作 一共做了E阶次

1406
01:23:47,520 --> 01:23:49,740
或者是刚好是E次

1407
01:23:49,820 --> 01:23:52,930
队列的插入 以及队列的出列操作

1408
01:23:53,000 --> 01:23:56,350
这代替了取最小值的操作 花费常数时间

1409
01:23:56,420 --> 01:23:57,470
所以总的时间是

1410
01:23:57,540 --> 01:23:59,710
顶点的数目加上边的数目

1411
01:23:59,780 --> 01:24:01,420
好像不是显然有效

1412
01:24:01,490 --> 01:24:04,860
但你可以用Dijkstra的分析来证明它有效

1413
01:24:05,280 --> 01:24:07,180
你要证明的就是FIFO队列做的事情

1414
01:24:07,250 --> 01:24:10,180
跟优先队列做的事情是一样的

1415
01:24:10,220 --> 01:24:11,980
一旦证明了它 根据Dijkstra的正确性

1416
01:24:12,050 --> 01:24:14,200
你也可以得到广度搜索的正确性

1417
01:24:14,270 --> 01:24:17,250
所以 广度搜索不仅能找到所有的点

1418
01:24:17,320 --> 01:24:18,640
这是你通常用到的功能

1419
01:24:18,710 --> 01:24:20,840
它还能找到最短路径

1420
01:24:20,870 --> 01:24:24,610
起点为S到其他所有的点 如果边长都为1的话

1421
01:24:25,400 --> 01:24:27,960
所以 这就是最短路径序章

1422
01:24:28,030 --> 01:24:30,070
下一次课我们会处理负环的问题

