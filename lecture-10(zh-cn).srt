1
00:00:05,330 --> 00:00:08,140
早上好

2
00:00:08,570 --> 00:00:12,980
看来9点半对大家来说 越来越早了

3
00:00:13,280 --> 00:00:14,610
电视机前的家庭观众 大家好

4
00:00:16,200 --> 00:00:19,580
我觉得应该定一条规矩

5
00:00:19,680 --> 00:00:21,340
如果你们是在家看视频

6
00:00:21,360 --> 00:00:24,820
那你只能够在 每周日9点半到11点这段时间看

7
00:00:25,810 --> 00:00:33,030
至少在早上开始看 这样才能感受到我们早起上课的浪漫

8
00:00:33,480 --> 00:00:36,390
今天我们讲一下平衡搜索树

9
00:00:36,930 --> 00:00:38,870
其实 我们之前就已经提到过了

10
00:00:40,120 --> 00:00:43,310
今天的目标是 获得一种搜索树的数据结构

11
00:00:43,800 --> 00:00:45,680
可以插入、删除和搜索

12
00:00:46,230 --> 00:00:48,960
所有操作的时间都是O(log n)

13
00:00:49,670 --> 00:00:53,040
我们希望保证一棵树的高度是log n

14
00:00:54,640 --> 00:00:56,950
那就是一个平衡搜索树的数据结构

15
00:01:09,500 --> 00:01:11,820
我们要的数据结构

16
00:01:12,250 --> 00:01:15,140
它维护一个n个元素的动态集的时间

17
00:01:15,230 --> 00:01:18,200
是log n阶的

18
00:01:28,710 --> 00:01:35,640
所以树高为O(log n)

19
00:01:43,890 --> 00:01:46,430
如果你细心一想

20
00:01:46,750 --> 00:01:50,320
我们好像从未定义过什么是搜索树的数据结构

21
00:01:50,570 --> 00:01:52,850
但我们定义过二叉搜索树的数据结构

22
00:01:53,310 --> 00:01:54,680
而那就是其中特别的一种

23
00:01:54,870 --> 00:01:56,310
也就是今天要具体讨论的内容

24
00:01:56,310 --> 00:02:00,480
在星期五的复习课 你会发现

25
00:02:00,680 --> 00:02:03,280
平衡搜索树不一定是二叉树

26
00:02:03,480 --> 00:02:06,520
每个结点都可能有多个子结点  不单只2个

27
00:02:07,860 --> 00:02:09,900
我这个是一般的定义

28
00:02:10,020 --> 00:02:13,140
以后会看到 在一般情况下的搜索树是怎么样的

29
00:02:13,280 --> 00:02:15,780
但今天的重点是二叉树

30
00:02:16,130 --> 00:02:17,540
所以这里 不会具体定义

31
00:02:19,920 --> 00:02:22,480
有多种不同的平衡搜索树的数据结构

32
00:02:25,140 --> 00:02:28,990
以下是我所知道的主要几种

33
00:02:29,340 --> 00:02:31,300
第一种是AVL树

34
00:02:32,010 --> 00:02:34,250
是在1962年发明的

35
00:02:35,450 --> 00:02:37,760
它是第一个快速数据结构

36
00:02:42,210 --> 00:02:45,490
下面这三种一起

37
00:02:47,020 --> 00:02:54,590
会在这周的复习课讲解

38
00:02:55,900 --> 00:02:58,840
这三个都是非二叉树

39
00:02:59,310 --> 00:03:01,560
相对于二叉 它可能是二叉加三叉的

40
00:03:01,800 --> 00:03:03,770
或者二叉加三叉还有四叉

41
00:03:04,460 --> 00:03:06,800
或者是用一般化的概念表示：B

42
00:03:08,350 --> 00:03:11,570
这是另外一些可以构造平衡树的方法

43
00:03:11,900 --> 00:03:14,040
2－3树 是第二种发明的树

44
00:03:14,160 --> 00:03:16,990
在1970年由霍普克罗夫特建立

45
00:03:19,370 --> 00:03:21,970
今天要讲的树叫红黑树

46
00:03:22,420 --> 00:03:33,890
这是一种确保拥有对数阶高度的二叉搜索树

47
00:03:35,070 --> 00:03:37,920
然后  还有一些别的

48
00:03:42,280 --> 00:03:46,840
跳跃表我们下周再介绍

49
00:03:49,900 --> 00:03:52,470
它确切来说不是树 但或多或少有树的结构

50
00:03:52,860 --> 00:03:58,610
还有一个在这周的练习题里会出现的 叫树堆的算法

51
00:04:01,220 --> 00:04:03,720
我这里不会讲太多

52
00:04:03,900 --> 00:04:05,850
但在某种程度上  它更容易构建

53
00:04:06,110 --> 00:04:09,870
因为它的基础就是 上周一材料里的内容

54
00:04:10,550 --> 00:04:12,130
在周一的课上讲过

55
00:04:12,370 --> 00:04:14,120
如果随机建立一个二叉搜索树

56
00:04:14,510 --> 00:04:18,140
大部分时候  树的高度都是期望中的log n

57
00:04:18,850 --> 00:04:22,240
树堆是一种使其动态化的算法

58
00:04:22,450 --> 00:04:24,330
而不是只有n个项的静态集

59
00:04:24,540 --> 00:04:26,500
你能够进行插入 删除操作

60
00:04:26,660 --> 00:04:28,600
而且还能高效地打乱数组的排列

61
00:04:29,160 --> 00:04:30,180
再把它们加入到树中

62
00:04:30,940 --> 00:04:32,560
在某种程度上 这是最容易的

63
00:04:32,830 --> 00:04:36,270
也是最新的搜索树结构之一

64
00:04:36,500 --> 00:04:38,160
它发明于1996年

65
00:04:39,000 --> 00:04:43,490
发明者是几个几何学家 里蒙·锡德尔和阿拉贡

66
00:04:43,920 --> 00:04:47,900
这是一些搜索树的数据结构

67
00:04:48,150 --> 00:04:50,370
在这节课里唯一不涉及的是AVL树

68
00:04:51,170 --> 00:04:52,990
不是特别难 如果感兴趣的话

69
00:04:53,210 --> 00:04:55,040
你应该学习一下 因为会很有趣

70
00:04:56,850 --> 00:05:00,760
我想它应该会以习题的形式 出现在课本里

71
00:05:01,720 --> 00:05:05,050
但今天 我们的重点是红黑树

72
00:05:13,700 --> 00:05:21,470
一个相单简洁的结构 红黑树

73
00:05:22,220 --> 00:05:26,140
它能保证树的高度是对数阶的

74
00:05:26,570 --> 00:05:29,200
所以 它所有的操作都能在log n时间完成

75
00:05:30,290 --> 00:05:33,080
它们也是二叉搜索树的一种

76
00:05:35,670 --> 00:05:43,000
而在每个结点  它都会附带一些额外的信息

77
00:05:43,070 --> 00:05:45,630
称为色域

78
00:06:00,910 --> 00:06:04,070
而一个有色域的树

79
00:06:04,430 --> 00:06:06,680
还必须先满足几个性质

80
00:06:06,770 --> 00:06:08,930
才能称之为红黑树

81
00:06:09,430 --> 00:06:11,440
这些性质叫做红黑性

82
00:06:11,870 --> 00:06:15,530
虽然写出来要花点时间

83
00:06:15,860 --> 00:06:17,860
但其实是很简单的

84
00:06:18,360 --> 00:06:22,240
我会边写边解释它的意思

85
00:06:22,600 --> 00:06:24,860
有四个性质

86
00:06:27,870 --> 00:06:29,710
第一个非常简单

87
00:06:30,000 --> 00:06:33,520
每个结点 或者是红色 或者是黑色

88
00:06:34,380 --> 00:06:37,750
这也是为什么称为红黑树

89
00:06:39,910 --> 00:06:44,250
所以色域只需要一个位 来确定其颜色

90
00:06:44,450 --> 00:06:47,540
我这里会用双圆圈来代表红色结点

91
00:06:47,680 --> 00:06:49,010
因为这边没有彩色粉笔

92
00:06:49,230 --> 00:06:51,060
黑色结点是单圆圈

93
00:06:51,280 --> 00:06:52,950
很可能你也没有彩色笔

94
00:06:53,150 --> 00:06:55,340
所以这样表示会方便很多

95
00:06:55,570 --> 00:07:00,960
红色是双圆圈 黑色是单圆圈

96
00:07:01,240 --> 00:07:02,920
所以 我们会更倾向于使用黑结点

97
00:07:03,250 --> 00:07:05,570
因为红色结点要多画一个圈

98
00:07:07,210 --> 00:07:16,080
第二个性质是 根结点和叶结点都是黑色的

99
00:07:23,610 --> 00:07:27,450
这里要用到一个小技巧

100
00:07:27,740 --> 00:07:30,520
我们要稍微换个角度来看二叉搜索树

101
00:07:30,560 --> 00:07:31,780
跟以前不一样

102
00:07:32,290 --> 00:07:35,570
通常情况下 树是一簇簇结点

103
00:07:35,730 --> 00:07:38,910
每个结点有0个 1个或2个子结点

104
00:07:39,250 --> 00:07:40,250
就像这样

105
00:07:40,550 --> 00:07:43,440
我们要在附加一些东西

106
00:07:43,470 --> 00:07:45,590
到每个没有子树的结点上

107
00:07:45,920 --> 00:07:48,680
我要在这里画一些点

108
00:07:48,930 --> 00:07:50,700
一个外部结点 叫做叶结点

109
00:07:51,130 --> 00:07:53,260
所以 这些项一般就是叶结点

110
00:07:53,570 --> 00:07:58,290
我们要给每一个空的子指针 添加一个新的叶结点

111
00:07:58,670 --> 00:07:59,820
所以  这些就是叶结点

112
00:08:00,110 --> 00:08:03,450
它们其实是这些结点的空的子指针

113
00:08:03,710 --> 00:08:06,300
这样 每个内部结点都有两个子结点

114
00:08:06,710 --> 00:08:08,450
每个叶结点有零个子结点

115
00:08:08,850 --> 00:08:11,360
这些就是我提到的叶结点

116
00:08:11,540 --> 00:08:16,870
根据规则二 它们都是黑色的 还有根结点也是黑色的

117
00:08:17,220 --> 00:08:21,690
接下来的性质会有趣一点

118
00:08:26,540 --> 00:08:31,380
每个红色结点的父结点都是黑色的

119
00:08:35,070 --> 00:08:38,450
当有一个红色结点时

120
00:08:38,740 --> 00:08:42,650
它的父结点就一定是黑色的 单圆圈

121
00:08:44,910 --> 00:08:50,060
换句话说 如果你观察树的任意路径

122
00:08:50,410 --> 00:08:53,000
你都不可能找到有两个连续的红结点

123
00:08:53,310 --> 00:08:56,370
你只能找到红黑相间的情况

124
00:08:56,560 --> 00:08:58,380
又或者是几个连续的黑结点

125
00:08:58,550 --> 00:08:59,940
但不可能是两个红结点

126
00:09:00,260 --> 00:09:03,400
还有一条规则

127
00:09:03,730 --> 00:09:06,630
这一条涉及到更多的路径方面的内容

128
00:09:09,670 --> 00:09:14,970
如果选一条简单路径 也就是不重复任何结点

129
00:09:15,610 --> 00:09:30,980
从一个结点x  一直到x的子孙叶结点

130
00:09:33,880 --> 00:09:37,420
所有到各子孙叶结点的路径

131
00:09:37,740 --> 00:09:40,350
都有相等的黑结点数

132
00:09:54,880 --> 00:10:00,950
我画图解释下 有一棵树

133
00:10:01,300 --> 00:10:03,220
在树里有一个结点x

134
00:10:03,660 --> 00:10:05,840
我观察所有从x

135
00:10:06,080 --> 00:10:08,350
下降到各个子孙叶结点的路径

136
00:10:08,690 --> 00:10:10,870
一直下降到树的最底层

137
00:10:11,220 --> 00:10:15,480
这些路径全都有相等的黑结点数

138
00:10:15,700 --> 00:10:21,000
所以 这里每条路径都有四个黑结点

139
00:10:21,200 --> 00:10:23,020
除了叶结点 上面有三个

140
00:10:26,070 --> 00:10:29,190
根据性质三

141
00:10:29,400 --> 00:10:32,820
最多只能有一半的结点是红色的

142
00:10:33,100 --> 00:10:34,200
因为当有一个红结点

143
00:10:34,420 --> 00:10:35,670
它的父结点就一定是黑色

144
00:10:36,100 --> 00:10:38,590
但我想确保所有这些路径

145
00:10:38,760 --> 00:10:40,230
都有相同的黑结点数

146
00:10:40,670 --> 00:10:43,390
也就是所谓的黑高度

147
00:10:43,750 --> 00:10:47,250
这边没位置写了 写到那边

148
00:10:50,190 --> 00:10:53,570
所有路径的黑高度应该一致  但其实

149
00:10:53,770 --> 00:10:58,450
计算x的黑高度时 并不用考虑x本身

150
00:11:04,070 --> 00:11:09,600
即使x是黑色的 我也只计算下面的黑高度

151
00:11:09,820 --> 00:11:12,200
这里x的黑高度为4

152
00:11:12,620 --> 00:11:15,380
即使x不是黑色的 黑高度也是4

153
00:11:15,660 --> 00:11:18,050
这些只是一些微小的细节

154
00:11:18,330 --> 00:11:21,730
让所有算法看起来整洁一点

155
00:11:22,160 --> 00:11:24,610
先来看一个红黑树的例子

156
00:11:27,430 --> 00:11:31,270
对 我会举一个例子

157
00:11:31,460 --> 00:11:33,530
然后再讲解为什么要有这些性质

158
00:12:14,750 --> 00:12:17,610
这棵树有几个性质

159
00:12:17,830 --> 00:12:19,580
首先它是一个二叉搜索树

160
00:12:20,330 --> 00:12:22,170
所以你能够用中序遍历

161
00:12:22,360 --> 00:12:24,080
来给这些数字排一下序

162
00:12:24,330 --> 00:12:27,940
3，7，8，10，11，18，22，26

163
00:12:28,130 --> 00:12:30,010
它是一个有效的二叉搜索树

164
00:12:30,270 --> 00:12:32,100
我们还在后面附加了无值的叶结点

165
00:12:32,180 --> 00:12:33,310
只是摆在那里

166
00:12:33,390 --> 00:12:35,100
全都是空指针

167
00:12:35,350 --> 00:12:36,950
每一个都为nil

168
00:12:37,200 --> 00:12:42,650
它们只是附加在没有子结点的地方

169
00:12:42,970 --> 00:12:47,640
有些结点画了双圆圈 表示为红色

170
00:12:47,930 --> 00:12:51,680
如果这些节点不是红色的话  黑高度就不相等了

171
00:12:52,020 --> 00:12:53,850
这里要小心点

172
00:12:54,100 --> 00:12:57,790
我们来计算一下

173
00:12:57,970 --> 00:13:00,720
每个结点下降到子孙叶的黑结点数

174
00:13:01,050 --> 00:13:05,680
比如 这个空指针 它的黑高度为0

175
00:13:05,860 --> 00:13:07,200
对 答案是0

176
00:13:07,380 --> 00:13:09,630
所以 叶结点的黑高度都为0

177
00:13:09,860 --> 00:13:14,330
这里要记一下 黑高度等于0

178
00:13:14,710 --> 00:13:18,560
3的黑高度是多少？

179
00:13:20,260 --> 00:13:25,200
0？不对 因为这些点是黑色的

180
00:13:25,570 --> 00:13:27,180
所以黑高度是1

181
00:13:27,660 --> 00:13:31,020
对了 即使3是黑色的 我们也不考虑它

182
00:13:31,310 --> 00:13:35,360
因为不用算原结点  但要算叶结点

183
00:13:35,780 --> 00:13:37,840
这里只有两条路径

184
00:13:38,040 --> 00:13:40,880
而每一条都必然地有相同的黑结点数

185
00:13:41,190 --> 00:13:43,990
这边8的黑高度也是1

186
00:13:44,090 --> 00:13:45,590
即使它是红色的

187
00:13:46,920 --> 00:13:49,140
11也一样

188
00:13:49,770 --> 00:13:54,440
26也一样 它们都只有两条路径

189
00:13:54,660 --> 00:13:58,040
每条路径上都有一个黑结点

190
00:13:58,340 --> 00:14:01,670
10的黑高度是多少？

191
00:14:01,970 --> 00:14:06,900
还是1 因为不算10这个结点

192
00:14:07,230 --> 00:14:09,690
它有四条到叶结点的路径

193
00:14:10,000 --> 00:14:12,840
每一条都包括了1个黑结点

194
00:14:12,930 --> 00:14:14,080
但根结点没有算进去

195
00:14:14,560 --> 00:14:17,700
22应该也是一样的

196
00:14:18,270 --> 00:14:20,570
但这个比较有意思

197
00:14:20,820 --> 00:14:22,340
这一条路径有1个黑结点

198
00:14:22,600 --> 00:14:23,940
而这些路径更长一些

199
00:14:24,210 --> 00:14:26,330
但仍然只有一个黑结点

200
00:14:26,740 --> 00:14:28,460
所以 就相当于忽略这个红结点

201
00:14:28,710 --> 00:14:30,240
所有的路径都一样长

202
00:14:30,480 --> 00:14:34,580
18的黑高度应该会大一点 等于2

203
00:14:34,930 --> 00:14:39,570
因为这边有1个黑结点

204
00:14:39,840 --> 00:14:42,490
还有黑的叶结点  这边也有1个黑结点

205
00:14:42,750 --> 00:14:44,510
加上一个黑的叶结点

206
00:14:45,140 --> 00:14:51,340
最后 根结点的黑高度就会是2

207
00:14:52,480 --> 00:14:53,780
应该很容易看出来

208
00:14:54,010 --> 00:14:55,620
每条路径都有两个黑结点

209
00:14:55,880 --> 00:14:57,480
这边的也一样

210
00:14:58,000 --> 00:15:02,180
正如希望中那样 所有性质都成立

211
00:15:02,190 --> 00:15:03,900
除了一个性质还没检查

212
00:15:03,910 --> 00:15:05,670
每个红结点都有一个黑的父结点

213
00:15:05,960 --> 00:15:07,910
如果你观察所有这些路径

214
00:15:08,200 --> 00:15:12,200
它们都是交替分布的 最多就红黑相间

215
00:15:12,430 --> 00:15:13,910
或者干脆都是黑的

216
00:15:14,000 --> 00:15:15,890
但两个红结点从不重复出现

217
00:15:15,930 --> 00:15:17,660
根结点和叶结点都是黑的

218
00:15:17,940 --> 00:15:19,910
完全符合定义

219
00:15:20,330 --> 00:15:22,420
所有结点非红即黑  这很简单

220
00:15:24,210 --> 00:15:26,570
这是一组特殊的性质

221
00:15:26,580 --> 00:15:28,200
虽然现在看来 可能有点随意

222
00:15:28,280 --> 00:15:29,980
一旦我们了解到它带来的影响

223
00:15:30,190 --> 00:15:32,180
你就会发现它很有道理

224
00:15:32,580 --> 00:15:34,570
但这里有几个目标

225
00:15:34,890 --> 00:15:36,490
我们要去达成

226
00:15:36,850 --> 00:15:39,190
一是这些性质要促使树的高度...

227
00:15:39,400 --> 00:15:42,000
是对数阶的 O(log n)高度

228
00:15:42,280 --> 00:15:44,490
它们做到了  虽然在这里不是很明显

229
00:15:44,740 --> 00:15:49,230
主要是根据这些性质推出

230
00:15:49,790 --> 00:15:51,250
性质三和性质四是主要的部分

231
00:15:51,530 --> 00:15:53,320
但实际上这四个性质缺一不可

232
00:15:53,660 --> 00:15:59,220
我们还希望 这些性质

233
00:15:59,560 --> 00:16:01,000
是相对容易保持的

234
00:16:01,660 --> 00:16:05,150
在一开始  我们可以创建一个拥有这些性质的树

235
00:16:05,420 --> 00:16:09,500
比如说 这里要注意一下

236
00:16:09,780 --> 00:16:14,200
假设建立一个完全平衡二叉树

237
00:16:14,580 --> 00:16:19,010
让所有结点都为黑色 当然能满足这些性质

238
00:16:19,370 --> 00:16:22,000
这是一个红黑树

239
00:16:25,090 --> 00:16:28,270
要拥有这些性质

240
00:16:28,460 --> 00:16:29,570
在一开始并不难

241
00:16:29,850 --> 00:16:32,090
问题在于如何保持它们

242
00:16:32,400 --> 00:16:34,170
当我插入一个结点

243
00:16:34,370 --> 00:16:35,410
再删除树的一个结点

244
00:16:35,600 --> 00:16:37,820
我不想搞得太复杂

245
00:16:38,060 --> 00:16:41,300
在log n的时间完成操作 之后还能恢复所有性质

246
00:16:41,590 --> 00:16:44,210
那是最难的地方

247
00:16:44,570 --> 00:16:47,390
首先 我们要证明这些性质...

248
00:16:47,850 --> 00:16:50,150
能推导出树高为O(log n)的结论

249
00:16:50,440 --> 00:16:52,170
因此 这个数据结构里

250
00:16:52,420 --> 00:16:54,300
所有搜索和查询的速度都很快

251
00:16:54,850 --> 00:16:57,330
但难题是  即使这些性质一开始都成立

252
00:16:57,650 --> 00:17:02,990
一旦我们对树做了改动 我们要如何保证这些性质一直成立？

253
00:17:07,200 --> 00:17:15,420
先讨论红黑树的高度

254
00:17:32,080 --> 00:17:34,780
从这里我们就会开始了解

255
00:17:35,010 --> 00:17:36,920
这些性质是从哪里来的

256
00:17:37,330 --> 00:17:39,920
为什么选择那些性质

257
00:18:03,360 --> 00:18:08,170
有n个键的红黑树的高度

258
00:18:08,660 --> 00:18:10,020
这里不说结点

259
00:18:10,210 --> 00:18:11,950
因为要计算的只是内部结点

260
00:18:12,290 --> 00:18:14,430
不包括这些附加上去的叶结点

261
00:18:14,660 --> 00:18:18,830
树的高度 最多为2log(n+1) 也就是O(log n)

262
00:18:21,420 --> 00:18:25,030
这有一个相当精确的因子2

263
00:18:25,290 --> 00:18:29,920
课本里有一个用归纳法的证明

264
00:18:30,220 --> 00:18:31,670
应该去看一下

265
00:18:31,950 --> 00:18:34,880
而我要给出的  则是另外一种证明思路

266
00:18:39,220 --> 00:18:41,240
但你们应该看一下那个归纳证明

267
00:18:41,240 --> 00:18:43,390
因为归纳法能很好地帮你

268
00:18:43,640 --> 00:18:45,110
解决实际练习中的问题

269
00:18:45,430 --> 00:18:47,710
另一种证明的思路则能让我们...

270
00:18:47,790 --> 00:18:50,110
对红黑树有一个更直观的理解

271
00:18:50,390 --> 00:18:53,180
还把周五的复习课联系在了一起

272
00:18:53,400 --> 00:18:55,380
那么 我来讲另一个证明

273
00:18:55,880 --> 00:19:01,680
我想把这块的黑板留空 到这边来

274
00:19:27,290 --> 00:19:31,340
我要做的第一件事

275
00:19:31,890 --> 00:19:33,930
是对树进行改造

276
00:19:34,020 --> 00:19:35,850
直到它变得像是某种已知的结构

277
00:19:36,160 --> 00:19:41,210
我要做的主要的改变...

278
00:19:41,490 --> 00:19:43,920
是将每个红结点跟它的父结点合并起来

279
00:19:44,300 --> 00:19:47,930
我们知道红结点的父结点一定是黑色的

280
00:19:56,740 --> 00:20:00,600
将每个红结点合并入黑色父结点里

281
00:20:01,150 --> 00:20:04,360
看这里

282
00:20:04,690 --> 00:20:07,600
把这个红结点 合并到它的父结点里

283
00:20:07,810 --> 00:20:10,450
把这个红结点 跟这个父结点合并 等等

284
00:20:10,800 --> 00:20:13,800
有一个结点在上面我够不到

285
00:20:14,000 --> 00:20:15,770
不过我打算重新画一张图

286
00:20:16,050 --> 00:20:21,020
最上面的结点现在变成

287
00:20:21,260 --> 00:20:23,800
7和18的某种结合

288
00:20:24,150 --> 00:20:26,040
它们合并在一起了

289
00:20:26,230 --> 00:20:27,500
没有别的数加入它们

290
00:20:27,820 --> 00:20:30,740
然后 在左边的是3

291
00:20:31,110 --> 00:20:34,570
没有别的数加入  和之前一样 有些叶结点

292
00:20:34,960 --> 00:20:39,530
如果你看...可能还是要在那张图上画

293
00:20:41,080 --> 00:20:45,630
杯具了  我又要毁黑板了

294
00:20:45,940 --> 00:20:49,920
那么 把这些结点合并到一起

295
00:20:50,220 --> 00:20:53,690
还有这些结点也合并到一起

296
00:20:54,080 --> 00:20:57,370
因为这两个红结点都要并入这个黑结点里

297
00:20:57,580 --> 00:20:59,450
这两个结点也合并到一起

298
00:20:59,660 --> 00:21:02,150
把这些红结点放进黑结点里

299
00:21:02,340 --> 00:21:05,030
从根结点看起 是7/18

300
00:21:05,440 --> 00:21:07,680
下面有三个子结点

301
00:21:08,090 --> 00:21:13,560
我再把结果画到另一张图里

302
00:21:14,010 --> 00:21:18,100
希望这块板还能多扛一会儿 好的

303
00:21:18,490 --> 00:21:24,740
在7和18中间

304
00:21:25,030 --> 00:21:32,340
有一个混合结点 8，10，11

305
00:21:32,690 --> 00:21:37,290
下面有四个叶结点

306
00:21:41,840 --> 00:21:45,270
右边 在18之后

307
00:21:45,550 --> 00:21:49,820
有一个混合结点 22/26

308
00:21:50,170 --> 00:21:52,660
它有三个叶结点

309
00:21:54,540 --> 00:21:58,390
相当古怪的树

310
00:21:58,600 --> 00:22:00,680
因为到目前为止 我们接触主要是二叉树

311
00:22:00,860 --> 00:22:03,380
但这算是周五内容的一个预告吧

312
00:22:03,730 --> 00:22:06,790
这是种树叫2－3－4的树

313
00:22:09,660 --> 00:22:13,520
猜一下为什么叫2－3－4树？

314
00:22:16,860 --> 00:22:20,700
每个结点能有2个，3个或者4个子结点

315
00:22:21,050 --> 00:22:23,760
除了叶结点 它没有子结点

316
00:22:24,000 --> 00:22:25,130
2－3－4树还隐含着...

317
00:22:25,140 --> 00:22:29,040
一个不错的性质

318
00:22:29,190 --> 00:22:30,560
首先 它是没有限制的

319
00:22:30,750 --> 00:22:35,180
一个结点可以有2个、3个或4个子结点

320
00:22:35,480 --> 00:22:37,670
但它还有一个不错的性质

321
00:22:39,390 --> 00:22:40,710
问题？

322
00:22:41,540 --> 00:22:46,380
[学生]...

323
00:22:46,980 --> 00:22:49,840
没错  所有叶结点都有相同的深度

324
00:22:50,290 --> 00:22:53,150
所有的叶结点在树里都有同样的深度

325
00:22:53,480 --> 00:22:55,750
为什么？因为有性质4

326
00:22:56,100 --> 00:23:00,970
在周五我们会学到 如何保持性质4

327
00:23:01,220 --> 00:23:02,560
但经过这种转换之后

328
00:23:02,820 --> 00:23:05,480
所有叶结点的深度都成一样的了

329
00:23:05,690 --> 00:23:07,480
因为现在的深度...

330
00:23:07,750 --> 00:23:11,630
或者说在树里的高度 等于它们的黑高度

331
00:23:12,030 --> 00:23:14,370
这些叶结点的深度

332
00:23:14,620 --> 00:23:17,070
就是根结点的黑高度

333
00:23:17,450 --> 00:23:20,680
因为我们把红结点都向上合并了

334
00:23:21,010 --> 00:23:22,600
当我们观察路径时

335
00:23:22,840 --> 00:23:24,110
把红结点都忽略掉

336
00:23:24,350 --> 00:23:26,920
这样沿着路径的黑结点的就一样多了

337
00:23:27,190 --> 00:23:29,300
而现在只剩下黑结点了

338
00:23:29,630 --> 00:23:32,650
所以 沿着所有这些路径

339
00:23:32,900 --> 00:23:34,320
黑结点的数量都相同

340
00:23:34,630 --> 00:23:37,580
因此 所有叶结点的深度也都相同

341
00:23:38,600 --> 00:23:41,130
让我把这些性质写下来

342
00:23:41,400 --> 00:23:53,720
每个内部结点 都有2到4个子结点

343
00:23:57,650 --> 00:24:02,710
而且每个叶结点的深度一致

344
00:24:10,450 --> 00:24:15,920
都等于根结点的黑高度

345
00:24:25,890 --> 00:24:35,790
这都是根据性质4推出来的 这条性质很有内涵

346
00:24:36,180 --> 00:24:37,890
本质上  这种转换做的是

347
00:24:38,120 --> 00:24:40,190
忽略掉所有的红结点

348
00:24:40,450 --> 00:24:42,180
而如果只是看黑结点的话

349
00:24:42,460 --> 00:24:43,810
结点高度就等于黑高度

350
00:24:44,100 --> 00:24:46,300
然后 黑高度又告诉我们

351
00:24:46,550 --> 00:24:50,700
所有从根结点到叶结点的路径都是等长的

352
00:24:51,100 --> 00:24:52,860
所以 这些结点全都在同一层

353
00:24:53,220 --> 00:24:56,630
叶结点全都在同一层是件好事

354
00:24:56,950 --> 00:24:59,180
因为它意味着树是非常平衡的

355
00:24:59,470 --> 00:25:01,920
如果树的所有内部结点都有分支

356
00:25:02,190 --> 00:25:04,370
每个内部结点至少都有两个子结点

357
00:25:04,660 --> 00:25:06,550
而且所有的叶结点都在同一层

358
00:25:06,860 --> 00:25:08,860
那就非常地平衡

359
00:25:09,080 --> 00:25:11,480
现在要证明部分内容

360
00:25:11,730 --> 00:25:17,330
假设这棵树的高度为h'

361
00:25:17,620 --> 00:25:22,030
原树的高度是h

362
00:25:22,400 --> 00:25:24,480
也就是这里要限制的高度

363
00:25:26,460 --> 00:25:28,510
首先  我们要限制h'的高度

364
00:25:28,780 --> 00:25:31,050
然后通过h'来求出h

365
00:25:32,610 --> 00:25:39,090
第一个问题是

366
00:25:39,310 --> 00:25:42,310
这棵树里有多少叶结点？

367
00:25:42,580 --> 00:25:44,240
看哪棵树都无所谓

368
00:25:44,310 --> 00:25:46,250
因为我没有对叶结点做过改动

369
00:25:46,310 --> 00:25:48,540
所有叶结点都是黑色的 没有发生改变

370
00:25:49,010 --> 00:25:50,870
这棵树里有多少叶结点？

371
00:25:51,070 --> 00:25:52,510
这棵树也一样

372
00:25:52,730 --> 00:25:57,270
多少？  9 确实是9

373
00:25:57,510 --> 00:25:58,960
但我想问一般的情况...对不起

374
00:25:59,280 --> 00:26:00,420
在这个例子里是9

375
00:26:00,770 --> 00:26:04,820
有多少个键？ 8个

376
00:26:05,090 --> 00:26:09,540
在一般情况下 什么函数能把8变成9？

377
00:26:09,850 --> 00:26:16,250
对于9或8这种大数来说

378
00:26:16,520 --> 00:26:24,000
什么？加1 回答正确 猜的吧

379
00:26:24,290 --> 00:26:29,620
n+1 为什么是n+1?

380
00:26:29,820 --> 00:26:32,620
我们先看一下这个二叉树的例子

381
00:26:32,850 --> 00:26:34,290
这样 我们就能明白一点了

382
00:26:34,590 --> 00:26:37,600
无论哪一个键

383
00:26:37,910 --> 00:26:39,580
都有两个分支

384
00:26:39,920 --> 00:26:43,370
嗯 这样说不太好

385
00:26:43,710 --> 00:26:48,850
这是一个平衡二叉树

386
00:26:49,120 --> 00:26:51,070
每个内部结点都有两个子结点

387
00:26:51,890 --> 00:26:54,520
我们要用内部结点数

388
00:26:54,610 --> 00:26:55,760
根据这种情况

389
00:26:55,850 --> 00:26:57,240
来计算叶结点的数量

390
00:26:57,550 --> 00:27:00,180
一个平衡树的叶结点数

391
00:27:00,410 --> 00:27:02,760
总是等于内部结点数加1

392
00:27:03,080 --> 00:27:04,500
你应该能理解

393
00:27:04,760 --> 00:27:06,350
你可以用归纳来证明

394
00:27:06,560 --> 00:27:08,730
所以叶结点数是n+1

395
00:27:08,940 --> 00:27:10,380
如果只有1个子结点那就不成立了

396
00:27:10,770 --> 00:27:16,270
成立的前提是每个内部结点 它的分支数为2

397
00:27:19,900 --> 00:27:22,270
所以 两棵树的叶结点都是n+1

398
00:27:23,770 --> 00:27:27,050
现在要引用一些

399
00:27:27,250 --> 00:27:29,270
叶结点数与树高度之间的关系

400
00:27:30,550 --> 00:27:33,240
这里用哪个关系比较好？

401
00:27:33,550 --> 00:27:35,720
我们知道有多少个叶结点

402
00:27:35,920 --> 00:27:37,260
它和n有关

403
00:27:37,510 --> 00:27:39,270
但我们关注的是高度

404
00:27:39,480 --> 00:27:40,800
看一下这棵树的高度

405
00:27:42,770 --> 00:27:47,650
如果2-3-4树的高度为h'
那它会有多少个叶结点？

406
00:27:50,180 --> 00:27:54,180
它可能的最小值、最大值又是多少？

407
00:27:55,850 --> 00:27:58,470
2^h到4^h  应该是h'

408
00:27:59,610 --> 00:28:03,430
那么 在一个2-3-4树里

409
00:28:05,710 --> 00:28:11,330
叶结点数小于或等于4^h

410
00:28:11,570 --> 00:28:14,080
因为每个结点最多有4个分支

411
00:28:14,320 --> 00:28:17,790
至少是2^h’

412
00:28:18,010 --> 00:28:23,630
因为每个内部结点至少有2个分支 也就是每个键

413
00:28:24,860 --> 00:28:27,960
那么 我只关注这部分不等式

414
00:28:29,130 --> 00:28:33,690
得出2^h’

415
00:28:33,930 --> 00:28:35,400
最多等于n+1

416
00:28:35,700 --> 00:28:37,080
因为叶结点数是n+1

417
00:28:37,160 --> 00:28:38,450
这是我们已知的

418
00:28:38,800 --> 00:28:41,970
我们重写一下  两边都取对数

419
00:28:42,240 --> 00:28:46,990
得出h'小于或等于log(n+1)

420
00:28:48,260 --> 00:28:51,030
所以这是一棵漂亮的平衡树

421
00:28:51,040 --> 00:28:52,410
直觉上是这样的

422
00:28:52,600 --> 00:28:54,460
如果每个结点都有2个分支

423
00:28:54,690 --> 00:28:57,480
而且所有叶结点都在同一层  那就是一棵完美的树了

424
00:28:57,750 --> 00:29:01,210
正好等于以2为底的log(n+1）

425
00:29:01,420 --> 00:29:02,490
结果比n小很多

426
00:29:02,720 --> 00:29:04,150
这就是这棵树的高度

427
00:29:04,340 --> 00:29:05,870
我们还可能有更多的分支

428
00:29:06,070 --> 00:29:08,850
这样  树就会变得更矮一些

429
00:29:09,110 --> 00:29:11,730
那在同一高度 我们就有更多的叶结点

430
00:29:11,820 --> 00:29:13,120
但这样更好

431
00:29:13,180 --> 00:29:14,460
因为随着叶结点数的增加

432
00:29:14,530 --> 00:29:15,680
高度也会降低

433
00:29:15,950 --> 00:29:18,690
这里叶结点数是n+1

434
00:29:18,930 --> 00:29:24,950
帅!  这是这棵树的比较宽松的上界

435
00:29:25,150 --> 00:29:27,430
但我们真正关注的是这棵树的高度
所以我们要把h和h'关联起来

436
00:29:29,980 --> 00:29:32,220
但我们要怎么做？给个建议？

437
00:29:32,450 --> 00:29:36,550
我们怎么知道 这棵简化树的高度

438
00:29:36,790 --> 00:29:38,560
不会比原树的高度小太多？

439
00:29:39,050 --> 00:29:40,690
下面这棵树最多是log n

440
00:29:40,850 --> 00:29:43,810
我们想让原树的高度 不超过2log(n+1)

441
00:29:45,200 --> 00:29:49,750
我们其实知道答案 因为已经讲过这定理了  嗯嗯？

442
00:29:50,070 --> 00:29:52,450
[学生]...

443
00:29:52,690 --> 00:29:55,340
对  性质3告诉了我们

444
00:29:55,540 --> 00:29:58,810
每个红结点只能连着黑结点

445
00:29:59,070 --> 00:30:00,580
所以 最多只能红黑相间

446
00:30:00,860 --> 00:30:02,580
如果观察任意一条路径

447
00:30:02,740 --> 00:30:06,750
从根结点到叶结点的

448
00:30:07,040 --> 00:30:08,790
它所经过的红结点数

449
00:30:09,040 --> 00:30:10,850
最多是路径长的一半

450
00:30:11,100 --> 00:30:14,500
而所有路径里最长的那条 就是树的高度

451
00:30:14,850 --> 00:30:19,400
所以我们有  h小于等于2h'

452
00:30:19,770 --> 00:30:25,370
或者更容易点  h'至少是h的一半

453
00:30:25,670 --> 00:30:27,300
这应该是正确的

454
00:30:27,580 --> 00:30:33,290
因为在任意从根到叶的路径上

455
00:30:33,560 --> 00:30:47,600
最多有一半的结点是红色的

456
00:30:49,740 --> 00:30:51,840
所以 至少有一半的结点是黑色的

457
00:30:52,120 --> 00:30:55,290
这幅图只包含了所有的黑结点

458
00:30:55,290 --> 00:30:57,980
因为红结点都已经合并了 所以我们有这条式

459
00:30:58,270 --> 00:31:03,930
因此 h最多不超过2log(n+1)

460
00:31:04,350 --> 00:31:07,980
非常简单

461
00:31:08,300 --> 00:31:10,200
但你们要记住

462
00:31:10,470 --> 00:31:12,360
这颗树必须在平衡的情况下

463
00:31:12,630 --> 00:31:14,350
两树之间的高度差才不会太大

464
00:31:14,400 --> 00:31:17,370
在周五的复习课上

465
00:31:17,610 --> 00:31:19,120
你会学习怎么改造这种树

466
00:31:19,350 --> 00:31:20,400
有一种不错的方法

467
00:31:20,610 --> 00:31:21,680
那就是2－3－4树

468
00:31:21,900 --> 00:31:23,270
今天要讲的是

469
00:31:23,480 --> 00:31:26,440
怎么把这种形式的树改造成红黑树

470
00:31:26,790 --> 00:31:28,590
而且你会发现  今天的方法

471
00:31:28,690 --> 00:31:29,940
和周五的复习课会讲到的方法

472
00:31:30,160 --> 00:31:31,800
好像没有什么关系

473
00:31:32,150 --> 00:31:34,300
但其实它们是相同的 只是不太明显

474
00:31:38,510 --> 00:31:47,830
这是个好消息

475
00:31:48,100 --> 00:31:50,470
因为我们知道所有的红黑树都是平衡的

476
00:31:50,800 --> 00:31:52,660
只要我们能保证

477
00:31:52,890 --> 00:31:57,910
我们的树总是红黑树 那就没问题

478
00:31:58,230 --> 00:32:01,710
从树高的角度来看 只要树的高度总是log n就行

479
00:32:02,030 --> 00:32:10,320
那么 红黑树的查询

480
00:32:10,580 --> 00:32:14,020
查询跟搜索类似  都是查找一个给定的键

481
00:32:14,290 --> 00:32:17,590
查找最小值 查找最大值

482
00:32:17,890 --> 00:32:22,260
查找下一个 查找上一个

483
00:32:22,550 --> 00:32:24,460
所有的这些查询

484
00:32:24,660 --> 00:32:27,570
我们都知道在二叉树里要怎么做

485
00:32:27,860 --> 00:32:31,190
我们知道如何在树高阶的时间内完成

486
00:32:33,250 --> 00:32:36,520
因为树的高度为log n  所以...

487
00:32:36,570 --> 00:32:43,880
红黑树里所有这些操作 花费时间都为O(log n)

488
00:32:54,840 --> 00:33:13,480
好的 查询比较简单

489
00:33:13,730 --> 00:33:15,200
这里不多加赘述

490
00:33:15,490 --> 00:33:18,280
因为从平衡树出发 没什么难度

491
00:33:18,370 --> 00:33:19,720
红黑树非常平衡

492
00:33:19,950 --> 00:33:22,430
难的部分是更新操作

493
00:33:30,660 --> 00:33:34,040
在这种情况下 更新就是插入和删除

494
00:33:37,540 --> 00:33:40,670
通常 在数据结构里

495
00:33:40,980 --> 00:33:43,840
查询是指访问结构里的数据

496
00:33:44,030 --> 00:33:46,490
更新是指修改结构里的数据

497
00:33:46,730 --> 00:33:48,140
在大部分情况里

498
00:33:48,350 --> 00:33:49,610
我们讨论的都是动态集

499
00:33:49,910 --> 00:33:51,010
我们修改动态集

500
00:33:51,010 --> 00:33:52,420
是通过插入、删除操作

501
00:33:52,780 --> 00:33:54,310
你还可以做查询操作

502
00:33:54,600 --> 00:33:57,810
在优先队列里 还有其它更新操作 像删除最小值

503
00:33:58,390 --> 00:34:02,380
就是先查找最小值 然后再删除它

504
00:34:02,690 --> 00:34:05,960
而这些是我们关注的典型的操作

505
00:34:06,230 --> 00:34:08,000
我们会讨论更新操作 包括这两个

506
00:34:08,000 --> 00:34:09,660
还有查询 所有的这些

507
00:34:09,960 --> 00:34:12,340
或者任何与之相关的

508
00:34:12,670 --> 00:34:14,610
尤其是在练习题里

509
00:34:14,800 --> 00:34:17,080
你会看到各种不同的查询操作

510
00:34:19,510 --> 00:34:22,280
如何进行更新呢？

511
00:34:22,680 --> 00:34:25,570
我们有二叉搜索树插入

512
00:34:26,050 --> 00:34:27,760
也称为树插入

513
00:34:28,020 --> 00:34:30,260
有二叉搜索树删除 简称树删除

514
00:34:31,950 --> 00:34:33,970
这些操作都能保持二叉搜索树的性质

515
00:34:34,320 --> 00:34:36,050
但它们不一定维持树的平衡

516
00:34:36,350 --> 00:34:37,820
我们不断地插入的新元素

517
00:34:38,000 --> 00:34:39,330
但它们一个比一个小

518
00:34:39,340 --> 00:34:41,240
那最后得到的路径就非常长

519
00:34:41,520 --> 00:34:45,950
这样的话 就不能保持红黑树的性质

520
00:34:46,240 --> 00:34:48,500
因为红黑树必须是平衡的

521
00:34:48,810 --> 00:34:51,460
而且 它们还不能满足性质1

522
00:34:51,700 --> 00:34:53,660
刚被我擦掉了 就是说，节点不是红色就是黑色

523
00:34:53,930 --> 00:34:55,900
虽然加了结点 但没给它上色

524
00:34:56,180 --> 00:34:57,720
所以 必须为新结点指定颜色

525
00:34:57,980 --> 00:35:00,150
而且在上色的过程中

526
00:35:00,400 --> 00:35:02,000
我们可能会破坏其它性质

527
00:35:02,230 --> 00:35:03,850
然后又得重新改 恶性循环了

528
00:35:04,050 --> 00:35:06,190
有点棘手 但你要玩转它

529
00:35:06,400 --> 00:35:08,570
并不算特别难

530
00:35:10,250 --> 00:35:15,420
要更新就必须修改树

531
00:35:24,320 --> 00:35:27,440
为了保持红黑性

532
00:35:27,700 --> 00:35:32,110
将会用到三种不同的操作

533
00:35:32,340 --> 00:35:35,880
首先是应用BST的操作

534
00:35:36,190 --> 00:35:37,490
树插入或者树删除

535
00:35:37,800 --> 00:35:39,210
这些已经学过

536
00:35:39,490 --> 00:35:42,360
那我们就按程序走

537
00:35:42,530 --> 00:35:45,440
然后我们还要改变结点的颜色

538
00:35:45,660 --> 00:35:49,160
尤其是新插入的结点 最好先上个颜色

539
00:35:49,510 --> 00:35:51,290
通常 如果移除一个结点

540
00:35:51,550 --> 00:35:53,170
我们也必须重新着色

541
00:35:53,410 --> 00:35:57,740
为周边的结点重新着色

542
00:35:57,750 --> 00:36:01,630
我们还要做另外一种操作...

543
00:36:01,890 --> 00:36:04,230
重新着色只是改成红色或黑色

544
00:36:04,520 --> 00:36:08,060
另一个操作是对树进行重新排列

545
00:36:08,280 --> 00:36:11,950
改变指针 改变从一个结点到另一个的连接

546
00:36:12,250 --> 00:36:14,910
我们会用非常结构化的方法来实现

547
00:36:15,170 --> 00:36:18,040
这也是为什么..

548
00:36:18,280 --> 00:36:20,430
红黑树会这么有趣

549
00:36:20,680 --> 00:36:22,480
这种改变的实现非常简单

550
00:36:22,740 --> 00:36:24,850
而且不会涉及到太多结点

551
00:36:25,120 --> 00:36:27,350
这种方法叫旋转

552
00:36:27,610 --> 00:36:30,000
我们开始讲旋转

553
00:36:44,540 --> 00:36:48,930
这里画的是树的一部分

554
00:36:49,220 --> 00:36:50,540
这样两个结点 A和B

555
00:36:50,770 --> 00:36:51,770
这里是一些子树

556
00:36:51,830 --> 00:36:52,990
用三角形代替

557
00:36:53,040 --> 00:36:54,460
我们不知道它多大

558
00:36:54,720 --> 00:36:57,150
但它们的黑高度应该是一致的

559
00:36:57,440 --> 00:36:58,600
如果这是棵红黑树的话

560
00:36:58,850 --> 00:37:00,360
一般来说 它看起来就是这样的

561
00:37:00,590 --> 00:37:02,220
当然 还有一些父结点和其它部分

562
00:37:02,220 --> 00:37:03,470
但没有画出来

563
00:37:03,870 --> 00:37:05,480
我把这些子树命名为

564
00:37:05,760 --> 00:37:08,130
希腊字母 α，β，γ

565
00:37:09,540 --> 00:37:16,930
然后 我要定义B的右旋转

566
00:37:19,250 --> 00:37:21,760
一般来说 如果有一个结点 假设是B

567
00:37:21,980 --> 00:37:23,170
我想要对它进行右旋转

568
00:37:23,450 --> 00:37:25,830
我先要对着它左边的子结点 重新把图画一遍

569
00:37:26,130 --> 00:37:28,080
包括这两个结点的子树

570
00:37:28,420 --> 00:37:32,140
然后 得出这棵树

571
00:37:43,230 --> 00:37:49,280
我所做的 就是将这条边旋转90°

572
00:37:49,520 --> 00:37:52,630
B的父结点现在成了A的父结点

573
00:37:52,960 --> 00:37:54,480
A变成B新的父结点

574
00:37:54,800 --> 00:37:55,910
子树也重新排序了

575
00:37:55,990 --> 00:37:57,240
之前 这两个都是子树

576
00:37:57,290 --> 00:37:59,120
都是A的子树

577
00:37:59,350 --> 00:38:01,050
另外 γ是B的子树

578
00:38:01,300 --> 00:38:02,580
γ还是B的子树

579
00:38:02,800 --> 00:38:03,850
α还是A的子树

580
00:38:04,060 --> 00:38:08,760
但β却变成B的子树

581
00:38:09,030 --> 00:38:11,590
好的 我们要确认的主要是

582
00:38:11,800 --> 00:38:16,540
这个操作保持了二叉搜索树的性质

583
00:38:16,830 --> 00:38:21,500
记得二叉搜索树的性质是

584
00:38:21,770 --> 00:38:24,450
位于结点左子树上的所有元素

585
00:38:24,710 --> 00:38:27,550
都小于或等于该结点的值

586
00:38:27,810 --> 00:38:29,290
所有位于右子树上的元素

587
00:38:29,560 --> 00:38:31,550
都大于或等于该值

588
00:38:31,830 --> 00:38:35,260
如果这里定义几个结点

589
00:38:35,500 --> 00:38:42,020
a在α里  b在β里  c在γ里

590
00:38:42,290 --> 00:38:47,100
那么 a就小于或等于A

591
00:38:47,310 --> 00:38:48,860
小于或等于b

592
00:38:49,110 --> 00:38:52,200
小于或等于B

593
00:38:52,480 --> 00:38:55,080
小于或等于c

594
00:38:55,380 --> 00:38:57,730
这种情况

595
00:38:58,080 --> 00:39:00,110
在左边和右边都同时成立

596
00:39:00,350 --> 00:39:03,370
因为α在最左边

597
00:39:03,640 --> 00:39:05,830
β在A和B之间

598
00:39:06,020 --> 00:39:07,890
γ在B右边

599
00:39:08,150 --> 00:39:09,850
这边的情形也一样

600
00:39:10,050 --> 00:39:11,780
β还是...它代表所有

601
00:39:11,980 --> 00:39:13,580
位于A和B之间的结点

602
00:39:13,820 --> 00:39:18,790
所以这是成立的 这个操作没有问题

603
00:39:19,000 --> 00:39:20,360
这颗还是二叉搜索树

604
00:39:20,550 --> 00:39:23,350
我们要用一种特别小心的方式来旋转

605
00:39:23,590 --> 00:39:25,730
以确保我们仍然保持这些性质

606
00:39:25,850 --> 00:39:26,920
这是难点

607
00:39:27,190 --> 00:39:29,090
但旋转会是关键点

608
00:39:29,340 --> 00:39:30,950
这是右旋转操作

609
00:39:31,190 --> 00:39:33,520
反过来就是左旋转操作

610
00:39:36,500 --> 00:39:38,890
这是A的左旋转

611
00:39:39,170 --> 00:39:41,950
一般来说 如果有两个结点

612
00:39:42,130 --> 00:39:43,230
我们都用上面结点来表示

613
00:39:43,490 --> 00:39:46,200
所以 B的右旋转会得出这个

614
00:39:46,410 --> 00:39:47,810
A的左旋转会得出那个

615
00:39:48,070 --> 00:39:53,340
这都是可逆的操作 很好

616
00:39:53,530 --> 00:40:00,760
还有就是 它只需花费常数级的操作时间

617
00:40:01,080 --> 00:40:04,940
因为指针的改变量是常数级的

618
00:40:05,140 --> 00:40:07,400
只要知道你想要的结点B

619
00:40:07,590 --> 00:40:10,460
然后把B的左指针设为...

620
00:40:10,700 --> 00:40:12,500
如果你要的是β

621
00:40:12,700 --> 00:40:15,370
就把B的左子树设为A的右子树 以此类推

622
00:40:15,700 --> 00:40:17,220
进行常数次改变

623
00:40:17,460 --> 00:40:18,480
也更新了父结点

624
00:40:18,690 --> 00:40:21,040
只有固定几个连接被改变了

625
00:40:21,300 --> 00:40:23,910
所以 只需要做固定数量的赋值运算

626
00:40:24,130 --> 00:40:28,370
你们之前可能已经见过旋转了

627
00:40:28,760 --> 00:40:35,730
但这次 我们会用得更为复杂

628
00:40:43,630 --> 00:40:45,590
先看一下怎么插入

629
00:40:50,340 --> 00:40:52,790
我们可能会分三部分来讲

630
00:40:58,680 --> 00:41:01,420
首先 我会告诉你基本思路 非常简单

631
00:41:01,670 --> 00:41:03,130
之前提到过一部分

632
00:41:03,350 --> 00:41:06,450
然后 举一个例子 从骨子里来感受它

633
00:41:06,680 --> 00:41:09,400
最后给出伪代码

634
00:41:09,630 --> 00:41:13,610
这样的话 你就可以回家实践一下

635
00:41:13,800 --> 00:41:17,420
这里我应该说 红黑插入

636
00:41:17,740 --> 00:41:20,210
在书里叫做RB插入

637
00:41:20,510 --> 00:41:25,010
RB不是指麦根汽水 而是表示红黑

638
00:41:26,600 --> 00:41:30,290
正如我所说的 首先要做的是

639
00:41:30,480 --> 00:41:32,190
在二叉搜索树里 插入该结点

640
00:41:32,400 --> 00:41:34,060
x变成一个新的叶结点

641
00:41:34,240 --> 00:41:36,400
我们先搜索x要放在哪里

642
00:41:36,580 --> 00:41:38,800
生成...现在不应该叫叶结点

643
00:41:39,080 --> 00:41:41,660
应该说是一个添加到...

644
00:41:41,670 --> 00:41:44,330
是一个内部结点 添加到初始的某个结点下面

645
00:41:44,540 --> 00:41:45,990
可能添加到这里

646
00:41:46,280 --> 00:41:48,750
现在变成它下面有两个叶结点

647
00:41:50,070 --> 00:41:52,090
因为它没有内部的子结点

648
00:41:52,360 --> 00:41:54,980
然后我们要给它选一种颜色

649
00:41:55,170 --> 00:42:00,210
选择红色

650
00:42:01,520 --> 00:42:05,630
为什么是红色？我们必须选这两种颜色之一

651
00:42:05,820 --> 00:42:07,730
抛硬币或许管用

652
00:42:07,940 --> 00:42:09,880
但这只会把事情弄得更乱

653
00:42:10,170 --> 00:42:14,550
我们添加的是一个新结点

654
00:42:14,750 --> 00:42:16,140
它不大可能是根结点或者叶结点

655
00:42:16,500 --> 00:42:19,240
所以根据性质2  它不一定是黑颜色

656
00:42:19,490 --> 00:42:22,490
性质3 每个红结点有一个黑色的父结点

657
00:42:22,730 --> 00:42:24,330
这可能是个问题

658
00:42:24,550 --> 00:42:28,270
如果它的父结点是红色的 就会有问题

659
00:42:28,490 --> 00:42:31,870
那就破坏了性质2

660
00:42:32,100 --> 00:42:43,880
父结点可能是红色 抱歉 应该是性质3

661
00:42:44,140 --> 00:42:49,520
但好消息是 性质4仍然成立

662
00:42:49,760 --> 00:42:51,220
因为性质4是计算

663
00:42:51,310 --> 00:42:52,560
每条路径的黑结点数

664
00:42:52,740 --> 00:42:54,590
那确实是难以保持的性质

665
00:42:54,760 --> 00:42:56,670
如果只是添加一个新的红结点

666
00:42:56,860 --> 00:42:58,500
所有黑高度不变

667
00:42:58,680 --> 00:43:01,270
沿着路径的黑结点数不变

668
00:43:01,490 --> 00:43:03,310
所以性质4仍然成立

669
00:43:03,560 --> 00:43:06,640
唯一可能破坏的是性质3

670
00:43:06,880 --> 00:43:08,550
这很正常

671
00:43:08,760 --> 00:43:11,530
一开始肯定会破坏一些设定

672
00:43:11,710 --> 00:43:13,830
因为这不是简单的二叉树的插入

673
00:43:16,150 --> 00:43:22,940
好的 我们在这树上做一些试验

674
00:43:28,030 --> 00:43:31,720
应该说 如何弥补这个

675
00:43:31,930 --> 00:43:35,960
如何弥补性质3

676
00:43:36,270 --> 00:43:43,820
我们要把性质3的破坏往上移

677
00:43:45,440 --> 00:43:48,050
从结点x开始

678
00:43:48,140 --> 00:43:49,500
往根结点上移

679
00:43:49,770 --> 00:43:54,210
这要重新上色

680
00:43:54,290 --> 00:43:55,700
最开始唯一做的事

681
00:43:55,900 --> 00:43:58,620
就是重新着色 直到某个点

682
00:44:02,820 --> 00:44:06,560
再改用旋转来弥补

683
00:44:17,840 --> 00:44:20,060
——很可能还要重新着色

684
00:44:25,850 --> 00:44:29,240
好的 我们从例子里看一下这个算法

685
00:44:29,530 --> 00:44:32,110
我要把这棵树重抄一遍

686
00:44:32,330 --> 00:44:33,760
你们也应该抄下来

687
00:44:34,020 --> 00:44:37,070
我将重新画一次 不去改变那副图

688
00:44:51,780 --> 00:44:54,550
好 我们有这颗漂亮的红黑树

689
00:44:54,850 --> 00:45:09,160
然后 我们尝试插入一个新的值15

690
00:45:14,200 --> 00:45:20,980
22是黑结点 好的 应该是一样的树

691
00:45:21,290 --> 00:45:24,840
现在我选择15做为插入的值

692
00:45:25,030 --> 00:45:27,750
因为它会让这插入操作 变得相当有意思

693
00:45:28,030 --> 00:45:30,190
有时 插入并不会花太大功夫

694
00:45:30,390 --> 00:45:31,680
只要旋转一下就行了

695
00:45:31,860 --> 00:45:36,810
我只是想让大家看一个有意思的例子

696
00:45:37,000 --> 00:45:39,170
插入15 15大于7

697
00:45:39,340 --> 00:45:40,700
小于18 大于10

698
00:45:40,890 --> 00:45:42,700
大于11 所以15落在这里

699
00:45:42,930 --> 00:45:47,140
所以 我们添加了一个新的红结点15

700
00:45:47,410 --> 00:45:51,470
它下面有两个黑色叶结点

701
00:45:51,760 --> 00:45:53,760
换掉一个黑色叶结点 现在变成两个

702
00:45:54,060 --> 00:46:04,450
现在 它违反了性质3

703
00:46:04,760 --> 00:46:07,610
因为给一个红结点 添加了一个红的子结点

704
00:46:07,820 --> 00:46:10,300
现在从根到叶的一条路径上 出现了两个连续的红结点

705
00:46:10,600 --> 00:46:12,220
如果把它设成黑色

706
00:46:12,430 --> 00:46:13,800
则会搞乱黑高度

707
00:46:14,010 --> 00:46:16,770
因为对于这个结点 从这出发有1个黑结点

708
00:46:16,940 --> 00:46:18,550
而沿着这条路 则会有2个黑结点

709
00:46:18,550 --> 00:46:22,160
所以不能直接改颜色 我们要怎么办？

710
00:46:22,410 --> 00:46:23,910
那么  试一下重新着色吧

711
00:46:31,140 --> 00:46:36,440
最近又变得天然呆了

712
00:46:36,690 --> 00:46:41,690
弥补的方法是重新上色

713
00:46:41,940 --> 00:46:43,950
我的第一个感觉就是 坑爹啊

714
00:46:44,160 --> 00:46:46,090
因为在这周边 重新上色

715
00:46:46,330 --> 00:46:48,000
看起来没有用

716
00:46:48,510 --> 00:46:50,560
因为这个是红色的

717
00:46:50,770 --> 00:46:51,900
而这边则是一个黑色结点

718
00:46:52,100 --> 00:46:54,090
所以不能让这个结点变红 这个变黑

719
00:46:54,350 --> 00:46:55,410
没什么作用

720
00:46:55,600 --> 00:47:00,520
如果向上看 在15的爷爷结点这儿

721
00:47:00,740 --> 00:47:03,760
有一个黑结点和两个红色子结点

722
00:47:04,020 --> 00:47:06,270
这是非常好的消息

723
00:47:06,530 --> 00:47:11,300
因为我们能换过来 变成两个黑色子结点

724
00:47:11,510 --> 00:47:14,400
和一个红色父结点 这在局部是没问题的

725
00:47:14,720 --> 00:47:16,940
不会改变任何黑高度

726
00:47:17,140 --> 00:47:19,700
因为之前任何经过这个结点的路径

727
00:47:19,890 --> 00:47:22,520
仍然会经过相同数量的黑结点

728
00:47:22,750 --> 00:47:25,020
相对于经过这里的黑色父结点

729
00:47:25,220 --> 00:47:26,830
变成了经过下面两个黑色子结点

730
00:47:27,030 --> 00:47:29,240
因为路径总是下降到叶结点

731
00:47:29,490 --> 00:47:32,830
这就是要做的 给这些结点重新着色

732
00:47:33,110 --> 00:47:37,110
会得到10是红色的

733
00:47:37,400 --> 00:47:42,250
8是黑色的 11是黑色的

734
00:47:42,490 --> 00:47:45,860
这些叶结点不变

735
00:47:46,100 --> 00:47:48,370
其余的都不变

736
00:47:48,620 --> 00:47:49,630
15是红的

737
00:47:49,820 --> 00:47:51,080
不再有违例

738
00:47:51,270 --> 00:47:54,500
15没问题了 因为它的父结点是黑色的

739
00:47:54,730 --> 00:47:57,580
但现在 18这里又出现了一个新的违例

740
00:47:57,800 --> 00:47:59,870
因为18也是红色的

741
00:48:00,100 --> 00:48:03,290
这是唯一的违例

742
00:48:03,480 --> 00:48:04,870
通常 在任意时刻

743
00:48:05,050 --> 00:48:08,020
我们最多只有1个违例 直到弥补好一切

744
00:48:08,250 --> 00:48:10,230
然后就没有违例了

745
00:48:18,680 --> 00:48:26,220
现在 10和18之间有一个违例

746
00:48:30,010 --> 00:48:31,760
总觉得有些不自然

747
00:48:32,010 --> 00:48:36,930
我必须再看一下小抄  没错吧？

748
00:48:37,240 --> 00:48:40,130
妥妥的 继续讲课

749
00:48:40,330 --> 00:48:41,890
不能再重新着色了

750
00:48:42,140 --> 00:48:46,190
我还能再战  我们要做的

751
00:48:46,190 --> 00:48:47,990
是再看一次10的祖父结点

752
00:48:48,220 --> 00:48:50,020
现在是7 树的根结点

753
00:48:50,230 --> 00:48:53,290
它是黑色的 但只有一个黑色子结点

754
00:48:53,510 --> 00:48:55,710
另一个是红的 不能再用刚才的方法

755
00:48:55,730 --> 00:48:57,120
将7的黑色

756
00:48:57,400 --> 00:48:59,590
转移到两个子结点上

757
00:48:59,790 --> 00:49:01,050
先不说 根结点必须是黑色的

758
00:49:01,280 --> 00:49:02,440
先不说那个性质

759
00:49:02,810 --> 00:49:05,880
我们不能让两个为黑 让这个变红

760
00:49:05,970 --> 00:49:07,680
因为这样会导致不平衡

761
00:49:07,890 --> 00:49:09,750
这个已经是黑结点了

762
00:49:09,950 --> 00:49:11,900
从这边下去的路径

763
00:49:12,160 --> 00:49:14,300
会比这条路径少一个黑结点

764
00:49:14,520 --> 00:49:17,100
所以 不能将7和它的子结点重新着色

765
00:49:17,350 --> 00:49:19,910
那就换种方法 进行旋转操作

766
00:49:20,160 --> 00:49:21,460
在最后这里旋转会好一点

767
00:49:21,680 --> 00:49:24,320
旋转这条边

768
00:49:24,510 --> 00:49:27,600
把18旋转到右边

769
00:49:27,800 --> 00:49:37,480
所以下个操作是18的右旋转

770
00:50:00,520 --> 00:50:03,280
但这之后 我们要减少一个操作

771
00:50:03,560 --> 00:50:05,690
好的 我们右旋转18

772
00:50:05,900 --> 00:50:09,690
根结点不变：7，3，它的子结点

773
00:50:09,910 --> 00:50:13,720
右边的子结点不再是18

774
00:50:14,060 --> 00:50:18,330
变为10 18变成10的红色子结点

775
00:50:20,750 --> 00:50:27,070
8在这里 和它两个子结点

776
00:50:27,350 --> 00:50:31,590
11和15是位于10和18之间的子树

777
00:50:31,990 --> 00:50:39,790
移到这里：11和15

778
00:50:44,490 --> 00:50:46,080
然后 是右边的子树

779
00:50:46,290 --> 00:50:47,470
所有在18右边的

780
00:50:47,710 --> 00:50:52,960
移到这里：22和26

781
00:50:53,210 --> 00:50:58,260
希望这过程中 我没有改变任何颜色

782
00:51:00,340 --> 00:51:01,740
如果有 告诉我

783
00:51:01,960 --> 00:51:05,880
看起来不错 但还是有这个违例

784
00:51:06,120 --> 00:51:08,920
还是在10和18之间的麻烦

785
00:51:09,150 --> 00:51:11,210
但树变得更直了

786
00:51:11,430 --> 00:51:13,590
这正是我想要的

787
00:51:13,810 --> 00:51:16,340
它让18这个违例者

788
00:51:16,580 --> 00:51:19,050
与其祖父结点 形成一个直的连接

789
00:51:19,140 --> 00:51:20,390
两个都在右 或者两个都在左

790
00:51:20,610 --> 00:51:22,370
这里我们左转右转

791
00:51:22,570 --> 00:51:23,980
把树变直了

792
00:51:24,150 --> 00:51:27,720
但它看起来没有之前的树平衡

793
00:51:27,880 --> 00:51:28,890
实际上 变得更糟了

794
00:51:29,100 --> 00:51:31,950
但现在我们可以旋转这几个结点

795
00:51:32,180 --> 00:51:34,760
或者说 旋转这条边

796
00:51:34,980 --> 00:51:40,110
将7旋转到左边 让10变成根结点

797
00:51:40,340 --> 00:51:42,430
这样看起来会更平衡

798
00:51:46,530 --> 00:51:52,920
这是7的左旋转操作

799
00:51:53,180 --> 00:51:56,110
同时我也要重新上色

800
00:51:56,370 --> 00:52:01,140
这样我可以少画一张图

801
00:52:01,380 --> 00:52:03,750
根结点必须是黑色

802
00:52:03,960 --> 00:52:05,470
所以10必为黑结点

803
00:52:05,670 --> 00:52:09,450
让7变为红色 这是一个变化

804
00:52:09,700 --> 00:52:11,240
剩下的只是旋转了

805
00:52:13,680 --> 00:52:16,320
18在这里

806
00:52:16,510 --> 00:52:21,400
最终还是要通过旋转来保持红黑性

807
00:52:25,380 --> 00:52:29,470
8在7和10中间

808
00:52:29,710 --> 00:52:39,370
移到这里 11移到10和18之间 在这里

809
00:52:45,130 --> 00:52:49,590
22和26在18后面

810
00:52:56,800 --> 00:53:00,720
如果好运的话  这应该会满足所有的性质

811
00:53:00,970 --> 00:53:02,320
所有结点非红即黑

812
00:53:02,600 --> 00:53:05,700
所有红结点都有一个黑色子结点

813
00:53:05,910 --> 00:53:07,370
这是我们最后改动的地方

814
00:53:07,640 --> 00:53:08,670
红结点有黑色子结点

815
00:53:08,840 --> 00:53:11,680
所有的黑高度都很明确

816
00:53:11,910 --> 00:53:15,580
对于每个结点 在到叶结点的所有路径上

817
00:53:15,780 --> 00:53:18,730
黑结点的数量都一致

818
00:53:18,980 --> 00:53:21,850
你可以验证一下 这之前它是成立的

819
00:53:22,060 --> 00:53:25,790
而这边 经过一些重新上色等小改动后

820
00:53:26,050 --> 00:53:27,260
它仍然成立

821
00:53:27,500 --> 00:53:31,430
我是指 你可以在旋转的位置附近 进行验证

822
00:53:31,680 --> 00:53:33,380
其实一会儿 我们也会这么做

823
00:53:33,560 --> 00:53:35,200
现在只是个例子

824
00:53:35,400 --> 00:53:38,100
你可能不明白 这些重新上色和旋转操作...

825
00:53:38,280 --> 00:53:40,150
它们为什么可行  但它们确实有效

826
00:53:40,360 --> 00:53:42,790
但这至少能说服你 它是可用的

827
00:53:43,000 --> 00:53:46,210
现在 我要给出一个通用的算法

828
00:53:46,460 --> 00:53:48,520
在继续讲之前 大家还有什么问题？

829
00:53:52,510 --> 00:53:57,630
它不是绝对的 我先把算法写下来

830
00:53:57,690 --> 00:54:00,070
算法不是凭直觉得来的

831
00:54:00,290 --> 00:54:05,580
像红黑树这种经常用到的算法

832
00:54:05,770 --> 00:54:09,180
不能仅凭直觉 就对其进行重新上色和旋转操作

833
00:54:09,330 --> 00:54:11,520
必须给这些操作一个严谨的约束

834
00:54:11,670 --> 00:54:13,680
我要怎么做？ 先试着重新上色

835
00:54:13,860 --> 00:54:16,220
如果可行 问题可以继续

836
00:54:16,440 --> 00:54:19,680
树高为log n层  O(log n)层

837
00:54:19,980 --> 00:54:21,790
所以要花费O(log n)的时间

838
00:54:21,980 --> 00:54:23,070
在某个步骤 可能会卡住

839
00:54:23,180 --> 00:54:24,540
不能再重新着色了

840
00:54:24,720 --> 00:54:27,190
这时做一些旋转操作就行了

841
00:54:27,410 --> 00:54:29,640
一般两次旋转就能够了

842
00:54:29,850 --> 00:54:33,460
就这样重复 最后总能解决

843
00:54:33,680 --> 00:54:46,000
接下来就是方法...先假设有一棵红黑树

844
00:54:46,190 --> 00:54:47,900
要插入的值为x

845
00:54:48,110 --> 00:54:49,910
算法如下

846
00:54:50,120 --> 00:54:52,720
首先 将x插入BST

847
00:54:52,940 --> 00:54:59,740
然后 将新结点设为红色

848
00:54:59,940 --> 00:55:02,700
这里要用到一个 略微精确的定义

849
00:55:02,920 --> 00:55:05,940
颜色是x的一个域

850
00:55:08,560 --> 00:55:10,810
然后我们要一直往上走

851
00:55:10,970 --> 00:55:13,960
用一个循环的算法 直到根结点为止

852
00:55:15,070 --> 00:55:19,510
或者x变为一个黑结点

853
00:55:26,580 --> 00:55:28,610
一般来说 x一开始代表着...

854
00:55:28,820 --> 00:55:30,630
要插入的元素

855
00:55:30,830 --> 00:55:32,130
但我们要把x往上移

856
00:55:32,330 --> 00:55:34,360
如果发现x是一个黑结点

857
00:55:34,540 --> 00:55:36,850
我们会很满意 因为它的父结点可能是红色

858
00:55:37,020 --> 00:55:38,520
也可能不是 但无所谓

859
00:55:38,680 --> 00:55:41,050
黑结点可以拥有任意颜色的父结点

860
00:55:41,280 --> 00:55:43,030
我们担心的只是红结点的情况

861
00:55:43,250 --> 00:55:45,580
如果x是红色 那继续这个循环算法

862
00:55:47,350 --> 00:55:50,150
当然 这里写错了

863
00:55:50,390 --> 00:55:54,250
当颜色为红色时 就不断地循环

864
00:55:58,130 --> 00:56:02,260
所以这里分3种情况 或者6种

865
00:56:02,470 --> 00:56:04,290
这要看你怎么算

866
00:56:04,500 --> 00:56:07,300
这是一个记忆的小技巧

867
00:56:13,100 --> 00:56:18,670
因为也有一些对称的情况

868
00:56:18,900 --> 00:56:24,060
让我把它画下来 我们所讨论的是

869
00:56:24,230 --> 00:56:27,820
是x和它祖父结点之间的部分

870
00:56:28,060 --> 00:56:29,920
这里用p[x]来表示

871
00:56:30,120 --> 00:56:31,640
x的父结点 这样更简洁

872
00:56:31,860 --> 00:56:34,400
所以p[p[x]]表示x的祖父结点

873
00:56:34,660 --> 00:56:37,840
left[p[p[x]]]就是左子结点

874
00:56:38,050 --> 00:56:40,670
我们关注的是x

875
00:56:40,870 --> 00:56:45,110
如果我不画箭头 x是p[x]的子结点

876
00:56:45,340 --> 00:56:51,860
p[x]是祖父结点p[p[x]]的子结点

877
00:56:52,070 --> 00:56:53,550
实际上 这些关系线不是垂直的

878
00:56:53,630 --> 00:56:55,070
或者是左 或者是右

879
00:56:55,290 --> 00:56:56,530
但我关注的是...

880
00:56:56,760 --> 00:57:00,210
我想知道 父结点是不是

881
00:57:00,410 --> 00:57:01,940
祖父结点的左子结点

882
00:57:02,150 --> 00:57:12,350
我想知道 它是不是这个样子的？

883
00:57:12,700 --> 00:57:14,860
我不知道x是它父结点的

884
00:57:15,050 --> 00:57:17,340
左子结点还是右子结点

885
00:57:17,540 --> 00:57:19,920
但x的父结点是p[p[x]]的左子结点

886
00:57:20,150 --> 00:57:21,940
还是它的右子结点？

887
00:57:22,180 --> 00:57:26,500
这两种情况完全对称

888
00:57:26,710 --> 00:57:29,470
但我要假设是其中的一种

889
00:57:29,660 --> 00:57:31,480
否则我画不了图

890
00:57:31,710 --> 00:57:37,210
假设是这样 我们称之为A类

891
00:57:37,450 --> 00:57:39,120
这是B类

892
00:57:39,340 --> 00:57:42,120
我会告诉你在A类的情况下要怎么做

893
00:57:42,400 --> 00:57:45,010
B类是对称的 只需要左换成右

894
00:57:45,360 --> 00:57:49,220
这是A类

895
00:57:52,600 --> 00:57:57,360
在A类里还分三种情况

896
00:57:57,710 --> 00:57:59,020
在B类里

897
00:57:59,230 --> 00:58:00,840
也有三种同样的情况 只是反过来了

898
00:58:01,100 --> 00:58:10,450
我们要做的是查看祖父结点的另一个子结点

899
00:58:16,020 --> 00:58:17,820
这也是为什么我们要知道

900
00:58:18,050 --> 00:58:20,310
它属于哪一种情况的原因

901
00:58:20,540 --> 00:58:23,470
如果x的父结点是祖父结点的左子结点

902
00:58:23,880 --> 00:58:25,780
那我们就看一下祖父的另外一个子结点

903
00:58:25,990 --> 00:58:28,980
也就是祖父的右子结点 设该结点为y

904
00:58:29,180 --> 00:58:32,660
也可以看成是x的大叔结点或大婶结点

905
00:58:32,860 --> 00:58:34,550
这要看y是男还是女

906
00:58:34,810 --> 00:58:39,860
好的 这是大叔或大婶

907
00:58:40,120 --> 00:58:41,790
不幸的是 在英语里

908
00:58:42,000 --> 00:58:45,480
就我所知 还没有无性别的版本

909
00:58:45,740 --> 00:58:49,300
有家长结点和子结点 但没有叔婶结点

910
00:58:49,550 --> 00:58:50,800
我们肯定能想到一个

911
00:58:50,990 --> 00:58:54,960
但我不打算尝试 因为一定很坑爹

912
00:58:55,180 --> 00:58:59,590
为什么我这么在乎y呢？

913
00:58:59,860 --> 00:59:02,250
因为我想知道 能不能做重新上色这个步骤

914
00:59:02,500 --> 00:59:03,980
重新上色的思路是...

915
00:59:04,220 --> 00:59:06,920
假设祖父结点是黑色

916
00:59:07,140 --> 00:59:11,010
如果我能将祖父结点的黑色

917
00:59:11,260 --> 00:59:12,710
向下转移给两个子结点

918
00:59:12,940 --> 00:59:17,210
换个角度 如果两个子结点都是红色的 那就解决了

919
00:59:17,430 --> 00:59:18,780
那我就能把问题往上移

920
00:59:19,000 --> 00:59:20,390
p[p[x]]变为红色  p[x]变成黑结点

921
00:59:20,590 --> 00:59:21,680
这两个都没问题了

922
00:59:21,880 --> 00:59:23,660
这虽然可能与曾祖父结点冲突

923
00:59:23,890 --> 00:59:27,250
但我们继续向上执行这个步骤 那就没问题

924
00:59:27,520 --> 00:59:30,150
如果运气好的话 y是红的

925
00:59:30,440 --> 00:59:32,260
然后直接重新上色

926
00:59:35,940 --> 00:59:47,590
如果y是红色 则重新上色

927
00:59:47,830 --> 00:59:52,630
我会把它归入情形一的图里

928
00:59:54,540 --> 00:59:56,780
好的 我先说一下分别是哪几种情形

929
00:59:56,980 --> 00:59:58,810
再分别看一下它们如何运作

930
01:00:14,310 --> 01:00:18,160
如果不是情形一

931
01:00:18,370 --> 01:00:20,420
这个else应该和上面对齐

932
01:00:20,650 --> 01:00:24,820
那就会是情形二或情形三

933
01:00:25,040 --> 01:00:27,740
这又分为两种情形

934
01:00:32,370 --> 01:00:35,650
实际上我们见过所有的情形

935
01:00:35,860 --> 01:00:39,180
也许不是A相对于B 但在最开始

936
01:00:39,410 --> 01:00:41,000
我们讲重新上色的时候 见过这种情形

937
01:00:41,190 --> 01:00:43,510
那是情形一 而第二种情形则是...

938
01:00:43,700 --> 01:00:48,020
那个蛋疼的祖父结点和10...

939
01:00:48,270 --> 01:00:50,710
就是7和10的不在直线上

940
01:00:50,940 --> 01:00:52,040
是Z形的

941
01:00:52,260 --> 01:00:53,860
情形二是当它们为Z形时

942
01:00:54,100 --> 01:01:01,540
如果x是父结点的右子结点

943
01:01:01,860 --> 01:01:05,820
而父结点 又是祖父结点的左子结点

944
01:01:06,060 --> 01:01:08,700
这就是目前所假设的情形二

945
01:01:14,340 --> 01:01:18,900
另一种情形是 x是父结点的左子结点

946
01:01:19,100 --> 01:01:20,640
那么左边就成链状

947
01:01:20,640 --> 01:01:23,050
x  x的父结点  x的祖父结点

948
01:01:23,290 --> 01:01:24,480
这就是情形三

949
01:01:27,450 --> 01:01:30,010
这里没有写“其它”

950
01:01:30,320 --> 01:01:33,170
因为情形三是由情形二简化得出的

951
01:01:33,450 --> 01:01:35,450
所以在情形二 我们要做这些额外操作

952
01:01:35,550 --> 01:01:37,160
然后 是下面的操作

953
01:01:37,330 --> 01:01:39,130
如果是情形三 只需要做这些操作

954
01:01:39,350 --> 01:01:41,140
在情形一 只要做这些操作

955
01:01:41,410 --> 01:01:45,640
然后 这就完成了A类的三种情形

956
01:01:45,900 --> 01:01:53,480
回到这个if  这个else指的是B类

957
01:01:55,810 --> 01:01:58,680
和A类一样

958
01:02:01,820 --> 01:02:06,410
但左右是互换的

959
01:02:11,710 --> 01:02:15,920
非常自然

960
01:02:16,140 --> 01:02:17,560
每次提到的“左”

961
01:02:17,770 --> 01:02:19,730
都换成“右” 或者反过来

962
01:02:19,950 --> 01:02:23,050
只需要将所有左右翻转

963
01:02:23,240 --> 01:02:27,230
我们只把A类作为重点

964
01:02:27,430 --> 01:02:29,990
看一下这三种情形分别 该如何处理

965
01:02:30,220 --> 01:02:31,330
我们已经在一个例子里看过了

966
01:02:31,550 --> 01:02:37,380
但更一般化的算法 我们写在这儿

967
01:02:45,240 --> 01:02:50,120
不好意思 这个算法还有一步

968
01:02:50,430 --> 01:02:55,420
不是跟这里对齐的 这一步是给根结点上色

969
01:02:55,650 --> 01:02:57,630
所有这些操作 都有可能

970
01:02:57,850 --> 01:02:59,010
让根结点变为红色

971
01:02:59,220 --> 01:03:00,880
我们想要根结点总为黑色

972
01:03:01,100 --> 01:03:05,330
如果它为红 则在算法最后将它设为黑色

973
01:03:07,400 --> 01:03:11,460
这个并不影响黑高度的性质

974
01:03:11,640 --> 01:03:14,510
所有性质都依然成立 因为每条路径...

975
01:03:14,730 --> 01:03:17,920
要么都经过根结点 要么都不经过 每条x到叶的路径

976
01:03:18,180 --> 01:03:21,670
所以 把根结点从红色变为黑色是没有问题的

977
01:03:21,920 --> 01:03:24,330
虽然会增加每条路径的黑高度

978
01:03:24,530 --> 01:03:28,080
但所有路径的黑高度仍保持一致

979
01:03:28,320 --> 01:03:30,490
全部都加1

980
01:03:31,540 --> 01:03:34,280
回到这三种情形

981
01:03:34,470 --> 01:03:42,300
我还要用一些定义

982
01:03:42,520 --> 01:03:45,330
还记得吗 当我们定义旋转时

983
01:03:45,540 --> 01:03:49,830
我们用三角形来表示任意一个子树

984
01:03:50,070 --> 01:03:52,720
我们用一个顶角带点的三角形

985
01:03:52,960 --> 01:04:02,310
来表示有黑色根结点的子树

986
01:04:02,560 --> 01:04:06,760
虽然填充的是白色 但实际上它是黑结点

987
01:04:07,000 --> 01:04:08,660
因为它是写在黑板上

988
01:04:08,850 --> 01:04:20,450
好的  同时它还有一个性质

989
01:04:20,620 --> 01:04:24,000
每个三角形的黑高度一致

990
01:04:27,010 --> 01:04:29,360
这样能确保

991
01:04:29,530 --> 01:04:32,970
黑高度性质 就是性质4能被观察得到

992
01:04:33,170 --> 01:04:37,670
讲一下情形一

993
01:04:37,940 --> 01:04:41,130
我们总要保证性质4不被破坏

994
01:04:41,350 --> 01:04:42,690
因为如果破坏了就很难改回来

995
01:04:42,940 --> 01:04:45,260
它代表的是树的平衡性

996
01:04:45,490 --> 01:04:49,470
假设有一些结点

997
01:04:49,710 --> 01:04:54,510
C结点 左子结点A 右子结点B

998
01:04:54,770 --> 01:04:57,650
还有其下的一些子树

999
01:04:57,960 --> 01:05:00,670
所有子树都有相同的黑高度

1000
01:05:00,920 --> 01:05:04,830
换句话说 它们都在同一层

1001
01:05:10,140 --> 01:05:13,840
好吧 这不是我想要的

1002
01:05:14,040 --> 01:05:18,510
抱歉了 假设这是x结点

1003
01:05:18,730 --> 01:05:21,310
x是红色 而且它的父结点为红

1004
01:05:21,570 --> 01:05:22,890
因此 需要改变某些结构

1005
01:05:23,100 --> 01:05:25,600
看一下另一边的结点y

1006
01:05:25,880 --> 01:05:29,710
假设里面的键值是D

1007
01:05:29,920 --> 01:05:35,560
这个结点称为y 同样也有一些子树

1008
01:05:35,780 --> 01:05:38,400
都有相同的黑高度

1009
01:05:38,630 --> 01:05:42,290
如果所有这些结点都是红的

1010
01:05:42,500 --> 01:05:45,340
则所有这些结点都有相同的黑高度

1011
01:05:45,590 --> 01:05:47,480
因此 所有这些

1012
01:05:47,670 --> 01:05:48,800
有黑色根结点的子树

1013
01:05:49,000 --> 01:05:51,410
同样也有相同的黑高度

1014
01:05:51,610 --> 01:05:57,690
把这看成是拥有大量红色子结点的黑结点

1015
01:05:57,890 --> 01:06:01,130
它的所有子结点恰好都是红色的

1016
01:06:01,330 --> 01:06:03,690
在情形一里 因为红色是可以被合并的

1017
01:06:03,890 --> 01:06:07,000
如果转换成2－3－4树

1018
01:06:07,190 --> 01:06:08,870
或者试着转换

1019
01:06:09,080 --> 01:06:11,630
这里所有红结点 都会合并到这一个结点里

1020
01:06:11,820 --> 01:06:13,570
这就是所要做的

1021
01:06:13,770 --> 01:06:15,550
尽管这个不是2－3－4树

1022
01:06:15,730 --> 01:06:17,560
因为它有5个子结点 相当糟糕

1023
01:06:17,770 --> 01:06:19,020
这也是要做弥补的原因

1024
01:06:19,250 --> 01:06:25,680
情形一需要重新着色

1025
01:06:25,930 --> 01:06:27,910
取结点C

1026
01:06:28,060 --> 01:06:29,880
我们不是要把C设为黑 让A和D为红

1027
01:06:30,100 --> 01:06:32,260
而是把A和D设为黑 C设为红

1028
01:06:32,470 --> 01:06:42,130
这样 C是红色 A是黑色 D是黑色

1029
01:06:42,370 --> 01:06:46,300
子树不变

1030
01:06:46,510 --> 01:06:48,050
B也不变 还是红色

1031
01:06:53,000 --> 01:06:56,390
接下来 要检查这颗树是否仍保持性质4

1032
01:06:56,600 --> 01:06:58,770
是不是所有路径的黑结点数一致

1033
01:06:58,970 --> 01:07:01,460
这是成立的 因为所有子树都没有改动

1034
01:07:01,640 --> 01:07:03,070
仍然有着相同的黑高度

1035
01:07:03,260 --> 01:07:06,050
如果你观察任意一条路径 例如

1036
01:07:06,240 --> 01:07:08,450
所有从A出发的路径 都有这个黑高度

1037
01:07:08,640 --> 01:07:11,870
所有从C出发的路径 都是这个黑高度加1

1038
01:07:12,080 --> 01:07:15,130
因为在所有左边的路径上 都多了个黑结点

1039
01:07:15,390 --> 01:07:17,170
在所有右边的路径上 也都多了个黑结点

1040
01:07:17,420 --> 01:07:20,240
因此 所有黑结点数相等

1041
01:07:20,480 --> 01:07:22,780
所以它保持着性质4

1042
01:07:23,000 --> 01:07:25,380
而且 它也把这一块的性质3给改好了

1043
01:07:25,450 --> 01:07:27,710
因为B之前跟A是冲突的

1044
01:07:27,880 --> 01:07:30,330
现在B没有违反任何东西

1045
01:07:30,640 --> 01:07:33,930
C反而可能是违例

1046
01:07:34,230 --> 01:07:35,630
所以 我们要把x指向...

1047
01:07:35,800 --> 01:07:38,680
新的x的值 将指向C

1048
01:07:38,890 --> 01:07:42,760
之前x的值是B 现在向上移了几层

1049
01:07:42,980 --> 01:07:45,280
同样 在原来的树里

1050
01:07:45,460 --> 01:07:46,850
x也向上移了几层

1051
01:07:47,020 --> 01:07:48,690
就这样向上不断修正这棵树

1052
01:07:48,900 --> 01:07:50,790
然后继续这个循环

1053
01:07:50,990 --> 01:07:54,730
这是情形一：重新上色 向上查找

1054
01:07:54,980 --> 01:07:59,180
C可能会与它的父结点冲突 但这必须用递归来解决

1055
01:07:59,410 --> 01:08:03,990
应该说 我们是在递归 或者是从C继续循环

1056
01:08:07,010 --> 01:08:10,580
现在看一下情形二

1057
01:08:36,810 --> 01:08:43,060
那我继续通过图 来说明这个算法

1058
01:08:43,300 --> 01:08:47,530
这真是个不错的、"可视化"的编程语言

1059
01:08:55,630 --> 01:08:58,360
我们来画一下情形二

1060
01:09:02,210 --> 01:09:04,860
我忘了说情形一的某个内容了

1061
01:09:05,110 --> 01:09:08,990
那么 我在这里画了一些图

1062
01:09:09,140 --> 01:09:11,360
但我最后得出的什么？

1063
01:09:11,560 --> 01:09:14,730
我们再看一下 那个相反的算法

1064
01:09:14,930 --> 01:09:18,320
我们假设 现在是A类的情况

1065
01:09:18,530 --> 01:09:21,270
换句话说 父结点是祖父结点的左子结点

1066
01:09:21,510 --> 01:09:24,090
也就是说 已知A是C的左子结点

1067
01:09:24,280 --> 01:09:25,570
因此 y是右子结点

1068
01:09:25,760 --> 01:09:27,810
D是C的右子结点

1069
01:09:28,040 --> 01:09:29,380
实际上 我并不知道

1070
01:09:29,550 --> 01:09:30,950
B到底是右子结点 还是左子结点

1071
01:09:31,120 --> 01:09:34,180
关系不大 在情形一里并不影响

1072
01:09:34,370 --> 01:09:39,980
虽然A的子结点可能在反方向上

1073
01:09:40,240 --> 01:09:42,950
但实际上都一样

1074
01:09:51,850 --> 01:09:54,370
我之所以说这个 是因为情形二里它是有影响的

1075
01:09:54,380 --> 01:09:56,920
在情形一里 我们不用关注这个

1076
01:09:57,110 --> 01:10:02,340
但在情形二里 我们就要关注...情形二在上面

1077
01:10:02,590 --> 01:10:05,610
x是右子结点还是左子结点？

1078
01:10:05,820 --> 01:10:07,610
如果它是右子结点 那就是情形二

1079
01:10:07,840 --> 01:10:10,580
那这里 我们已知x是在这里

1080
01:10:10,790 --> 01:10:14,110
也就是B——A的右子结点

1081
01:10:14,390 --> 01:10:16,270
情形一里 我既不清楚也不在乎

1082
01:10:16,530 --> 01:10:18,700
现在 我们假设它是这种情况

1083
01:10:19,030 --> 01:10:20,780
y还是在另一边

1084
01:10:21,030 --> 01:10:24,810
而且 已知y是黑色的

1085
01:10:25,050 --> 01:10:28,760
所以 这里的y是一个黑结点

1086
01:10:29,010 --> 01:10:30,470
现在 如果我用合并的技巧

1087
01:10:30,710 --> 01:10:34,880
把所有这些结点：A，B，C合并到一起

1088
01:10:35,080 --> 01:10:37,900
那我就只有四个子结点 看起来非常不错

1089
01:10:38,120 --> 01:10:39,600
y不参与合并 因为它是黑结点

1090
01:10:39,840 --> 01:10:50,840
在这种情况下 我们对A进行左旋转

1091
01:10:56,200 --> 01:11:00,450
取这条边 旋转90°

1092
01:11:00,680 --> 01:11:05,470
结果是A还在左边 B还在右边

1093
01:11:05,710 --> 01:11:09,070
这还保持中序遍历的性质 C还在上面

1094
01:11:09,280 --> 01:11:12,160
y子树跟之前一样还是在这

1095
01:11:12,360 --> 01:11:16,760
其它三棵子树中 有一棵到了B下面

1096
01:11:16,970 --> 01:11:18,680
还有其它两棵在A下面

1097
01:11:18,920 --> 01:11:23,200
这是对这条边旋转得到的一个的图

1098
01:11:23,460 --> 01:11:27,020
使用前 x与它的祖父结点之间

1099
01:11:27,240 --> 01:11:30,300
是一个Z形关系 现在曲线变直线了

1100
01:11:30,530 --> 01:11:33,350
有一个笔直的路径穿过x

1101
01:11:33,620 --> 01:11:36,260
x还是在下面 这种情况下我们不改变x

1102
01:11:36,470 --> 01:11:40,230
因为在情形二之后 马上就进入情形三

1103
01:11:40,450 --> 01:11:42,560
这就是情形三的样子

1104
01:11:42,780 --> 01:11:44,950
接下来讲到情形三

1105
01:11:59,130 --> 01:12:03,030
终于 我们讲到了情形三

1106
01:12:03,290 --> 01:12:05,850
我们也终于要完成这个插入算法

1107
01:12:06,100 --> 01:12:12,780
有一个黑结点C 它有一个红色左子结点

1108
01:12:13,010 --> 01:12:17,090
有一个红色左子孙结点x

1109
01:12:19,010 --> 01:12:20,620
还有这些黑色子树

1110
01:12:20,920 --> 01:12:23,930
它们的黑高度都一致

1111
01:12:28,460 --> 01:12:33,130
这和情形二在最后的图完全一样

1112
01:12:33,370 --> 01:12:35,440
照本复制过来

1113
01:12:35,640 --> 01:12:39,420
记住 这是A类里剩下的最后一种情形

1114
01:12:39,640 --> 01:12:43,800
在A类里 我们假设B是x的父结点

1115
01:12:43,970 --> 01:12:46,530
也是祖父结点的左子结点 这个C

1116
01:12:46,760 --> 01:12:50,000
这些都是已知的

1117
01:12:50,000 --> 01:12:52,490
我们已经讲过情形一了 y是红色的

1118
01:12:52,710 --> 01:12:55,170
那是情形一 所以这里假设y是黑色的

1119
01:12:55,410 --> 01:13:00,040
现在我们就要看  x是左子还是右子

1120
01:13:00,230 --> 01:13:02,860
如果是右子结点  则将它转成左子结点

1121
01:13:03,070 --> 01:13:06,440
x在这里确实有变化的 之前x是B

1122
01:13:06,640 --> 01:13:10,940
现在x是A  好的 最后就是情形三了

1123
01:13:11,120 --> 01:13:12,780
就是x是左子结点

1124
01:13:12,990 --> 01:13:14,680
而它的父结点也是左子结点时

1125
01:13:14,930 --> 01:13:17,530
这是最后要考虑的情形

1126
01:13:17,710 --> 01:13:26,000
我们要做的 是另一次旋转

1127
01:13:26,000 --> 01:13:29,250
就像上次在例子里做的旋转一样

1128
01:13:29,480 --> 01:13:31,510
这就是情形三

1129
01:13:31,730 --> 01:13:42,340
在这种情况下 我们要对C进行右旋转

1130
01:13:42,680 --> 01:13:45,800
而且要重新上色

1131
01:13:46,070 --> 01:13:58,190
好的 我们会得到什么呢？

1132
01:13:58,400 --> 01:13:59,930
那么  B现在变成根结点

1133
01:14:00,200 --> 01:14:01,940
我们要把它设为黑色

1134
01:14:02,180 --> 01:14:04,750
要记住 这也只是子树的根结点

1135
01:14:04,920 --> 01:14:06,850
图外面还有树的其它部分

1136
01:14:07,020 --> 01:14:09,140
在所有这些图里 其实应该

1137
01:14:09,320 --> 01:14:10,870
还有更多的父结点

1138
01:14:11,040 --> 01:14:12,610
这只是一棵树的某个部分

1139
01:14:12,610 --> 01:14:15,100
我不知道是哪部分 可能是一个向右的分支

1140
01:14:15,300 --> 01:14:17,380
也可能是一个向左的分支 我不知道

1141
01:14:17,580 --> 01:14:20,910
C变成B的子结点 将它设为红色子结点

1142
01:14:21,100 --> 01:14:25,020
A变成B的子结点 跟之前一样保持红色

1143
01:14:25,240 --> 01:14:30,370
其它挂着部分保持不变

1144
01:14:30,620 --> 01:14:36,080
这里有四棵黑高度相等的子树

1145
01:14:36,390 --> 01:14:38,930
特别是最后一棵 拥有结点y

1146
01:14:39,310 --> 01:14:41,540
但我们不再特别地关注y了

1147
01:14:41,770 --> 01:14:45,620
现在看起来 树的形状已经很不错了

1148
01:14:45,840 --> 01:14:48,240
因为再也没有冲突了

1149
01:14:48,470 --> 01:14:52,320
之前发生冲突的是 x和它的父结点——A和B

1150
01:14:52,510 --> 01:14:55,690
A和B仍然是父子结点的关系

1151
01:14:55,910 --> 01:15:00,220
但B现在是黑色的

1152
01:15:00,420 --> 01:15:02,080
先不管B的父结点是什么颜色

1153
01:15:02,260 --> 01:15:03,700
是红是黑 都没问题

1154
01:15:03,910 --> 01:15:05,350
这幅图已经不再违反性质三

1155
01:15:05,550 --> 01:15:07,640
这里已经完事了

1156
01:15:07,840 --> 01:15:11,440
性质三是成立的

1157
01:15:15,200 --> 01:15:17,850
你可以这样想 x变成这个结点

1158
01:15:18,070 --> 01:15:21,050
在检查循环条件时  x不再是红色

1159
01:15:21,320 --> 01:15:23,840
因此 循环结束  但同时 我们还要检查

1160
01:15:24,050 --> 01:15:26,300
在这个过程中性质4是否还保持着

1161
01:15:26,560 --> 01:15:27,700
同样 这不难

1162
01:15:27,840 --> 01:15:29,950
因为有2－3－4树转换

1163
01:15:30,160 --> 01:15:32,460
如果将所有红结点合并到它们的父结点里

1164
01:15:32,630 --> 01:15:36,610
其它都是一个常值了  我的意思是

1165
01:15:36,770 --> 01:15:39,460
树里的每条路径都有相同的长度

1166
01:15:39,630 --> 01:15:42,280
因为它们有相等的黑高度

1167
01:15:42,480 --> 01:15:44,820
在这边 同样成立

1168
01:15:45,010 --> 01:15:47,090
这里抄了点近路

1169
01:15:47,260 --> 01:15:48,560
因为我们在旋转的同时 也重新上色了

1170
01:15:48,740 --> 01:15:51,080
但是如果你观察这棵树的任意路径

1171
01:15:51,280 --> 01:15:54,110
在这图里 它们都会经过黑结点C

1172
01:15:54,300 --> 01:15:56,520
还有一些红结点之类的  但那些不用管

1173
01:15:56,610 --> 01:15:57,960
然后是这些子树

1174
01:15:58,140 --> 01:15:59,270
因为它们黑高度相同

1175
01:15:59,350 --> 01:16:00,590
所以所有路径的黑高度也一致

1176
01:16:00,960 --> 01:16:04,160
现在 路径经过一个黑结点B

1177
01:16:04,370 --> 01:16:05,720
然后是一些红结点

1178
01:16:05,810 --> 01:16:08,490
那不影响  但再往下的所有子树

1179
01:16:08,590 --> 01:16:09,800
黑高度都相同

1180
01:16:10,060 --> 01:16:11,770
所以 经过这棵树的每条路径

1181
01:16:11,950 --> 01:16:13,870
都有相同的黑高度

1182
01:16:14,150 --> 01:16:16,330
当然 它们是从同一个结点出发

1183
01:16:16,590 --> 01:16:21,230
这样我们保持了性质4 弥补了性质3

1184
01:16:21,430 --> 01:16:26,620
这就是插入算法 一匹布那么长

1185
01:16:26,870 --> 01:16:31,450
这些东西 你可能必须记下来

1186
01:16:31,740 --> 01:16:34,660
但如果你实践过一些例子 就知道它并不太难

1187
01:16:34,890 --> 01:16:36,930
在这个例子里 我们所做的

1188
01:16:37,150 --> 01:16:38,400
无非都是这三种情形

1189
01:16:38,630 --> 01:16:40,720
第一步...很遗憾 因为要腾空间 我擦掉了

1190
01:16:40,790 --> 01:16:42,870
我们所做的是重新上色

1191
01:16:43,100 --> 01:16:45,640
把10，8  还有11重新上色

1192
01:16:45,870 --> 01:16:46,910
这是情形一

1193
01:16:47,080 --> 01:16:48,490
10是15的祖父结点

1194
01:16:48,710 --> 01:16:52,580
然后 我们看到10  10发生冲突了

1195
01:16:52,750 --> 01:16:56,190
而且 它和祖父结点之间是Z形关系

1196
01:16:56,460 --> 01:16:59,280
所以 我们对这条边做右旋转来补救

1197
01:16:59,570 --> 01:17:01,900
将它转过来 这样10变成紧挨着7

1198
01:17:02,140 --> 01:17:03,530
变成上面那张图

1199
01:17:03,780 --> 01:17:06,640
18是新的违例者

1200
01:17:06,930 --> 01:17:08,620
它和祖父结点是直线关系

1201
01:17:08,880 --> 01:17:11,030
它们都在同一边

1202
01:17:11,290 --> 01:17:15,500
然后 我们再做一次旋转来补救

1203
01:17:15,720 --> 01:17:17,630
这是唯一要记住的地方

1204
01:17:17,830 --> 01:17:19,440
如果可以的话 将祖父结点重新着色

1205
01:17:19,670 --> 01:17:22,220
否则 将它变为直线关系

1206
01:17:22,500 --> 01:17:24,800
然后 做最后一次旋转

1207
01:17:25,010 --> 01:17:26,800
并且重新上色 那就可以了

1208
01:17:27,020 --> 01:17:28,890
如果你把这些都记下来了

1209
01:17:29,120 --> 01:17:31,630
你就能应付任意一个例子

1210
01:17:31,880 --> 01:17:34,320
我们把10旋转过去 把它变成黑结点

1211
01:17:34,540 --> 01:17:36,110
因为在这里 它会变为根结点

1212
01:17:36,310 --> 01:17:37,850
但无论如何 我们都会将它设为黑色

1213
01:17:38,090 --> 01:17:39,890
因为根节点必须为黑色

1214
01:17:40,110 --> 01:17:43,440
如果没有同步进行重新上色

1215
01:17:43,650 --> 01:17:45,210
就会违反性质4

1216
01:17:47,770 --> 01:17:50,060
人家才不会把这种情况画下来呢

1217
01:17:50,070 --> 01:17:51,840
好吧 看在还有几分钟时间

1218
01:17:52,100 --> 01:17:54,850
如果这里只做旋转操作

1219
01:17:55,080 --> 01:18:01,990
先写好 这不是推论  取B为红色

1220
01:18:02,370 --> 01:18:03,740
这么做能直观地告诉我们

1221
01:18:03,820 --> 01:18:06,290
为什么算法要这么做  而不是用其他的方法

1222
01:18:06,480 --> 01:18:12,300
C是黑色的  我们就得到了这样的树

1223
01:18:12,510 --> 01:18:14,330
如果只是对树做旋转  对B旋转的话

1224
01:18:14,570 --> 01:18:15,970
或者说 把C向右旋转

1225
01:18:16,160 --> 01:18:19,480
这些子树还是一样挂在这儿

1226
01:18:19,650 --> 01:18:24,120
子树都没问题  因为它们都有相同的黑高度

1227
01:18:24,350 --> 01:18:25,690
但你看 这有一个问题

1228
01:18:25,700 --> 01:18:27,480
如果我们观察 所有从B出发

1229
01:18:27,490 --> 01:18:29,810
下降到的叶的路径 左边这些

1230
01:18:30,040 --> 01:18:32,230
它们的黑结点数等于

1231
01:18:32,230 --> 01:18:34,520
无论这里的黑高度是多少

1232
01:18:34,690 --> 01:18:39,520
假设它是bh  但右边所有路径

1233
01:18:39,700 --> 01:18:42,420
它们的黑高度都将是bh+1 因为C是黑色的

1234
01:18:42,660 --> 01:18:46,000
这样就违反了性质4

1235
01:18:49,210 --> 01:18:52,950
所以在情形三里 我们不这样处理

1236
01:18:53,170 --> 01:18:56,660
在进行旋转后 我们还要重新上色

1237
01:18:56,900 --> 01:18:58,740
然后 才能得到这个图 换句话说

1238
01:18:58,910 --> 01:19:00,490
要把黑结点放在顶端

1239
01:19:00,720 --> 01:19:03,370
因为所有路径都会经过这个结点

1240
01:19:03,560 --> 01:19:05,530
相对于这边 有些会经过C

1241
01:19:05,610 --> 01:19:06,820
有些会经过A

1242
01:19:06,980 --> 01:19:11,070
这样不好 不仅会违反性质3

1243
01:19:11,300 --> 01:19:12,890
但真正糟糕的是

1244
01:19:13,050 --> 01:19:15,190
这里违反了性质4

1245
01:19:16,700 --> 01:19:19,060
好的 再总结一下

1246
01:19:30,140 --> 01:19:33,810
如果要对红黑树进行插入操作

1247
01:19:34,080 --> 01:19:36,060
我们可以维持其为红黑树

1248
01:19:39,530 --> 01:19:49,130
RB插入：将x加入到动态集里

1249
01:19:49,340 --> 01:19:54,090
但同时维持 并保留其红黑性

1250
01:20:00,130 --> 01:20:02,730
它保持了这棵树仍为红黑树

1251
01:20:03,010 --> 01:20:06,510
这是有益的 因为它能保持树高为对数级

1252
01:20:06,710 --> 01:20:08,090
因此 红黑树里所有的查询

1253
01:20:08,270 --> 01:20:10,210
都将花费对数级的时间

1254
01:20:10,430 --> 01:20:12,860
RB插入要花多长时间？

1255
01:20:15,320 --> 01:20:20,650
我们的目标是只花log n的准备时间

1256
01:20:20,880 --> 01:20:24,090
我不打算正式地证明它

1257
01:20:24,270 --> 01:20:25,570
它应该很直观了

1258
01:20:25,750 --> 01:20:29,650
情形二和情形三 不好意思 指错地方了

1259
01:20:29,870 --> 01:20:33,550
情形二和三是终止情形

1260
01:20:33,810 --> 01:20:35,890
当进入情形三时 就表明要结束了

1261
01:20:36,080 --> 01:20:38,130
当进入情形二时 就意味着要进入情形三了

1262
01:20:38,200 --> 01:20:39,430
然后就完成了

1263
01:20:39,660 --> 01:20:42,200
所以唯一要计算的是情形一

1264
01:20:42,410 --> 01:20:43,600
因为这里的每一个操作

1265
01:20:43,810 --> 01:20:46,560
包括重新上色、旋转  都花费常数级时间

1266
01:20:46,770 --> 01:20:48,650
所以问题是 情形一有多少次循环？

1267
01:20:48,690 --> 01:20:54,820
情形一进行重新着色 并不改变树的结构

1268
01:20:55,080 --> 01:20:58,120
每次x都会上移两层

1269
01:20:58,330 --> 01:21:01,250
因为树高已知

1270
01:21:01,450 --> 01:21:02,620
最多是2log(n+1)

1271
01:21:02,810 --> 01:21:06,240
所以情形一的次数最多为log(n+1)

1272
01:21:06,450 --> 01:21:12,270
所以 情形一的循环次数最多为log n

1273
01:21:14,450 --> 01:21:17,910
所以花费log n的时间

1274
01:21:18,090 --> 01:21:20,130
然后是情形二和情形三

1275
01:21:20,350 --> 01:21:23,530
每种情形最多为1遍循环

1276
01:21:23,790 --> 01:21:27,190
情形二加上情形三一起 最多为2

1277
01:21:28,840 --> 01:21:30,980
所以总共是log n时间 帅气！

1278
01:21:31,280 --> 01:21:34,590
RB插入的另一个有意思的地方是

1279
01:21:34,810 --> 01:21:38,390
它只需做O(1)次旋转

1280
01:21:38,620 --> 01:21:42,780
所以大部分改动 都是重新上色

1281
01:21:45,540 --> 01:21:50,230
情形一只进行重新上色 没有旋转

1282
01:21:50,420 --> 01:21:51,890
情形二可能只做一次旋转

1283
01:21:52,130 --> 01:21:55,290
情形三也只做一次旋转 如果刚好遇到那些情况

1284
01:21:55,530 --> 01:21:57,210
所以旋转次数最多为2

1285
01:21:57,450 --> 01:22:00,020
在一次插入里 不是1就是2

1286
01:22:00,280 --> 01:22:03,530
这很方便 因为旋转树

1287
01:22:03,730 --> 01:22:09,020
比重新上色更加麻烦

1288
01:22:09,220 --> 01:22:13,460
为什么？因为如果你有一个数据结构

1289
01:22:13,680 --> 01:22:14,980
假设是一个搜索树

1290
01:22:15,240 --> 01:22:16,700
人们会拿来做一些事

1291
01:22:16,780 --> 01:22:18,220
例如查询

1292
01:22:18,390 --> 01:22:22,080
举个例子  这棵搜索树里存的是

1293
01:22:22,260 --> 01:22:24,460
Google公司里 和"电脑"相关的文件

1294
01:22:24,720 --> 01:22:26,400
因为这里有人穿了件Google的T恤

1295
01:22:26,600 --> 01:22:27,950
所以帮Google卖个广告

1296
01:22:28,160 --> 01:22:29,230
这个搜索树

1297
01:22:29,410 --> 01:22:31,850
存放了所有包含有“谷歌”这个单词的文件

1298
01:22:32,030 --> 01:22:33,900
你想要搜索...比如

1299
01:22:34,080 --> 01:22:35,130
在某段时间修改过的文件

1300
01:22:35,220 --> 01:22:36,480
或者其它你想要的数据

1301
01:22:36,650 --> 01:22:38,390
你要对这棵树做一些查询

1302
01:22:38,560 --> 01:22:41,180
在查询时 人们疯狂地输入“Google”

1303
01:22:41,370 --> 01:22:44,030
在一秒内输入无数次 不要问我怎么数的

1304
01:22:44,280 --> 01:22:46,100
数量可能不精确  是不计其数的

1305
01:22:46,300 --> 01:22:49,920
但人们一直都在搜索

1306
01:22:50,140 --> 01:22:52,640
如果对树进行重新上色 人们仍然可以搜索

1307
01:22:52,860 --> 01:22:54,920
这并不影响使用

1308
01:22:55,120 --> 01:22:57,330
在搜索时 我根本不会注意一个结点是红是黑

1309
01:22:57,510 --> 01:22:59,340
因为我知道它的高度是对数级就行了

1310
01:22:59,540 --> 01:23:02,390
那么 你就可以不断地做些更新

1311
01:23:02,600 --> 01:23:05,050
一边上网玩 一边做一些改动

1312
01:23:05,250 --> 01:23:08,870
重新上色没有影响  但旋转会费一些工夫

1313
01:23:09,090 --> 01:23:10,620
因为你必须锁定一些结点

1314
01:23:10,790 --> 01:23:12,050
保证在旋转过程中

1315
01:23:12,240 --> 01:23:13,640
没有改变它们 然后再解锁

1316
01:23:13,830 --> 01:23:16,230
所以 旋转的次数越少越好

1317
01:23:16,420 --> 01:23:18,220
真的很小 只有2

1318
01:23:18,450 --> 01:23:20,580
尽管时间还是要log n

1319
01:23:20,800 --> 01:23:23,230
因为本质上 这是给排序表做插入

1320
01:23:23,450 --> 01:23:25,680
所以 如果有n个插入 时间下界是n log n

1321
01:23:25,940 --> 01:23:28,580
还有删除操作 在这里不打算讲解

1322
01:23:28,660 --> 01:23:29,930
你们课后要看下书

1323
01:23:30,150 --> 01:23:33,690
稍微复杂一点 但思路是一样的

1324
01:23:33,950 --> 01:23:36,760
得到的界限是一样的  log n的运行时间和O(1)的旋转

1325
01:23:37,040 --> 01:23:40,650
回去看一下  这就是红黑树

1326
01:23:40,910 --> 01:23:44,140
现在你可以在log n的期望时间内维护数据了  爽歪了

1327
01:23:44,430 --> 01:23:48,850
我们现在已经学会了三种方法了

