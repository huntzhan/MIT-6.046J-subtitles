1
00:00:08,340 --> 00:00:09,530
我们马上开始上课

2
00:00:09,530 --> 00:00:13,740
如果谁还没拿到讲义的话请在门口领取

3
00:00:13,740 --> 00:00:16,340
我叫Charles Leiserson

4
00:00:16,340 --> 00:00:19,840
这学期将由我来执教这门课，算法导论

5
00:00:19,840 --> 00:00:22,750
和我一起执教的是Erik Demaine

6
00:00:22,750 --> 00:00:27,910
另外，这是一门SMA课程，即新加坡-MIT联盟课程

7
00:00:27,910 --> 00:00:32,460
将由David Hsu提供给新加坡

8
00:00:32,460 --> 00:00:37,100
所有的课程将被录像

9
00:00:37,100 --> 00:00:41,050
并且通过网络提供给新加坡的学生

10
00:00:41,050 --> 00:00:46,130
MIT的学生也可以在网上选择观看

11
00:00:46,130 --> 00:00:53,010
如果你不想上镜头

12
00:00:53,010 --> 00:00:56,070
你就坐到后排去

13
00:00:56,070 --> 00:01:00,170
好吗？否则，你就会出现在镜头里

14
00:01:00,170 --> 00:01:04,240
有个关于录像的条款，但貌似已经发完了

15
00:01:04,240 --> 00:01:06,070
如果谁想看下这个条款

16
00:01:06,070 --> 00:01:10,180
同学们，你们互相借阅下

17
00:01:10,180 --> 00:01:15,350
还没看到的可以来我这里

18
00:01:15,350 --> 00:01:18,770
我这里还留有一份

19
00:01:18,770 --> 00:01:21,070
在我们开始这门课之前

20
00:01:21,070 --> 00:01:24,240
先概括下这门课的全貌

21
00:01:24,240 --> 00:01:28,880
因为这门课有一些规定我们得简单的说下

22
00:01:28,880 --> 00:01:31,140
如你所见，这学期我们有很多助教

23
00:01:31,140 --> 00:01:34,100
看看讲义这里

24
00:01:34,100 --> 00:01:37,770
共有六个助教

25
00:01:37,770 --> 00:01:41,620
这比我们以前在这门课中的助教多了2名

26
00:01:41,620 --> 00:01:44,560
这就是说复习课能够做到十分小班化

27
00:01:44,560 --> 00:01:48,500
我们做了个网站

28
00:01:48,500 --> 00:01:53,110
你应该把它加入收藏并且经常访问它

29
00:01:53,110 --> 00:01:55,850
因为这门课的所有相关信息都在那里发布

30
00:01:55,850 --> 00:01:57,270
邮箱

31
00:01:57,270 --> 00:02:00,610
你们不要直接发邮件给个人

32
00:02:00,610 --> 00:02:02,730
即便我们给了你们邮件地址

33
00:02:02,730 --> 00:02:06,420
也不要直接发给某一名教职人员

34
00:02:06,420 --> 00:02:08,790
你应该发邮件给到我们全体

35
00:02:08,790 --> 00:02:11,420
原因是你可以得到更迅速的回复

36
00:02:11,420 --> 00:02:14,280
此外，对于任何的沟通

37
00:02:14,280 --> 00:02:16,720
我们通常都想查看完整的来往记录

38
00:02:16,720 --> 00:02:21,260
所以把电子邮件群发给课程相关的所有工作人员是有益的

39
00:02:21,260 --> 00:02:24,620
正如我前面提到的，我们本学期将进行远程教学

40
00:02:24,620 --> 00:02:30,400
所以你想的话，可以观看在线课程

41
00:02:30,400 --> 00:02:37,710
我建议，有机会在线观看的同学，应该到现场看看

42
00:02:37,710 --> 00:02:39,730
在现场效果更好，你可以进行交互

43
00:02:39,730 --> 00:02:42,910
到现场来的话会有无形的收益

44
00:02:42,910 --> 00:02:45,370
事实上，除了视频之外

45
00:02:45,370 --> 00:02:49,260
我每周会和新加坡的学生有面对面交流

46
00:02:49,260 --> 00:02:52,400
所以他们也会有现场讨论的契机

47
00:02:52,400 --> 00:02:55,190
预备知识

48
00:02:55,190 --> 00:03:02,090
（算法导论）这门课的预备知识是6.042

49
00:03:02,090 --> 00:03:06,350
也就是计算科学的数学基础，以及6.001

50
00:03:06,350 --> 00:03:11,150
你还要懂离散数学和概率论的基础知识

51
00:03:11,150 --> 00:03:14,760
以及编程经验，有了这些你才能学好这门课

52
00:03:14,760 --> 00:03:18,680
没有上过这些基础课的同学是不能上这门课的

53
00:03:18,680 --> 00:03:20,620
我们会检查预备知识

54
00:03:20,620 --> 00:03:23,910
如果你有任何问题，请在课后告诉我们

55
00:03:23,910 --> 00:03:29,040
嗯，课是在这里上的

56
00:03:29,040 --> 00:03:30,620
对于SMA的学生

57
00:03:30,620 --> 00:03:39,410
他们有课程的视频以及每周的讨论例会

58
00:03:39,410 --> 00:03:44,580
同学们必须每周参加一个小时的复习课

59
00:03:44,580 --> 00:03:47,560
在复习课上会发一些新的资料

60
00:03:47,560 --> 00:03:50,190
与现场课程不同的是，这些不会放到网上

61
00:03:50,190 --> 00:03:51,460
还有

62
00:03:51,460 --> 00:03:55,040
在复习课上通常不会分发课程讲义

63
00:03:55,040 --> 00:04:01,860
还有，有些内容就是考试直接会考的

64
00:04:01,860 --> 00:04:04,550
每学期末都有人会说，这个什么时候讲过？

65
00:04:04,550 --> 00:04:06,590
复习课讲过，你缺勤了吧

66
00:04:06,590 --> 00:04:10,140
所以，复习课是一定要上的

67
00:04:10,140 --> 00:04:12,500
尤其是，我要指出

68
00:04:12,500 --> 00:04:16,380
你复习课导师就是决定你最终成绩的人

69
00:04:16,380 --> 00:04:21,410
所以我们有一个分数评委会来保证所有人的成绩都是公平的

70
00:04:21,410 --> 00:04:24,520
但是你的复习课导师会最终决定你的成绩

71
00:04:26,700 --> 00:04:28,490
讲义

72
00:04:28,490 --> 00:04:31,360
讲义可以从课程主页上得到

73
00:04:31,360 --> 00:04:34,260
除了第一份讲义，我们一般不会

74
00:04:34,260 --> 00:04:38,600
把讲义带到课堂上

75
00:04:38,600 --> 00:04:44,100
课本是这本书，《算法导论》

76
00:04:44,100 --> 00:04:50,240
附近任何一个书店都能买到它，包括MIT Coop

77
00:04:50,240 --> 00:04:57,250
还有新的在线服务也能提供这本书

78
00:04:57,250 --> 00:05:03,500
如果你从MIT出版社书店购买可以的获得一个折扣

79
00:05:03,500 --> 00:05:08,680
在MIT学生电话目录里有个优惠券

80
00:05:08,680 --> 00:05:11,490
在MIT出版社书店可以打折

81
00:05:11,490 --> 00:05:17,890
你可以使用优惠券购买这本书

82
00:05:17,890 --> 00:05:20,960
课程网站 这里是课程网站

83
00:05:20,960 --> 00:05:26,370
它连到Stellar网站，这个网站会把一切保存下来

84
00:05:26,370 --> 00:05:30,380
SMA学生有自己的网站

85
00:05:30,380 --> 00:05:37,100
一些学生发现这门课非常具有挑战性

86
00:05:37,100 --> 00:05:40,460
所以我们会有额外的帮助

87
00:05:40,460 --> 00:05:45,830
我们会在课程网站上贴出助教的每周工作时段

88
00:05:45,830 --> 00:05:48,020
然后作为本学期的一个试验

89
00:05:48,020 --> 00:05:51,160
我们会为这个班提供课外作业实验室

90
00:05:51,160 --> 00:05:53,650
所谓课外作业实验室

91
00:05:53,650 --> 00:05:56,590
就是在规定时间你可以去一个地方

92
00:05:56,590 --> 00:06:00,460
那里有其他学习这门课的同学会在那里做课后作业

93
00:06:00,460 --> 00:06:06,330
而且那儿会安排两个实验室助教

94
00:06:06,330 --> 00:06:08,150
所以，如果你在那里做课后作业

95
00:06:08,150 --> 00:06:11,010
你可以在需要的情况下获得助教的帮助

96
00:06:11,010 --> 00:06:14,370
这将成为一个常规方，我们会安排的

97
00:06:14,370 --> 00:06:17,660
安排会写在课程日程表上

98
00:06:17,660 --> 00:06:21,290
时间和地点都会清楚地列出来

99
00:06:21,290 --> 00:06:26,970
通常是星期天的下午2点到4点，或者会是某个晚上

100
00:06:26,970 --> 00:06:29,130
我想把第一次（课外作业实验室）放到晚上，好么？

101
00:06:29,130 --> 00:06:33,040
大概就在交作业的前夕

102
00:06:33,040 --> 00:06:37,900
你最好在去课外作业实验室之前就试着自己做作业

103
00:06:37,900 --> 00:06:40,620
只有这样，才会有额外的帮助

104
00:06:40,620 --> 00:06:42,810
才会有东西拿来和别人讨论

105
00:06:42,810 --> 00:06:44,660
关于作业，待会我会讲到

106
00:06:44,660 --> 00:06:47,740
和本班同学合作解决问题是允许的

107
00:06:49,230 --> 00:06:54,740
另外，这里还有数个学生互助项目

108
00:06:54,740 --> 00:07:03,790
另外少数民族教育办公室也有一套协助计划

109
00:07:03,790 --> 00:07:06,360
一般这些很快会被预订完

110
00:07:06,360 --> 00:07:07,530
如果你有兴趣

111
00:07:07,530 --> 00:07:15,090
一个好的做法就是提前预约，才能得到帮助

112
00:07:15,090 --> 00:07:18,730
我希望大家都能去参加这个课后作业实验室

113
00:07:18,730 --> 00:07:20,740
我们从来没有这样做过，我也不知道其他课程是否这样做

114
00:07:20,740 --> 00:07:24,440
谁知道是否有其他的MIT课程在这样做？

115
00:07:26,970 --> 00:07:29,590
6.011课程这样做过，了解了，好的

116
00:07:29,590 --> 00:07:35,950
在那个班开放的成功么？从来没去过，天

117
00:07:36,970 --> 00:07:39,850
好吧

118
00:07:39,850 --> 00:07:42,050
走一步算一步

119
00:07:42,050 --> 00:07:44,100
如果（我们的课后实验室）没有成功

120
00:07:44,100 --> 00:07:48,140
那么我们的助教会回归平常的办公时间

121
00:07:48,140 --> 00:07:53,990
但我认为对一些学生来说（实验室）是个很好的机会

122
00:07:53,990 --> 00:07:57,450
如果你想注册参加这个课程

123
00:07:57,450 --> 00:07:59,780
你必须在课程主页上注册

124
00:07:59,780 --> 00:08:02,320
要求之一，今天必须完成这件事儿

125
00:08:02,320 --> 00:08:11,400
如果你缺勤，就很难通过考试

126
00:08:11,400 --> 00:08:16,900
如果你决定放弃这门课，应该告诉你的助教

127
00:08:16,900 --> 00:08:18,760
这样我们可以把你移出邮件列表

128
00:08:18,760 --> 00:08:20,120
省得你不断收到垃圾邮件

129
00:08:20,120 --> 00:08:26,500
你必须在晚上7点之前注册

130
00:08:26,500 --> 00:08:28,140
那时我们会发送邮件

131
00:08:28,140 --> 00:08:31,500
在明天中午之前发出你们的复习课作业

132
00:08:31,500 --> 00:08:36,360
如果你在周四之前没有收到这封邮件

133
00:08:36,360 --> 00:08:41,030
请群发一个邮件给课程的所有工作人员

134
00:08:41,030 --> 00:08:42,990
不要发给我个人

135
00:08:42,990 --> 00:08:46,630
如果你没收到复习课作业的话

136
00:08:46,630 --> 00:08:52,450
在周四中午之前没有收到复习课作业，你就需要…

137
00:08:52,450 --> 00:08:55,620
我想复习课作业今晚就会发出

138
00:08:55,620 --> 00:08:58,390
或者最迟明天早上，嗯

139
00:08:59,450 --> 00:09:01,990
SMA的学生不用为此操心

140
00:09:01,990 --> 00:09:04,900
习题集，我们有九套习题集

141
00:09:04,900 --> 00:09:07,770
会在这学期分发下去

142
00:09:07,770 --> 00:09:10,100
几件关于习题集的事

143
00:09:10,100 --> 00:09:12,600
作业迟交等现象

144
00:09:12,600 --> 00:09:16,070
一般是不被允许的

145
00:09:16,070 --> 00:09:20,200
除非你事先和复习课导师沟通过

146
00:09:20,200 --> 00:09:22,110
事实上，几乎所有教务上的事

147
00:09:22,110 --> 00:09:24,950
都不应该跑来问我，说我可以迟一点交某某东西么？

148
00:09:24,950 --> 00:09:29,230
你应该告诉你的复习课导师

149
00:09:29,230 --> 00:09:33,840
你可以阅读下其他相关规定

150
00:09:33,840 --> 00:09:39,130
我只提一下，还会有一些不用上交的练习

151
00:09:39,130 --> 00:09:42,820
但这部分练习同样有助于你深入理解知识

152
00:09:42,820 --> 00:09:45,250
我强烈推荐你们做这些练习题

153
00:09:45,250 --> 00:09:47,580
作业和练习都可以帮你理解知识

154
00:09:47,580 --> 00:09:51,240
考题里面可能会有练习题中的原题

155
00:09:53,290 --> 00:09:58,060
你应该会被要求描述各种算法

156
00:09:58,060 --> 00:10:03,050
而你想描述某种算法的话，这里有一个小的模板

157
00:10:03,050 --> 00:10:07,020
评分办法是我一定会提到的

158
00:10:07,020 --> 00:10:09,850
但每学期总是有少数几个学生说不知道

159
00:10:09,850 --> 00:10:14,370
就好像我没有讲过这些一样

160
00:10:15,250 --> 00:10:25,030
如果作业中你跳过某些题，这会对成绩造成非线性的影响

161
00:10:25,030 --> 00:10:27,700
非线性，听清楚了？

162
00:10:27,700 --> 00:10:31,680
没有漏题，成绩将不会受到影响

163
00:10:31,680 --> 00:10:37,740
跳过任何一题，我们会扣除你1%个字母等的成绩

164
00:10:37,740 --> 00:10:41,070
跳过两个题目就扣除1/10

165
00:10:41,070 --> 00:10:46,060
如你所见，如果你跳过五道题

166
00:10:46,060 --> 00:10:48,620
将扣除1/3

167
00:10:48,620 --> 00:10:50,570
顺便说下，我说的不是习题集漏交次数

168
00:10:50,570 --> 00:10:55,780
我说的是跳过的题目数目，五个题将下降1/3字母等

169
00:10:55,780 --> 00:11:00,720
如果你漏掉完成9道题或以上

170
00:11:00,720 --> 00:11:04,420
大概是三到四次习题集的内容

171
00:11:04,420 --> 00:11:06,820
你就不可能及格了

172
00:11:06,820 --> 00:11:10,250
年末的时候经常有学生跑来找我

173
00:11:10,250 --> 00:11:12,330
说哦，我作业一道题也没写

174
00:11:12,330 --> 00:11:14,970
我如果考试还可以的话，能让我及格吗？

175
00:11:14,970 --> 00:11:21,290
答案是不可能，一句话，我们有言在先

176
00:11:21,290 --> 00:11:26,480
所以习题集是这门课程不可分割的一部分

177
00:11:26,480 --> 00:11:27,980
合作规则

178
00:11:27,980 --> 00:11:30,560
这是非常重要的，所以每个人都要注意

179
00:11:30,560 --> 00:11:33,860
如果你在打瞌睡，现在醒醒

180
00:11:33,860 --> 00:11:38,240
这样的事儿会让任何人清醒过来，对吧？

181
00:11:40,390 --> 00:11:42,460
课后作业的目的

182
00:11:42,460 --> 00:11:44,380
Demaine教授和我的观点是

183
00:11:44,380 --> 00:11:47,300
家庭作业的目标是帮你学习这些知识

184
00:11:47,300 --> 00:11:52,000
促进学习的一个办法是不要卡在一道题目上

185
00:11:52,000 --> 00:11:56,250
因为这对你考试的时候没有任何帮助

186
00:11:56,250 --> 00:11:59,260
考试才是检验你真枪实弹水平的地方

187
00:11:59,260 --> 00:12:03,150
所以在做作业时你大可以和别人合作

188
00:12:03,150 --> 00:12:09,480
但是有一些关于合作的常识问题

189
00:12:09,480 --> 00:12:11,740
如果你合作到

190
00:12:11,740 --> 00:12:14,550
所有的信息你都从别人那里获得的地步

191
00:12:14,550 --> 00:12:16,190
你就什么都学不到

192
00:12:16,190 --> 00:12:19,170
你就不能在考试中取得好成绩

193
00:12:19,170 --> 00:12:23,520
依我们的经验，通常合作的学生

194
00:12:23,520 --> 00:12:27,170
比单独一个人学习的表现会更好

195
00:12:27,170 --> 00:12:30,960
如果要参加学习小组合作学习，你必须保证

196
00:12:30,960 --> 00:12:33,950
你在小组讨论时是做了准备的

197
00:12:33,950 --> 00:12:39,350
讨论之前，每个问题你应该花半个小时到45分钟思考

198
00:12:39,350 --> 00:12:43,620
这样你就能进步的更快

199
00:12:43,620 --> 00:12:45,910
而且你已经尝试过了你的想法

200
00:12:45,910 --> 00:12:50,090
你可能解决了一些问题，可能还有一些把你卡住了

201
00:12:50,090 --> 00:12:52,850
但是至少应该让自己有所准备

202
00:12:52,850 --> 00:12:57,490
30到45分钟后，如果你还是不能解决问题

203
00:12:57,490 --> 00:13:01,430
那你就不要再这个问题上浪费时间了

204
00:13:01,430 --> 00:13:04,070
这是在做无用功

205
00:13:04,070 --> 00:13:09,040
我想大家可以用这个时间，可以去做点别的什么

206
00:13:10,170 --> 00:13:11,940
已经人在心不在了

207
00:13:11,940 --> 00:13:16,540
这样的话，就不要在思考难题上浪费时间了

208
00:13:16,540 --> 00:13:20,180
就算完全弄不懂也没什么关系

209
00:13:20,180 --> 00:13:23,300
此时学习小组可以帮助解决问题

210
00:13:23,300 --> 00:13:25,720
就像我说的那样，我们会有课外实验室

211
00:13:25,720 --> 00:13:29,830
这里可以和其他同学合作来找出答案

212
00:13:29,830 --> 00:13:32,050
不一定非得成立你自己的学习小组

213
00:13:32,050 --> 00:13:34,190
也可以向助教请教

214
00:13:36,480 --> 00:13:39,320
如果你的小组不能解决你遇到的问题

215
00:13:39,320 --> 00:13:43,040
去其他小组尝试下，或者请教你的辅导老师

216
00:13:43,040 --> 00:13:45,160
这些都是可以解决问题的方法

217
00:13:45,160 --> 00:13:47,590
不过，写作业则是

218
00:13:47,590 --> 00:13:51,350
你必须独立完成的过程，这是你的责任

219
00:13:51,350 --> 00:13:55,800
你写答案的时候，不能与其它人讨论

220
00:13:55,800 --> 00:13:59,150
你必须独立作出解答

221
00:13:59,150 --> 00:14:04,670
而且在作业上…

222
00:14:04,670 --> 00:14:06,630
因为这里是做学术的地方

223
00:14:06,630 --> 00:14:11,610
我们知道学术信息来源是非常重要的

224
00:14:11,610 --> 00:14:15,380
如果是通过合作而得到的解决方案，你应该列出合作者名单

225
00:14:15,380 --> 00:14:19,930
说明合作情况

226
00:14:19,930 --> 00:14:22,280
这不会影响你的评分

227
00:14:22,280 --> 00:14:27,140
这是学术研究的态度问题

228
00:14:27,140 --> 00:14:33,740
如果你不能对授课工作人员完整口述你的问题解决方案

229
00:14:33,740 --> 00:14:38,380
这是明令禁止的

230
00:14:38,380 --> 00:14:42,080
你可能说，好吧，我所写的作业只是和其他人的类似

231
00:14:42,080 --> 00:14:45,960
我没有抄袭别人

232
00:14:45,960 --> 00:14:50,440
我们会要求你口述你的解决方案

233
00:14:50,440 --> 00:14:53,950
如果你不能完成，根据规定

234
00:14:53,950 --> 00:14:56,110
你将被视为作弊

235
00:14:56,110 --> 00:14:59,540
因此，不要写下你不懂的东西

236
00:14:59,540 --> 00:15:03,310
按部就班去完成你所弄懂的

237
00:15:03,310 --> 00:15:07,530
总结解决问题的方法和方式

238
00:15:07,530 --> 00:15:13,820
显然，考试中无论如何不会允许任何形式的合作

239
00:15:13,820 --> 00:15:17,210
考试是我们评估你的方式

240
00:15:17,210 --> 00:15:21,180
我们不会对评估其他人感兴趣

241
00:15:21,180 --> 00:15:23,450
我们唯一感兴趣的是评估你的学习情况

242
00:15:23,450 --> 00:15:26,000
所以，考试中没有合作一说

243
00:15:26,000 --> 00:15:29,330
我们还会有课堂外的测试科目

244
00:15:29,330 --> 00:15:31,090
你们可以看一下计划表

245
00:15:31,090 --> 00:15:34,620
如果对于计划表有任何疑问，尽快去搞清楚

246
00:15:34,620 --> 00:15:39,370
更多合作的细节

247
00:15:39,370 --> 00:15:42,160
将在11月28号星期一的讲座中公布

248
00:15:42,160 --> 00:15:44,340
基本上我们都会在这里上课

249
00:15:44,340 --> 00:15:47,620
你们必须清楚，这是没有商量的余地的

250
00:15:47,620 --> 00:15:51,950
我知道一些人会抱怨，九点半太早了

251
00:15:51,950 --> 00:15:55,320
特别是在周一

252
00:15:55,320 --> 00:15:57,750
早起是有益的

253
00:15:57,750 --> 00:16:00,670
11月28日周一

254
00:16:00,670 --> 00:16:05,770
如果你不能出勤，你的考试也就没法及格

255
00:16:05,770 --> 00:16:08,890
至少那一天，你必须准时出勤

256
00:16:08,890 --> 00:16:11,220
还有其他问题吗

257
00:16:11,220 --> 00:16:14,350
那一天，准时出勤

258
00:16:14,350 --> 00:16:17,400
即便你已经通过互联网看过一遍了

259
00:16:17,400 --> 00:16:24,570
如果有你发现自己违规了

260
00:16:24,570 --> 00:16:27,110
最好的方式是来找我们交流

261
00:16:27,110 --> 00:16:28,880
我们通常会拿出解决办法来

262
00:16:28,880 --> 00:16:31,950
如果我们从第三方发现

263
00:16:31,950 --> 00:16:36,170
或有明显迹象证明了任何人做作业时不规矩

264
00:16:36,170 --> 00:16:41,850
那就糟透了

265
00:16:41,850 --> 00:16:44,420
因此，如果因为某些原因

266
00:16:44,420 --> 00:16:47,880
你认识到自己做了错误的事情，主动来找我们交流

267
00:16:47,880 --> 00:16:54,170
我们曾经也是学生，虽然那是很多年前

268
00:16:54,170 --> 00:16:59,010
还有其他问题吗? 这门课程的内容很棒

269
00:16:59,010 --> 00:17:00,870
非常棒的内容

270
00:17:00,870 --> 00:17:07,700
而且十分有趣，但是大家必须努力

271
00:17:10,450 --> 00:17:14,220
让我们进入正题

272
00:17:25,240 --> 00:17:29,830
开始课程第一部分的主题

273
00:17:29,830 --> 00:17:33,620
这一部分将关注算法分析

274
00:17:33,620 --> 00:17:37,170
第二部分将主要介绍算法设计

275
00:17:37,170 --> 00:17:40,310
在我们开始设计之前

276
00:17:40,310 --> 00:17:46,200
我们不得不掌握一些分析算法的实用技巧

277
00:17:46,200 --> 00:17:48,840
然后你们将有能力设计算法

278
00:17:48,840 --> 00:17:51,340
并知道哪一种方式更有效

279
00:17:51,340 --> 00:18:00,180
算法分析是理论研究

280
00:18:00,180 --> 00:18:20,750
是关于计算机程序性能和资源利用的研究

281
00:18:20,750 --> 00:18:23,910
特别关注性能

282
00:18:23,910 --> 00:18:27,930
我们要学习如何让事情变得更快

283
00:18:27,930 --> 00:18:30,340
尤其是计算机程序

284
00:18:30,340 --> 00:18:33,410
我们也将涉及并讨论其他的问题

285
00:18:33,410 --> 00:18:39,900
例如通信，例如存储器，无论是内存还是磁盘存储

286
00:18:39,900 --> 00:18:45,150
还有其他的内容我们同样需要关注

287
00:18:45,150 --> 00:18:48,970
但首先我们需要关注性能

288
00:18:48,970 --> 00:18:53,830
因为这是一门关注性能的学科

289
00:18:53,830 --> 00:19:00,190
我喜欢用提问的方式，由浅入深的去分析问题

290
00:19:00,190 --> 00:19:11,410
在程序设计方面，什么是比性能更重要的呢？

291
00:19:11,410 --> 00:19:16,260
如果你正处于一个软件工程环境，写代码，写软件

292
00:19:16,260 --> 00:19:19,710
什么比性能更重要呢？

293
00:19:19,710 --> 00:19:21,340
正确性，好

294
00:19:21,520 --> 00:19:26,130
还有其他的吗？

295
00:19:26,130 --> 00:19:29,910
简洁，非常好

296
00:19:33,000 --> 00:19:37,710
可维护性通常比性能更重要

297
00:19:38,570 --> 00:19:39,830
成本

298
00:19:39,830 --> 00:19:41,860
那种类型的成本或开销呢？

299
00:19:43,060 --> 00:19:45,310
不，我的意思是为此你付出了哪些代价？

300
00:19:47,800 --> 00:19:49,550
我们正在讨论软件，是吗

301
00:19:49,550 --> 00:19:52,450
在你的脑海中存在哪些成本？

302
00:19:54,450 --> 00:20:04,680
我们经常碰到成本开销，例如程序员的时间成本

303
00:20:04,680 --> 00:20:08,380
程序员的时间可能是另外一件需要考虑的事情

304
00:20:09,590 --> 00:20:10,990
稳定性

305
00:20:10,990 --> 00:20:12,940
软件的健壮性

306
00:20:12,940 --> 00:20:22,310
它是否老崩溃；还有什么？

307
00:20:22,310 --> 00:20:27,510
快，我们这里有很多工程师，应该有很多问题

308
00:20:27,510 --> 00:20:32,570
特性呢？特性十分重要

309
00:20:32,570 --> 00:20:35,930
比你的竞争对手拥有更多的特性集合

310
00:20:35,930 --> 00:20:37,820
功能性

311
00:20:37,820 --> 00:20:39,530
模块化

312
00:20:39,530 --> 00:20:41,400
它是否经由这样的设计方法

313
00:20:41,400 --> 00:20:44,480
你只需要修改局部的代码

314
00:20:44,480 --> 00:20:47,330
避免修改全部代码

315
00:20:47,330 --> 00:20:53,380
以便于影响功能中的简单变化

316
00:20:53,380 --> 00:20:57,130
还有一个很重要的因素，尤其是90年代

317
00:20:57,130 --> 00:20:59,750
对计算机而言意义重大

318
00:20:59,750 --> 00:21:02,230
这是一件大事

319
00:21:03,560 --> 00:21:05,800
安全，很好

320
00:21:05,800 --> 00:21:08,010
我没有指出，但安全非常重要

321
00:21:08,010 --> 00:21:10,820
事实上到2000年以后

322
00:21:10,820 --> 00:21:14,900
安全已经变得比性能更加重要

323
00:21:15,940 --> 00:21:17,990
可扩展性也很重要

324
00:21:17,990 --> 00:21:21,650
尽管在某种意义上，可扩展性与性能相关

325
00:21:21,650 --> 00:21:23,820
但是，是的，可扩展性不容忽视

326
00:21:23,820 --> 00:21:25,740
还有什么巨大的突破？

327
00:21:25,740 --> 00:21:30,550
为什么人们更青睐苹果操作系统，而不是Windows？

328
00:21:30,550 --> 00:21:32,770
这些人简直成了苹果的教徒？

329
00:21:34,320 --> 00:21:36,070
用户友好

330
00:21:36,070 --> 00:21:39,450
如果你一直关注计算机的发展历程

331
00:21:39,450 --> 00:21:42,660
你就会见证90年代计算机是如何进入用户友好时代

332
00:21:42,660 --> 00:21:45,100
从几乎完全的空白状态直到

333
00:21:45,100 --> 00:21:50,290
现在，大部分的计算设备都变得对用户友好了

334
00:21:50,290 --> 00:21:53,060
因此，所有的这些事情都比性能重要

335
00:21:53,060 --> 00:21:56,310
这是一门关于性能的课程

336
00:21:56,310 --> 00:21:59,360
你可能会有疑问

337
00:21:59,360 --> 00:22:13,100
如果算法和性能都不重要

338
00:22:13,100 --> 00:22:16,460
为什么我们还要学习？

339
00:22:16,460 --> 00:22:24,680
几乎总是有人在说其他的事情比性能更重要

340
00:22:24,680 --> 00:22:27,140
你可能会纠结

341
00:22:27,140 --> 00:22:30,130
到底是要性能还是要更好的用户体验呢？

342
00:22:30,130 --> 00:22:33,940
看似这些都比性能重要

343
00:22:33,940 --> 00:22:38,670
为什么我们还要关注性能？

344
00:22:40,490 --> 00:22:42,570
那不是用户体验

345
00:22:42,570 --> 00:22:47,920
可以肯定的是，很多时候性能和用户体验是紧密联系在一起的

346
00:22:47,920 --> 00:22:52,230
没有事情比坐着干等更令人沮丧的

347
00:22:52,230 --> 00:22:55,020
因此，这是一个不错的理由

348
00:22:55,020 --> 00:22:56,430
其他的原因是什么？

349
00:23:00,060 --> 00:23:01,910
用户体验有时也有实时的限制

350
00:23:01,910 --> 00:23:05,010
如果性能达不到要求，用户体验难以保证

351
00:23:05,010 --> 00:23:08,390
请讲

352
00:23:13,830 --> 00:23:18,570
难说，我们通常无法衡量用户体验，因此我不无法确定

353
00:23:18,570 --> 00:23:20,820
我理解你的意思

354
00:23:20,820 --> 00:23:27,950
他说在用户体验方面我们不能做到指数倍性能改进

355
00:23:27,950 --> 00:23:30,880
当然，通常性能也不可能实现指数倍增长

356
00:23:30,880 --> 00:23:36,150
但有些时候我们可以见证奇迹

357
00:23:40,070 --> 00:23:44,310
这里有几点重要的原因

358
00:23:44,310 --> 00:23:47,220
其一，通常性能的好与坏

359
00:23:47,220 --> 00:23:51,440
直接决定着可行还是不可行

360
00:23:51,440 --> 00:23:53,080
我们听说过不少例子

361
00:23:53,080 --> 00:23:56,570
例如，对于实时的需求

362
00:23:56,570 --> 00:23:59,650
程序不快，这只能表示它不可行

363
00:23:59,650 --> 00:24:04,500
或者，如果它占用过多的内存，也只能说是不可行

364
00:24:06,090 --> 00:24:08,090
所以

365
00:24:08,090 --> 00:24:11,950
算法总是处于解决问题的最前沿

366
00:24:11,950 --> 00:24:14,630
如果你讨论的只是重新实现

367
00:24:14,630 --> 00:24:17,370
十年前人们就做过的东西

368
00:24:17,370 --> 00:24:20,180
那某种意义上，性能就不再重要

369
00:24:20,180 --> 00:24:23,160
但是如果你正在积极尝试其他人没有成功的事情

370
00:24:23,160 --> 00:24:25,190
之所以别人没有成功

371
00:24:25,190 --> 00:24:27,210
因为太消耗时间

372
00:24:27,210 --> 00:24:31,200
不具备可扩展的空间

373
00:24:31,200 --> 00:24:35,790
这是第一层原因，算法能够将不可行变成可行

374
00:24:35,790 --> 00:24:36,900
第二层原因

375
00:24:36,900 --> 00:24:42,280
算法是一种描述程序行为的语言

376
00:24:42,280 --> 00:24:45,020
它业已形成了一种语言

377
00:24:45,020 --> 00:24:50,070
一种已经广泛应用于计算机科学领域

378
00:24:50,070 --> 00:24:54,600
已经被所有的实践者所采用的理论语言

379
00:24:54,600 --> 00:24:57,240
它是一种让程序最为简洁的思考方式

380
00:24:57,240 --> 00:25:00,900
我有一个很好的比喻来形容性能

381
00:25:00,900 --> 00:25:02,890
以及为何性能处于最底层

382
00:25:02,890 --> 00:25:09,980
它所扮演的角色就如同经济中的货币一般

383
00:25:09,980 --> 00:25:15,740
想想一沓一百美元的钞票有什么好的？

384
00:25:15,740 --> 00:25:21,360
你也许更需要有食物、水、房子等等

385
00:25:21,360 --> 00:25:25,400
你需要用钞票才能…

386
00:25:25,400 --> 00:25:32,370
前提是你有的话，才能买下这些商品

387
00:25:32,370 --> 00:25:36,700
尽管水对于你的生命比钞票重要

388
00:25:36,700 --> 00:25:42,640
同样，性能是确保良好的用户体验的前提

389
00:25:42,640 --> 00:25:44,810
也是安全的保障

390
00:25:44,810 --> 00:25:46,930
你可能听人说到

391
00:25:46,930 --> 00:25:52,190
我希望有更多的功能，因此人们会用Java来写程序

392
00:25:52,190 --> 00:25:54,790
尽管它比C写的程序要慢很多

393
00:25:54,790 --> 00:26:00,610
他们会说用Java编程性能会损失三倍左右

394
00:26:00,610 --> 00:26:04,380
但是值得为Java付出这些代价

395
00:26:04,380 --> 00:26:07,490
因为它提供面向对象的特性

396
00:26:07,490 --> 00:26:10,150
以及异常机制等等

397
00:26:10,150 --> 00:26:13,850
所以人们能够接受三倍的性能损失

398
00:26:13,850 --> 00:26:17,360
这就是为什么你需要性能

399
00:26:17,360 --> 00:26:22,630
因为你需要性能作为支付其他东西的"货币"

400
00:26:22,630 --> 00:26:26,250
在某种意义上，这就是为什么性能是处于最底层的原因

401
00:26:26,250 --> 00:26:30,760
因为它是衡量的一般性标准

402
00:26:30,760 --> 00:26:32,960
你愿意消耗两倍的性能在这上面

403
00:26:32,960 --> 00:26:36,270
还是消耗三倍的性能在安全上呢，等等

404
00:26:36,270 --> 00:26:42,120
另外，其他资源方面同样适用

405
00:26:42,120 --> 00:26:45,130
例如通信、内存等等

406
00:26:45,130 --> 00:26:49,780
我们学习算法性能最后一个原因是，这里充满了乐趣

407
00:26:49,780 --> 00:26:52,380
速度永远让人渴望，是吗？

408
00:26:52,380 --> 00:26:59,250
为什么人们喜欢驾驶跑车、赛马这些快速的东西？

409
00:26:59,250 --> 00:27:03,130
例如火箭，为什么？因为我们向往速度

410
00:27:03,130 --> 00:27:05,780
滑雪，为什么你热爱滑雪

411
00:27:05,780 --> 00:27:09,700
我喜欢在雪地中快速飞驰，这很有趣

412
00:27:09,700 --> 00:27:14,110
冰球，刺激的运动，我们都喜欢快速刺激的运动

413
00:27:14,110 --> 00:27:18,620
也不是所有人啦，有些人会说他们与我道不同不相为谋

414
00:27:18,620 --> 00:27:22,510
好吧，让我们继续

415
00:27:22,510 --> 00:27:26,240
这是为什么学习算法的一些基本概念

416
00:27:26,240 --> 00:27:27,690
在某种意义上

417
00:27:27,690 --> 00:27:31,500
这些是开展后续课程的基本前提

418
00:27:31,500 --> 00:27:33,230
我们希望知道

419
00:27:33,230 --> 00:27:36,860
如何才能让计算转化为金钱

420
00:27:36,860 --> 00:27:40,530
让我们从一个非常简单的问题开始

421
00:27:40,530 --> 00:27:46,490
这是一个在算法学习中最古老的问题

422
00:27:46,490 --> 00:27:50,560
就是排序问题

423
00:27:50,560 --> 00:27:54,390
我们将用几个课时来介绍它

424
00:27:54,390 --> 00:28:00,200
排序包含了很多基本的算法

425
00:28:00,200 --> 00:28:04,050
举一个排序的例子

426
00:28:04,050 --> 00:28:21,380
我们输入一组序列a₁, a₂直到an

427
00:28:25,750 --> 00:28:39,640
按照需求重新排列后作为输出

428
00:28:40,120 --> 00:28:44,220
排列是指对一组数字的重新排序

429
00:28:44,220 --> 00:28:48,790
排序后每个数字出现且仅出现一次，使得…

430
00:28:48,790 --> 00:28:53,010
我有时会用$符号来表示“使得”

431
00:28:57,640 --> 00:29:06,160
使得a₁'≤a₂'≤…

432
00:29:06,160 --> 00:29:12,470
使得它们的大小单调递增

433
00:29:14,540 --> 00:29:18,460
输入一组数字，将它们按一定顺序排列

434
00:29:21,520 --> 00:29:28,430
这里有一种算法来完成这项工作，称为插入排序

435
00:29:36,220 --> 00:29:45,180
我们将用伪代码来描述此算法

436
00:29:45,180 --> 00:29:49,530
伪代码与编程语言很类似，只是经常会包含一些英语在里面

437
00:29:49,530 --> 00:29:54,780
伪代码能够让我们更容易理解算法所要表达的意思

438
00:29:54,780 --> 00:30:01,000
从第一项到第n项排序

439
00:30:01,000 --> 00:30:07,200
下面是它的代码

440
00:30:55,840 --> 00:31:02,050
这就是我们所说的伪代码

441
00:31:06,300 --> 00:31:10,560
如果你不理解伪代码

442
00:31:10,560 --> 00:31:14,530
你可以就不理解的符号进行提问

443
00:31:14,530 --> 00:31:16,570
今后你们将习惯使用伪代码

444
00:31:16,570 --> 00:31:20,190
值得一提的是我们在伪代码中使用缩进

445
00:31:20,190 --> 00:31:24,680
相当于在大多数语言中标注开始和结束的分隔符

446
00:31:24,680 --> 00:31:27,970
好比Java和C中使用的大括号

447
00:31:27,970 --> 00:31:29,480
伪代码中只使用缩进

448
00:31:29,480 --> 00:31:34,460
伪代码的目的是让算法的表达尽量简洁

449
00:31:34,460 --> 00:31:37,190
同时表达每一步的含义

450
00:31:38,940 --> 00:31:41,170
实际上，还真有过一些编程语言

451
00:31:41,170 --> 00:31:46,740
使用缩进来表示嵌套的意义

452
00:31:46,740 --> 00:31:52,360
这不是一个好主义，比如当代码换页时

453
00:31:52,360 --> 00:31:57,030
你很难知道自己在哪一个嵌套的层级

454
00:31:57,030 --> 00:32:00,920
而使用大括号会清晰明了得多

455
00:32:00,920 --> 00:32:02,240
所以，这就是为什么说

456
00:32:02,240 --> 00:32:08,300
在软件工程中用缩进表示嵌套并非好事的原因

457
00:32:08,300 --> 00:32:09,560
但对于研究算法

458
00:32:09,560 --> 00:32:14,340
它是不错的选择，因为这让我们的代码简短、容易书写

459
00:32:14,340 --> 00:32:16,660
这就是插入排序

460
00:32:16,660 --> 00:32:19,920
让我们来一步一步的看看它是如何工作的

461
00:32:21,740 --> 00:32:41,680
首先构造数组A，需要理解的是

462
00:32:41,680 --> 00:32:46,520
设置外部循环条件，j为从2到n递增

463
00:32:46,520 --> 00:32:52,530
而内部循环条件开始于j-1

464
00:32:52,530 --> 00:32:57,630
并递减至0

465
00:32:57,630 --> 00:33:02,660
基本上算法中的任意一步是这样的

466
00:33:02,660 --> 00:33:06,220
我们找到j

467
00:33:06,220 --> 00:33:09,120
数组A的第j个位置

468
00:33:09,120 --> 00:33:17,460
我们把这个位置的值提取出来，在这里称之为键值(key)

469
00:33:17,460 --> 00:33:22,960
在这里有一点很重要

470
00:33:22,960 --> 00:33:26,640
我们也会在周五的助教课中再次谈到

471
00:33:26,640 --> 00:33:29,080
即存在一个常量

472
00:33:29,080 --> 00:33:33,780
每次循环后这个常量保持不变

473
00:33:33,780 --> 00:33:39,030
常量就是数组已经被排序过的这部分

474
00:33:40,980 --> 00:33:46,050
每次循环的目的是完成增量

475
00:33:46,050 --> 00:33:49,600
就是使已排序部分的长度增加1

476
00:33:49,600 --> 00:33:52,700
实现方法是提取当前循环中位置为j的数字键

477
00:33:52,700 --> 00:33:56,840
然后我们就一直这样复制值

478
00:33:56,840 --> 00:34:03,470
一步步把前面的值抄到下一位上，直到找到此键合适的位置

479
00:34:03,470 --> 00:34:05,340
然后我们插入键值

480
00:34:05,340 --> 00:34:09,380
这就是称之为插入排序的原因

481
00:34:09,380 --> 00:34:11,890
我们在数组中移动元素的位置

482
00:34:11,890 --> 00:34:14,270
持续复制这些元素直到我们找到它们的适当位置

483
00:34:14,270 --> 00:34:16,970
并将它们放置到这些位置中去

484
00:34:16,970 --> 00:34:22,750
至此，从数组A中的数字已经从1到j的位置排列好

485
00:34:22,750 --> 00:34:26,000
现在我们可以来执行j+1

486
00:34:26,000 --> 00:34:29,610
这里有一个具体的实例

487
00:34:29,610 --> 00:34:38,380
给定数组8，2，4，9，3，6

488
00:34:38,380 --> 00:34:42,690
我们首先设定j从数字2的位置开始

489
00:34:42,690 --> 00:34:46,600
然后找到我们希望插入的位置

490
00:34:46,600 --> 00:34:51,200
得到2，8，4，9，3，6

491
00:34:51,200 --> 00:34:57,220
然后我们再找到4，按照排序规则移动

492
00:34:57,220 --> 00:35:05,470
执行第二次循环，我们得到2，3，8，9，3，6

493
00:35:05,470 --> 00:35:12,730
找到数字9，我们发现它已经处于正确位置

494
00:35:12,730 --> 00:35:15,080
直接跳过

495
00:35:15,080 --> 00:35:21,050
这个循环没有任何变化

496
00:35:21,050 --> 00:35:25,740
然后考虑数字3，执行循环插到这里

497
00:35:25,740 --> 00:35:29,950
现在是2, 3, 4, 8, 9, 6

498
00:35:29,950 --> 00:35:33,490
最终考虑数字6，并执行循环移到这里

499
00:35:33,490 --> 00:35:37,850
得到2, 3, 4, 6, 8, 9.

500
00:35:37,850 --> 00:35:40,740
问题解决了

501
00:35:43,920 --> 00:35:48,020
大家有没有问题？

502
00:35:55,120 --> 00:35:58,180
我们的数组下标从1开始，对

503
00:35:58,180 --> 00:36:02,500
A[1到n]

504
00:36:02,500 --> 00:36:09,110
好了，这就是插入排序算法

505
00:36:09,110 --> 00:36:12,520
并且它是我们要着手分析的第一个算法

506
00:36:12,520 --> 00:36:16,560
我们会找一些数学工具

507
00:36:16,560 --> 00:36:18,230
来分析这个算法

508
00:36:18,230 --> 00:36:24,540
首先，让我们来关注一下运行时间的问题

509
00:36:27,060 --> 00:36:32,160
算法的运行时间取决于诸多因素

510
00:36:32,160 --> 00:36:38,670
其中一个因素是输入本身

511
00:36:44,410 --> 00:36:48,580
举例而言，如果输入已经有序

512
00:36:48,580 --> 00:36:56,820
那末插入排序要做的工作就十分之少了

513
00:36:56,820 --> 00:37:01,740
因为每次遍历，它做的事都如此这般

514
00:37:01,740 --> 00:37:04,380
它没有必要整理太多东西

515
00:37:04,380 --> 00:37:08,130
因为它们已经各就各位了

516
00:37:08,130 --> 00:37:12,080
那么从这种意义上讲，什么是插入排序的最坏情况呢？

517
00:37:12,080 --> 00:37:18,880
最坏的是逆序情形，此时算法必须做大量的工作

518
00:37:18,880 --> 00:37:24,680
因为这么一来，它就不得不把所有的元素都重新整理一遍

519
00:37:24,680 --> 00:37:30,840
除此之外，当然，算法的运行时间还取决于输入规模

520
00:37:35,830 --> 00:37:39,020
比如在这里，我们一共要处理六个元素

521
00:37:39,020 --> 00:37:41,890
但如果要处理六十亿个元素的话

522
00:37:41,890 --> 00:37:47,280
它就需要花上长很多的时间

523
00:37:50,340 --> 00:37:55,340
这就是说要处理的输入规模越大，所花费的运行时间也越长

524
00:37:55,340 --> 00:37:57,940
通常，我们处理输入规模的方式是

525
00:37:57,940 --> 00:38:08,050
我们将依输入的规模将其参数化

526
00:38:08,050 --> 00:38:14,680
以后，我们会把运行时间看作待排列数据规模的函数

527
00:38:14,680 --> 00:38:18,700
这么一来，我们在审视算法的行为时就有依据了

528
00:38:18,700 --> 00:38:24,660
关于运行时间，我最后想谈一下的是

529
00:38:24,660 --> 00:38:28,430
一般来说，我们都想知道运行时间的上界

530
00:38:28,430 --> 00:38:34,490
也就是说我们想知道运行时间是不会超过某个特定量的

531
00:38:34,490 --> 00:38:38,610
原因在于，这代表了对用户的一种承诺

532
00:38:40,710 --> 00:38:43,160
如果我说，这个程序不会运行超过某个时间，例如

533
00:38:43,160 --> 00:38:47,770
我告诉你，这个程序，它的运行时间不会超过三秒钟

534
00:38:47,770 --> 00:38:51,100
这就是给了你一个有关你将如何使用该程序的真实信息

535
00:38:51,100 --> 00:38:55,420
这就是给了你一个有关你将如何使用该程序的真实信息

536
00:38:55,420 --> 00:39:03,040
反之，如果我告诉你这个程序至少会运行三秒钟

537
00:39:03,040 --> 00:39:06,670
你就拿不准它会不会运行上三年时间了

538
00:39:06,670 --> 00:39:10,170
那末这样的信息就不能当作给用户提供的承诺了

539
00:39:10,170 --> 00:39:12,160
再说一遍，我们一般想获得运行时间的上界

540
00:39:12,160 --> 00:39:19,480
因为它代表了对用户的承诺

541
00:39:22,010 --> 00:39:32,070
人们会对算法做各种各样的分析

542
00:39:41,740 --> 00:39:45,140
我们将要最关注的一种分析

543
00:39:45,140 --> 00:39:50,090
就是所谓的最坏情况分析

544
00:39:50,090 --> 00:39:55,670
我们通常最关注这个

545
00:39:55,670 --> 00:40:10,490
T(n)定义为输入规模为n时的最长运行时间

546
00:40:12,430 --> 00:40:14,880
它是输入规模为n时

547
00:40:14,880 --> 00:40:19,290
程序运行的最长可能消耗时间

548
00:40:19,290 --> 00:40:23,260
这个结果的意义是

549
00:40:23,260 --> 00:40:27,140
如果你检视一下这个事实，输入有好有坏

550
00:40:27,140 --> 00:40:29,550
我们所关注的，正是所有输入中的最坏情况

551
00:40:29,550 --> 00:40:32,010
因为，只有这样我们才可以作出承诺

552
00:40:32,010 --> 00:40:36,720
这种算法总能做到这样，而不是有时能

553
00:40:36,720 --> 00:40:38,840
是故，我们现在关注的是最大值

554
00:40:38,840 --> 00:40:40,510
请注意，若是我们得不到最大值

555
00:40:40,510 --> 00:40:45,240
那么T(n)在某种意义上只能算一种相关性，而不能算函数

556
00:40:45,240 --> 00:40:51,910
因为它还牵扯到该输入规模n之下到底是怎么样的一个输入

557
00:40:51,910 --> 00:40:54,600
这样我就可以得到好多不同的时间结果

558
00:40:54,600 --> 00:40:57,440
但一旦我说我要的是最大值

559
00:40:57,440 --> 00:40:59,660
结果就成为了一种函数关系

560
00:40:59,660 --> 00:41:03,440
因为只有一个最长时间作为结果

561
00:41:05,120 --> 00:41:09,680
有时，我们也会讨论平均情况

562
00:41:12,360 --> 00:41:15,280
有时我们会这样做

563
00:41:17,080 --> 00:41:35,120
这里T(n)就成了输入规模n之下所有可能输入的期望时间

564
00:41:35,610 --> 00:41:38,550
记住，是时间的期望值哟

565
00:41:38,550 --> 00:41:43,210
讲到期望值，还需要讲到什么？

566
00:41:43,210 --> 00:41:47,490
什么是期望时间？哪位说知道

567
00:41:47,490 --> 00:41:49,420
请举手

568
00:41:50,920 --> 00:41:53,840
期望输入。这又是什么意思，期望输入？

569
00:42:03,130 --> 00:42:05,690
我想听到更有数学味儿的回答

570
00:42:05,690 --> 00:42:08,480
我这里说期望时间是什么意思，往数学方面想？

571
00:42:12,510 --> 00:42:17,900
要把所有输入的运行时间加起来然后求平均值

572
00:42:17,900 --> 00:42:20,640
这接近我要讲的期望时间了

573
00:42:20,640 --> 00:42:21,740
有点儿靠谱了

574
00:42:21,740 --> 00:42:23,590
但还不是那么好

575
00:42:23,590 --> 00:42:30,980
我是说，你说的完全正确，但就是还不太到位

576
00:42:30,980 --> 00:42:32,150
什么？

577
00:42:35,510 --> 00:42:38,610
这应该是每种输入的运行时间，乘以那种输入出现的概率

578
00:42:38,610 --> 00:42:41,530
这是一种加权平均，完全正确

579
00:42:41,530 --> 00:42:45,490
那我又如何知道每种输入出现的概率是多少？

580
00:42:45,490 --> 00:42:58,640
我如何知道某种特定输入在给定情形下出现的概率是多少？

581
00:42:58,640 --> 00:43:01,670
我不可能知道

582
00:43:01,670 --> 00:43:04,650
我得作出假设

583
00:43:04,650 --> 00:43:06,850
那我要做什么样的假设？

584
00:43:09,470 --> 00:43:13,790
在这个假设中我需要满足些什么条件呢？

585
00:43:13,790 --> 00:43:16,790
我需要一个假设

586
00:43:20,790 --> 00:43:35,890
一个有关输入的统计分布的假设

587
00:43:35,890 --> 00:43:40,500
否则的话，期望时间就无从谈起

588
00:43:40,500 --> 00:43:43,140
因为我不清楚某种东西的可能性是怎么样的

589
00:43:43,140 --> 00:43:47,140
为了计算概率，你就要做一些假设

590
00:43:47,140 --> 00:43:49,540
并且，你需要将这些假设说明得一清二楚

591
00:43:49,540 --> 00:43:52,650
最常见的假设之一就是

592
00:43:52,650 --> 00:43:55,260
所有输入都是以等可能的方式出现的

593
00:43:55,260 --> 00:43:58,200
即所谓均匀分布

594
00:43:58,200 --> 00:44:05,020
所有规模为n的输入情况都是等可能地出现

595
00:44:05,020 --> 00:44:07,310
但也有其他方法来做这样的假设

596
00:44:07,310 --> 00:44:10,150
并且它们可能并不都是对的

597
00:44:10,150 --> 00:44:12,890
这个就复杂多了，如你们所见

598
00:44:12,890 --> 00:44:16,060
好在，你们都有很不错的概率背景

599
00:44:16,060 --> 00:44:20,050
所以，我们不会

600
00:44:20,050 --> 00:44:25,590
在有关期望等诸如此类的概率问题上遇到拦路虎

601
00:44:27,350 --> 00:44:32,290
如果情况不是这样，也许你会后悔：真该学学概率论的

602
00:44:32,290 --> 00:44:34,870
它是这门课的先修课程

603
00:44:36,470 --> 00:44:42,480
我最后想讲一讲的是最好情况分析

604
00:44:42,480 --> 00:44:47,010
对于这个，我称之为假象

605
00:44:47,010 --> 00:44:48,580
假象

606
00:44:50,370 --> 00:44:52,210
没啥用

607
00:44:53,610 --> 00:44:59,190
为什么最好情况分析是假象？嗯？

608
00:45:00,800 --> 00:45:03,920
最好的情况可能永远不会出现

609
00:45:05,920 --> 00:45:08,640
事实上，这很有趣，因为对于排序问题

610
00:45:08,640 --> 00:45:11,360
最常见的是我们打算加以排序的

611
00:45:11,360 --> 00:45:16,360
都已以某种有意思的方式作了一定的排序

612
00:45:16,360 --> 00:45:18,460
或差不多排好了序

613
00:45:18,460 --> 00:45:21,400
例如，欲加以排序的最常见的

614
00:45:21,400 --> 00:45:24,040
是银行的支票号码

615
00:45:24,040 --> 00:45:27,950
它们被送入的顺序，往往与被签写的顺序相同

616
00:45:27,950 --> 00:45:31,720
它们就是“已经差不多被排好序的被排序物”

617
00:45:31,720 --> 00:45:34,460
我的意思是说，这不赖…你说…

618
00:45:37,380 --> 00:45:40,150
什么时候我们要上界，不要下界？

619
00:45:41,980 --> 00:45:44,020
对，在你想作出承诺的时候

620
00:45:44,020 --> 00:45:46,850
那么，为什么下界就不是一个保证呢？

621
00:45:52,550 --> 00:45:56,330
你的确说出了一些东西

622
00:45:56,330 --> 00:45:59,210
但这里我们需要更多一点的精确性

623
00:45:59,210 --> 00:46:05,390
为什么说这是欺骗？嗯？

624
00:46:09,750 --> 00:46:12,150
对，你可以骗到人

625
00:46:12,150 --> 00:46:13,880
你这样骗

626
00:46:13,880 --> 00:46:16,800
你采用你想要的任何效率低下的算法

627
00:46:16,800 --> 00:46:20,400
然后你只对某些特定输入检验它

628
00:46:20,400 --> 00:46:22,240
如果输入正好就是那个最好的，你马上说

629
00:46:22,240 --> 00:46:24,790
“好了，你要的答案有了”

630
00:46:24,790 --> 00:46:28,080
然后，你就得到了“好得很”的最好情况

631
00:46:28,080 --> 00:46:30,680
可是你并没有说明绝大多数情况下

632
00:46:30,680 --> 00:46:32,580
将会发生什么的任何信息

633
00:46:32,580 --> 00:46:38,020
所以，你可以采用一个慢速算法

634
00:46:38,020 --> 00:46:41,640
但它对于某些输入很快

635
00:46:41,640 --> 00:46:44,330
这种信息没什么大用

636
00:46:44,330 --> 00:46:47,300
所以一般我们也不为此操心

637
00:46:47,300 --> 00:46:50,520
我们来看看

638
00:46:50,520 --> 00:46:59,270
插入排序的最坏情况时间是多少？

639
00:47:02,520 --> 00:47:06,660
现在我们遇到了一些有趣的事儿

640
00:47:06,660 --> 00:47:12,210
首先，它取决于运行它的计算机

641
00:47:12,210 --> 00:47:17,100
谁的计算机，对吗？

642
00:47:17,100 --> 00:47:23,730
它是个大型超级计算机，还是仅仅是你的腕表芯片？

643
00:47:23,730 --> 00:47:29,240
它们的计算能力大相径庭

644
00:47:29,240 --> 00:47:38,330
而当我们比较算法时，我们通常比较的是其相对速度

645
00:47:38,330 --> 00:47:42,920
也就是两个算法在同一台机器上的表现

646
00:47:45,020 --> 00:47:47,670
你可能会说，那好，什么机器都无所谓

647
00:47:47,670 --> 00:47:50,760
因为我只想知道它们的相对速度

648
00:47:50,760 --> 00:47:55,810
但是，理所当然，我可能也对其绝对速度感兴趣

649
00:47:55,810 --> 00:48:05,390
真有某种算法能无论在什么机器上运行都表现得更好吗？

650
00:48:05,390 --> 00:48:10,230
诸如此类的言论

651
00:48:10,230 --> 00:48:13,490
在我谈论某个软件算法而不涉及硬件时

652
00:48:13,490 --> 00:48:17,180
对最坏情况时间而言会造成一些迷惑

653
00:48:17,180 --> 00:48:20,220
因为，显然，如果我在一台更快的计算机上运行

654
00:48:20,220 --> 00:48:23,150
我的算法会跑得更快

655
00:48:23,150 --> 00:48:33,880
所以，这里我们就要谈到算法的大局观

656
00:48:33,880 --> 00:48:36,410
这也是为什么算法涉猎如此广泛

657
00:48:36,410 --> 00:48:38,190
以及为什么算法可以催生

658
00:48:38,190 --> 00:48:42,250
像Google、Akamai和Amzon这样的巨头

659
00:48:42,250 --> 00:48:49,260
为什么算法分析，在整个计算史上

660
00:48:49,260 --> 00:48:54,650
取得过如此辉煌的成功，为何我们可以掌握

661
00:48:54,650 --> 00:48:59,930
并对付那些看起来一团迷局、复杂无比的局面

662
00:48:59,930 --> 00:49:03,260
把它们简化到可以采用一些数学手段处理的程度

663
00:49:03,260 --> 00:49:11,600
那样的一种观点，就是所谓的渐近分析

664
00:49:15,150 --> 00:49:18,370
而渐近分析的基本思路

665
00:49:18,370 --> 00:49:30,570
则是忽略掉那些依赖于机器的常量

666
00:49:30,570 --> 00:49:38,640
以及，不是去检查实际的运行时间

667
00:49:38,640 --> 00:49:49,440
而是关注运行时间的增长

668
00:49:56,660 --> 00:49:59,700
所以，我们不关注实际的运行时间

669
00:49:59,700 --> 00:50:03,220
我们只关注它如何增长

670
00:50:03,220 --> 00:50:07,300
我们看一下这是什么意思

671
00:50:07,300 --> 00:50:10,000
这种思路很伟大

672
00:50:10,000 --> 00:50:12,660
但并不难理解

673
00:50:12,660 --> 00:50:15,810
不然的话我也不可能在第一讲就拿出来教给你们

674
00:50:15,810 --> 00:50:18,080
但这个思路的确非常伟大

675
00:50:18,080 --> 00:50:22,120
我们要花费数讲的时间来理解它的内涵

676
00:50:22,120 --> 00:50:26,510
而且本质上说，我们整个学期就是在做这么一件事

677
00:50:26,510 --> 00:50:33,030
而且你成为一线工程师的话，成天就干这个

678
00:50:33,030 --> 00:50:37,580
为了做这件事，就要采用一些有助于我们理解的符号

679
00:50:38,700 --> 00:50:44,010
尤其是，我们要采用渐近符号

680
00:50:44,010 --> 00:50:49,570
你们中的大多数已经了解了一些渐近符号

681
00:50:49,570 --> 00:50:54,060
也许有些同学还没见过，但大多数应该多少见过几个

682
00:50:54,060 --> 00:51:00,990
其中一个我们要在这门课里使用的主要符号叫θ符号

683
00:51:00,990 --> 00:51:08,930
θ符号掌握起来很简单，你要做的就是

684
00:51:08,930 --> 00:51:26,790
写个公式，弃去它的低阶项，并忽略前面的常数因子

685
00:51:26,790 --> 00:51:42,240
例如，如果公式为3n³+90n²-5n+6046

686
00:51:42,240 --> 00:51:52,980
我就看什么是要弃去的低阶项？n³比n²阶数高

687
00:51:52,980 --> 00:51:56,980
所以我把这些都弃去，把前面的常数因子也忽略掉

688
00:51:56,980 --> 00:52:00,920
所以我就说，这个公式是θ(n³)的

689
00:52:00,920 --> 00:52:04,210
简单吧？

690
00:52:04,210 --> 00:52:06,570
这就是θ符号

691
00:52:06,570 --> 00:52:12,520
现在，操纵θ符号都已经有了工程方法了

692
00:52:12,520 --> 00:52:15,480
其实它有个数学定义

693
00:52:15,480 --> 00:52:17,920
我们下次再说这个

694
00:52:17,920 --> 00:52:23,010
具体而言，它有一种函数定义

695
00:52:23,010 --> 00:52:25,170
而且，你们得负起责任

696
00:52:25,170 --> 00:52:31,040
因为这既是一门数学课又是一门计算机科学工程课

697
00:52:31,040 --> 00:52:33,150
在整个课程中，你们担负着双重责任

698
00:52:33,150 --> 00:52:37,500
你们既要像对待数学课那样有数学的严谨

699
00:52:37,500 --> 00:52:41,740
又得像工程课那样富于直觉

700
00:52:41,740 --> 00:52:43,810
我们两者都要满足

701
00:52:43,810 --> 00:52:47,330
这里讲的是让你理解在做什么的工程途径

702
00:52:47,330 --> 00:52:50,270
所以你就要负责学会如此这般进行运算

703
00:52:50,270 --> 00:52:51,790
你们同样也要负责

704
00:52:51,790 --> 00:52:54,850
理解θ符号的数学定义

705
00:52:54,850 --> 00:52:59,840
以及和它相关的大O符号和Ω符号

706
00:53:02,770 --> 00:53:09,290
如果我关注当n趋向于无穷大的情况

707
00:53:09,290 --> 00:53:16,540
就知道一个θ(n²)的算法

708
00:53:16,540 --> 00:53:24,910
迟早会战胜一个θ(n³)的算法

709
00:53:24,910 --> 00:53:30,250
假如我用公式来描述这个精确的行为，当n变大时

710
00:53:30,250 --> 00:53:36,050
其它项是什么都不能动摇这个结果

711
00:53:36,050 --> 00:53:40,190
假如我有一个θ(n²)的算法

712
00:53:40,190 --> 00:53:46,300
总有某个充分大的n使得它比θ(n³)的算法快

713
00:53:46,300 --> 00:53:49,100
无论那些低阶项是什么都影响不了这个结果

714
00:53:49,100 --> 00:53:52,200
无论常数项是多少也不会动摇这个结果

715
00:53:52,200 --> 00:53:55,870
这个算法永远会更快

716
00:53:55,870 --> 00:54:03,540
即使你在一台慢速计算机上运行这个θ(n²)算法

717
00:54:03,540 --> 00:54:07,560
而在一台高速计算机上运行这个θ(n³)算法

718
00:54:07,560 --> 00:54:11,420
渐近符号的伟大之处在于

719
00:54:11,420 --> 00:54:18,020
它能一举满足我们对相对和绝对速度的双重比较要求

720
00:54:18,020 --> 00:54:26,550
因为我们在无论什么计算平台上都能实现这一点

721
00:54:26,550 --> 00:54:31,860
在不同的平台上我们也许只是差个常数因子

722
00:54:31,860 --> 00:54:35,250
就是有关运行时间的机器相关的常数因子

723
00:54:35,250 --> 00:54:39,680
但是如果我关注随着输入规模变大的时间增长

724
00:54:39,680 --> 00:54:42,770
渐近结果一般而言不会改变

725
00:54:42,770 --> 00:54:48,730
举个例子，我画个图给大家看

726
00:54:48,730 --> 00:54:53,720
这条轴是n，那条是T(n)

727
00:54:53,720 --> 00:55:01,840
这个，也许是

728
00:55:01,840 --> 00:55:07,960
一个θ(n³)的算法而那是一个θ(n²)的算法

729
00:55:07,960 --> 00:55:12,750
总会有某个点n₀

730
00:55:12,750 --> 00:55:18,450
比它大的任何数，θ(n²)的算法

731
00:55:18,450 --> 00:55:20,930
都比θ(n³)有更小的开销

732
00:55:20,930 --> 00:55:23,440
不管你一开始给后者多大的优势

733
00:55:23,440 --> 00:55:26,110
在计算机的运行速度等方面给再大优势都没用

734
00:55:26,110 --> 00:55:29,970
现在，以工程视角来看

735
00:55:29,970 --> 00:55:32,080
有一些问题我们还是要处理

736
00:55:32,080 --> 00:55:37,010
因为有的时候，这样的n₀是过大了

737
00:55:37,010 --> 00:55:42,610
大到计算机无法运行该算法

738
00:55:42,610 --> 00:55:47,870
这就是为什么我们有时会对一些相对低速的算法有兴趣

739
00:55:47,870 --> 00:55:50,800
因为有些这样的低速算法

740
00:55:50,800 --> 00:55:54,840
尽管用渐近的观点来看，它们有可能较慢

741
00:55:54,840 --> 00:55:56,890
尽管用渐近的观点来看，它们有可能较慢

742
00:55:56,890 --> 00:56:00,880
它们仍然可以在合理规模的输入下运行得更快

743
00:56:00,880 --> 00:56:04,290
因此，我们就必须在我们的数学理解

744
00:56:04,290 --> 00:56:08,880
和工程直觉之间作好权衡才能写出好用的程序

745
00:56:08,880 --> 00:56:11,290
所以，仅仅会做算法分析

746
00:56:11,290 --> 00:56:14,070
并不能使你自动地成为一个编程高手

747
00:56:14,070 --> 00:56:19,620
你还需要学习怎样编程以及在实践中运用这些工具

748
00:56:19,620 --> 00:56:23,460
这样才能了解什么时候它们相关，什么时候又不相关

749
00:56:23,460 --> 00:56:25,700
有一种说法

750
00:56:25,700 --> 00:56:29,130
如果你想成为一个编程高手

751
00:56:29,130 --> 00:56:32,860
只要两年中每天坚持编程，你就能成为编程高手

752
00:56:32,860 --> 00:56:36,990
如果你想成为一名世界级的大牛

753
00:56:36,990 --> 00:56:40,520
你既可以十年如一日每天坚持编程

754
00:56:40,520 --> 00:56:46,120
也可以两年中每天编程，然后上一门算法课

755
00:56:50,520 --> 00:56:57,170
言归正传，继续做插入排序的分析

756
00:56:57,170 --> 00:57:00,370
我们看看最坏情况

757
00:57:13,780 --> 00:57:22,810
这就我们刚才说的，逆向排好序的情形

758
00:57:22,810 --> 00:57:27,250
最大元素占首，最小元素断后

759
00:57:27,250 --> 00:57:31,880
此时每次做插入操作你总要把所有项翻动一遍

760
00:57:31,880 --> 00:57:38,240
你可以看看循环嵌套的情况，写下运行时间

761
00:57:38,240 --> 00:57:40,270
我们要做的就是求和

762
00:57:40,270 --> 00:57:43,300
我们假设，每一种操作

763
00:57:43,300 --> 00:57:47,500
每一种原子操作都耗费某常数时间

764
00:57:47,500 --> 00:57:50,070
这个常数是多少，无关紧要

765
00:57:50,070 --> 00:57:52,420
因为我们做的是渐近分析

766
00:57:52,420 --> 00:57:54,550
如我所说，这种方法的妙处在于

767
00:57:54,550 --> 00:57:59,620
它会使得诸多彼此各异的麻烦一举消失

768
00:57:59,620 --> 00:58:05,790
我们就像是从三万英尺的高度看整件事

769
00:58:05,790 --> 00:58:09,220
而不是从三毫米的距离

770
00:58:09,220 --> 00:58:13,810
这里的每项操作都差不多是某种基本操作

771
00:58:13,810 --> 00:58:16,500
我们进行操作数目计数的一种办法

772
00:58:16,500 --> 00:58:18,380
叫做内存引用计数

773
00:58:18,380 --> 00:58:22,070
你实际上访问了某个变量多少次？

774
00:58:22,070 --> 00:58:25,540
这就是思考这个问题的另一种思路

775
00:58:25,540 --> 00:58:29,990
当我们来做这件事时，好吧，我们遍历该循环

776
00:58:29,990 --> 00:58:33,950
j是从2循环到n

777
00:58:33,950 --> 00:58:38,290
我们把循环里的所有工作全部汇总

778
00:58:38,290 --> 00:58:45,340
我们可以写成数学里的求和号，j是从2到n

779
00:58:45,340 --> 00:58:51,350
然后，循环体中做了哪些工作呢？

780
00:58:51,350 --> 00:58:56,360
好，循环中进行的工作量有各种可能

781
00:58:56,360 --> 00:58:59,120
但考虑最坏情况

782
00:58:59,120 --> 00:59:07,010
对于j的每一个取值，会做多少次操作呢？

783
00:59:07,010 --> 00:59:11,670
对于给定的j值，循环将做多少次操作？

784
00:59:11,670 --> 00:59:16,270
有没有人能用渐近的语言告诉我？

785
00:59:18,830 --> 00:59:28,080
渐近上，这等于j乘上某个常数，所以应该是θ(j)

786
00:59:28,080 --> 00:59:31,360
因此，那里会发生θ(j)次操作

787
00:59:31,360 --> 00:59:35,940
因为内循环里的i以j-1作为初值

788
00:59:35,940 --> 00:59:40,780
然后它在i每次取新值时只做固定量的工作

789
00:59:40,780 --> 00:59:49,990
而i则从是从j-1步降至0

790
00:59:49,990 --> 00:59:56,300
所以我们说那里做了θ(j)数量的工作

791
00:59:56,300 --> 00:59:58,710
你们跟得上我讲的吗？

792
01:00:00,200 --> 01:00:03,120
现在我们得到了一个可用以计算的公式了

793
01:00:03,120 --> 01:00:06,160
怎么计算呢？

794
01:00:06,160 --> 01:00:11,270
如果我想化简该公式，它等于什么呢？

795
01:00:18,060 --> 01:00:20,370
不好意思，后面那位

796
01:00:25,820 --> 01:00:28,110
好，对了

797
01:00:28,110 --> 01:00:32,870
这就是个θ(n²)的算法，对

798
01:00:32,870 --> 01:00:38,410
因为这相当于对连续整数求和，什么意思呢？

799
01:00:38,410 --> 01:00:42,200
有个什么数学术语可以描述它呢？

800
01:00:42,200 --> 01:00:44,300
你得知道这些术语，才能顺利沟通

801
01:00:44,300 --> 01:00:48,190
这就是所谓的哪种数列来着？

802
01:00:48,190 --> 01:00:51,370
实际上它是一种级数，不过没关系

803
01:00:51,370 --> 01:00:54,250
这叫什么级数？

804
01:00:54,250 --> 01:00:56,910
算术级数，很好

805
01:00:56,910 --> 01:01:01,820
哇，我们中间颇有一些高手，沟通就好办了

806
01:01:01,820 --> 01:01:03,970
这是个算术级数

807
01:01:03,970 --> 01:01:09,600
你基本上是像1+2+3+4这样一些常数求和

808
01:01:09,600 --> 01:01:14,410
但说到底它是1+2+3+4+5+6一直加到n

809
01:01:14,410 --> 01:01:17,650
这当然是θ(n²)的

810
01:01:17,650 --> 01:01:20,070
你要是不懂这部分的数学

811
01:01:20,070 --> 01:01:24,110
书中专门有一章你可以看看，或者还是老话，去修预备课程

812
01:01:24,110 --> 01:01:29,810
算术级数

813
01:01:29,810 --> 01:01:32,860
你们总算还有点儿印象，对

814
01:01:32,860 --> 01:01:35,040
好

815
01:01:35,040 --> 01:01:38,530
现在，你必须学会这些运算

816
01:01:38,530 --> 01:01:41,010
我们下次还会提一些这个内容

817
01:01:41,010 --> 01:01:45,270
但你得学会θ运算，并了解θ符号是做什么的

818
01:01:45,270 --> 01:01:48,830
并且你要特别小心，因为θ是一种弱符号

819
01:01:48,830 --> 01:01:53,330
强符号是像微积分中莱布尼茨符号这样的东西

820
01:01:53,330 --> 01:01:56,990
用它，链式法则可以直接约分消项

821
01:01:56,990 --> 01:02:00,940
能在链式法则内消项是很神奇的事

822
01:02:00,940 --> 01:02:06,580
莱布尼茨符号的表达那么直接，以至于你可以直接运算

823
01:02:06,580 --> 01:02:09,870
θ符号不是这样的

824
01:02:09,870 --> 01:02:12,300
如果你认为它是这样的，你就有麻烦了

825
01:02:12,300 --> 01:02:15,730
你得想明白θ符号背后究竟做了什么工作

826
01:02:15,730 --> 01:02:21,120
与其说它是个运算符号，不如说它是个描述符号

827
01:02:21,120 --> 01:02:23,400
你的确可以用它来进行一些运算

828
01:02:23,400 --> 01:02:25,510
但除非你明白是怎么回事

829
01:02:25,510 --> 01:02:29,400
否则在θ符号下你会发现自己陷入麻烦

830
01:02:29,400 --> 01:02:32,650
下次我们会讲更多有关θ符号的内容

831
01:02:32,650 --> 01:02:42,730
插入排序快不快？

832
01:02:42,730 --> 01:02:51,320
嗯，对于很小的n，它挺快的

833
01:03:00,310 --> 01:03:09,800
但是对于巨大的n就完全不是那么回事了

834
01:03:15,780 --> 01:03:19,610
所以我要给你一个更快的算法

835
01:03:19,610 --> 01:03:21,660
叫做归并排序

836
01:03:21,660 --> 01:03:23,890
插入排序还留着吗

837
01:03:23,890 --> 01:03:26,750
干嘛不呢

838
01:03:43,450 --> 01:03:46,310
这里的我呆会儿写

839
01:03:46,310 --> 01:03:51,240
如果你要做笔记，在左边留点空

840
01:03:51,240 --> 01:03:59,020
这是对于数组A[1..n]的归并排序

841
01:03:59,020 --> 01:04:02,790
它有三个基本步骤

842
01:04:02,790 --> 01:04:07,870
如果n是1，那我们做完了

843
01:04:07,870 --> 01:04:11,530
对一个元素排序，那它已经是排好序的

844
01:04:11,530 --> 01:04:12,780
好

845
01:04:12,780 --> 01:04:15,320
递归算法

846
01:04:15,320 --> 01:04:16,100
否则

847
01:04:16,100 --> 01:04:28,640
我们做的就是递归地对A[1到n/2向上取整]这部分

848
01:04:28,640 --> 01:04:42,200
以及A[n/2+1向上取整..n]这部分排序

849
01:04:42,200 --> 01:04:49,160
所以，我们的输入是分成两半的

850
01:04:49,160 --> 01:04:58,480
然后，第三步，我们把排好序的两个表归并

851
01:04:58,480 --> 01:05:01,260
而且，为了实现这一点

852
01:05:01,260 --> 01:05:05,810
我们用了一个归并子程序，一会儿给你看

853
01:05:11,240 --> 01:05:24,250
关键的子程序在于归并，它是这样做的

854
01:05:24,250 --> 01:05:27,150
两张表，假定其中一张有20…

855
01:05:27,150 --> 01:05:31,160
我按相反顺序做，先对它这样排序

856
01:05:31,160 --> 01:05:34,450
然后我同样排序另一张表

857
01:05:34,450 --> 01:05:37,340
我也不知道为什么按这个顺序，无论如何

858
01:05:37,340 --> 01:05:40,410
这是另一张表

859
01:05:40,410 --> 01:05:42,940
我现在有两张已经排好序的表

860
01:05:42,940 --> 01:05:50,110
好，这个就是A[1..n/2]，那个就是A[n/2+1..n]

861
01:05:50,110 --> 01:05:53,680
这就是程序要调用的排序方式

862
01:05:53,680 --> 01:05:57,250
要归并它们两个，我要做的是

863
01:05:57,250 --> 01:06:00,320
从这两者出发得到一个排好序的总表

864
01:06:00,320 --> 01:06:05,240
我要做的是先观察

865
01:06:05,240 --> 01:06:11,350
两张已排序的列表中，最小元素是多少？

866
01:06:11,350 --> 01:06:17,130
它在两个地方之一，第一张表之首或第二张表之首

867
01:06:17,130 --> 01:06:23,310
我看一下这两个元素哪个更小，这个更小

868
01:06:23,310 --> 01:06:29,670
然后我将这两个中较小的那个输出到最终的输出数组中

869
01:06:29,670 --> 01:06:31,100
然后叉掉

870
01:06:31,100 --> 01:06:33,560
下一个最小元素在哪？

871
01:06:33,560 --> 01:06:37,000
答案仍是两个列表的首元素之一

872
01:06:37,000 --> 01:06:41,880
我叉掉这个家伙，放在这里，圈上这个

873
01:06:41,880 --> 01:06:44,590
现在我看这两个家伙

874
01:06:44,590 --> 01:06:49,870
这个更小，所以我把它输出，圈上那个

875
01:06:49,870 --> 01:06:52,880
现在我看这两个，输出9

876
01:06:52,880 --> 01:06:57,840
所以，这里的每一步都是固定数目的操作

877
01:06:57,840 --> 01:07:01,350
这和每一步中的数组尺寸无关

878
01:07:01,350 --> 01:07:05,850
每一步中，我只关注两个元素

879
01:07:05,850 --> 01:07:10,310
并挑出最小的，再把数组指针推进一位

880
01:07:10,310 --> 01:07:13,860
所以我总是知道当前的表头在哪

881
01:07:13,860 --> 01:07:26,860
是故，对于总数为n的输入，时间是θ(n)的

882
01:07:29,300 --> 01:07:35,960
把这两个遍历和归并的时间是θ(n)

883
01:07:35,960 --> 01:07:40,480
我们有时将此称为线性时间

884
01:07:40,480 --> 01:07:45,000
因为它不是平方的或怎么样的

885
01:07:45,000 --> 01:07:49,790
它与n成正比，与输入规模成正比，这就是线性时间

886
01:07:49,790 --> 01:07:52,220
我在遍历时，仅仅做这些简单操作

887
01:07:52,220 --> 01:07:54,220
先把这些表做出来

888
01:07:54,220 --> 01:07:57,030
最后我做了必须的n个操作

889
01:07:57,030 --> 01:08:00,240
线性阶次操作，每个操作耗费常数时间

890
01:08:00,240 --> 01:08:03,090
所以总时间是θ(n)的

891
01:08:05,330 --> 01:08:08,830
大家跟得上吗？好

892
01:08:08,830 --> 01:08:13,920
那么，这是个递归程序

893
01:08:13,920 --> 01:08:17,960
我们实际上可以为该程序写出一个所谓递归式

894
01:08:17,960 --> 01:08:23,860
我们这么做，比如为n个元素排序的时间是T(n)

895
01:08:23,860 --> 01:08:33,020
第一步要用多长时间？

896
01:08:33,020 --> 01:08:35,620
只用了常数时间

897
01:08:35,620 --> 01:08:40,050
我们只是检查n是否为1，如果是则返回

898
01:08:40,050 --> 01:08:44,410
这一步与我们所做工作的输入规模毫无关系

899
01:08:44,410 --> 01:08:47,060
它只耗费固定数目的机器指令

900
01:08:47,060 --> 01:08:50,850
无论什么机器都一样，我们只说常数时间

901
01:08:50,850 --> 01:08:52,160
我们称之为θ(1)

902
01:08:52,160 --> 01:08:56,570
如果你较真的话，好吧，这有点儿滥用θ符号的意思

903
01:08:56,570 --> 01:08:59,380
其原因是，典型情况下

904
01:08:59,380 --> 01:09:02,290
如果你要用这个符号你就要描述它增长时的情形

905
01:09:02,290 --> 01:09:05,800
反正，我们这里就滥用一次这个记号表示

906
01:09:05,800 --> 01:09:07,170
“它是个常数”

907
01:09:07,170 --> 01:09:13,000
总之，"滥用"，写在这里提醒你们

908
01:09:13,000 --> 01:09:16,730
不过写θ(1)确实可以让事情变得简单

909
01:09:16,730 --> 01:09:19,250
而且它想要表达的意思是一样的

910
01:09:19,250 --> 01:09:23,050
现在我们递归地对这两者排序

911
01:09:23,050 --> 01:09:27,710
我怎么来描述呢？

912
01:09:27,710 --> 01:09:35,590
做这个的时候，我可以递归地描述成

913
01:09:35,590 --> 01:09:46,020
T(n/2向上取整)+T(n减去n/2向上取整)

914
01:09:46,020 --> 01:09:49,460
这看起来好像有点儿乱

915
01:09:49,460 --> 01:09:54,800
所以我们就略去细节，写成2T(n/2)

916
01:09:54,800 --> 01:09:58,320
这真的是只是略去细节

917
01:09:58,320 --> 01:10:04,280
周五的复习课上，我们会看到为什么可以这样略去

918
01:10:04,280 --> 01:10:06,350
这是关于算法的大妙处

919
01:10:06,350 --> 01:10:11,560
只要你严格而精确，你可以任意略去细节

920
01:10:13,680 --> 01:10:17,760
这种略去，是因为我不担心会发生意外

921
01:10:17,760 --> 01:10:19,790
因为到头来是没区别的

922
01:10:19,790 --> 01:10:22,150
而我们将要看到，正是如此

923
01:10:22,150 --> 01:10:28,650
最后，我要归并已排好序的、总元素数为n的两张表

924
01:10:28,650 --> 01:10:31,420
我们刚刚用归并子程序分析过

925
01:10:31,420 --> 01:10:34,060
这耗用了我们θ(n)的时间

926
01:10:34,060 --> 01:10:43,360
这就使得我们现在能够为归并排序的性能写出递归表达式

927
01:10:49,420 --> 01:11:03,580
就是说，若n=1，则T(n)=θ(1)

928
01:11:03,580 --> 01:11:14,390
而如果n>1，则T(n)=2T(n/2)+θ(n)

929
01:11:19,560 --> 01:11:25,810
因为无论我做的是第一步还是全部的三个步骤

930
01:11:25,810 --> 01:11:28,680
要么，我做第一步并返回，就做完了

931
01:11:28,680 --> 01:11:33,100
要么，我做第一步，没返回，接着做二三两步

932
01:11:33,100 --> 01:11:34,430
然后把所有的加起来

933
01:11:34,430 --> 01:11:40,190
我可以说结果是θ(n)+θ(1)，但θ(n)+θ(1)就是θ(n)

934
01:11:40,190 --> 01:11:45,760
因为θ(1)比θ(n)低阶，可以直接舍去

935
01:11:45,760 --> 01:11:53,500
它或是θ(1)或是2T(n/2)+θ(n)

936
01:11:53,500 --> 01:11:57,780
好吧，我们通常不写这个

937
01:11:57,780 --> 01:12:01,430
通常我们省略这个

938
01:12:01,430 --> 01:12:04,510
它对递归解没有影响

939
01:12:04,510 --> 01:12:07,040
通常我们会省略常数的基本情形

940
01:12:07,040 --> 01:12:10,640
注意，在数学中一般不成立

941
01:12:10,640 --> 01:12:14,900
但在算法中如果你给的是常数规模的输入

942
01:12:14,900 --> 01:12:17,140
那它也只需要常数的运行时间

943
01:12:17,140 --> 01:12:20,520
所以，我们并不操心具体的是多少

944
01:12:20,520 --> 01:12:26,150
而且，这对于递归的渐近解并无实际影响

945
01:12:26,150 --> 01:12:29,410
我们怎么样解这样的递归式？

946
01:12:29,410 --> 01:12:33,290
现在我是用T(n/2)来表示T(n)的

947
01:12:35,730 --> 01:12:40,170
这个书上有，我们在第二讲中也会讲

948
01:12:40,170 --> 01:12:44,490
我们将在第二讲中解决这个问题

949
01:12:44,490 --> 01:12:46,970
但现在，我将

950
01:12:46,970 --> 01:12:52,520
让大家直观地理解究竟运行成本几何

951
01:12:52,520 --> 01:12:55,050
这种方法的具体知识下集分解

952
01:12:55,050 --> 01:13:00,080
它叫做递归树方法

953
01:13:00,080 --> 01:13:05,980
我会在实际的递归式上应用该方法

954
01:13:05,980 --> 01:13:11,140
T(n)基本上等于2T(n/2)…

955
01:13:11,140 --> 01:13:12,880
后面的式子我也显式地也写出来

956
01:13:11,140 --> 01:13:24,380
即用cn替换θ(n)的形式来描述

957
01:13:12,880 --> 01:13:15,570
因为我想让你明白这是怎么来的

958
01:13:15,570 --> 01:13:24,380
后面加上某个常数，乘以n，c是大于0的常数

959
01:13:24,380 --> 01:13:29,700
所以我们来看看这个基本情形为θ(1)的递归式

960
01:13:29,700 --> 01:13:33,570
我只是把常数写了出来

961
01:13:33,570 --> 01:13:37,010
用cn显式函数地替换掉了隐式的θ(n)

962
01:13:33,570 --> 01:13:37,010
θ(n)是线性的，和cn等价，所以可以这么表示

963
01:13:37,010 --> 01:13:40,960
构造递归树的方法如下

964
01:13:40,960 --> 01:13:46,240
你先把递归式的左半部分写下来

965
01:13:46,240 --> 01:13:49,950
然后你说，好，这个等于

966
01:13:49,950 --> 01:13:53,040
现在我们把它写成树状结构

967
01:13:53,040 --> 01:13:59,510
我做了cn的工作，加上我必须在子节点处做这些

968
01:14:02,580 --> 01:14:05,880
如果我在这里把结果加起来的话

969
01:14:05,880 --> 01:14:12,090
我得到这个，因为递归式说T(n)=2T(n/2)+cn

970
01:14:12,090 --> 01:14:15,060
我得到了2T(n/2)+cn

971
01:14:15,060 --> 01:14:17,460
然后继续下去

972
01:14:17,460 --> 01:14:20,020
我这里有个cn

973
01:14:20,020 --> 01:14:23,470
现在我这里有个cn/2

974
01:14:23,470 --> 01:14:25,930
这里也有cn/2

975
01:14:25,930 --> 01:14:30,070
现在，每一项变成T(n/4)了

976
01:14:30,070 --> 01:14:36,060
这些项各有T(n/4)

977
01:14:36,060 --> 01:14:40,070
这里得到了T(n/4)

978
01:14:40,070 --> 01:14:46,490
然后我一直做下去，危险的省略号

979
01:14:51,940 --> 01:14:57,980
并且，如果我一直做下去，最终就会变成这样

980
01:15:16,380 --> 01:15:20,290
我一直探下去，直到到达叶节点

981
01:15:20,290 --> 01:15:26,410
对于叶节点，我只有T(1)，即θ(1)

982
01:15:28,450 --> 01:15:37,390
所以我的第一个问题是，这树的高度是多少？

983
01:15:39,060 --> 01:15:42,890
对，lgn

984
01:15:42,890 --> 01:15:46,390
实际上，它精确地接近lgn

985
01:15:46,390 --> 01:15:50,630
因为我是从顶点n出发的

986
01:15:50,630 --> 01:15:59,070
然后我n/2、n/4这样一路算下去，直到1为止

987
01:15:59,070 --> 01:16:02,120
从n到1的折半次数是lgn

988
01:16:02,130 --> 01:16:04,800
所以这里的高度也是lgn

989
01:16:04,800 --> 01:16:09,370
其实是lgn的常数倍

990
01:16:09,370 --> 01:16:10,800
不过不要紧

991
01:16:10,800 --> 01:16:13,670
那末，顺便问下，树上有多少叶节点？

992
01:16:21,890 --> 01:16:26,480
整棵树上的叶节点数目是多少？请讲

993
01:16:28,570 --> 01:16:33,450
叶节点的数目…其实就是n

994
01:16:34,240 --> 01:16:37,230
如果你这样一路算下来

995
01:16:37,230 --> 01:16:40,090
我们来做一些简化的假设

996
01:16:40,090 --> 01:16:45,660
设n是个2的完全幂数，即2的整数次幂

997
01:16:45,660 --> 01:16:49,070
这样，降到T(1)时，正好有lgn步

998
01:16:49,070 --> 01:16:56,760
是故总共有n个叶节点，因为这里的叶节点总数

999
01:16:56,760 --> 01:17:02,770
这一级上的节点数是1，然后是2、4、8

1000
01:17:02,770 --> 01:17:08,380
如果树的高度是h，我就有2的h次方个叶节点

1001
01:17:08,380 --> 01:17:14,250
这里是2的lgn次方，这正好是n

1002
01:17:14,250 --> 01:17:17,020
我们这是做数学题呢，对吧？

1003
01:17:18,750 --> 01:17:22,340
现在，让我们计算一下做了多少工作

1004
01:17:22,340 --> 01:17:27,060
看一下T(n)情况下把树中的一切加起来是多少

1005
01:17:27,060 --> 01:17:29,960
让我们来算一下总和

1006
01:17:29,960 --> 01:17:32,090
好，让我们一级级地加和

1007
01:17:32,090 --> 01:17:35,300
第一级中我们用了多少时间？仅仅是cn

1008
01:17:35,300 --> 01:17:41,860
如果我把第二级的加起来有多少？cn

1009
01:17:41,860 --> 01:17:47,770
第三级怎么样？还是cn

1010
01:17:47,770 --> 01:17:56,300
那所有的叶结点加起来有多少？θ(n)

1011
01:17:58,490 --> 01:18:07,820
它不一定就是cn，因为边界情况可能是别的常数

1012
01:18:07,820 --> 01:18:11,590
它实际上是θ(n)，但在这里算下来都是cn

1013
01:18:11,590 --> 01:18:22,080
如果我计算总数，那就是cn乘以lgn

1014
01:18:22,080 --> 01:18:24,130
因为那是树的高度

1015
01:18:24,130 --> 01:18:28,210
也是我有多少个cn，还要加上θ(n)

1016
01:18:28,210 --> 01:18:34,270
第一项比第二项高阶，所以第二项不要了

1017
01:18:34,270 --> 01:18:40,430
常数项不要了，这就等价于θ(nlgn)

1018
01:18:40,430 --> 01:18:52,700
而且考虑渐近的情况，θ(nlgn)比θ(n²)要快

1019
01:18:52,700 --> 01:18:58,920
因此，归并排序在一个充分大的输入规模下

1020
01:18:58,920 --> 01:19:01,210
将优于插入排序

1021
01:19:03,090 --> 01:19:06,620
归并排序是个更快的算法

1022
01:19:06,620 --> 01:19:09,870
不好意思，我没发现你们看不到那里

1023
01:19:13,970 --> 01:19:17,380
看不见的话就要说嘛

1024
01:19:17,380 --> 01:19:20,730
所以，这是一个更快的算法

1025
01:19:20,730 --> 01:19:25,310
因为θ(nlgn)的算法比θ(n²)的增长得慢

1026
01:19:25,310 --> 01:19:29,080
所以渐近情况下，归并排序胜过插入排序

1027
01:19:29,080 --> 01:19:31,760
即使你在一台超级计算机上运行插入排序

1028
01:19:31,760 --> 01:19:36,460
而另一个人在PC上运行归并排序

1029
01:19:37,170 --> 01:19:40,530
在输入规模充分大时也是后者会赢

1030
01:19:40,530 --> 01:19:46,590
因为事实上在n充分大时，n²就是比nlgn大

1031
01:19:46,590 --> 01:19:55,690
并且实际上，在n大于，30吧，归并排序就更快了

1032
01:19:55,690 --> 01:19:58,730
如果你有一个很小的输入，30个元素左右的规模

1033
01:19:58,730 --> 01:20:01,840
插入排序是个完美优雅的可用排序算法

1034
01:20:01,840 --> 01:20:06,260
但是，归并排序终将快很多

1035
01:20:06,260 --> 01:20:13,120
即使在只有百把个元素的规模的情况下

1036
01:20:13,120 --> 01:20:17,760
归并排序也将成为更快的算法

1037
01:20:17,760 --> 01:20:21,780
课就上到这儿好不好？

1038
01:20:21,780 --> 01:20:27,190
记得领取复习课作业，然后周五来上复习课

1039
01:20:27,190 --> 01:20:29,830
因为我们还有好些事儿得做呢

1040
01:20:29,830 --> 01:20:31,930
因为我们还有好些事儿得做呢

1041
01:20:31,930 --> 01:20:33,960
下周一见

