1
00:00:04,850 --> 00:00:07,850
-- 最短路径

2
00:00:14,460 --> 00:00:16,670
这次是最终回了

3
00:00:17,080 --> 00:00:19,550
希望这次也是值得期待啊

4
00:00:19,660 --> 00:00:22,220
提醒一下 接下来会有个小测验哦亲

5
00:00:22,290 --> 00:00:23,540
是时候开始复习了

6
00:00:23,660 --> 00:00:26,570
因为测验 我就不布置作业了

7
00:00:26,650 --> 00:00:28,920
考虑到你们现在肯定要复习的

8
00:00:29,000 --> 00:00:30,800
这是个课后测验

9
00:00:30,900 --> 00:00:32,940
你们周一都必须回来上课

10
00:00:33,010 --> 00:00:35,670
当然 在座的都会来 不过现在在家看视频的人

11
00:00:35,740 --> 00:00:39,700
下周一也得回来参加考试

12
00:00:39,770 --> 00:00:44,090
这是课程的要求

13
00:00:47,600 --> 00:00:53,300
因此 我们要回顾下 到目前为止 这三部曲的重点

14
00:00:53,380 --> 00:00:58,650
那么 上两次课 之前那两集

15
00:00:58,730 --> 00:01:02,880
是关于单源最短路径

16
00:01:04,710 --> 00:01:08,620
那么 如果我们要找到最短路径

17
00:01:08,700 --> 00:01:11,930
从源点到其他每个顶点的最短路径

18
00:01:13,480 --> 00:01:18,600
我们有这样几个算法来求解

19
00:01:18,780 --> 00:01:24,080
回顾一下 我们知道在未加权的情况下

20
00:01:24,160 --> 00:01:27,110
这是最简单的 所有的边的长度都是1

21
00:01:27,240 --> 00:01:29,540
那我们可以使用广度优先搜索算法

22
00:01:29,610 --> 00:01:33,330
它的时间复杂度 在图的范畴里是线性的

23
00:01:33,410 --> 00:01:36,430
即顶点数和边的数目之和

24
00:01:37,930 --> 00:01:41,140
而第二个最简单的情况

25
00:01:41,320 --> 00:01:44,450
是非负权边

26
00:01:49,160 --> 00:01:54,180
在这个案例中 我们应该使用哪种算法呢

27
00:01:54,390 --> 00:01:58,320
Dijkstra算法 挺带感嘛 大家都目光炯炯啊

28
00:01:58,550 --> 00:02:01,650
都学会抢答了 果然是期末的节奏

29
00:02:03,100 --> 00:02:07,630
所以这个基本上是线性时间

30
00:02:07,730 --> 00:02:12,440
如果你用对了堆结构的话

31
00:02:12,550 --> 00:02:15,730
那就是V log V + E

32
00:02:15,870 --> 00:02:19,310
而在一般情况下 对于一般的权值

33
00:02:19,390 --> 00:02:24,650
我们用的是Bellman-Ford算法

34
00:02:26,320 --> 00:02:35,250
这需要花费VE 矮油不错嘛 不过这个就略显低端了

35
00:02:35,320 --> 00:02:37,230
因为这个log可以忽略

36
00:02:37,310 --> 00:02:39,390
所以 Dijkstra算法基本也是线性的

37
00:02:39,460 --> 00:02:41,550
但Bellman-Ford算法至少是平方阶的

38
00:02:41,640 --> 00:02:43,830
如果你有一个连通图

39
00:02:43,900 --> 00:02:46,740
所以在稀疏情况下 当E是V阶的时候

40
00:02:46,820 --> 00:02:50,400
这个是线性的 这个却是平方阶的

41
00:02:50,480 --> 00:02:53,050
在密集情况下 当E大约是V的平方的时候

42
00:02:53,130 --> 00:02:56,960
这个是平方阶的 而这个是立方阶的

43
00:02:57,040 --> 00:02:58,590
所以 Dijkstra算法和Bellman-Ford算法

44
00:02:58,660 --> 00:03:03,030
是以一个V阶因数区分开的

45
00:03:03,140 --> 00:03:04,970
这就非常糟糕了

46
00:03:05,190 --> 00:03:08,190
好的 但这是我们能想到的最好办法了

47
00:03:08,290 --> 00:03:11,950
对于单源最短路径 有负权边的情况下

48
00:03:12,020 --> 00:03:14,990
Bellman-Ford算法是最好的了

49
00:03:15,080 --> 00:03:20,560
我们在复习课中还看到DAG的情况

50
00:03:20,630 --> 00:03:23,690
这个怎么办？

51
00:03:25,810 --> 00:03:30,070
[学生]:……

52
00:03:30,140 --> 00:03:32,610
[教授]:拓扑排序 噢耶

53
00:03:34,850 --> 00:03:36,430
没错 你们可以用拓扑排序

54
00:03:36,500 --> 00:03:38,400
来得到这些顶点的顺序

55
00:03:38,470 --> 00:03:42,760
来运行一次Bellman-Ford算法

56
00:03:43,380 --> 00:03:46,780
这是一种思考方式

57
00:03:48,990 --> 00:03:52,470
在运行Bellman-Ford算法时

58
00:03:52,560 --> 00:03:55,720
按照拓扑排序得到的顺序

59
00:03:55,840 --> 00:03:59,400
然后你得到了一个线性时间算法

60
00:04:00,870 --> 00:04:03,610
那么 我们也知道DAG的解法

61
00:04:03,710 --> 00:04:08,030
即使是加权 或未加权的情况 都可以用线性时间来做

62
00:04:08,120 --> 00:04:09,700
绝大多数的情况下是这样

63
00:04:09,770 --> 00:04:12,070
这个一定要记住 在测验里

64
00:04:12,150 --> 00:04:13,440
如果遇到了一个最短路径问题

65
00:04:13,510 --> 00:04:14,960
或者是你最终确定

66
00:04:15,060 --> 00:04:16,950
这是一个最短路径问题 想想看

67
00:04:17,030 --> 00:04:20,790
在这情况下哪个算法会最好

68
00:04:20,870 --> 00:04:23,470
好的 这就是单源最短路径问题

69
00:04:23,540 --> 00:04:27,260
那么 在我们死星的发展史中

70
00:04:27,330 --> 00:04:29,760
最初这只是非负权边

71
00:04:29,830 --> 00:04:31,090
然后我们遇到了负权边

72
00:04:31,180 --> 00:04:33,520
今天 死星又开了新的副本

73
00:04:33,630 --> 00:04:37,390
最终boss叫“全对最短路径”问题

74
00:04:37,890 --> 00:04:39,610
这次我们要求的

75
00:04:39,680 --> 00:04:42,610
是每一对顶点之间的最短路径

76
00:04:56,540 --> 00:05:00,110
好 让我们看些显而易见的结果

77
00:05:00,210 --> 00:05:02,150
在这种情况下 我们怎么做？

78
00:05:02,220 --> 00:05:10,260
举个栗子 假设我有一个未加权的图

79
00:05:10,600 --> 00:05:12,540
大家有什么建议么

80
00:05:12,620 --> 00:05:16,110
我该如何求出“全对最短路径”

81
00:05:19,010 --> 00:05:20,630
我想知道每一对顶点间

82
00:05:20,700 --> 00:05:23,160
它们的最短路径权重

83
00:05:23,530 --> 00:05:24,500
[学生]：BFS（广度优先搜索）

84
00:05:24,570 --> 00:05:35,500
[教授]：BFS 能多说点么亲？

85
00:05:35,670 --> 00:05:37,680
[学生]：……

86
00:05:37,750 --> 00:05:45,290
[教授]:好吧 用BFS搜索V次  我是说用V次BFS

87
00:05:45,390 --> 00:05:53,930
明白吧？ 所以我们的运行时间会是V^2 + V*E

88
00:05:54,040 --> 00:05:58,560
嗯 假设你的图是连通图

89
00:05:58,670 --> 00:06:00,760
那就是V乘以E

90
00:06:01,310 --> 00:06:06,360
好 很好 这大概是我们知道的最好的算法了

91
00:06:06,430 --> 00:06:08,630
对于未加权图来说

92
00:06:08,740 --> 00:06:11,590
所以 一切的一切都指向一个明显的答案				

93
00:06:11,660 --> 00:06:14,870
你编写一个单源算法 然后运行它V次

94
00:06:14,950 --> 00:06:16,620
那就是最好的方法了

95
00:06:16,730 --> 00:06:17,960
或者是我们知道的最好方法了

96
00:06:18,030 --> 00:06:18,840
这还挺不错嘛

97
00:06:18,920 --> 00:06:23,170
对比来看 这就像Bellman-Ford算法中的一次迭代

98
00:06:23,260 --> 00:06:24,540
我们肯定至少需要

99
00:06:24,610 --> 00:06:27,510
大概V^2的时间 因为输出的大小是V^2

100
00:06:27,570 --> 00:06:29,940
我们必须计算V^2个最短路径权值

101
00:06:30,040 --> 00:06:32,280
这并不是最完美的 不过还不赖

102
00:06:32,390 --> 00:06:36,100
我们也不打算改进这方法了

103
00:06:36,850 --> 00:06:43,270
所以对于非负权边 最自然的解决方法就是

104
00:06:43,340 --> 00:06:48,540
运行Dijkstra算法V次 没啥好说的

105
00:06:51,190 --> 00:06:56,440
所需要的运行时间是 嗯 还是V乘以E

106
00:06:56,510 --> 00:07:05,710
加上V的平方 乘以log V  这个也不差

107
00:07:05,810 --> 00:07:09,140
我的意思是 这基本和BFS差不多

108
00:07:09,220 --> 00:07:10,430
然后 这还有个log因子

109
00:07:10,510 --> 00:07:13,560
如果你把log忽略不计 这个就是决定项了

110
00:07:13,660 --> 00:07:16,190
然后 这还有一个V的平方

111
00:07:16,280 --> 00:07:18,930
所以它们都挺不错的

112
00:07:19,000 --> 00:07:20,810
我的意思是 这挺整洁的 但其实

113
00:07:20,890 --> 00:07:25,220
在运行Bellman-Ford再加一个log的因子的时间里

114
00:07:25,320 --> 00:07:27,210
你已经能够求出所有最短路径了

115
00:07:27,290 --> 00:07:29,390
如果都是非负权边的话

116
00:07:29,460 --> 00:07:32,710
所以 我的意思是 比较单源和全对最短路径

117
00:07:32,780 --> 00:07:34,480
这个看起来就犀利多了

118
00:07:34,540 --> 00:07:38,400
当然我们只能处理非负权边

119
00:07:39,120 --> 00:07:43,660
好 我们现在来设想更平凡的情况

120
00:07:45,820 --> 00:07:48,000
嗯 这就是我们今天这课的重点

121
00:07:48,110 --> 00:07:50,070
也是我们可以作出改进的地方

122
00:07:50,180 --> 00:07:55,310
显然 V次的Bellman-Ford算法

123
00:08:00,220 --> 00:08:05,250
需要花费V^2*E

124
00:08:06,150 --> 00:08:08,080
这就显得太渣了点

125
00:08:08,150 --> 00:08:10,120
我们现在就要调教它

126
00:08:10,190 --> 00:08:13,290
让它更接近这个非负权边的界

127
00:08:13,370 --> 00:08:15,660
而结果是 我们确实可以做出相应的改进

128
00:08:15,780 --> 00:08:17,090
而在这些特殊的情况中

129
00:08:17,170 --> 00:08:20,080
我们真心抢救不能

130
00:08:20,160 --> 00:08:21,820
好吧 我也说不出为什么

131
00:08:21,960 --> 00:08:23,180
但事实就是如此

132
00:08:23,250 --> 00:08:24,800
我们将会涉及到

133
00:08:24,870 --> 00:08:30,490
应对此问题的三个算法

134
00:08:32,330 --> 00:08:34,720
最后一个会是最好的

135
00:08:34,830 --> 00:08:37,050
不过在过程中我们会看到一些

136
00:08:37,150 --> 00:08:39,580
最短路径与动态规划之间神奇的联系

137
00:08:39,650 --> 00:08:40,690
这些是我们以前没有见过的

138
00:08:40,800 --> 00:08:44,290
我们看过了应用贪心算法来求最短路径

139
00:08:44,360 --> 00:08:46,970
但今天我们做动态规划

140
00:08:47,080 --> 00:08:49,500
直观地说 对于“全对最短路径”

141
00:08:49,610 --> 00:08:53,040
其实有很多潜在的可重用的子问题

142
00:08:53,110 --> 00:08:54,280
我们要计算所有的x和y间

143
00:08:54,380 --> 00:08:56,240
从x到y的最短路径

144
00:08:56,310 --> 00:08:58,040
或许 在计算其他最短路径时

145
00:08:58,110 --> 00:09:01,270
我们可以重用已经算好的路径

146
00:09:01,350 --> 00:09:05,640
我们可以说 这就有了更多的可重用性了

147
00:09:05,750 --> 00:09:12,570
好 让我们快速定义一下 “全对最短路径”

148
00:09:12,650 --> 00:09:16,190
因为接下来 我们要稍微改变一下表示法

149
00:09:16,310 --> 00:09:18,820
这是因为我们现在关注的是“全对的”

150
00:09:19,000 --> 00:09:23,600
所以 好像以往一样 输入的是有向图

151
00:09:23,800 --> 00:09:25,500
顶点和边

152
00:09:25,610 --> 00:09:28,610
我们说把这些顶点

153
00:09:28,680 --> 00:09:34,650
为了方便 标记为从1到n

154
00:09:34,760 --> 00:09:38,010
因为对于“全对的”来说

155
00:09:38,080 --> 00:09:40,710
我们最好是把它想象成一个n阶矩阵

156
00:09:40,780 --> 00:09:44,170
来替代通常意义的边

157
00:09:44,250 --> 00:09:47,500
因为如果用邻接表的话

158
00:09:47,580 --> 00:09:51,290
不是那么容易理解

159
00:09:54,710 --> 00:09:57,080
按惯例 这些边也是加权的

160
00:09:57,150 --> 00:09:59,020
这就是有趣的地方

161
00:09:59,090 --> 00:10:01,760
有些边会变成负的

162
00:10:02,100 --> 00:10:05,350
w 可以是全体实数

163
00:10:05,450 --> 00:10:11,390
而输出目标就是最短路径矩阵

164
00:10:11,450 --> 00:10:14,800
所以这现在是一个n阶矩阵

165
00:10:14,870 --> 00:10:18,580
n只是顶点的数目

166
00:10:18,650 --> 00:10:22,410
表示最短路径权重的矩阵

167
00:10:29,960 --> 00:10:36,090
那么δ(i,j)是从i到j的最短路径权重

168
00:10:36,200 --> 00:10:39,590
对于所有的顶点对

169
00:10:43,000 --> 00:10:44,290
所以 你可以把这个表示为

170
00:10:44,360 --> 00:10:47,200
一个n阶矩阵

171
00:10:48,650 --> 00:10:55,860
好 现在开始我们的算法

172
00:10:55,930 --> 00:10:58,000
首先我们有非常简单的算法

173
00:10:58,070 --> 00:10:59,520
V次的Bellman-Ford算法

174
00:10:59,600 --> 00:11:03,180
E*V^2 为了比较

175
00:11:03,250 --> 00:11:05,620
我要说 让我们重新写下这些

176
00:11:05,700 --> 00:11:15,450
V次的Bellman-Ford算法耗费E*V^2运行时间

177
00:11:15,520 --> 00:11:18,480
我将会考虑这个情况

178
00:11:18,550 --> 00:11:22,680
我们就说这个图是稠密的吧

179
00:11:22,790 --> 00:11:25,240
就是说遇到的边缘数是平方的

180
00:11:25,320 --> 00:11:27,360
是顶点数的平方阶

181
00:11:27,490 --> 00:11:32,680
在这个情况下 我们会花费V^4的时间

182
00:11:32,750 --> 00:11:35,370
这样就非常慢了 我们可以做得更好些

183
00:11:35,440 --> 00:11:43,730
所以 第一目标是解决V^4  V的超立方

184
00:11:43,800 --> 00:11:47,120
但愿如此 好吧 我们应该

185
00:11:47,190 --> 00:11:50,410
用动态规划搞定它

186
00:11:54,420 --> 00:11:56,320
或者至少这该是我们的动力所在

187
00:11:56,390 --> 00:11:59,980
解决V^4的路漫漫其修远兮

188
00:12:00,050 --> 00:12:03,280
可能还会有些乏味

189
00:12:03,340 --> 00:12:07,390
但这需要睿智的洞察力

190
00:12:08,710 --> 00:12:11,740
好 下面我会介绍

191
00:12:11,810 --> 00:12:14,920
这个图的一些表示法

192
00:12:15,970 --> 00:12:18,030
我也将会考虑

193
00:12:18,140 --> 00:12:22,330
加权邻接矩阵

194
00:12:29,750 --> 00:12:34,470
在以前的课没讲过这个

195
00:12:34,580 --> 00:12:36,490
虽然附录里有

196
00:12:36,560 --> 00:12:38,450
这就意味着

197
00:12:38,530 --> 00:12:39,980
通常 邻接矩阵都会是

198
00:12:40,050 --> 00:12:42,540
有边相邻记1 否则记0

199
00:12:42,580 --> 00:12:43,630
这是在有向图中

200
00:12:43,730 --> 00:12:45,170
所以你们得小心一点

201
00:12:45,240 --> 00:12:49,600
而在此 这些矩阵里的元素

202
00:12:49,670 --> 00:12:52,580
都会是边的权值

203
00:12:52,650 --> 00:12:56,440
好 这里如果ij是一条边

204
00:12:59,070 --> 00:13:01,970
所以 如果ij是图里的一条边

205
00:13:02,040 --> 00:13:05,080
如果没有边的话则是正无穷

206
00:13:05,170 --> 00:13:07,620
好 用最短路径来表示

207
00:13:07,690 --> 00:13:10,380
这是个更好用的表述图的方法

208
00:13:10,420 --> 00:13:11,920
好 这就包涵了我们这里

209
00:13:11,960 --> 00:13:13,630
所需要的东西了

210
00:13:13,710 --> 00:13:15,450
现在我们需要把它当成矩阵来考虑

211
00:13:15,490 --> 00:13:20,860
接下来 矩阵会成为一个很有用的工具

212
00:13:21,410 --> 00:13:27,520
好 我现在要定义一些子问题了

213
00:13:27,550 --> 00:13:29,940
你们可以用不同的方法来定义

214
00:13:30,020 --> 00:13:32,550
最短路径问题里的具体情况

215
00:13:32,620 --> 00:13:36,470
但自然地  我会想 从顶点I到顶点J

216
00:13:36,540 --> 00:13:37,910
最短路径是什么

217
00:13:37,950 --> 00:13:39,270
好 我们需要更深入地

218
00:13:39,330 --> 00:13:42,550
细化子问题  就是这样

219
00:13:42,620 --> 00:13:45,340
好好回想下吧 我是怎么类推Bellman-Ford的

220
00:13:45,410 --> 00:13:47,650
Bellman-Ford的做法是

221
00:13:47,720 --> 00:13:50,570
构建越来越长的最短路径

222
00:13:50,680 --> 00:13:54,080
但在这里 长度是依据边的数目而定

223
00:13:54,160 --> 00:13:55,990
首先 它构建了长度为一的最短路径

224
00:13:56,060 --> 00:13:57,830
我们证明了在第一轮它是这样的

225
00:13:57,900 --> 00:13:59,070
在第二轮里

226
00:13:59,140 --> 00:14:02,250
它给出了所有的长度为二的最短路径

227
00:14:02,330 --> 00:14:06,470
呃...边的数目为二  如此类推

228
00:14:06,580 --> 00:14:09,110
我们喜欢类推

229
00:14:09,180 --> 00:14:11,400
然后重用之前的计算结果

230
00:14:11,470 --> 00:14:17,790
那么 我定义d  下标ij  上标m

231
00:14:18,220 --> 00:14:25,090
它是从i到j的最短路径的权值

232
00:14:25,160 --> 00:14:28,310
并有一个限制条件m

233
00:14:28,380 --> 00:14:41,980
那么这是从i到j的最短路径  最多用m条边

234
00:14:42,320 --> 00:14:45,660
举个例子 如果m是零的话

235
00:14:45,740 --> 00:14:47,420
那样我们就不用想破头地

236
00:14:47,490 --> 00:14:50,430
去找出长度为零的最短路径了

237
00:14:50,500 --> 00:14:53,540
我应该说 是用了零条边的最短路径

238
00:14:53,610 --> 00:14:55,430
而Bellman-Ford算法则提示我们

239
00:14:55,500 --> 00:14:57,280
如何从m前进到m+1

240
00:14:57,350 --> 00:15:00,800
那我们就来想想看吧

241
00:15:00,870 --> 00:15:03,870
我们从Bellman-Ford算法中分析知道的一件事

242
00:15:03,940 --> 00:15:07,620
就是如果我们观察 d_ij 上标m-1

243
00:15:07,690 --> 00:15:08,780
我们知道 在某种意义上

244
00:15:08,880 --> 00:15:10,730
最长的对应最短路径

245
00:15:10,830 --> 00:15:12,270
除非出现了负权环

246
00:15:12,340 --> 00:15:13,600
最长的对应最短路径

247
00:15:13,670 --> 00:15:15,560
出现在m=n-1时

248
00:15:15,630 --> 00:15:18,010
因为那是你能找到的最长的简单路径了

249
00:15:18,080 --> 00:15:22,580
所以这应该就是从i到j的最短路径值了

250
00:15:22,650 --> 00:15:24,080
这与你的上标

251
00:15:24,150 --> 00:15:28,430
输入的是多大的值没有任何关系

252
00:15:28,540 --> 00:15:31,420
这应该是δ(i,j)

253
00:15:31,490 --> 00:15:35,760
如果没有负权环

254
00:15:41,800 --> 00:15:44,160
好 这动态规划还挺不错的

255
00:15:44,240 --> 00:15:45,080
这就给出了答案

256
00:15:45,150 --> 00:15:47,050
只要我们能算出所有m的对应值

257
00:15:47,120 --> 00:15:49,610
那我们就可以得到具体的最短路径权值

258
00:15:49,680 --> 00:15:51,700
我们需要一个方法来发现负权环

259
00:15:51,800 --> 00:15:55,230
但我们现在还不需要着急这些

260
00:15:55,260 --> 00:15:57,350
虽然有负权数 但我们先假设

261
00:15:57,460 --> 00:16:00,580
这里没有负权环

262
00:16:00,970 --> 00:16:08,600
好 那我们就得到了一个循环递归

263
00:16:08,700 --> 00:16:12,530
初始情况是当m等于零的时候

264
00:16:12,640 --> 00:16:15,270
这个很简单了

265
00:16:15,700 --> 00:16:18,320
顶点相同 则权值为零

266
00:16:18,420 --> 00:16:21,130
否则就是正无穷

267
00:16:22,310 --> 00:16:31,100
好 接下来是m的实际递归情况

268
00:16:55,750 --> 00:16:58,440
如果我没手滑 这个就是很

269
00:16:58,510 --> 00:17:02,430
直观的递归  因为d_ij 上标m是

270
00:17:02,500 --> 00:17:05,400
用m-1项求得的最小值

271
00:17:05,500 --> 00:17:07,140
我画个图来解释

272
00:17:07,250 --> 00:17:11,710
这样一来 这个证明就很显然了

273
00:17:11,830 --> 00:17:17,590
这个是画图证明   所以一方面说

274
00:17:17,660 --> 00:17:22,140
i在这儿 j在这儿

275
00:17:22,210 --> 00:17:24,760
我们想知道从i到j的最短路径

276
00:17:24,820 --> 00:17:29,610
接下来我们要用至多m条边

277
00:17:29,710 --> 00:17:31,960
所以思路是 嗯

278
00:17:32,070 --> 00:17:36,800
你可以用m-1条边先到一些地方

279
00:17:36,870 --> 00:17:38,470
所以这是 最多

280
00:17:38,540 --> 00:17:42,110
用m-1条边 到其他地方

281
00:17:42,190 --> 00:17:46,110
我们就叫它k吧  这是其中的一个k

282
00:17:46,220 --> 00:17:48,640
然后你可以直接获得从k到j的边长

283
00:17:48,710 --> 00:17:57,240
所以这花费a_kj 这需要d_ik 上标m-1

284
00:17:57,760 --> 00:18:00,990
好 这是其中一个候选路径

285
00:18:01,100 --> 00:18:02,980
最多用m条边从i到j

286
00:18:03,050 --> 00:18:05,190
这实际上已经考虑到全部情况了

287
00:18:05,260 --> 00:18:07,840
好 那就有蛮多路径需要考虑的了

288
00:18:07,950 --> 00:18:09,520
那么这些都是k的候选项

289
00:18:09,590 --> 00:18:12,120
我们都用k来表示

290
00:18:12,190 --> 00:18:15,740
作为过渡点  随便啦

291
00:18:16,100 --> 00:18:18,150
就是这样  我们选择这些最好的路径

292
00:18:18,220 --> 00:18:19,980
这就包含了所有的最短路径

293
00:18:20,050 --> 00:18:22,250
这本质上就是

294
00:18:22,320 --> 00:18:23,350
Bellman-Ford算法做的事儿

295
00:18:23,420 --> 00:18:26,580
虽然不完全是 但我们还会这样想

296
00:18:26,680 --> 00:18:30,570
如果我直接说 就只有m-1条边呢？

297
00:18:30,640 --> 00:18:34,890
如果这里根本没有我用的上的边呢？

298
00:18:34,960 --> 00:18:36,230
在某种意义上？

299
00:18:36,300 --> 00:18:38,450
嗯 我们总是认为

300
00:18:38,520 --> 00:18:41,370
这些a都已经定义好了

301
00:18:41,440 --> 00:18:44,030
而且总有零权边  就是从自己到自己

302
00:18:44,110 --> 00:18:47,210
所以 你们可以用一个更加短的路径

303
00:18:47,320 --> 00:18:51,810
从i到j  而j则是k的一个特殊值

304
00:18:51,870 --> 00:18:52,870
我们可以这样想  然后

305
00:18:52,940 --> 00:18:56,980
最后用一个零权的边  a_jj

306
00:18:57,050 --> 00:18:59,570
好 这就涵盖一切方案了

307
00:18:59,640 --> 00:19:03,360
所以这个没什么大不了的

308
00:19:03,430 --> 00:19:06,490
懂没？ 现在我们建立了这个递归式

309
00:19:06,560 --> 00:19:08,140
我们就有了动态规划

310
00:19:08,210 --> 00:19:10,640
我的意思是 在某种意义上是的

311
00:19:10,710 --> 00:19:13,920
这是个递归的语句 你可以写成自底向上法

312
00:19:13,990 --> 00:19:15,640
我是有点喜欢自底向上法

313
00:19:15,720 --> 00:19:17,700
因为 这样写不像是它的风格

314
00:19:17,780 --> 00:19:19,420
这是一种松弛操作

315
00:19:19,490 --> 00:19:21,750
这是另一种松弛算法

316
00:19:21,820 --> 00:19:29,220
我会给出 嗯 这就是这种算法

317
00:19:29,330 --> 00:19:30,910
这不是一种很有趣的算法

318
00:19:31,010 --> 00:19:35,440
所以你们不需要把这它都写下来

319
00:19:35,510 --> 00:19:37,010
如果你们不喜欢它

320
00:19:37,080 --> 00:19:38,670
它很有可能也不在书里			

321
00:19:38,780 --> 00:19:41,400
这只是一个中间步骤

322
00:19:41,590 --> 00:19:43,840
我们循环所有的m值

323
00:19:43,910 --> 00:19:46,280
这差不多是最基本的事了

324
00:19:46,660 --> 00:19:48,810
我想要构建一个越来越长的路径

325
00:19:48,880 --> 00:19:50,690
这模糊地对应了Bellman-Ford算法

326
00:19:50,790 --> 00:19:52,650
虽然它实际上要比Bellman-Ford算法糟糕

327
00:19:52,720 --> 00:19:55,620
诶我

328
00:19:55,690 --> 00:19:59,840
这是块垫脚石 好 然后对于所有的i和j

329
00:19:59,910 --> 00:20:05,000
接下来 我们要计算这个最小值

330
00:20:05,070 --> 00:20:14,760
我们把所有k值过一遍 然后进行松弛

331
00:20:16,190 --> 00:20:19,470
这儿就是我们要计算最小值的地方

332
00:20:30,080 --> 00:20:32,490
这个是松弛操作  这个是重点

333
00:20:32,600 --> 00:20:35,320
松弛法是我们的好伙伴

334
00:20:35,390 --> 00:20:41,880
松弛边 好吧 这不是

335
00:20:41,950 --> 00:20:46,690
唷 我想我们要松弛kj边 或者别的什么

336
00:20:47,240 --> 00:20:51,080
只是我们不再有一个清晰的表达方式

337
00:20:51,150 --> 00:20:52,700
我的意思是 我们松弛的是个特别的东西

338
00:20:52,770 --> 00:20:54,340
并不只是一条单独的边

339
00:20:54,410 --> 00:20:56,290
因为这不再是单源了

340
00:20:56,400 --> 00:20:57,910
现在是相对于源i来说

341
00:20:58,020 --> 00:20:59,580
我们在松弛kj这条边

342
00:20:59,650 --> 00:21:02,740
差不多吧  但这的确是松弛法

343
00:21:02,840 --> 00:21:05,730
我们现在就是在使三角不等式成立

344
00:21:05,800 --> 00:21:07,420
如果以前不成立的话

345
00:21:07,560 --> 00:21:10,890
三角不等式应该在所有点对之间都成立

346
00:21:10,960 --> 00:21:13,060
同时 这也是在实现这个取最小值吧？

347
00:21:13,130 --> 00:21:14,510
你在用d_ij.

348
00:21:14,590 --> 00:21:18,400
在某种意义上  你是给之前的结果取最小值

349
00:21:18,510 --> 00:21:21,460
这是我们考虑的一种可能方案

350
00:21:21,530 --> 00:21:23,230
如果我们研究零权边的话

351
00:21:23,300 --> 00:21:26,320
或者说 你先从i到某一个k

352
00:21:26,420 --> 00:21:28,510
用上一些我们已知的结果

353
00:21:28,580 --> 00:21:30,340
然后再加上这条边

354
00:21:30,410 --> 00:21:33,670
然后看看跟原来相比会不会更好

355
00:21:33,740 --> 00:21:35,590
如果会 则赋予现有的估值

356
00:21:35,700 --> 00:21:39,810
你可以对所有的k这样做 尤其是

357
00:21:39,880 --> 00:21:42,550
你确实有可能算出 比这个最小值还要小的值

358
00:21:42,620 --> 00:21:44,920
因为我这里没有写上标

359
00:21:44,990 --> 00:21:46,810
但是那样只会让路径更好

360
00:21:46,880 --> 00:21:48,490
好了 你们现在可以说

361
00:21:48,550 --> 00:21:50,560
松弛一直是个不错的选择

362
00:21:50,600 --> 00:21:52,620
那么  不加上标

363
00:21:52,690 --> 00:21:54,210
可能我可以做更多的松弛

364
00:21:54,280 --> 00:21:56,360
毕竟  更多的松弛也没有什么坏处

365
00:21:56,430 --> 00:21:59,830
你仍然可以用这个证明来验证正确性

366
00:21:59,900 --> 00:22:01,430
这不是很直接的实现方法

367
00:22:01,500 --> 00:22:03,970
但是动态规划就是这样

368
00:22:04,040 --> 00:22:06,030
我要写下它的主要理由是

369
00:22:06,100 --> 00:22:08,140
你也知道  这是个松弛操作

370
00:22:08,210 --> 00:22:15,420
而它的运算时间为 n^4

371
00:22:17,790 --> 00:22:20,930
好吧 它肯定没有Bellman-Ford好

372
00:22:21,000 --> 00:22:24,150
即使在密集的情况下  Bellman-Ford 也是n^4

373
00:22:24,220 --> 00:22:25,840
在稀疏情况下会稍好一点

374
00:22:25,910 --> 00:22:28,010
所以这个并不是很好

375
00:22:28,080 --> 00:22:31,020
不过这是个开始

376
00:22:31,170 --> 00:22:35,390
它只是让我们着眼于动态规划

377
00:22:35,500 --> 00:22:38,470
很快我们就会想到更好地动态规划了

378
00:22:38,510 --> 00:22:40,420
但首先

379
00:22:41,560 --> 00:22:46,460
实际上 这条等式还是能派上用场的

380
00:22:55,790 --> 00:22:57,610
我会先问问你们

381
00:22:57,680 --> 00:23:00,510
先想到的人能提升好感度哦

382
00:23:00,580 --> 00:23:03,200
这个等式让你联想到什么？

383
00:23:03,270 --> 00:23:07,300
你曾经在哪里看到过的？

384
00:23:07,370 --> 00:23:09,500
数学模型或者算法？

385
00:23:09,570 --> 00:23:15,750
你是否在什么地方看到过这个循环体？

386
00:23:16,350 --> 00:23:23,190
好吧  当然不是一模一样  但是差不多

387
00:23:24,130 --> 00:23:26,310
我相信如果你们思考一会

388
00:23:26,410 --> 00:23:30,790
是可以想出来的  有答案了吗

389
00:23:30,930 --> 00:23:33,050
意识啊 骚年

390
00:23:33,150 --> 00:23:37,110
这个答案是矩阵乘法

391
00:23:37,650 --> 00:23:40,580
现在这对你们来讲应该很明显了  也可能不是

392
00:23:40,650 --> 00:23:44,260
如果你有很准确而独到的洞察力

393
00:23:44,330 --> 00:23:46,970
你就会发现它明显就是矩阵乘法

394
00:23:47,050 --> 00:23:48,430
记住  矩阵乘法

395
00:23:48,540 --> 00:23:51,270
我们有A,B,C

396
00:23:51,370 --> 00:23:54,640
它们都是n阶矩阵

397
00:23:57,260 --> 00:24:01,100
我们想计算出C=A*B

398
00:24:01,210 --> 00:24:09,650
那它就意味着  呃

399
00:24:09,720 --> 00:24:11,960
c_ij= ∑(a_ik * b_kj)  对于所有k

400
00:24:12,130 --> 00:24:15,400
好了  这就是对矩阵乘法的定义

401
00:24:15,510 --> 00:24:19,010
那个公式看起来就跟这个一样

402
00:24:19,110 --> 00:24:22,760
我的意思是  注意这些下标  ik和kj

403
00:24:22,830 --> 00:24:24,700
现在  这个运算有点不同

404
00:24:24,780 --> 00:24:26,230
在这里 我们是把里面的东西相乘

405
00:24:26,340 --> 00:24:27,730
然后把它们全部相加

406
00:24:27,800 --> 00:24:31,090
而在那边 我们把里面的加起来 并且放进来

407
00:24:31,160 --> 00:24:34,000
但除此之外 它们都是相同的

408
00:24:35,610 --> 00:24:38,310
好吧 很神奇 但就是这样

409
00:24:38,380 --> 00:24:43,360
那么 要想跟最短路径扯上关系

410
00:24:53,510 --> 00:24:56,100
你先要替换掉这些运算

411
00:24:56,210 --> 00:25:01,270
让我们来改造矩阵乘法吧

412
00:25:01,380 --> 00:25:06,070
先要干嘛  用求最小值 替换这个求和

413
00:25:08,730 --> 00:25:11,090
我们仅仅是改变运算方法

414
00:25:11,150 --> 00:25:15,240
把点乘替换成加法

415
00:25:16,480 --> 00:25:18,760
这只是换了一套不同的代数来做

416
00:25:18,830 --> 00:25:20,330
这里的加号实际上是求最小值

417
00:25:20,400 --> 00:25:22,050
点乘号实际上是加号

418
00:25:22,120 --> 00:25:24,100
因此 你必须去检验一下 是不是真的能这么用

419
00:25:24,170 --> 00:25:28,790
但如果可以的话  我们就会得到 c_ij

420
00:25:28,890 --> 00:25:40,480
等于 对于所有k   a_ik加上b_kj 的最小值

421
00:25:40,560 --> 00:25:44,550
这应该就是我们实际要算的东西

422
00:25:44,620 --> 00:25:46,290
这里  因为有一个m值

423
00:25:46,360 --> 00:25:48,720
所以 你必须迭代m次

424
00:25:48,790 --> 00:25:55,110
而这个其实就是d_ij上标m  这个是d_ik上标m-1

425
00:25:55,180 --> 00:25:59,030
因此 这看起来像是一个矩阵乘积

426
00:25:59,100 --> 00:26:01,150
酷炫啊

427
00:26:01,220 --> 00:26:06,100
因此  如果我们带入上面那个定义

428
00:26:06,170 --> 00:26:09,730
然后在联系一下矩阵运算

429
00:26:10,380 --> 00:26:16,190
这个定义 这个循环就给出了...

430
00:26:16,260 --> 00:26:18,450
现在我用矩阵的形式来表示

431
00:26:18,530 --> 00:26:27,820
D上标m等于 D上标m-1  圈圈乘一个A

432
00:26:28,220 --> 00:26:29,730
好了 这些就是权值

433
00:26:29,800 --> 00:26:31,760
这些是带权值的邻接矩阵

434
00:26:31,830 --> 00:26:34,780
这是前面那个D的值

435
00:26:34,850 --> 00:26:35,900
这个是新的D的值

436
00:26:36,010 --> 00:26:37,250
我就把它们重新写成

437
00:26:37,320 --> 00:26:39,330
用矩阵的形式  用大写字母来表示

438
00:26:39,400 --> 00:26:41,560
好的 我这个圈圈乘

439
00:26:41,630 --> 00:26:44,130
就代表了刚才说的这种代数运算

440
00:26:44,930 --> 00:26:46,960
所以 这是一个特殊的圈乘

441
00:26:47,060 --> 00:26:49,460
好的  有点小技巧

442
00:26:49,530 --> 00:26:52,960
我们对矩阵乘法的计算有了一些了解

443
00:26:53,030 --> 00:26:54,990
我们可以在n^3 的时间内完成

444
00:26:55,060 --> 00:26:55,890
如果我们爆发小宇宙的话

445
00:26:55,960 --> 00:26:57,630
可能还可以在次立方的时间内完成

446
00:26:57,710 --> 00:27:02,340
所以 我们可以尽量利用这种联系

447
00:27:02,410 --> 00:27:05,740
好好回想下吧 我们这儿算的是到底是什么

448
00:27:05,810 --> 00:27:06,840
我们说的是

449
00:27:06,940 --> 00:27:10,540
D上标m等于 它的前一项圈乘A

450
00:27:10,620 --> 00:27:15,760
这个D上标m是什么？

451
00:27:16,570 --> 00:27:19,520
是不是我们知道的某个代数概念？

452
00:27:22,660 --> 00:27:26,310
[学生]:...

453
00:27:26,380 --> 00:27:27,330
[教授]:没错 就是指数

454
00:27:27,400 --> 00:27:30,240
我们用一个A  希望把这个D的上标提升为m

455
00:27:30,310 --> 00:27:31,830
用这个圈圈乘的概念

456
00:27:31,900 --> 00:27:32,840
换句话讲

457
00:27:32,950 --> 00:27:37,410
D上标m  你可以把它看成是A的圈圈上标m

458
00:27:37,480 --> 00:27:40,050
因此  我将把它圈出来

459
00:27:40,300 --> 00:27:42,000
好吧？ 听起来不错

460
00:27:42,110 --> 00:27:46,350
我们也知道如何更快地求幂

461
00:27:46,420 --> 00:27:50,150
如果你记得怎么样做的话  我要定义这个概念

462
00:27:50,220 --> 00:27:52,030
这个幂的概念  要理解它

463
00:27:52,100 --> 00:27:54,530
我应该说说A的零次方是什么意义

464
00:27:54,600 --> 00:27:57,250
所以 我需要某种单位矩阵

465
00:27:57,320 --> 00:28:01,830
就目前而言  单位矩阵是这个

466
00:28:07,310 --> 00:28:08,810
如果我没搞错的话

467
00:28:08,920 --> 00:28:10,920
沿着对角线都是零

468
00:28:10,990 --> 00:28:13,270
其它都是正无穷

469
00:28:14,570 --> 00:28:17,850
这个仅仅是为了匹配这个定义

470
00:28:17,910 --> 00:28:20,370
d_ij 上标0 应该就是对角线上的零

471
00:28:20,440 --> 00:28:21,780
然后其它都是正无穷

472
00:28:21,850 --> 00:28:23,400
但是你可以验证这其实是一个单位矩阵

473
00:28:23,500 --> 00:28:25,150
如果你用它乘以

474
00:28:25,220 --> 00:28:27,200
用这个圈圈乘来跟其它矩阵相乘

475
00:28:27,270 --> 00:28:29,290
你会得到原来的矩阵  什么都没变

476
00:28:29,360 --> 00:28:32,970
这真的是一个有效的单位矩阵

477
00:28:33,070 --> 00:28:39,910
我应该提到对A的m次方的理解

478
00:28:40,050 --> 00:28:45,490
你们应该知道这个圈乘运算是有结合律的

479
00:28:45,560 --> 00:28:51,680
所以A的m圈次方成立

480
00:28:51,790 --> 00:28:58,270
因为这个圈圈乘法符合结合律

481
00:28:58,340 --> 00:29:00,390
你可以检验一下  不难的

482
00:29:00,460 --> 00:29:04,550
我的意思是说  min和加法都满足结合律

483
00:29:04,620 --> 00:29:07,040
各种神奇

484
00:29:07,110 --> 00:29:10,420
而且它还符合分配律

485
00:29:10,490 --> 00:29:13,460
这个是依次的

486
00:29:13,560 --> 00:29:16,300
因为实数和...

487
00:29:16,370 --> 00:29:18,770
这个顺序要正确

488
00:29:18,880 --> 00:29:22,810
用min替换加法运算

489
00:29:22,910 --> 00:29:26,850
用加法替换乘法运算

490
00:29:26,920 --> 00:29:30,570
是一个闭合的半环

491
00:29:30,680 --> 00:29:32,930
如果你想知道

492
00:29:33,030 --> 00:29:37,100
当指数有意义时  这就是个不错的规则

493
00:29:37,170 --> 00:29:38,760
如果你有一个闭合的半环

494
00:29:38,830 --> 00:29:41,160
那么半环上进行矩阵积

495
00:29:41,230 --> 00:29:42,730
就会是符合结合律的运算

496
00:29:42,800 --> 00:29:45,350
那么  很好  你可以尽情地乘了

497
00:29:45,460 --> 00:29:48,810
好了 那只是一些形式化的东西

498
00:29:49,610 --> 00:29:52,050
现在 我们有了一些直观的东西

499
00:29:52,130 --> 00:29:54,050
问题在于 什么是正确的算法？

500
00:29:54,130 --> 00:29:55,640
这有很多可能的回答

501
00:29:55,710 --> 00:30:00,110
有些是对的  有些则不然

502
00:30:04,520 --> 00:30:07,550
那么  总之我们跟矩阵乘法扯上了关系

503
00:30:07,660 --> 00:30:11,680
跟矩阵指数也扯上了关系

504
00:30:11,750 --> 00:30:13,970
对于两个 我们都有对应的算法

505
00:30:14,080 --> 00:30:17,140
问题来了  我们应该怎么做？

506
00:30:17,690 --> 00:30:19,120
我们现在所需要做的就是

507
00:30:19,190 --> 00:30:23,020
计算A的n-1次方  那个圈次方

508
00:30:23,090 --> 00:30:25,310
n-1就是我们得到的最短路径

509
00:30:25,380 --> 00:30:30,970
假设我们没有负权环的话

510
00:30:31,120 --> 00:30:34,320
事实上  我们可以计算一个比n-1更大的次方

511
00:30:34,390 --> 00:30:36,120
一旦超过了n-1

512
00:30:36,190 --> 00:30:39,510
再乘以A也不会产生任何改变

513
00:30:39,660 --> 00:30:42,450
那我们应该怎么做

514
00:30:49,730 --> 00:30:51,440
好吧 你们都木有想法

515
00:30:51,550 --> 00:30:53,660
让我来抛砖引玉一下吧

516
00:30:53,770 --> 00:30:56,230
你可以这么说  我先拿个A

517
00:30:56,300 --> 00:30:59,480
用A乘以它  再用A乘以它

518
00:30:59,540 --> 00:31:02,060
不断重复无聊的矩阵乘法

519
00:31:02,170 --> 00:31:05,970
我就这么做  一共做了N-2次

520
00:31:06,080 --> 00:31:15,870
标准的矩阵乘法  标准乘法复杂度是

521
00:31:15,970 --> 00:31:20,970
n^3  现在我要算n次

522
00:31:21,080 --> 00:31:23,730
所以这给我一个n^4的算法

523
00:31:23,800 --> 00:31:26,690
在n^4时间里算出所有的最短路径  喔呼

524
00:31:26,770 --> 00:31:32,400
好吧 还是那囧样   这到底要怎么破？

525
00:31:35,090 --> 00:31:37,160
[学生]:...

526
00:31:37,230 --> 00:31:40,460
[教授]:对  最自然会想到的 虽然还是不起效

527
00:31:40,530 --> 00:31:43,980
就是用次立方的矩阵乘积算法

528
00:31:44,050 --> 00:31:46,120
嗯 其实我们也快要讲到了

529
00:31:46,150 --> 00:31:47,530
跟一个更简单的问题一起讲

530
00:31:47,600 --> 00:31:50,180
但实际上 我们不知道要怎么运用快速矩阵乘法

531
00:31:50,250 --> 00:31:51,830
来计算最短路径

532
00:31:51,900 --> 00:31:53,780
比如Strassen系统算法

533
00:31:53,850 --> 00:31:58,310
不过这是个好建议  好了  你们必须思考一下

534
00:31:58,380 --> 00:32:01,560
为什么它不起作用  这个我会告诉你

535
00:32:01,630 --> 00:32:03,920
但它不是很明显

536
00:32:03,990 --> 00:32:07,300
这是个非常合理的建议

537
00:32:07,370 --> 00:32:09,130
但是在这个情况下   它基本没用

538
00:32:09,200 --> 00:32:11,910
我们很快就会说到

539
00:32:11,980 --> 00:32:13,180
这个问题是

540
00:32:13,250 --> 00:32:16,430
Strassen 要求有减法的概念

541
00:32:16,510 --> 00:32:18,590
在这里 加法被换成了取最小值

542
00:32:18,690 --> 00:32:20,220
而且 min是不可逆的

543
00:32:20,330 --> 00:32:21,530
一旦你选择了某个参数

544
00:32:21,600 --> 00:32:23,730
你不能随便撤销一个min

545
00:32:23,800 --> 00:32:25,110
因此 没有减法这一概念

546
00:32:25,210 --> 00:32:30,720
更悲剧的是  我们不知道怎么消掉它

547
00:32:30,790 --> 00:32:34,810
那么  我们还有什么大招没放  嗯？

548
00:32:34,920 --> 00:32:37,740
[学生]:...

549
00:32:37,840 --> 00:32:39,200
[教授]:分治法 log n的乘方

550
00:32:39,310 --> 00:32:41,880
对了 重复乘方的方法

551
00:32:41,950 --> 00:32:47,830
那样会有效  好极了  我们有了个很棒的方法

552
00:32:47,900 --> 00:32:50,890
如果你有一个数字n  你可以观察它

553
00:32:50,960 --> 00:32:53,730
把n用二进制编码来表示

554
00:32:53,840 --> 00:32:55,770
你可以把这个数写成平方的乘方形式

555
00:32:55,830 --> 00:32:57,800
或者平方后再乘上A的另一个因数

556
00:32:57,910 --> 00:33:00,880
这里我们甚至可以脑残一点

557
00:33:00,990 --> 00:33:03,750
我们只需要计算

558
00:33:04,510 --> 00:33:07,620
我们仅仅需要考虑2的幂

559
00:33:07,690 --> 00:33:09,390
我们想知道的是

560
00:33:09,500 --> 00:33:12,480
这里我现在需要把字写大一点

561
00:33:12,520 --> 00:33:17,750
因为会有好多层下标  A的圈次方

562
00:33:17,820 --> 00:33:24,850
2的log n向上取整次方

563
00:33:25,150 --> 00:33:28,040
事实上  n-1就足够了

564
00:33:28,110 --> 00:33:30,680
不过就这样吧 你可以写n

565
00:33:30,850 --> 00:33:34,170
如果你跟我一样没地方写的话

566
00:33:34,240 --> 00:33:38,890
log n向上取整的圈次方

567
00:33:38,970 --> 00:33:42,850
这个意思是n-1的下一个2的幂

568
00:33:42,920 --> 00:33:44,420
是2的┌log┐次方

569
00:33:44,490 --> 00:33:47,780
因此我们没必要直接去到n-1

570
00:33:47,850 --> 00:33:48,910
我们可以更进一步  因为

571
00:33:48,980 --> 00:33:50,470
任何比n-1更多的

572
00:33:50,570 --> 00:33:52,220
都会是最短路径

573
00:33:52,330 --> 00:33:53,610
如果你再看看定义

574
00:33:53,710 --> 00:33:55,080
你就知道你的路径是单一的

575
00:33:55,150 --> 00:33:58,650
如果没有负权环的话就成立

576
00:33:58,720 --> 00:34:00,750
那好吧  就走远一点吧

577
00:34:00,820 --> 00:34:02,500
为什么不呢  那么要计算这个

578
00:34:02,570 --> 00:34:06,360
我们只要做┌log (n-1)┐次相乘

579
00:34:06,430 --> 00:34:08,030
我们只用算A的平方

580
00:34:08,100 --> 00:34:10,480
接着用这个结果进行平方 再平方...

581
00:34:10,550 --> 00:34:18,080
这就是O(log n)乘上平方运算的复杂度

582
00:34:19,280 --> 00:34:21,330
我们不知道怎么使用Strassen

583
00:34:21,400 --> 00:34:22,510
但是我们可以使用这个无聊的

584
00:34:22,570 --> 00:34:24,670
n^3的标准乘法

585
00:34:24,740 --> 00:34:28,990
得出O(n^3  log n)的运算时间

586
00:34:32,100 --> 00:34:33,620
好了 这个东西最终

587
00:34:33,690 --> 00:34:38,870
会在密集情况下胜于Bellman-Ford

588
00:34:38,970 --> 00:34:42,600
在密集情况下  Bellman-Ford是O(n^4)

589
00:34:42,670 --> 00:34:45,150
这里得到的是O(n^3 log n)  终于逆转了

590
00:34:45,220 --> 00:34:47,950
在稀疏情况下  两者差不多

591
00:34:48,020 --> 00:34:51,080
可能差一点  E是V阶

592
00:34:51,160 --> 00:34:53,630
我们将得到  Bellman-Ford是O(V^3)

593
00:34:53,700 --> 00:34:57,130
这里我们有O(n^3 log n)   但毕竟这个log因子

594
00:34:57,200 --> 00:35:01,760
也算是一个进步

595
00:35:01,870 --> 00:35:04,630
好吧  在其它时候差不多是一样的

596
00:35:04,700 --> 00:35:07,130
这个算法还自带一个被动技能

597
00:35:07,230 --> 00:35:09,050
就是可以检测到负权环

598
00:35:09,110 --> 00:35:11,620
这里有点疑问

599
00:35:11,690 --> 00:35:15,100
我算过了这个乘积后 还怎么检测负环？

600
00:35:15,180 --> 00:35:18,220
A的2的[log(n-1)]次方

601
00:35:18,290 --> 00:35:21,320
我要怎么样知道自己发现了一个负权环

602
00:35:21,390 --> 00:35:23,200
在这矩阵里它是代表什么呢？

603
00:35:23,270 --> 00:35:28,490
这矩阵里的最短路径 都应该是某个有限长度的吧？

604
00:35:32,440 --> 00:35:33,500
如果我发现一个循环

605
00:35:33,570 --> 00:35:35,110
这矩阵肯定会变成怎样？   嗯？

606
00:35:35,180 --> 00:35:37,340
[学生]:...

607
00:35:37,410 --> 00:35:38,570
[教授]:对  我可以 比方说

608
00:35:38,630 --> 00:35:40,200
把这个东西 乘一个A

609
00:35:40,270 --> 00:35:41,860
看看这矩阵有没有变化

610
00:35:41,930 --> 00:35:44,100
好吧  这的确可行  我们在Bellman-Ford中就是这么做的

611
00:35:44,170 --> 00:35:45,340
但这里甚至更简单

612
00:35:45,410 --> 00:35:47,360
它已经是那样了  你都不用做乘法了

613
00:35:47,430 --> 00:35:49,140
但是  这个运算时间是相同的

614
00:35:49,210 --> 00:35:51,070
恭喜你 答对了

615
00:35:51,570 --> 00:35:54,850
对角线上会有一个负值 很好

616
00:35:55,000 --> 00:35:59,890
因此  这是个很好玩的事情  两种方法都有效

617
00:35:59,960 --> 00:36:02,630
都能检测一个负权环

618
00:36:02,730 --> 00:36:07,750
仅仅是通过监测矩阵的对角线

619
00:36:16,710 --> 00:36:23,900
你只要在这个对角线上找负值就好

620
00:36:27,930 --> 00:36:29,970
我们姑且称之为算法一

621
00:36:30,080 --> 00:36:32,280
我是说  虽然我们说了很多无效的 方法

622
00:36:32,340 --> 00:36:34,040
但是我将称这个为第一

623
00:36:34,150 --> 00:36:36,660
好  我们再多看两个

624
00:36:39,270 --> 00:36:41,140
这将是唯一的一个

625
00:36:41,210 --> 00:36:42,940
喔唷  我不应该这么说

626
00:36:43,010 --> 00:36:45,230
随便吧  我们继续

627
00:36:46,280 --> 00:36:51,240
这是一个没多大帮助的动态规划

628
00:36:51,310 --> 00:36:53,520
除了它给我们展示了一个与矩阵乘法的联系

629
00:36:53,590 --> 00:36:54,790
这点很有爱

630
00:36:54,890 --> 00:36:58,220
你们会看到它还有什么用

631
00:36:58,290 --> 00:37:03,870
但它却带来了这个恶心的四层嵌套循环

632
00:37:03,980 --> 00:37:07,270
运用这个技巧  我们可以把复杂度降到O(n^3 log n)

633
00:37:07,410 --> 00:37:09,650
让我们试一下  就用n^3

634
00:37:09,760 --> 00:37:13,070
只要除去log就好  这东西很烦人

635
00:37:13,170 --> 00:37:15,110
这让你变得比 Bellman-Ford的还糟糕

636
00:37:15,210 --> 00:37:16,160
在稀疏的情况下

637
00:37:16,270 --> 00:37:20,100
让我们先擦掉这些嵌套循环中的一个

638
00:37:20,200 --> 00:37:22,160
好的 我想这么做

639
00:37:22,300 --> 00:37:24,720
很显然这个算法就没用了

640
00:37:24,830 --> 00:37:26,830
因为这本来有个k  现在却没有定义了

641
00:37:26,900 --> 00:37:30,860
但是你看  我们已经有足够多的变量了

642
00:37:30,960 --> 00:37:33,290
我为什么不直接定义把k为m？

643
00:37:33,790 --> 00:37:35,290
实际上 这是可行的

644
00:37:35,400 --> 00:37:41,430
我先从打草稿开始  不来一发吗？  是吧？

645
00:37:41,510 --> 00:37:43,450
我不知道Floyd和Warshall

646
00:37:43,560 --> 00:37:44,530
是不是就是这样想出这算法的

647
00:37:44,600 --> 00:37:47,310
但我们是这样  这就是Floyd-Warshall算法

648
00:37:53,510 --> 00:37:54,770
这个思路是

649
00:37:54,870 --> 00:37:57,990
用更聪明的方式来定义这些子问题

650
00:37:58,100 --> 00:38:00,690
所以要计算这其中的一个值

651
00:38:00,760 --> 00:38:02,580
你没必要去算n个东西的最小值

652
00:38:02,690 --> 00:38:05,080
我只要2个中的最小就好

653
00:38:05,150 --> 00:38:08,130
如果我这么做  我仍然只有n^3子问题

654
00:38:08,240 --> 00:38:10,130
那么我还要n^3的时间

655
00:38:10,240 --> 00:38:12,730
因此  好吧  这个动态规划的运算时间

656
00:38:12,800 --> 00:38:14,430
就是子问题的数目乘上

657
00:38:14,530 --> 00:38:17,320
计算一个子问题循环的时间

658
00:38:17,390 --> 00:38:19,790
所以这是线性时间乘上n^3

659
00:38:19,900 --> 00:38:23,100
我们让n^3不变  但那样还不错

660
00:38:23,210 --> 00:38:24,610
这就是 Floyd-Warshall算法

661
00:38:24,720 --> 00:38:29,960
现在我们即将重新定义c_ij

662
00:38:30,030 --> 00:38:32,180
我觉得  也可以称之为 d_ij

663
00:38:32,280 --> 00:38:34,610
不错  我们要定义一些新的东西

664
00:38:34,680 --> 00:38:38,770
d_ij上标k  现在要变成

665
00:38:38,840 --> 00:38:50,810
从i到j的最短路径的权重  跟以前一样

666
00:38:51,630 --> 00:38:54,690
注意我用这个上标k代替m

667
00:38:54,800 --> 00:38:57,070
因为我想让k和m变成同一个东西

668
00:38:57,150 --> 00:39:02,810
掂！ 现在 这里有个新的约束条件

669
00:39:03,400 --> 00:39:06,110
我想让这条路径上所有的媒介点

670
00:39:06,220 --> 00:39:08,510
也就是除了i和j的所有顶点

671
00:39:08,610 --> 00:39:13,260
从头到尾的所有点都有一个小标签

672
00:39:13,370 --> 00:39:19,120
它们应该属于一个从1到k的集合

673
00:39:19,190 --> 00:39:20,580
这里实际上我们真正做的

674
00:39:20,650 --> 00:39:22,520
是把顶点被标注为1到m

675
00:39:22,590 --> 00:39:24,160
我会说 好吧

676
00:39:24,230 --> 00:39:25,360
首先考虑这样一条最短路径

677
00:39:25,430 --> 00:39:27,150
它没用经过任何顶点

678
00:39:27,220 --> 00:39:29,000
这时k=0

679
00:39:29,070 --> 00:39:30,520
接着考虑一下所有的

680
00:39:30,590 --> 00:39:32,570
可能经过顶点一的最短路径

681
00:39:32,640 --> 00:39:33,470
然后再考虑那些

682
00:39:33,540 --> 00:39:35,620
可能经过顶点一或者顶点二的最短路径

683
00:39:35,700 --> 00:39:37,680
为什么不呢？你完全可以这样定义它

684
00:39:37,750 --> 00:39:39,330
然后得出

685
00:39:39,400 --> 00:39:41,560
当你增大k时

686
00:39:41,630 --> 00:39:44,120
你只要考虑新的顶点就好了

687
00:39:44,190 --> 00:39:46,330
这里 我们必须算所有k的最小值

688
00:39:46,400 --> 00:39:48,940
现在我已经知道要看哪个k了

689
00:39:49,010 --> 00:39:50,410
可能这就讲得通了

690
00:39:50,480 --> 00:39:52,050
可能它现在依旧不是很明显

691
00:39:52,150 --> 00:39:59,310
但是我会重新做这个证明  重做这个循环

692
00:40:00,230 --> 00:40:03,950
那么 我可能先要说明一些明显的事情

693
00:40:04,060 --> 00:40:09,100
如果我想要这个最短路径中的δ(i,j)

694
00:40:09,210 --> 00:40:11,330
只需要用到所有的顶点

695
00:40:11,410 --> 00:40:14,030
用c_ij  上标n

696
00:40:14,100 --> 00:40:15,710
这就是全部了  这就可以能算出来了

697
00:40:15,780 --> 00:40:17,620
即使你有一个负权环也可以

698
00:40:17,690 --> 00:40:19,830
虽然我们还是会忽略掉负权环

699
00:40:19,900 --> 00:40:23,320
只要我们能检测它们的话

700
00:40:23,940 --> 00:40:29,400
另一个简单的情况是 如果你有 呃

701
00:40:29,500 --> 00:40:32,530
c_ij 上标0的话  让我把这个写进证明里

702
00:40:32,840 --> 00:40:35,990
跟前面保持一致

703
00:40:36,090 --> 00:40:40,430
那么这里是个新的证明

704
00:40:40,530 --> 00:40:47,220
如果我们想计算c_ij上标0，这是什么？

705
00:40:48,090 --> 00:40:49,760
上标0的意思是我不会用到

706
00:40:49,830 --> 00:40:52,630
任何的中间的媒介点

707
00:40:59,760 --> 00:41:01,470
那么  这就有了一个非常简单的答案

708
00:41:01,540 --> 00:41:03,310
答案只有三个字母

709
00:41:04,050 --> 00:41:05,550
所以不是0

710
00:41:05,620 --> 00:41:09,260
zero有四个字母  那是啥？

711
00:41:09,330 --> 00:41:13,480
空？不是  不是这个

712
00:41:14,100 --> 00:41:17,150
它也包含一些下标字符

713
00:41:22,080 --> 00:41:24,220
这个定义就是

714
00:41:24,330 --> 00:41:26,910
从i到j的最短路径是什么？

715
00:41:26,970 --> 00:41:30,880
当你被禁止使用任何中介点时

716
00:41:31,490 --> 00:41:32,990
[学生]:....

717
00:41:33,070 --> 00:41:34,240
[教授]:没听清？

718
00:41:34,310 --> 00:41:38,220
[学生]:...

719
00:41:38,330 --> 00:41:41,670
[教授]:好吧 它有一个非常简单的名字

720
00:41:41,740 --> 00:41:45,060
这就是它的诡异之处  好了  那么如果i=j

721
00:41:45,160 --> 00:41:46,490
好聪明喔  没错

722
00:41:46,600 --> 00:41:49,870
去掉括号  i=j的意思就是1   好吧

723
00:41:49,940 --> 00:41:51,190
这也行   但并不是非常准确

724
00:41:51,300 --> 00:41:55,080
事实上 我要的是正无穷 如果i不等于j的话

725
00:41:55,190 --> 00:42:02,910
如果i等于j  i就是零  a_ij   很好

726
00:42:02,980 --> 00:42:05,690
我认为它是a_ij  它也应该是的 对吧？

727
00:42:05,760 --> 00:42:07,720
可能我错了

728
00:42:12,170 --> 00:42:14,690
是吧 就是a_ij  因为本质上 这不是我说的

729
00:42:14,750 --> 00:42:16,240
这才是关键

730
00:42:16,340 --> 00:42:19,150
如果i不等于j

731
00:42:19,220 --> 00:42:20,700
你还需要考虑

732
00:42:20,770 --> 00:42:24,080
一个连接i和j的单边 是吧？

733
00:42:24,150 --> 00:42:25,350
好吧 这是有点微妙

734
00:42:25,420 --> 00:42:27,160
这只是中间的媒介点

735
00:42:27,230 --> 00:42:29,630
因此你仍然可以经由一个单边连接i到j

736
00:42:29,700 --> 00:42:31,220
那样花费就是a_ij

737
00:42:31,300 --> 00:42:32,330
如果有一条边：无穷

738
00:42:32,430 --> 00:42:34,700
如果没有：那就是a_ij

739
00:42:34,770 --> 00:42:38,590
好的 让我们开始吧

740
00:42:38,660 --> 00:42:43,870
接着  我们需要做一个循环

741
00:42:48,590 --> 00:42:50,310
这个循环就是 好吧

742
00:42:50,380 --> 00:42:54,130
可能你不需要用你之前用到的所有的顶点

743
00:42:54,200 --> 00:42:56,460
因此 如果你想知道用到顶点1到k的路径

744
00:42:56,530 --> 00:42:59,280
可能只需要用到1到k-1就好

745
00:42:59,390 --> 00:43:02,580
你可以试一下   或者你可以试着用一下k

746
00:43:02,650 --> 00:43:03,890
因此  你可以用或者不用K

747
00:43:04,000 --> 00:43:05,750
如果你不用  那就会是这样

748
00:43:05,820 --> 00:43:09,260
如果你用  那么你必须经过k

749
00:43:09,360 --> 00:43:12,200
所以为什么不以k结束呢？

750
00:43:12,300 --> 00:43:16,590
你从i走到k之前用到的顶点

751
00:43:16,660 --> 00:43:18,760
很显然 你不想再重复走一次k

752
00:43:18,830 --> 00:43:22,370
那么你需要从k到j

753
00:43:22,440 --> 00:43:26,820
这时用到的顶点不是k

754
00:43:27,450 --> 00:43:29,440
这些应该是非常直观的

755
00:43:29,540 --> 00:43:32,300
我可以再画一个图

756
00:43:33,930 --> 00:43:36,570
所以 要么你们从来没到过k

757
00:43:36,680 --> 00:43:39,290
就是这样一个弯弯的线

758
00:43:39,360 --> 00:43:41,410
你从i到j  用到的顶点

759
00:43:41,480 --> 00:43:44,610
仅仅是1到k-1  换句话说

760
00:43:44,680 --> 00:43:46,700
这里说 我们不得不用1到k

761
00:43:46,810 --> 00:43:48,600
那么 这一条是不用k的路径

762
00:43:49,170 --> 00:43:50,790
所以 这是这个值

763
00:43:51,470 --> 00:43:55,150
或者  你在中间的某些地方用到k

764
00:43:55,860 --> 00:43:58,340
好了  肯定是这两者二选一

765
00:43:58,410 --> 00:43:59,300
而在这种情况下

766
00:43:59,380 --> 00:44:02,700
从i到k 你仅需要用比k少的顶点

767
00:44:02,770 --> 00:44:04,330
因为你并不用经过k

768
00:44:04,400 --> 00:44:06,590
这里 你从k到j

769
00:44:06,660 --> 00:44:10,140
也仅用比k少的顶点

770
00:44:10,210 --> 00:44:13,630
每条路径都是这两者其中之一

771
00:44:13,740 --> 00:44:16,940
所以 在这两个子问题中 我们取最短那条

772
00:44:17,010 --> 00:44:18,000
这就是答案

773
00:44:18,070 --> 00:44:20,070
现在 我们就得到两个东西的最小值了

774
00:44:20,170 --> 00:44:21,920
它需要常数的时间来计算

775
00:44:21,990 --> 00:44:26,510
因此 我们得到一个三次算法

776
00:44:31,880 --> 00:44:34,560
让我先写下来

777
00:44:38,020 --> 00:44:41,360
这就是Floyd-Warshall算法

778
00:44:41,430 --> 00:44:47,510
我再写一遍这个名字  给它输入一个矩阵A

779
00:44:47,590 --> 00:44:49,280
这就是它所需要知道的全部数据

780
00:44:49,360 --> 00:44:54,130
剩下的都是代码  你把A复制给C

781
00:44:54,200 --> 00:44:59,320
这只是个热身 刚好时间为0时 C=A

782
00:44:59,390 --> 00:45:02,570
接着你有三重循环

783
00:45:02,640 --> 00:45:06,590
对于每一个k值   每一个i值

784
00:45:06,700 --> 00:45:09,890
每一个j值   你都算出这个最小值

785
00:45:09,970 --> 00:45:11,700
如果你对仔细一想

786
00:45:11,770 --> 00:45:14,350
这个最小值就是一个松弛法

787
00:45:14,420 --> 00:45:17,480
喵了个咪的

788
00:45:45,240 --> 00:45:50,170
这就是Floyd-Warshall算法

789
00:45:52,320 --> 00:45:55,450
现在很清楚了 它的运行时间是n^3

790
00:45:55,520 --> 00:45:58,740
三个嵌套循环  最里层时间为常数

791
00:45:59,710 --> 00:46:01,800
我们终于有成果了

792
00:46:01,870 --> 00:46:05,410
它肯定不会比Bellman-Ford差

793
00:46:05,450 --> 00:46:06,610
在稀疏情况下 两者是相同

794
00:46:06,690 --> 00:46:07,910
在稍微密集的情况下

795
00:46:07,970 --> 00:46:09,600
这个边的数量是超线性的

796
00:46:09,670 --> 00:46:11,880
这肯定要比 Bellman-Ford好多了

797
00:46:11,960 --> 00:46:13,630
它也是我们见过的最好的

798
00:46:13,740 --> 00:46:15,000
全对最短路径问题的解法

799
00:46:15,100 --> 00:46:19,340
它还能处理负权值的问题   非常简单的算法

800
00:46:19,410 --> 00:46:20,830
甚至比前一个都简单

801
00:46:20,860 --> 00:46:23,160
它只是三个循环里的松弛操作而已

802
00:46:23,240 --> 00:46:26,510
还能比它更好吗？ 我们还需要检查一下

803
00:46:26,580 --> 00:46:29,580
这是否真的是我们要算的最小值

804
00:46:29,650 --> 00:46:31,590
除了这些被省略的上标字符

805
00:46:31,660 --> 00:46:35,270
那其实又是 可以忽略不写的

806
00:46:35,340 --> 00:46:36,880
忽略上标是可以的

807
00:46:36,950 --> 00:46:38,040
因为那就仅仅意味着

808
00:46:38,110 --> 00:46:40,090
你要更多应该做的松弛操作

809
00:46:40,200 --> 00:46:42,980
做多一点松弛总是好的

810
00:46:43,040 --> 00:46:45,250
尤其是 我们做的都是我们必须做的事情

811
00:46:45,360 --> 00:46:47,650
因此  我们找到了着最短路径权值

812
00:46:47,720 --> 00:46:50,950
再有 这里 我们假设

813
00:46:51,020 --> 00:46:53,810
没有负权环

814
00:46:54,230 --> 00:46:55,960
要把它找出来也不难

815
00:46:56,030 --> 00:46:59,280
但是你不得不多考虑一下

816
00:46:59,970 --> 00:47:02,030
好了  你可以再跑一圈Bellman-Ford

817
00:47:02,130 --> 00:47:04,850
看它是否又松弛了新的一条边

818
00:47:04,960 --> 00:47:06,880
比如说

819
00:47:07,020 --> 00:47:12,210
但我觉得这并没有什么酷炫的技巧

820
00:47:16,260 --> 00:47:17,410
同时  我们接下来讲讲

821
00:47:17,480 --> 00:47:21,170
那就是我们求解全对最短路径的第二个算法

822
00:47:21,240 --> 00:47:22,920
在我们讲到第三个算法之前

823
00:47:23,000 --> 00:47:26,560
这也是它们之中最聪明的算法

824
00:47:26,660 --> 00:47:30,760
唯我独尊 独领风骚

825
00:47:31,580 --> 00:47:34,990
我们讲讲一点题外话  坊间杂谈

826
00:47:35,070 --> 00:47:38,620
是啥都好 我们简要讲一下传递闭包

827
00:47:38,690 --> 00:47:41,500
这是一个值得了解的东西

828
00:47:41,610 --> 00:47:45,500
它跟我们目前为止所了解的算法有关

829
00:47:45,610 --> 00:47:48,660
那么 这有一个传递闭包问题

830
00:47:48,770 --> 00:47:52,560
我给你一个有向图  对于所有顶点对

831
00:47:52,630 --> 00:47:55,300
i和j   我想计算一个数值

832
00:47:55,370 --> 00:47:59,280
如果从i到j存在一条路径  则为1

833
00:48:03,590 --> 00:48:11,520
从i到j   否则返回0

834
00:48:11,550 --> 00:48:14,460
这就像是一个无聊的邻接矩阵一样

835
00:48:14,530 --> 00:48:18,090
但没有加上权数  不过它是跟路径有关

836
00:48:18,160 --> 00:48:22,930
而不是跟边有关

837
00:48:23,000 --> 00:48:26,200
那么  我要怎么计算这个？

838
00:48:29,110 --> 00:48:32,970
这非常简单

839
00:48:43,920 --> 00:48:45,500
我应该怎么算？

840
00:48:45,570 --> 00:48:48,020
这个问题会给我一个输入图

841
00:48:48,090 --> 00:48:49,810
这是一个新图的邻接矩阵

842
00:48:49,880 --> 00:48:53,680
称为我这个输入图的传递闭包

843
00:48:58,540 --> 00:49:00,680
然后呢？

844
00:49:00,750 --> 00:49:02,650
[学生]:...

845
00:49:02,720 --> 00:49:05,700
[教授]:广度优先搜索  是的  非常好

846
00:49:05,780 --> 00:49:09,310
那么  我所需要做的就是找到最短路径

847
00:49:09,380 --> 00:49:11,780
而且如果这些权值是无穷大

848
00:49:11,890 --> 00:49:13,910
那也就是没有路径了  如果它小于无穷大

849
00:49:13,980 --> 00:49:17,370
那就存在一条路径  所以这里

850
00:49:17,440 --> 00:49:20,730
你说可能我不在乎这些权值

851
00:49:20,800 --> 00:49:23,610
我可以运行广度优先搜索n次

852
00:49:23,720 --> 00:49:29,090
那确实是有用的  因此  如果我们用B次BFS

853
00:49:29,160 --> 00:49:31,360
可能我中途插讲这个有点奇怪

854
00:49:31,430 --> 00:49:34,380
就当是小插曲把  那么  我们有

855
00:49:34,490 --> 00:49:39,900
BFS的复杂度大概是O(V*E)

856
00:49:40,400 --> 00:49:42,370
好的 你可以尝试这里的任何一个算法

857
00:49:42,470 --> 00:49:45,210
你可以用Floyd-Warshall算法做试验

858
00:49:46,740 --> 00:49:48,090
为什么不呢

859
00:49:51,330 --> 00:49:56,850
它的复杂度会是O(V^3)

860
00:49:56,950 --> 00:49:58,400
你可以在任一这些算法中进行运算

861
00:49:58,470 --> 00:50:01,490
用1或者0做为权值

862
00:50:01,570 --> 00:50:04,310
只要检验一下这些数值是否是无穷大

863
00:50:04,380 --> 00:50:08,670
好了  我的意思是  t_ij=0 当且仅当

864
00:50:08,730 --> 00:50:13,920
从i到j的的最短路径权值为无穷时

865
00:50:14,940 --> 00:50:16,340
这样就解决了

866
00:50:16,410 --> 00:50:18,460
这是一个比最短路径要简单的问题

867
00:50:18,530 --> 00:50:21,460
它实际上  真的很简单

868
00:50:21,530 --> 00:50:23,360
因为这只是传递闭包而已

869
00:50:23,460 --> 00:50:25,980
我也只是出于兴趣才谈及它的

870
00:50:26,050 --> 00:50:29,760
因为传递闭包是一个有用的东西

871
00:50:31,590 --> 00:50:33,540
本质上来讲 我们正在做的

872
00:50:33,610 --> 00:50:34,820
看看有没有说错

873
00:50:34,890 --> 00:50:36,650
使用的是另一套的运算规则

874
00:50:36,730 --> 00:50:39,570
我们正在使用“或”和“与”

875
00:50:39,670 --> 00:50:45,640
用逻辑上的“或”和“与”  来替换最小值和加法

876
00:50:46,020 --> 00:50:47,570
因为我们想知道

877
00:50:47,680 --> 00:50:50,850
如果你考虑松弛法 某种程度上

878
00:50:50,930 --> 00:50:53,280
可能我要根据这个最小值来考虑

879
00:50:53,350 --> 00:50:57,050
如果我想知道  是否存在一条从i到j的路径

880
00:50:57,160 --> 00:51:00,100
它中间用到了标有1到k的顶点？

881
00:51:00,200 --> 00:51:02,280
要么有一条路径

882
00:51:02,350 --> 00:51:03,810
它没有用到顶点k

883
00:51:03,920 --> 00:51:05,390
要么那条路径用到了k

884
00:51:05,460 --> 00:51:07,590
那它就会像是那样

885
00:51:07,660 --> 00:51:09,990
肯定有这样的一条路

886
00:51:10,060 --> 00:51:12,450
也肯定有那样的一条路

887
00:51:12,520 --> 00:51:16,420
用“或”和“与”来替换求最小值和加法

888
00:51:16,490 --> 00:51:17,990
如果你还记得  这里曾经是加号

889
00:51:18,060 --> 00:51:20,800
这里原来在矩阵中是乘积

890
00:51:20,880 --> 00:51:26,580
加号现在就是“或”   乘号则是“与”了

891
00:51:26,650 --> 00:51:29,120
这听起来非常带感 是吧？

892
00:51:29,220 --> 00:51:32,580
加法的确像是“或”  而乘法的确也像是“与”

893
00:51:32,650 --> 00:51:35,750
如果你是生活在二进制的世界里的话   事实上

894
00:51:35,820 --> 00:51:42,770
这并不是神马Zmod2域

895
00:51:42,870 --> 00:51:46,630
但这是个很好很很强大的代数域

896
00:51:46,740 --> 00:51:50,510
这是只有布尔函数知道的世界

897
00:51:52,080 --> 00:51:54,020
我就写布尔好了

898
00:51:54,090 --> 00:51:56,560
布尔大神对这些东西很熟悉

899
00:51:56,670 --> 00:51:59,080
这貌似是他的硕士论文

900
00:51:59,180 --> 00:52:01,600
谈一下这个布尔代数

901
00:52:01,670 --> 00:52:03,590
这事实上意味着

902
00:52:03,660 --> 00:52:05,600
你可以使用快速矩阵乘法

903
00:52:05,670 --> 00:52:07,030
你可以使用Strassen's算法

904
00:52:07,110 --> 00:52:08,740
或其他更牛的算法  同时你也可以

905
00:52:08,800 --> 00:52:11,390
在次立方的时间里 计算传递闭包

906
00:52:11,460 --> 00:52:15,200
如果这些边是稀疏的  这就是次立方

907
00:52:15,270 --> 00:52:17,170
但最坏情况下就是立方了

908
00:52:17,280 --> 00:52:19,630
如果有很多边的话  这就是立方

909
00:52:19,730 --> 00:52:24,300
事实上你用Strassen可以做得更好

910
00:52:26,010 --> 00:52:28,680
因此  我也只是说你可以这样做

911
00:52:28,730 --> 00:52:34,830
这应该没什么好细讲的

912
00:52:34,900 --> 00:52:36,850
事实上 这里有个定理

913
00:52:36,960 --> 00:52:38,740
它可能不在课本上

914
00:52:38,810 --> 00:52:40,000
但是确实这么个定理说

915
00:52:40,070 --> 00:52:44,800
传递闭包就跟矩阵乘法一样难求

916
00:52:44,860 --> 00:52:45,730
它们是等价的

917
00:52:45,800 --> 00:52:47,100
它们的运算时间也是相同的

918
00:52:47,170 --> 00:52:48,850
我们不知道它需要多久

919
00:52:48,930 --> 00:52:52,960
在一个域上进行一个矩阵乘法运算

920
00:52:53,030 --> 00:52:57,960
它应该在n^2到n^2.3之间

921
00:52:58,460 --> 00:52:59,500
但是 不管答案是什么

922
00:52:59,600 --> 00:53:01,340
它跟传递闭包是一样的

923
00:53:01,440 --> 00:53:04,040
这就是我们的小插曲

924
00:53:08,780 --> 00:53:09,860
事实上 这就是我们

925
00:53:09,930 --> 00:53:13,510
开始用Strassen和其他好帮手的地方

926
00:53:17,740 --> 00:53:23,710
记得吗？Strassen是n的以二为底log 7次方的算法

927
00:53:23,800 --> 00:53:26,200
记牢哟  尤其在期末考的时候

928
00:53:26,310 --> 00:53:29,350
那些东西是你应该张口就来的

929
00:53:31,010 --> 00:53:34,550
好的 这是我们要讲的最后一个算法

930
00:53:34,840 --> 00:53:36,310
它真的是建立在...

931
00:53:36,380 --> 00:53:40,720
我们上次了解的Johnson算法之上

932
00:53:40,830 --> 00:53:43,330
我在这里已经失去了一些运算时间了

933
00:53:43,400 --> 00:53:47,800
但是  当我们有未加权的图时

934
00:53:47,880 --> 00:53:49,320
我们可以很快地进行全对运算

935
00:53:49,410 --> 00:53:53,550
就想单源Bellman-Ford算法一样快

936
00:53:53,620 --> 00:53:54,580
非常漂亮

937
00:53:54,650 --> 00:53:56,010
我们不知道要怎么提高...

938
00:53:56,080 --> 00:53:58,070
在单源条件下的Bellman-Ford算法

939
00:53:58,170 --> 00:53:59,530
因此 我们真的没办法

940
00:53:59,600 --> 00:54:01,950
得到任何比V*E更好的东西

941
00:54:02,090 --> 00:54:05,440
如果你记得运算V次Dijkstra

942
00:54:05,550 --> 00:54:07,400
V次Dijkstra差不多也是这样的

943
00:54:07,470 --> 00:54:10,650
我把它写进这个“复习泡泡”里

944
00:54:10,760 --> 00:54:21,840
V次Dijkstra的复杂度是O( V*E+V^2 log(V) )

945
00:54:21,920 --> 00:54:26,010
如果你忽略log因子  就只是VE

946
00:54:26,080 --> 00:54:28,050
好 非常好 Dijkstra算法很好很强大

947
00:54:28,110 --> 00:54:29,450
这适用于非负权边

948
00:54:29,560 --> 00:54:30,830
那么  在负权边的情况下

949
00:54:30,900 --> 00:54:34,680
或许 我们也想得到相同的运算时间

950
00:54:34,820 --> 00:54:38,350
那现在 我们要怎么得到相同的运算时间？

951
00:54:38,660 --> 00:54:40,280
如果我可以使用Dijkstra  那就真的太好了

952
00:54:40,350 --> 00:54:42,830
当然  Dijkstra算法对负权值不起作用

953
00:54:42,900 --> 00:54:52,120
那么我该怎么做呢？我希望怎么做呢？

954
00:54:52,260 --> 00:54:55,260
我希望能怎样？假设我想

955
00:54:55,360 --> 00:54:56,430
在算法中间

956
00:54:56,540 --> 00:55:00,430
它要运算Dijkstra n次

957
00:55:00,820 --> 00:55:04,220
那么  我要做些什么准备工作？

958
00:55:05,340 --> 00:55:08,340
令所有的权数都变为正的或者非负

959
00:55:08,580 --> 00:55:12,110
好吧  来一发  这是个有前途的思路

960
00:55:12,180 --> 00:55:13,950
这就是我们要做的

961
00:55:14,100 --> 00:55:17,180
这就是所谓的图重加权

962
00:55:19,240 --> 00:55:22,100
最赞的就是 事实上我们已经知道要怎么做了

963
00:55:22,170 --> 00:55:24,600
我们只是不知道我们已经知道了而已

964
00:55:25,950 --> 00:55:29,340
但我知道我们其实知道我们要怎样做

965
00:55:29,440 --> 00:55:30,950
你还不知道其实我们知道

966
00:55:31,080 --> 00:55:35,180
我知道我们要怎么做

967
00:55:37,120 --> 00:55:41,230
所以 实际上你们可以对顶点进行权重调整

968
00:55:41,300 --> 00:55:43,990
上节课结束的时候有人问我

969
00:55:44,100 --> 00:55:46,800
您能只是  比如说  给所有的边加上同样的权值吗？

970
00:55:46,870 --> 00:55:48,740
那样没用的

971
00:55:48,810 --> 00:55:50,530
没什么用  因为不同的路径

972
00:55:50,640 --> 00:55:52,210
有不同的边数

973
00:55:52,280 --> 00:55:53,220
我们将要做的

974
00:55:53,370 --> 00:55:56,130
是给每一个顶点都加上一个特别的权重

975
00:55:56,200 --> 00:55:57,480
那是什么意思呢？

976
00:55:57,550 --> 00:55:59,870
因为我们只是边有权值

977
00:55:59,940 --> 00:56:00,940
而这是我们要做的

978
00:56:01,000 --> 00:56:10,170
我们要调整每条边界的权重  因此(u,v)  我们说

979
00:56:10,280 --> 00:56:15,470
回归到用图表示 而不是用矩阵表示

980
00:56:15,540 --> 00:56:17,820
用的是(u,v)而不是i和j

981
00:56:17,980 --> 00:56:20,830
我们将称之为修正权数w_h

982
00:56:20,900 --> 00:56:22,370
h是我们的函数

983
00:56:22,440 --> 00:56:25,010
它给每一个顶点一个值

984
00:56:25,120 --> 00:56:29,400
而它将会给旧的边权值

985
00:56:29,470 --> 00:56:32,720
加上起点的权值

986
00:56:32,790 --> 00:56:37,680
再减去终点的权值

987
00:56:37,750 --> 00:56:39,480
我确信这些都有很好的命名

988
00:56:39,630 --> 00:56:41,180
其中一个是头 另一个是尾巴

989
00:56:41,290 --> 00:56:43,060
但是我从来记不住哪个是哪个

990
00:56:43,130 --> 00:56:44,790
好了 我们有一条有向边(u,v)

991
00:56:44,860 --> 00:56:46,880
只要加上它们中的一个 减去另一个

992
00:56:46,950 --> 00:56:47,920
因为它是条有向边

993
00:56:47,990 --> 00:56:51,030
所以 这是个一致性的定义

994
00:56:51,470 --> 00:56:54,760
这就是所谓的权重调整

995
00:56:54,870 --> 00:56:56,930
这实际上是一个定理

996
00:56:57,000 --> 00:57:03,070
如果你这样做  那么我们说

997
00:57:03,140 --> 00:57:10,700
对于任何顶点 这图中的u和v

998
00:57:10,770 --> 00:57:12,660
对于任意两个点

999
00:57:13,040 --> 00:57:23,190
所有从u到v的路径的权值

1000
00:57:23,940 --> 00:57:27,270
就跟它们以前一样  好吧 不完全是

1001
00:57:27,820 --> 00:57:31,120
它们调整后的权重是相同的

1002
00:57:32,680 --> 00:57:36,300
所以 如果你观察所有不同的路径 你会问

1003
00:57:36,380 --> 00:57:38,370
vh之间有什么不同吗？

1004
00:57:38,440 --> 00:57:42,760
说错了 不好意思  我们说δ是之前的那种最短路径

1005
00:57:42,830 --> 00:57:44,980
而δ_h 则是根据这种新的加权函数

1006
00:57:45,040 --> 00:57:47,230
所求出来的最短路径权值

1007
00:57:47,300 --> 00:57:50,080
(所有新路径和旧路径)之间的差值是一样的

1008
00:57:50,150 --> 00:57:52,310
所以 我们说所有的这些路径

1009
00:57:52,410 --> 00:57:55,070
都以此相同的总量重新调整了权值

1010
00:57:55,140 --> 00:57:56,150
这事实上 是一个

1011
00:57:56,220 --> 00:57:58,470
关于所有路径 而不仅仅是最短路径的命题

1012
00:57:59,920 --> 00:58:04,660
就是这样 有多少人

1013
00:58:04,740 --> 00:58:07,080
已经听懂了的？

1014
00:58:07,150 --> 00:58:09,910
有一些  好吧

1015
00:58:09,990 --> 00:58:12,270
哪个词可以一语道破？

1016
00:58:13,810 --> 00:58:17,390
好吧 它可能不是很明显

1017
00:58:17,500 --> 00:58:20,330
没关系 当你们想到的时候就大声吼出来

1018
00:58:20,440 --> 00:58:25,800
而同时 我将把详细的证明过程写出来

1019
00:58:25,900 --> 00:58:32,310
其实用一个词就可以证明了  我还在等

1020
00:58:37,350 --> 00:58:39,250
好 我们选择其中一条路径

1021
00:58:39,320 --> 00:58:43,050
以u开始 以v结束 任何一个路径都可以

1022
00:58:43,120 --> 00:58:44,070
我们将看到

1023
00:58:44,140 --> 00:58:46,870
它的新的权值与旧的权值是相对应的

1024
00:58:46,940 --> 00:58:50,130
我们写下这个路径的w_h

1025
00:58:50,200 --> 00:58:51,700
用一般的定义方法

1026
00:58:51,770 --> 00:59:00,120
它是从v_i到v_(i+1)的

1027
00:59:00,190 --> 00:59:05,810
所有的边的新加权之和

1028
00:59:06,460 --> 00:59:08,050
你们想到那个单词了吗

1029
00:59:08,130 --> 00:59:11,200
还没有？这看来略难啊

1030
00:59:11,570 --> 00:59:16,030
好了 这就是一条路径的权值的定义

1031
00:59:16,100 --> 00:59:20,220
同时 我们知道的这个东西

1032
00:59:20,370 --> 00:59:26,240
就是w(v_i, v_(i+1))

1033
00:59:26,310 --> 00:59:29,190
把它写完  再加上第一个顶点的权值

1034
00:59:29,230 --> 00:59:32,590
再加上  对不起  是v_i的调整权值

1035
00:59:32,670 --> 00:59:37,430
减去v_(i+1)的调整权值

1036
00:59:37,540 --> 00:59:41,400
这些都在一个大括号里 都是对i求和的

1037
00:59:41,500 --> 00:59:45,280
现在我要一个魔力单词  缩进法  相当好

1038
00:59:45,360 --> 00:59:46,280
现在就很明显了

1039
00:59:46,390 --> 00:59:48,350
每一个项都能前后缩进

1040
00:59:48,410 --> 00:59:51,060
除了最初和最终的两个之外

1041
00:59:51,170 --> 00:59:57,040
因此 这是所有边的权值之和

1042
00:59:57,240 --> 00:59:59,740
但是在总和之外

1043
00:59:59,840 --> 01:00:07,130
我们再加上h(v_1)  减去h(v_k)

1044
01:00:07,440 --> 01:00:08,850
好吧 这两项不会相互抵消

1045
01:00:08,920 --> 01:00:11,720
我们寻找的是一条路径 而非循环

1046
01:00:11,900 --> 01:00:18,050
这就是路径w

1047
01:00:18,690 --> 01:00:21,360
同时 这是路径的普通权值

1048
01:00:21,470 --> 01:00:22,650
那么不同点是

1049
01:00:22,760 --> 01:00:28,370
w_h(p)和w(p)的差别就是这个东西

1050
01:00:28,820 --> 01:00:33,040
就是h(u)减去h(v)   重点是

1051
01:00:33,140 --> 01:00:35,640
这一项到处都一样  只要你固定了端点

1052
01:00:35,710 --> 01:00:37,900
在最短路径中的u和v

1053
01:00:37,980 --> 01:00:40,500
这样 你就调整了这条路径权值

1054
01:00:40,570 --> 01:00:43,550
所有路径调整的幅度都一样

1055
01:00:43,660 --> 01:00:45,570
这是对于任意从u到v的路径而言

1056
01:00:45,640 --> 01:00:46,990
那样就证明了这个定理

1057
01:00:47,090 --> 01:00:50,660
所以这里的魔法单词就是 缩进法

1058
01:00:51,380 --> 01:00:54,830
这些权值的变动在所有路径上都能缩进

1059
01:00:54,940 --> 01:00:58,000
因此 如果我们想找到最短路径

1060
01:00:58,110 --> 01:00:59,350
你只要在这个重新调整的版本里

1061
01:00:59,460 --> 01:01:00,640
寻找最短路径就好

1062
01:01:00,750 --> 01:01:03,480
然后再用这一个定量调整一下它

1063
01:01:03,580 --> 01:01:05,940
你只要减去这个数量 而不是加上这个数量

1064
01:01:06,050 --> 01:01:07,340
那你就会得到

1065
01:01:07,450 --> 01:01:09,340
原来的最短路径加权

1066
01:01:09,940 --> 01:01:12,530
好的 这是一个工具

1067
01:01:12,670 --> 01:01:15,310
现在我们已经明白如何调整图的权值

1068
01:01:15,420 --> 01:01:17,920
但是 我们真正需要的是去调整图中的权值

1069
01:01:18,020 --> 01:01:21,120
使得权值变为非负值

1070
01:01:21,220 --> 01:01:22,990
那么要怎么做呢？

1071
01:01:23,090 --> 01:01:25,990
这世界上怎么就有这种函数h

1072
01:01:26,100 --> 01:01:29,890
使得所有边的权值为非负呢？

1073
01:01:30,030 --> 01:01:37,000
这有点不科学  但看来我们都知道

1074
01:01:44,310 --> 01:01:51,050
我写一下这个推论

1075
01:02:09,880 --> 01:02:12,500
按照正确顺序写清楚 那么特别地

1076
01:02:12,600 --> 01:02:15,730
最小的路径权值有了这一定量的变化

1077
01:02:15,800 --> 01:02:17,090
如果你算出这个值

1078
01:02:17,160 --> 01:02:18,920
你就把这块移项到等式另一边

1079
01:02:18,990 --> 01:02:22,270
所以呢 我们计算出δ_h 然后再算出增量δ

1080
01:02:22,340 --> 01:02:24,580
这就是我们的推论

1081
01:02:24,680 --> 01:02:30,040
有多少人把这个单词发音成“磕了蚁”？

1082
01:02:30,610 --> 01:02:33,810
那又有多少人把它发音成"磕错了蚁"？

1083
01:02:33,910 --> 01:02:36,810
好吧  注定孤独一生

1084
01:02:36,880 --> 01:02:38,480
通常应该还有一个学生才对

1085
01:02:38,590 --> 01:02:43,290
而且呢 他们一般都是加拿大佬或英国佬神马的

1086
01:02:43,360 --> 01:02:44,810
我认为这就是口音

1087
01:02:44,880 --> 01:02:47,140
所以我总是避免说这个词

1088
01:02:47,210 --> 01:02:51,820
除非我确信这是“磕了蚁”  而且可以发对了音

1089
01:02:51,930 --> 01:02:56,180
至少我说的是Zii而不是Zed  好的 我们继续

1090
01:02:56,220 --> 01:03:05,690
所以我们要做的 就是找到一个这样的函数

1091
01:03:05,760 --> 01:03:09,260
我的意思是 我们来写一下什么想要得到的

1092
01:03:09,330 --> 01:03:11,230
我们想要找到一个调整权值函数h

1093
01:03:11,300 --> 01:03:13,100
给每一个顶点赋一个权值

1094
01:03:13,160 --> 01:03:18,920
使得w_h(u,v) 是非负的

1095
01:03:19,030 --> 01:03:28,630
对于所有集合E之中边(u,v)来说 这实在是太棒了

1096
01:03:29,830 --> 01:03:32,150
好的 那我们就可以跑Dijkstra算法了

1097
01:03:34,710 --> 01:03:37,300
我们运行Dijkstra算法  算出δ_h的值

1098
01:03:37,730 --> 01:03:40,540
然后撤销调整权值

1099
01:03:40,650 --> 01:03:44,330
得出我们想要的值  这就是Johnson算法

1100
01:03:44,440 --> 01:03:47,280
这引理说  这始终是可行的

1101
01:03:47,350 --> 01:03:49,060
为什么始终是可行的呢？

1102
01:03:49,130 --> 01:03:50,730
让我们看一下这个约束条件

1103
01:03:50,840 --> 01:03:53,450
w_h(u,v)等于

1104
01:03:53,520 --> 01:04:00,880
等于w(u,v) + h(u) - h(v)

1105
01:04:00,990 --> 01:04:03,210
应该是非负的

1106
01:04:03,310 --> 01:04:07,870
让我再把它重写一下

1107
01:04:13,260 --> 01:04:16,480
我要把这些项移到这边

1108
01:04:16,590 --> 01:04:18,430
这是没问题的

1109
01:04:18,500 --> 01:04:25,490
h(v) - h(u) 小于或等于 w(u,v)

1110
01:04:25,560 --> 01:04:37,590
是不是看着很眼熟  我算对没有？

1111
01:04:38,000 --> 01:04:45,060
这应该是对的  有人曾经见过这条不等式吗？

1112
01:04:45,580 --> 01:04:46,470
[学生]:...

1113
01:04:46,570 --> 01:04:48,220
[教授]:耶  是的  回答正确

1114
01:04:48,290 --> 01:04:50,470
在哪见过？

1115
01:04:50,520 --> 01:04:52,990
[学生]:...

1116
01:04:53,060 --> 01:04:54,920
[教授]:在上一节课上？

1117
01:04:55,660 --> 01:04:59,290
我在上上次课上提到过

1118
01:05:00,280 --> 01:05:06,990
这个叫什么？ 如果我用x替换h的话

1119
01:05:13,590 --> 01:05:15,550
查哥知道

1120
01:05:15,620 --> 01:05:18,230
真是愉悦  还有谁记得？

1121
01:05:18,330 --> 01:05:21,100
好好回想下我在第二集说的话吧

1122
01:05:21,170 --> 01:05:24,160
我记得那是个浪漫的周末

1123
01:05:24,580 --> 01:05:28,610
这个运算叫什么？

1124
01:05:29,410 --> 01:05:36,540
不是减法  它是...  我好像听到答案了

1125
01:05:37,630 --> 01:05:42,920
弱爆了 孩纸们  好吧  我告诉你们

1126
01:05:42,990 --> 01:05:45,430
这是差分约束 好吧

1127
01:05:45,530 --> 01:05:47,540
这是另一个差分运算

1128
01:05:47,610 --> 01:05:51,070
好的  这是我们的好朋友差分约束

1129
01:05:51,140 --> 01:05:52,740
那么 这是我们要满足的条件

1130
01:05:52,810 --> 01:05:54,760
我们有一套差分约束系统

1131
01:05:54,830 --> 01:05:57,260
h(v) 减去 h(u) 应该是  我们要求出这些东西

1132
01:05:57,330 --> 01:06:00,130
这些是未知数  被这些所约束

1133
01:06:00,240 --> 01:06:02,720
而我们已经给出了w  现在

1134
01:06:02,790 --> 01:06:06,990
我们知道什么时候这些差分约束是可满足的

1135
01:06:07,060 --> 01:06:08,660
有人可以告诉我吗

1136
01:06:08,730 --> 01:06:12,050
什么时候可以满足约束条件？

1137
01:06:12,160 --> 01:06:18,430
我们当然知道 什么时候能满足任意的约束约束条件

1138
01:06:28,510 --> 01:06:30,990
数学也是背多分的  孩纸们

1139
01:06:31,060 --> 01:06:32,470
如果是术语的话 我能理解

1140
01:06:32,550 --> 01:06:37,090
背单词是很麻烦的

1141
01:06:37,160 --> 01:06:42,220
除非你是语言学家

1142
01:06:45,010 --> 01:06:46,060
所以  什么时候这个

1143
01:06:46,130 --> 01:06:49,160
差分约束系统是可以满足的？

1144
01:06:59,950 --> 01:07:02,720
对  你们一定要... 非常好

1145
01:07:02,830 --> 01:07:06,540
[学生]:...

1146
01:07:06,640 --> 01:07:09,830
[教授]:对  很好  有人带来了他的课堂笔记。

1147
01:07:09,900 --> 01:07:13,870
当约束图没有负权环时

1148
01:07:14,030 --> 01:07:16,000
很好 谢谢

1149
01:07:22,090 --> 01:07:25,980
那么  什么是约束图？

1150
01:07:32,360 --> 01:07:37,220
好吧  这次的答案只有一个字母

1151
01:07:37,300 --> 01:07:39,970
我接受这个一个字母的回答

1152
01:07:41,540 --> 01:07:43,070
什么？A?

1153
01:07:43,180 --> 01:07:46,490
接近了 是G  木哈哈

1154
01:07:46,590 --> 01:07:48,120
耶  其实都一样嘛

1155
01:07:48,230 --> 01:07:51,790
所以所有的约束图基本上是G

1156
01:07:51,890 --> 01:07:55,290
事实上  就是G  约束图是G图  很好

1157
01:07:55,360 --> 01:07:58,210
我们论证方法是 增加一个新的源点

1158
01:07:58,320 --> 01:07:59,380
然后把它和其他点联系起来

1159
01:07:59,480 --> 01:08:01,760
不过那就和这个点无关了

1160
01:08:01,870 --> 01:08:03,750
其实这个点正是为了满足约束而存在的

1161
01:08:03,850 --> 01:08:08,430
但这是我们的特征 那如果我假设

1162
01:08:08,500 --> 01:08:10,180
在我们的图中没有负权环

1163
01:08:10,290 --> 01:08:12,110
我们一直都这么做

1164
01:08:12,210 --> 01:08:14,700
然后 我们就知道这个是可以满足的

1165
01:08:14,800 --> 01:08:17,240
因此 这里有一个赋值函数h

1166
01:08:17,310 --> 01:08:18,490
所以 就有了一个调整权值函数

1167
01:08:18,590 --> 01:08:19,780
使得所有的权值非负

1168
01:08:19,890 --> 01:08:22,990
然后我们就能运行Dijkstra算法了  大功告成

1169
01:08:23,100 --> 01:08:26,660
很神奇有木有！  那我们要如何满足这些约束呢？

1170
01:08:26,740 --> 01:08:29,330
我们知道怎么用一次Bellman-Ford来做

1171
01:08:29,430 --> 01:08:31,520
这会花费VE阶

1172
01:08:31,630 --> 01:08:35,130
小于V次Dijkstra算法

1173
01:08:35,200 --> 01:08:40,540
那么  就是这样  我找个位置写下这些

1174
01:08:57,630 --> 01:09:01,010
那么 这就是Johnson算法

1175
01:09:01,670 --> 01:09:04,580
这是他们之中最高级的。

1176
01:09:04,800 --> 01:09:07,220
也是最快捷的

1177
01:09:07,700 --> 01:09:10,600
全对最短路径算法

1178
01:09:10,720 --> 01:09:18,400
所以呢  结论就是  我们可以找到一个函数h 把V映射到R

1179
01:09:19,640 --> 01:09:24,900
并满足对每条边的权数调整

1180
01:09:24,970 --> 01:09:34,080
使得图中每条边(u,v)都为非负的

1181
01:09:34,190 --> 01:09:38,890
而且 我们运用Bellman-Ford算法

1182
01:09:39,400 --> 01:09:42,640
来解决差分约束

1183
01:09:55,350 --> 01:09:57,600
正是这一些差分约束

1184
01:09:57,670 --> 01:10:01,100
我们上节课学的知识 就是为了解决它而存在的

1185
01:10:01,170 --> 01:10:03,590
这里的这些图都是完全对应的

1186
01:10:03,660 --> 01:10:05,660
如果你仔细回顾定义的话

1187
01:10:05,730 --> 01:10:08,120
或者  Bellman-Ford算法会告诉我们

1188
01:10:08,230 --> 01:10:10,760
图中存在一个负权环

1189
01:10:10,870 --> 01:10:13,750
爽吧 那么我们就不用真的去假设

1190
01:10:13,830 --> 01:10:17,670
图里面没有负权环  我们待会就明白了

1191
01:10:17,740 --> 01:10:20,130
如果你很牛  你真的可以

1192
01:10:20,200 --> 01:10:22,120
直接用它找出负无穷出来

1193
01:10:22,190 --> 01:10:25,540
但是  现在

1194
01:10:25,780 --> 01:10:27,390
我只考虑一种情况

1195
01:10:27,500 --> 01:10:31,010
就是没有负权环

1196
01:10:31,040 --> 01:10:33,970
但是如果有  我们可以找到它的存在

1197
01:10:34,030 --> 01:10:37,160
然后告知用户  然后停止运算

1198
01:10:37,270 --> 01:10:39,530
否则的话  如果没有负权环

1199
01:10:39,600 --> 01:10:40,610
因此 会有一个赋值运算

1200
01:10:40,720 --> 01:10:42,540
使得边权都变为非负的

1201
01:10:42,610 --> 01:10:52,760
那我们就用上它吧  拿它来运行Dijkstra算法

1202
01:10:58,880 --> 01:11:00,630
接下来 第二步就是  噢

1203
01:11:00,700 --> 01:11:05,090
我得说一下所有这些的运行时间是V*E

1204
01:11:05,430 --> 01:11:06,800
所以 我们就再输入图上

1205
01:11:06,880 --> 01:11:09,330
运行下Bellman-Ford算法

1206
01:11:09,440 --> 01:11:12,440
另外 我们还添加了一个源  还记得吧

1207
01:11:12,540 --> 01:11:15,170
来解决一整套差分约束

1208
01:11:15,240 --> 01:11:16,550
你添加一个源顶点S

1209
01:11:16,620 --> 01:11:18,590
跟其他所有点连接 权值为0

1210
01:11:18,660 --> 01:11:20,120
从那运行Bellman-Ford算法

1211
01:11:20,220 --> 01:11:21,400
因为这里没有源

1212
01:11:21,400 --> 01:11:22,250
我们只有一个图

1213
01:11:22,270 --> 01:11:23,850
我们想知道是全顶点对

1214
01:11:23,960 --> 01:11:24,970
所以这下  你可以通过它去找

1215
01:11:25,050 --> 01:11:27,700
是不是某个地方存在负权环

1216
01:11:27,780 --> 01:11:29,980
或者 我们有这个神奇的赋值

1217
01:11:30,050 --> 01:11:31,960
所以现在  w_h是非负的

1218
01:11:32,030 --> 01:11:37,430
因此 我们能在w_h上跑Dijkstra算法

1219
01:11:40,760 --> 01:11:45,540
这里写用w_h  所以你就能算出w_h

1220
01:11:45,610 --> 01:11:47,540
这花费线性的时间

1221
01:11:47,610 --> 01:11:53,680
然后我们为每个可能的源 都运行Dijkstra算法。

1222
01:11:54,630 --> 01:11:55,920
我会特别写明这一点的

1223
01:11:55,990 --> 01:11:57,700
我们脑子里想了千百遍了。

1224
01:11:57,770 --> 01:12:00,950
但是 当我们说n次Dijkstra算法

1225
01:12:01,020 --> 01:12:03,660
n次BFS  这里就是

1226
01:12:03,730 --> 01:12:10,110
现在我们要计算所有v的δ_h(u,v)

1227
01:12:10,180 --> 01:12:13,620
然后分开再算一遍所有u的

1228
01:12:15,750 --> 01:12:23,330
那这里的运行时间  就是O(VE+V^2 * log V)

1229
01:12:23,400 --> 01:12:26,460
这个只是V次Dijkstra的运行时间

1230
01:12:26,530 --> 01:12:28,640
也就是 E + V log(V)

1231
01:12:28,740 --> 01:12:31,520
我们发现这一项跟这个是一样的

1232
01:12:31,590 --> 01:12:33,350
灰常不错  因为这意味着这第一步

1233
01:12:33,430 --> 01:12:38,380
没有给我们增加复杂度  好了 然后

1234
01:12:38,450 --> 01:12:41,180
最后一步是  那么  现在我们知道了δ_h

1235
01:12:41,250 --> 01:12:43,280
我们就只要计算δ了

1236
01:12:43,350 --> 01:12:48,600
那么  对于每个点对

1237
01:12:48,670 --> 01:12:55,610
用(u,v)表示  我们只计算

1238
01:12:55,680 --> 01:12:58,640
它本来的权值是多少

1239
01:12:58,720 --> 01:13:01,390
也就是δ(u,v)是多少

1240
01:13:01,460 --> 01:13:05,530
我们可以用这个推论来做

1241
01:13:06,800 --> 01:13:15,970
所以这个就是 δ_h(u,v)-h(u)+h(v)

1242
01:13:16,040 --> 01:13:21,800
好的我没写错  这个需要 V^2的时间

1243
01:13:21,990 --> 01:13:25,520
跟Dijkstra算法的时间相比也是相形见拙

1244
01:13:25,600 --> 01:13:33,310
所以Johnson算法的整体运行时间

1245
01:13:33,370 --> 01:13:35,780
就是第二步的运行时间

1246
01:13:35,850 --> 01:13:38,420
运行n次Dijkstra的时间

1247
01:13:49,880 --> 01:13:52,120
酷到无法直视啊

1248
01:13:52,300 --> 01:13:56,340
如果是单源最短路径的话

1249
01:13:56,790 --> 01:13:58,810
对于一般权值来说 Bellman-Ford是最好的

1250
01:13:58,880 --> 01:14:01,860
而对非负加权来说 Dijkstra是最好的

1251
01:14:01,930 --> 01:14:03,540
但是对于所有全对最短路径来说

1252
01:14:03,610 --> 01:14:06,740
我们可以绕开整个负权值问题

1253
01:14:06,840 --> 01:14:10,430
通过从Bellman-Ford得出的神奇的结果

1254
01:14:10,510 --> 01:14:12,430
运行n次的Dijkstra算法

1255
01:14:12,500 --> 01:14:14,080
已经是我们所知道的最好算法了

1256
01:14:14,150 --> 01:14:18,390
对于所有非负权点对来说

1257
01:14:18,460 --> 01:14:21,790
但现在 对于一般权值来说也是最好了

1258
01:14:21,860 --> 01:14:24,590
在我们讲过的技巧的组合里

1259
01:14:24,660 --> 01:14:26,470
这也是一个相当不错的组合了

1260
01:14:26,580 --> 01:14:27,670
这三部曲  一路走来

1261
01:14:27,740 --> 01:14:29,850
我们看到大量的动态规划

1262
01:14:29,920 --> 01:14:31,970
这总是很好的方案

1263
01:14:32,040 --> 01:14:33,860
有问题吗？

1264
01:14:34,090 --> 01:14:40,890
这是测验前最后一次讲新的内容

1265
01:14:40,960 --> 01:14:43,840
星期三将进行测验复习

1266
01:14:43,990 --> 01:14:47,570
如果我没有记错的话

1267
01:14:47,680 --> 01:14:50,080
然后就是感恩节了  就没有复习课了

1268
01:14:50,150 --> 01:14:51,730
然后  周一就开始测试了

1269
01:14:51,800 --> 01:14:55,370
好好学习吧孩纸们！ 愿算法与你同在！

