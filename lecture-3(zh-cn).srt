1
00:00:12,750 --> 00:00:14,500
各位同学 早上好

2
00:00:19,040 --> 00:00:24,620
今天我们将学习一些算法 说到算法

3
00:00:24,620 --> 00:00:27,500
我们将用到很多简单的数学知识

4
00:00:27,500 --> 00:00:29,040
其实也没有太多

5
00:00:29,040 --> 00:00:30,430
这些数学知识我们上节课都学过

6
00:00:30,430 --> 00:00:31,470
比如解决递归问题的主定理

7
00:00:31,470 --> 00:00:32,930
这个我们将会用到很多

8
00:00:32,930 --> 00:00:35,730
因为今天我们讨论的是递归算法

9
00:00:35,820 --> 00:00:37,090
通过这个主定理

10
00:00:37,090 --> 00:00:39,810
我们可以计算出它们的时间复杂度

11
00:00:39,810 --> 00:00:41,230
除非是我搞错了

12
00:00:41,230 --> 00:00:43,530
这里写的还是和上次的一样

13
00:00:47,460 --> 00:00:49,080
提醒大家几件事

14
00:00:49,080 --> 00:00:51,240
你们所有人必须在星期五的时候来上复习课

15
00:00:51,240 --> 00:00:52,000
这是最低要求

16
00:00:52,000 --> 00:00:52,870
如果你愿意的话

17
00:00:52,870 --> 00:00:54,850
你可以在星期天的时候到作业实验室来

18
00:00:54,850 --> 00:00:56,990
这可能需要你

19
00:00:56,990 --> 00:01:00,160
提前一些时间来完成作业

20
00:01:00,160 --> 00:01:02,000
其实作业实验室一直开到星期三

21
00:01:02,000 --> 00:01:03,720
所以你的时间还是很充足的

22
00:01:04,030 --> 00:01:06,200
还有 星期一没课

23
00:01:06,200 --> 00:01:07,980
这是所谓的学生假日

24
00:01:07,980 --> 00:01:09,230
这天就别来了

25
00:01:09,800 --> 00:01:18,380
今天我们将学习分治法

26
00:01:25,090 --> 00:01:27,930
也叫做分治法

27
00:01:27,930 --> 00:01:32,950
或者是拉丁语 "divide et impera"

28
00:01:32,950 --> 00:01:36,060
顾名思义 分治法是把一片领土分解

29
00:01:36,060 --> 00:01:38,040
分解为若干块小部分

30
00:01:38,040 --> 00:01:40,690
然后一块块的占领征服

31
00:01:40,690 --> 00:01:42,200
被分解的可以是不同的政治派别

32
00:01:42,200 --> 00:01:43,390
或是其他不同的什么

33
00:01:43,390 --> 00:01:46,180
然后让他们彼此异化

34
00:01:46,180 --> 00:01:47,600
就像策划了一次家庭内部斗争

35
00:01:47,600 --> 00:01:48,690
这是个不错的策略

36
00:01:48,690 --> 00:01:51,160
你在考试的时候得记住这个比喻

37
00:01:51,160 --> 00:01:52,220
开玩笑哈

38
00:01:52,220 --> 00:01:55,550
如果你能把一个大的结构

39
00:01:55,560 --> 00:01:57,980
分解成一些小结构

40
00:01:57,980 --> 00:02:00,160
然后去掌握每一个小的结构

41
00:02:00,160 --> 00:02:02,160
最终你就可以掌握小结构的和

42
00:02:02,160 --> 00:02:03,690
只要你不让它们再次结合

43
00:02:03,690 --> 00:02:07,550
这就是英国人的军事策略

44
00:02:07,550 --> 00:02:10,670
但我们今天所讲的是这本书

45
00:02:10,670 --> 00:02:14,310
《算法导论》

46
00:02:14,310 --> 00:02:15,640
或者其他算法书中的分治法

47
00:02:15,640 --> 00:02:18,040
这是一个非常基础的

48
00:02:18,040 --> 00:02:21,770
而且是非常有效的算法设计方法

49
00:02:21,770 --> 00:02:25,140
这是我们学习的第一个算法设计方法

50
00:02:25,140 --> 00:02:27,190
现在我们还是在算法分析阶段

51
00:02:27,190 --> 00:02:28,950
接下来我们就要开始学习算法设计

52
00:02:28,950 --> 00:02:32,470
我们将要学习3到4个算法设计方法

53
00:02:32,470 --> 00:02:33,560
这是其中之一

54
00:02:33,560 --> 00:02:35,920
所以这个分治法非常重要

55
00:02:35,920 --> 00:02:39,770
并且分治法将引出所有类型的递归

56
00:02:39,770 --> 00:02:44,200
我们将用到上节课学的所有的东西

57
00:02:44,200 --> 00:02:48,030
看看它们为什么这么有用

58
00:02:49,830 --> 00:02:53,250
正如你所想 分治法的第一步是分

59
00:02:53,250 --> 00:02:55,720
第二步是治

60
00:02:55,720 --> 00:02:58,590
你可能还想不到有第三步

61
00:02:58,590 --> 00:03:00,560
我在这留下了些空行

62
00:03:00,560 --> 00:03:02,540
你应该也空出来

63
00:03:05,850 --> 00:03:08,780
分治法是一个算法策略

64
00:03:08,780 --> 00:03:10,880
让你去解决一个很大的问题

65
00:03:10,880 --> 00:03:13,360
你根本不知道如何去有效的解决它

66
00:03:13,360 --> 00:03:15,460
你可以将它分解成一些子问题

67
00:03:15,460 --> 00:03:17,340
这就是"分"

68
00:03:19,680 --> 00:03:21,890
你可以把一个问题

69
00:03:21,890 --> 00:03:25,760
或者精确的说 一个问题的实例

70
00:03:26,710 --> 00:03:31,810
一个问题的特殊实例划分成若干子问题

71
00:03:35,880 --> 00:03:40,290
并且这些子问题在一定程度上更小了

72
00:03:40,470 --> 00:03:43,760
更小了就是说

73
00:03:43,760 --> 00:03:46,930
原问题的规模n更小了

74
00:03:46,930 --> 00:03:47,990
至此 你完成了第一步

75
00:03:47,990 --> 00:03:48,870
现在你有一个

76
00:03:48,870 --> 00:03:52,700
或者好几个子问题需要解决

77
00:03:52,700 --> 00:03:53,990
每个子问题的规模更小

78
00:03:53,990 --> 00:03:56,080
你递归的去解决每个子问题

79
00:03:56,310 --> 00:03:58,300
这就是第二步"治"

80
00:03:58,300 --> 00:04:04,930
递归的解决每一个子问题

81
00:04:04,930 --> 00:04:09,050
然后把这些子问题的解

82
00:04:09,050 --> 00:04:12,000
合并成为整个大问题的解

83
00:04:20,930 --> 00:04:25,120
这就是一般的分治法的步骤

84
00:04:25,120 --> 00:04:27,270
很多算法都用到了它

85
00:04:27,270 --> 00:04:30,390
你们已经学过一个采用分治策略的算法

86
00:04:30,390 --> 00:04:32,380
有人记得吗 归并排序

87
00:04:32,380 --> 00:04:34,070
非常好 你们还没睡着

88
00:04:34,070 --> 00:04:35,000
我太感动了

89
00:04:35,000 --> 00:04:36,600
好 我们来看看归并排序

90
00:04:36,600 --> 00:04:40,320
我觉着这块应该能写的下

91
00:04:40,320 --> 00:04:42,600
好 就在这块写吧

92
00:04:46,010 --> 00:04:48,480
我们来复习下归并排序

93
00:04:48,480 --> 00:04:51,830
它也有分治法的三个步骤

94
00:04:51,830 --> 00:04:55,480
第一步是将待排序的数组一分为二

95
00:04:55,480 --> 00:05:00,700
你得在大脑中模拟出这样的情景

96
00:05:00,700 --> 00:05:03,790
好 现在我已经把数组一分为二了

97
00:05:03,790 --> 00:05:05,090
这一步很简单

98
00:05:05,090 --> 00:05:07,570
这是第一步

99
00:05:08,300 --> 00:05:09,480
假设这个是待排序的数组

100
00:05:09,480 --> 00:05:13,370
我想你可能算出了n/2

101
00:05:13,370 --> 00:05:15,340
这个的计算时间是个常量

102
00:05:18,410 --> 00:05:20,570
好 假设现在这个数组

103
00:05:20,570 --> 00:05:23,180
已经分成了左半边和右半边

104
00:05:23,730 --> 00:05:27,060
接下来是递归的处理每一个部分

105
00:05:27,060 --> 00:05:28,920
这就是"治"这一步

106
00:05:31,140 --> 00:05:42,010
我们递归的对每一个子数组进行排序

107
00:05:44,660 --> 00:05:49,320
第三步就是合并

108
00:05:49,730 --> 00:05:52,010
现在一目了然了

109
00:05:52,010 --> 00:05:55,930
就像前面所说 这一部分已经有序了

110
00:05:55,930 --> 00:05:58,260
这一部分也有序了

111
00:05:58,260 --> 00:05:59,900
现在需要使整个数组都有序

112
00:05:59,900 --> 00:06:04,770
这是合并问题 合并两个有序数组

113
00:06:04,770 --> 00:06:07,910
我们已经知道这在线性时间n内可以完成

114
00:06:12,080 --> 00:06:13,720
我不想重复这个知识点

115
00:06:13,720 --> 00:06:17,580
但是它现在就在我们讨论的范围内

116
00:06:19,840 --> 00:06:26,030
我现在写出归并排序算法的时间复杂度

117
00:06:26,380 --> 00:06:28,220
你们已经学过这个递归算法

118
00:06:28,220 --> 00:06:29,670
知道是怎么回事

119
00:06:29,670 --> 00:06:32,930
现在应该知道如何设计递归算法

120
00:06:32,930 --> 00:06:34,100
好 进一步说

121
00:06:34,100 --> 00:06:38,080
每一个符合分治策略的算法

122
00:06:38,080 --> 00:06:41,540
几乎都有相似形式的递归出现

123
00:06:41,540 --> 00:06:44,800
就像我们的好朋友 主定理

124
00:06:44,800 --> 00:06:48,130
我们把它应用在归并排序中

125
00:06:48,130 --> 00:06:50,940
我们做点练习

126
00:06:57,310 --> 00:06:59,390
这是归并排序的递归表达式

127
00:06:59,390 --> 00:07:01,830
你应该记住它 并且爱上它

128
00:07:01,830 --> 00:07:04,210
因为它无处不在

129
00:07:04,210 --> 00:07:07,420
它从这个一般性方法归纳而来

130
00:07:07,420 --> 00:07:10,810
方法是计算子问题的规模

131
00:07:10,810 --> 00:07:12,900
你需要知道

132
00:07:12,900 --> 00:07:14,660
有多少计算量

133
00:07:14,660 --> 00:07:18,540
还有子问题的规模

134
00:07:19,920 --> 00:07:25,360
归并排序的子问题规模差不多一样

135
00:07:25,360 --> 00:07:28,120
有一个我没说清的问题

136
00:07:28,130 --> 00:07:32,290
就是跟 T(n/2) 的上下界

137
00:07:32,290 --> 00:07:35,980
星期五的复习课我会讲为什么是这样

138
00:07:35,980 --> 00:07:37,440
下界上界可以略去

139
00:07:37,440 --> 00:07:40,670
有个证明简单的定理可以用

140
00:07:40,670 --> 00:07:42,300
现在你可以假设n是2的幂次方

141
00:07:44,360 --> 00:07:46,410
我们现在就这样假设

142
00:07:46,410 --> 00:07:48,720
现有两个问题 规模都是n/2

143
00:07:48,720 --> 00:07:54,320
这个2是子问题的数目

144
00:07:57,610 --> 00:08:01,310
这个n是附加的计算量

145
00:08:01,310 --> 00:08:04,150
附加的计算量有哪些

146
00:08:04,150 --> 00:08:07,150
分解过程一般就是递归

147
00:08:07,150 --> 00:08:10,080
除了开头 这一步没有什么计算量

148
00:08:10,080 --> 00:08:12,530
这个例子中分解这一步不是很有意思

149
00:08:12,530 --> 00:08:13,990
一般来说 这一步有一些附加计算量

150
00:08:13,990 --> 00:08:16,780
合并也有些线性的计算量

151
00:08:16,780 --> 00:08:23,760
所以 这个是分治法的运行时间

152
00:08:26,600 --> 00:08:29,100
这一部分没有包括递归的计算量

153
00:08:29,100 --> 00:08:31,120
这就是如何把运用分治法

154
00:08:31,120 --> 00:08:33,540
写出递归的一般步骤

155
00:08:33,540 --> 00:08:36,930
这个简单 一般还会用到主定理

156
00:08:36,930 --> 00:08:43,590
现在是哪种情况 第二个 很好

157
00:08:43,590 --> 00:08:50,120
这是第二种情况k等于0

158
00:08:50,120 --> 00:08:51,460
在递归树中

159
00:08:51,460 --> 00:08:55,030
每一个结点的时间复杂度都差不多

160
00:08:55,030 --> 00:08:56,900
都是n^logb(a)

161
00:08:56,900 --> 00:09:01,360
n^log2(2) 还是n

162
00:09:01,360 --> 00:09:02,880
这两个式子是相等的

163
00:09:02,880 --> 00:09:04,470
还有个log因子

164
00:09:04,470 --> 00:09:07,250
因为递归树有好几层

165
00:09:07,790 --> 00:09:09,700
记住主方法中的直觉

166
00:09:09,700 --> 00:09:12,040
这里得出 nlogn

167
00:09:12,830 --> 00:09:13,960
这很好

168
00:09:13,960 --> 00:09:16,360
归并排序是个快速的nlogn排序算法

169
00:09:16,360 --> 00:09:18,320
插入排序的复杂度是n的平方

170
00:09:18,320 --> 00:09:21,330
一般来说 nlogn是最快的了

171
00:09:21,330 --> 00:09:24,220
我们得用两节课的时间来讲这个问题

172
00:09:24,220 --> 00:09:25,840
现在只是个铺垫

173
00:09:26,260 --> 00:09:29,770
今天我们要学几个分治算法

174
00:09:29,770 --> 00:09:31,350
排序只是其中之一

175
00:09:31,350 --> 00:09:33,100
有各种各样的问题需要我们去解决

176
00:09:33,100 --> 00:09:37,360
其中有一些问题可以使用分治法

177
00:09:37,550 --> 00:09:39,280
但不是每一个都行

178
00:09:39,280 --> 00:09:42,100
就像早上起床

179
00:09:42,100 --> 00:09:44,330
使用分治法不是那么简单的

180
00:09:44,330 --> 00:09:51,460
即使这个问题是个简单问题

181
00:09:56,400 --> 00:09:58,520
这是另一个使用分治法的算法

182
00:09:58,520 --> 00:10:03,010
这个算法比排序还简单

183
00:10:03,010 --> 00:10:04,490
比归并排序还简单

184
00:10:04,490 --> 00:10:09,230
这个算法只有一个子问题

185
00:10:09,230 --> 00:10:12,610
有没有人知道二分查找算法

186
00:10:12,610 --> 00:10:15,810
一个也没有 只有一个

187
00:10:15,810 --> 00:10:18,070
我快点讲

188
00:10:18,070 --> 00:10:19,560
设某个元素为x

189
00:10:19,560 --> 00:10:24,150
你需要在一个已排序的数组中找到这个x

190
00:10:27,140 --> 00:10:30,130
有多少人在没上复习课之前见过这个算法

191
00:10:30,130 --> 00:10:31,550
没有 很好

192
00:10:31,550 --> 00:10:33,620
在另外一节课上你们会学到这个算法

193
00:10:33,620 --> 00:10:34,910
好像是6.001

194
00:10:34,910 --> 00:10:36,550
很好 没学过更好

195
00:10:36,890 --> 00:10:41,400
我把这个二分查找按分治法一步一步来

196
00:10:41,400 --> 00:10:43,150
你一般看不出来这里有分治策略

197
00:10:43,150 --> 00:10:51,890
"分"就是把x与数组的中间元素相比较

198
00:10:52,000 --> 00:10:54,190
接下来是"治"

199
00:10:54,190 --> 00:10:57,880
这是一个数组 中间元素在这

200
00:10:57,880 --> 00:10:59,750
拿x和它比较

201
00:10:59,750 --> 00:11:03,750
假设x比中间元素小

202
00:11:03,750 --> 00:11:05,960
那么x一定在左半边

203
00:11:05,960 --> 00:11:08,290
因为数组是非递减排序的

204
00:11:08,290 --> 00:11:10,840
一个固定循环可以实现

205
00:11:10,840 --> 00:11:13,160
但我们要用递归的方式来解决这个问题

206
00:11:13,160 --> 00:11:17,020
我要在这个子数组中来找到x

207
00:11:18,550 --> 00:11:22,320
我们只在一个子数组中递归

208
00:11:22,320 --> 00:11:26,370
这与归并排序有两个子问题不同

209
00:11:26,370 --> 00:11:33,040
最后 在合并这一步没有计算量

210
00:11:37,180 --> 00:11:39,040
只要你在这里找到x

211
00:11:39,040 --> 00:11:42,190
那么在整个数组中间x就在这里

212
00:11:42,190 --> 00:11:45,600
就没必要再合并了

213
00:11:45,600 --> 00:11:52,930
这就是二分查找算法中的分治策略

214
00:11:52,930 --> 00:11:54,180
这个例子没什么意义

215
00:11:54,180 --> 00:11:55,600
但是有很多情况

216
00:11:55,600 --> 00:11:57,860
只需要在一边做递归

217
00:11:57,860 --> 00:11:59,780
而且重要的是

218
00:11:59,780 --> 00:12:06,040
看到做一个递归与做两个递归的差别

219
00:12:06,040 --> 00:12:12,760
这是二分查找算法的递归式

220
00:12:12,760 --> 00:12:14,240
问题的初始规模是n

221
00:12:14,240 --> 00:12:15,320
划分后子问题只有一个

222
00:12:15,320 --> 00:12:17,970
这省略了一个因子1

223
00:12:17,970 --> 00:12:22,230
子问题的规模是n/2

224
00:12:22,230 --> 00:12:23,610
上下界还是可以忽略不计

225
00:12:23,610 --> 00:12:27,230
x和中间元素的比较的工作是一个常量

226
00:12:27,230 --> 00:12:28,770
因为只有一次比较

227
00:12:28,770 --> 00:12:36,720
最后这个递归式等于logn

228
00:12:36,720 --> 00:12:41,490
现在你们知道二分查找的时间复杂度了

229
00:12:41,490 --> 00:12:44,100
但递归这里

230
00:12:44,100 --> 00:12:46,000
这两个问题有些不同

231
00:12:46,000 --> 00:12:48,330
二分查找的复杂度没有额外的n项

232
00:12:48,330 --> 00:12:52,230
就算也有线性复杂度的工作量

233
00:12:52,230 --> 00:12:53,640
结果仍然比 nlogn 快

234
00:12:53,640 --> 00:12:56,660
这个2在这变成了1

235
00:12:56,660 --> 00:12:58,650
n在这也变成了1

236
00:12:58,650 --> 00:13:01,410
所以这个时间快很多

237
00:13:01,410 --> 00:13:02,480
综合起来很快

238
00:13:02,480 --> 00:13:03,540
很简单

239
00:13:03,540 --> 00:13:06,160
再来看另外一些有意思的算法

240
00:13:16,370 --> 00:13:25,420
乘方问题 给你一个数x

241
00:13:25,420 --> 00:13:30,600
比如一个实数或者浮点数什么的

242
00:13:30,600 --> 00:13:39,030
然后再给你个正整数n

243
00:13:39,030 --> 00:13:41,810
叫你计算x的n次方

244
00:13:45,960 --> 00:13:48,570
这个问题很简单

245
00:13:48,570 --> 00:13:51,200
比前面这些问题都简单

246
00:13:51,200 --> 00:13:52,720
我们来看看吧

247
00:13:52,720 --> 00:13:54,870
用分治法可以解决它

248
00:13:54,870 --> 00:13:59,650
朴素算法非常简单

249
00:13:59,650 --> 00:14:01,790
你算x的n次方是怎么算的

250
00:14:01,790 --> 00:14:04,070
x的n次方定义是

251
00:14:04,070 --> 00:14:07,680
把x连乘n次

252
00:14:07,680 --> 00:14:15,020
x乘以x乘以...n个x

253
00:14:15,020 --> 00:14:17,080
这就是x的n次方

254
00:14:17,080 --> 00:14:19,500
就这么简单

255
00:14:19,500 --> 00:14:22,800
需要做n或n-1次乘法

256
00:14:22,800 --> 00:14:24,560
Θ(n)的工作量

257
00:14:32,210 --> 00:14:35,620
但这不是最佳的算法

258
00:14:35,620 --> 00:14:39,870
谁能想到怎么用分治策略

259
00:14:43,250 --> 00:14:46,760
有人以前学过这个算法吗

260
00:14:46,760 --> 00:14:51,500
有一些人 很好 那其他人呢

261
00:14:53,110 --> 00:14:57,680
创新很难

262
00:14:57,680 --> 00:15:01,340
但我喜欢这样的问题

263
00:15:01,340 --> 00:15:02,630
灵感很重要

264
00:15:02,630 --> 00:15:08,810
如何在非线性时间内解决这个问题

265
00:15:08,810 --> 00:15:10,780
怎么运用分治法

266
00:15:10,780 --> 00:15:14,110
我们有两个输入x和n

267
00:15:16,540 --> 00:15:18,860
我们可以对x进行划分

268
00:15:18,860 --> 00:15:23,450
好像有点难 它是个数

269
00:15:23,450 --> 00:15:25,340
或者 对n划分

270
00:15:28,050 --> 00:15:29,200
谁有灵感

271
00:15:29,200 --> 00:15:32,870
x的n/2次方 非常好

272
00:15:32,870 --> 00:15:37,000
这就是分治法的运用

273
00:15:46,430 --> 00:15:48,460
来看x的n/2次方

274
00:15:48,460 --> 00:15:50,310
这里有点小麻烦

275
00:15:50,310 --> 00:15:52,410
这次我们需要注意上下界

276
00:15:52,410 --> 00:15:54,270
x的n次方

277
00:15:54,270 --> 00:15:57,590
就是x的n/2次方

278
00:15:57,600 --> 00:16:00,920
乘上x的n/2次方

279
00:16:00,920 --> 00:16:04,350
如果n为偶数这个没问题

280
00:16:07,170 --> 00:16:10,000
如果n是奇数就需要注意下

281
00:16:10,000 --> 00:16:12,320
我们想为什么

282
00:16:12,320 --> 00:16:14,320
用分治法来解这个问题比较好

283
00:16:14,320 --> 00:16:16,880
这个问题的规模是n

284
00:16:16,880 --> 00:16:21,930
划分后两个子问题的规模是n/2

285
00:16:21,930 --> 00:16:24,310
而且两个子问题性质相同

286
00:16:24,310 --> 00:16:25,500
所以 只要解决一个子问题就行了

287
00:16:25,500 --> 00:16:26,820
如果已经算出x的n/2次方

288
00:16:26,820 --> 00:16:28,650
已知x的n/2次方

289
00:16:28,650 --> 00:16:32,130
这的问题规模变成了n/2

290
00:16:32,130 --> 00:16:33,800
最后求x的n/2次方的平方

291
00:16:33,800 --> 00:16:35,310
只需要一次计算

292
00:16:35,310 --> 00:16:38,070
这和二分查找的递归式一样

293
00:16:38,070 --> 00:16:40,300
logn比n好很多

294
00:16:40,300 --> 00:16:41,460
这个算法很好

295
00:16:41,460 --> 00:16:44,350
接下来得考虑n为奇数的情况

296
00:16:44,860 --> 00:16:51,720
n 为奇数 那么取(n-1)/2

297
00:16:51,720 --> 00:16:54,270
因为(n-1)/2是偶数

298
00:16:58,180 --> 00:17:01,760
最后再乘上一个x得到最后结果

299
00:17:02,310 --> 00:17:03,700
如果n是偶数

300
00:17:03,700 --> 00:17:07,730
需要一次递归调用和两次乘法

301
00:17:07,730 --> 00:17:09,400
递归式还是一样

302
00:17:11,250 --> 00:17:16,410
递归的规模是n/2然后加上常量

303
00:17:16,410 --> 00:17:22,040
子问题的规模是n/2

304
00:17:22,040 --> 00:17:25,920
最后合并这一步做一次或两次乘法

305
00:17:25,920 --> 00:17:28,140
递归式最后等于lgn

306
00:17:28,140 --> 00:17:32,850
对于连乘问题

307
00:17:32,850 --> 00:17:35,130
lgn 是最快的

308
00:17:35,560 --> 00:17:41,140
这是个短小精悍的算法

309
00:17:42,280 --> 00:17:46,150
今后你遇到乘方问题就知道怎么算了

310
00:17:53,010 --> 00:17:55,980
有人不知道斐波那契数的定义

311
00:17:55,980 --> 00:17:57,750
并且愿意承认吗

312
00:17:57,750 --> 00:18:00,590
好 所以说这是个很有用的老朋友

313
00:18:00,590 --> 00:18:03,700
仅作为提醒 我会写下它的定义

314
00:18:03,700 --> 00:18:05,280
尤其是它的基本情况

315
00:18:15,430 --> 00:18:17,760
我认为斐波那契数非常重要

316
00:18:17,760 --> 00:18:21,700
因为它在自然界随处可见

317
00:18:21,700 --> 00:18:24,210
你看到某种水果 就看到了斐波那契数列

318
00:18:24,210 --> 00:18:26,380
如果你数每次铃声中的振动次数

319
00:18:26,380 --> 00:18:28,550
如果你注意海滩上的沙子

320
00:18:28,550 --> 00:18:29,880
还有海浪拍打它的方式

321
00:18:29,880 --> 00:18:31,790
这就是我所说的斐波那契数列

322
00:18:31,790 --> 00:18:34,800
如果你环视穹庐 都能找到斐波那契数列

323
00:18:34,800 --> 00:18:39,590
那么大自然是如何计算斐波那契数列的

324
00:18:39,600 --> 00:18:41,440
这是另外一门课了

325
00:18:41,440 --> 00:18:45,880
但我们如何能尽快计算斐波那契数列

326
00:18:45,880 --> 00:18:48,080
你们很可能已经看过两种算法

327
00:18:48,080 --> 00:18:56,960
最朴素的一种算法是递归算法

328
00:19:00,930 --> 00:19:05,140
f(n)如果当n为0返回0

329
00:19:05,140 --> 00:19:06,220
如果n为1则返回 1

330
00:19:06,220 --> 00:19:07,960
否则就递归计算

331
00:19:07,960 --> 00:19:11,230
f(n-1)与f(n-2)

332
00:19:11,230 --> 00:19:12,030
将它们全加起来

333
00:19:12,640 --> 00:19:15,600
这个算法将占用多少时间

334
00:19:15,600 --> 00:19:17,910
有人之前考虑过吗

335
00:19:17,910 --> 00:19:20,660
这不是显而易见能猜出来的

336
00:19:20,660 --> 00:19:23,930
这不需要精确

337
00:19:28,760 --> 00:19:32,460
好吧 谁之前看到并分析过这个算法

338
00:19:32,460 --> 00:19:35,200
一半 好的 那么运行时间是多少

339
00:19:35,200 --> 00:19:37,880
非常非常久 非常好

340
00:19:37,880 --> 00:19:41,970
有更精确的答案吗 有吗

341
00:19:41,970 --> 00:19:44,550
指数级 是的

342
00:19:44,550 --> 00:19:49,340
这也是正确的并且更精确

343
00:19:49,340 --> 00:19:51,190
我给出的将更精确

344
00:19:51,190 --> 00:19:52,920
可能你们没看到过这样的分析

345
00:19:52,920 --> 00:19:55,600
这是φ的n次方

346
00:19:55,600 --> 00:19:57,390
φ是黄金比例

347
00:19:57,390 --> 00:20:02,330
黄金比例在数学的世界中无处不在

348
00:20:02,330 --> 00:20:08,020
但恐怕这可能是本节课中唯一一次接触

349
00:20:08,020 --> 00:20:10,360
我们很高兴邂逅黄金分割

350
00:20:10,360 --> 00:20:13,110
这就是所谓的指数级时间

351
00:20:13,110 --> 00:20:17,270
这比1要大 你们都应该知道

352
00:20:17,270 --> 00:20:19,200
这是指数级运行时间

353
00:20:19,200 --> 00:20:23,180
指数级时间意味着n的常数次方

354
00:20:24,050 --> 00:20:27,750
指数级时间是很长的一段时间

355
00:20:27,750 --> 00:20:34,040
这太差啦 多项式时间很好

356
00:20:34,040 --> 00:20:39,620
我们想要的就是多项式时间的算法

357
00:20:39,620 --> 00:20:42,730
这节课基本上全部是关于多项式时间算法

358
00:20:42,730 --> 00:20:43,730
有问题吗

359
00:20:45,210 --> 00:20:48,120
哦 再说一次算法做了什么

360
00:20:48,120 --> 00:20:52,340
f(n)定义了n的斐波那契函数

361
00:20:52,340 --> 00:20:54,180
我查看是不是这些基本情况

362
00:20:54,180 --> 00:20:57,410
否则 我递归调用n-1的斐波那契函数

363
00:20:57,410 --> 00:20:59,290
递归n-2的斐波那契函数

364
00:20:59,290 --> 00:21:00,370
并将两结果相加

365
00:21:00,370 --> 00:21:01,890
因此你得到了这个分支树

366
00:21:01,890 --> 00:21:04,400
你再处理两个规模几乎一致的子问题

367
00:21:04,400 --> 00:21:07,140
仅仅是累计减少了1或者2的规模

368
00:21:07,140 --> 00:21:10,700
我的意思是这几乎没有降低问题的规模

369
00:21:10,700 --> 00:21:13,230
这就是为什么直觉上复杂度会是指数级

370
00:21:13,230 --> 00:21:15,200
你可以画一个递归树

371
00:21:15,230 --> 00:21:17,200
然后你会发现它生成多大 增长多快

372
00:21:17,200 --> 00:21:19,000
我指的是在n/2层级上

373
00:21:19,000 --> 00:21:23,470
在一个分支上 问题规模从n降到n/2

374
00:21:23,470 --> 00:21:26,830
另一分支的规模则可能因此从n降到1

375
00:21:26,830 --> 00:21:29,650
但是没有哪个分支会在到n/2之后停止

376
00:21:29,650 --> 00:21:32,140
计算次数至少是2的n/2次幂

377
00:21:32,140 --> 00:21:35,180
也就是根号2的n次幂

378
00:21:35,180 --> 00:21:38,510
这与φ的n次方相当接近了

379
00:21:38,510 --> 00:21:40,340
因此 这确实是指数级的复杂度

380
00:21:40,340 --> 00:21:43,450
而指数级并不理想 我们想要多项式级

381
00:21:43,450 --> 00:21:47,180
n²、n³、logn等会比较理想

382
00:21:47,180 --> 00:21:51,140
任何以多项式级为上限的算法就是好算法

383
00:21:51,140 --> 00:21:53,330
这是一个古老的思想

384
00:21:53,330 --> 00:21:57,200
它出自某位重要的人物

385
00:21:57,200 --> 00:21:58,980
他声称多项式级很好

386
00:21:58,980 --> 00:22:04,600
他就是杰克-埃德蒙 在组合优化领域很有名

387
00:22:04,600 --> 00:22:07,470
学术方面他算是我的祖师爷

388
00:22:13,280 --> 00:22:17,930
他是个非常有意思的人

389
00:22:29,870 --> 00:22:32,860
好的 这确实是个糟糕的算法

390
00:22:32,870 --> 00:22:36,960
你们很可能已经看到过一个更好的算法

391
00:22:36,960 --> 00:22:40,410
可以认为是自下而上递归解决的算法

392
00:22:47,020 --> 00:22:49,070
或者 另一种理解它的思路是

393
00:22:49,070 --> 00:22:52,500
如果你建立关于n的斐波那契递归树

394
00:22:52,500 --> 00:22:54,790
你会发现很多公共子树

395
00:22:54,790 --> 00:22:55,970
而它们只会耗费你的时间

396
00:22:55,970 --> 00:22:58,370
当你计算n-1的斐波那契函数时

397
00:22:58,370 --> 00:23:00,370
n-2的斐波那契函数重复计算了

398
00:23:00,370 --> 00:23:02,880
为什么要计算两次 你只需要计算一次

399
00:23:02,880 --> 00:23:06,120
如果自下而上处理 事情就变得很简单

400
00:23:06,120 --> 00:23:09,500
但是你也可以通过将一些已经计算过的

401
00:23:09,500 --> 00:23:10,350
内容缓存的方式来递归处理

402
00:23:14,760 --> 00:23:16,480
所以 不用太惊讶

403
00:23:16,480 --> 00:23:20,090
依次计算这些斐波那契数

404
00:23:20,090 --> 00:23:23,170
每次计算与n相关的斐波那契数项时

405
00:23:23,170 --> 00:23:25,880
可以说 你已经计算出了前两项

406
00:23:25,880 --> 00:23:27,590
仅将之前的两项相加 耗费的时间固定

407
00:23:27,590 --> 00:23:33,270
因此运行时间是线性的 与n相关

408
00:23:33,270 --> 00:23:36,080
我们的输入也是线性的 很好

409
00:23:36,080 --> 00:23:39,550
这是我们能做到的最好程度吗 不是

410
00:23:39,550 --> 00:23:46,970
有比这个线性时间更快的方法吗

411
00:23:46,970 --> 00:23:51,670
现在要从我们已经学过的内容延伸出去

412
00:23:51,670 --> 00:23:56,430
有任何想法吗 请说

413
00:24:01,040 --> 00:24:05,590
是的 我们可以运用求n次幂的数学技巧

414
00:24:05,590 --> 00:24:09,460
实际上你可以使用φ、ψ、π...

415
00:24:09,460 --> 00:24:12,060
用什么希腊字母都可以

416
00:24:12,060 --> 00:24:17,100
好的 这是数学技巧

417
00:24:17,100 --> 00:24:18,980
同时 如你所说 这实际上是在作弊

418
00:24:18,980 --> 00:24:23,800
这不好 但是有用 我们称它为

419
00:24:23,800 --> 00:24:28,480
朴素平方递归式 我们了解这种方法

420
00:24:28,480 --> 00:24:30,780
平方递归占用logn这么多时间

421
00:24:30,780 --> 00:24:32,280
我们来用平方递归

422
00:24:33,280 --> 00:24:36,370
而如果你碰巧了解很多斐波那契数的特性

423
00:24:36,370 --> 00:24:37,440
当然事实上你不必了解很多

424
00:24:37,440 --> 00:24:39,400
但这里确实涉及到其中一个特性

425
00:24:39,600 --> 00:24:43,170
如果你用φ的n次幂去除以根号5

426
00:24:43,170 --> 00:24:46,630
并取整至最接近的整数

427
00:24:46,630 --> 00:24:49,070
那就是第n位斐波那契数

428
00:24:55,840 --> 00:24:59,590
这很酷 Fn基本上就是φ的n次幂

429
00:25:02,520 --> 00:25:06,440
我们可以用平方递归在logn时间内

430
00:25:06,440 --> 00:25:08,090
计算出φ的n次幂

431
00:25:08,090 --> 00:25:12,470
再除以根号5 假设计算机有一项操作

432
00:25:12,470 --> 00:25:15,260
能将一个数取整为最接近它的整数

433
00:25:15,260 --> 00:25:16,480
哦 我们搞定了

434
00:25:19,270 --> 00:25:22,720
由于各种原因 这方法实际上不能实现

435
00:25:22,720 --> 00:25:24,620
在现实中的机器上

436
00:25:24,620 --> 00:25:27,430
很有可能你得用浮点数表示φ和根号5

437
00:25:27,430 --> 00:25:30,420
浮点数有一些固定的精确位数

438
00:25:30,420 --> 00:25:31,850
而如果你作这些运算

439
00:25:31,850 --> 00:25:33,700
你将丢失一些重要的位

440
00:25:33,700 --> 00:25:36,230
而当你最近取整时你将得不到正确答案

441
00:25:36,230 --> 00:25:39,180
因此浮点机上不能取四舍五入将使你功亏一篑

442
00:25:39,180 --> 00:25:42,690
假设有一台奇妙的理论机器

443
00:25:42,690 --> 00:25:44,690
能够实现此类疯狂的运算

444
00:25:44,690 --> 00:25:49,590
这里每次乘法运算确实都要超过常数时间

445
00:25:49,590 --> 00:25:51,160
因此我们采用了一种略有不同的模型

446
00:25:51,160 --> 00:25:54,160
你不能在常数时间内完成φ乘以φ

447
00:25:54,160 --> 00:25:56,690
我是指这多少超出了本课程的范围

448
00:25:56,690 --> 00:25:58,300
但事实确实如此

449
00:26:01,270 --> 00:26:04,380
实际上 在一台普通机器上

450
00:26:04,380 --> 00:26:07,140
有些问题你只能用指数时间的算法解决

451
00:26:07,140 --> 00:26:09,260
而在一类理论机器上 你可以

452
00:26:09,260 --> 00:26:10,950
将现实数据相乘并取最近的整数值

453
00:26:10,950 --> 00:26:12,350
你就能在多项式时间内解决问题

454
00:26:12,350 --> 00:26:13,770
因此这确实打破了常规模式

455
00:26:13,770 --> 00:26:15,890
条件允许的话 你们可以试着疯狂一把

456
00:26:15,890 --> 00:26:18,210
这个算法在现有条件下不能实现

457
00:26:21,180 --> 00:26:24,020
在三节课之前我就已经预示过了

458
00:26:24,020 --> 00:26:27,820
或者三门课程之前 因此我不想再多谈

459
00:26:27,820 --> 00:26:31,430
但如果运用斐波那契数的另一种特性

460
00:26:31,430 --> 00:26:36,570
就可以用另一种方式来使用平方递归

461
00:26:36,570 --> 00:26:40,340
接下来的算法只有整数 所以问题很好解决

462
00:26:41,470 --> 00:26:44,610
别忘了参加复习课 大家可以去实验室

463
00:26:44,610 --> 00:26:47,590
周一别来这了 这是要求

464
00:26:51,000 --> 00:26:55,670
某种程度上这才是真正的平方递归算法

465
00:26:55,670 --> 00:26:58,080
如果你没见过这算法 要猜出来有点难

466
00:26:58,080 --> 00:27:01,530
所以我会把这个算法给你们

467
00:27:05,980 --> 00:27:08,130
显然... 我把这称为定理

468
00:27:08,130 --> 00:27:12,250
这是我这节课上第一次用“定理”这个词

469
00:27:15,020 --> 00:27:20,820
第n个斐波那契数就是这个矩阵的n次幂

470
00:27:21,310 --> 00:27:26,130
如果多看几眼你会说 哦是的 当然

471
00:27:26,130 --> 00:27:27,950
一会我们就会证明这个定理

472
00:27:27,950 --> 00:27:29,560
但是一旦我们有了这个定理

473
00:27:29,560 --> 00:27:33,840
我们可以通过计算矩阵的n次幂来得到Fn

474
00:27:33,840 --> 00:27:35,030
这是一个二阶矩阵

475
00:27:35,030 --> 00:27:37,040
你将两个二阶矩阵相乘

476
00:27:37,040 --> 00:27:38,550
得到一个二阶矩阵

477
00:27:38,550 --> 00:27:40,720
所以那是常数规模 只有四个数

478
00:27:40,720 --> 00:27:42,320
我能处理四个数

479
00:27:42,320 --> 00:27:46,210
就不必面对浮点机令人发狂的精确度问题

480
00:27:46,210 --> 00:27:47,650
只需要处理四个数

481
00:27:47,650 --> 00:27:49,320
矩阵不会变大

482
00:27:49,320 --> 00:27:52,200
所以分治算法的运行时间

483
00:27:52,200 --> 00:27:53,640
始终保持为logn

484
00:27:53,640 --> 00:27:58,090
因为二阶矩阵相乘占用常数时间 什么

485
00:28:01,610 --> 00:28:05,570
哦 是的 谢谢 我有个笔误

486
00:28:06,000 --> 00:28:13,230
很抱歉 我想Fn确实应该是在左上角

487
00:28:13,230 --> 00:28:18,440
检查下有没有漏了减1 确实漏了

488
00:28:18,440 --> 00:28:21,800
像你说的 Fn确实应该在右上角

489
00:28:22,650 --> 00:28:27,060
Fn 我需要更多空间 不好意思

490
00:28:31,550 --> 00:28:35,070
我真的应该将二阶矩阵写在左手边上

491
00:28:35,070 --> 00:28:36,570
谢谢

492
00:28:39,280 --> 00:28:45,890
那么 在logn时间内计算矩阵的n次幂

493
00:28:45,890 --> 00:28:49,180
从右上角或者左下角开始 都可以

494
00:28:49,180 --> 00:28:51,250
结果就得到第n个斐波那契数

495
00:28:51,250 --> 00:28:55,290
这就是logn时间的算法

496
00:28:55,290 --> 00:28:58,360
与前面提到的两个算法递归程度相同

497
00:28:58,360 --> 00:29:02,780
也就是二分查找和刚才的平方递归算法

498
00:29:02,780 --> 00:29:05,070
logn加上一个常数 还是logn

499
00:29:05,070 --> 00:29:08,630
现在来证明这个定理

500
00:29:28,950 --> 00:29:32,420
有哪些方法可以用呢 有什么建议吗

501
00:29:32,420 --> 00:29:35,380
或者什么技巧

502
00:29:37,730 --> 00:29:39,760
归纳法 很好

503
00:29:39,760 --> 00:29:43,010
任何时候我问这个问题 答案都是归纳法

504
00:29:43,010 --> 00:29:48,360
一个提示 以后的课上都会有用

505
00:29:52,640 --> 00:29:53,350
我的一个朋友

506
00:29:53,350 --> 00:29:56,270
当他在上分析课时 每当教授问到

507
00:29:56,270 --> 00:29:58,840
这个问题的答案是什么 答案总是0

508
00:29:58,990 --> 00:30:02,580
如果你们上分析课 就会发现这很有趣

509
00:30:04,760 --> 00:30:06,690
我也许应该提一些答案为0的

510
00:30:06,690 --> 00:30:12,390
问题 仅供我们自娱自乐

511
00:30:12,390 --> 00:30:17,140
接下来就是对n归纳 这是显而易见的

512
00:30:17,140 --> 00:30:19,860
但是我们还要先检查一些特殊情况

513
00:30:19,860 --> 00:30:24,950
基本情况就是将之应用到一次幂

514
00:30:24,950 --> 00:30:28,150
而结果就是它本身[(1, 1), (1, 0)]

515
00:30:28,150 --> 00:30:31,500
另外应当规定n至少为1

516
00:30:31,500 --> 00:30:33,850
你们可以检查下

517
00:30:33,850 --> 00:30:38,690
这应当是F₂ F₁ F₁ F₀

518
00:30:38,690 --> 00:30:43,440
而F₀是0 F₁是1 F₂是1 很好

519
00:30:43,440 --> 00:30:50,450
基本情况成立 下面就可以递推了

520
00:30:50,450 --> 00:30:53,430
但你必须证明你的算法有效

521
00:30:56,320 --> 00:31:02,820
假设这是我们要计算的

522
00:31:05,160 --> 00:31:14,850
有用的方法 某种程度上来说有很多种

523
00:31:14,850 --> 00:31:18,470
鉴于这并非高潮 我会单刀直入地解决

524
00:31:18,470 --> 00:31:22,570
哪个方向 就这个方向吧

525
00:31:22,570 --> 00:31:25,610
我想对n进行归纳

526
00:31:25,610 --> 00:31:28,410
那么 如果我要对n进行归纳

527
00:31:28,410 --> 00:31:31,440
理论上来说我应该可以用已知正确的东西

528
00:31:31,440 --> 00:31:35,020
如果将n减1 就有这样的特性

529
00:31:35,020 --> 00:31:39,280
这个就等于[(1, 1), (1, 0)]的n-1次幂

530
00:31:39,280 --> 00:31:44,240
根据归纳假设 我已经知道这点了

531
00:31:44,240 --> 00:31:46,490
[(1, 1), (1, 0)]的n-1次幂

532
00:31:46,490 --> 00:31:48,440
因此我估计我应当在某个地方用到这个

533
00:31:48,440 --> 00:31:51,880
你们也许注意到了 这个等式还不成立

534
00:31:51,880 --> 00:31:54,060
因此我需要加上一些东西

535
00:31:54,060 --> 00:31:57,320
加上什么才能保证等式会成立呢

536
00:31:57,320 --> 00:31:59,910
另一个已知的项[(1, 1), (1, 0)]

537
00:31:59,910 --> 00:32:06,720
到目前为止的推导步骤是我们唯一能做的

538
00:32:06,720 --> 00:32:08,010
某种程度上来说是这样

539
00:32:08,010 --> 00:32:09,980
如果你了解归纳法 这是你能做的全部

540
00:32:09,980 --> 00:32:13,970
检查一下 事实上这个等式其实很简单

541
00:32:13,970 --> 00:32:18,020
例如 F(n+1)是这两个乘积

542
00:32:18,020 --> 00:32:20,880
行乘以列

543
00:32:21,050 --> 00:32:24,140
所以这就是Fn乘以1加上F(n-1)乘以1

544
00:32:24,140 --> 00:32:26,280
而这实际上就是F(n+1)的定义

545
00:32:26,410 --> 00:32:28,200
然后你可以检查这四个数

546
00:32:28,200 --> 00:32:30,000
正确 太棒了

547
00:32:30,000 --> 00:32:34,530
既然这是对的 接下来我就都放到一起

548
00:32:34,530 --> 00:32:37,370
那就是[(1, 1), (1, 0)]的n-1次幂

549
00:32:37,380 --> 00:32:39,420
乘以[(1, 1), (1, 0)]

550
00:32:39,420 --> 00:32:43,720
得到[(1, 1), (1, 0)]的n次幂 结束

551
00:32:43,720 --> 00:32:44,950
非常简单的证明过程

552
00:32:44,950 --> 00:32:49,600
但你必须按部就班以确保你的算法有效

553
00:32:51,130 --> 00:32:56,120
很好 有问题吗

554
00:33:00,260 --> 00:33:01,590
哦是的 谢谢

555
00:33:01,590 --> 00:33:06,210
这里 右下角 应该是F(n-1)

556
00:33:06,210 --> 00:33:08,710
这就是为什么你们应当检查自己的证明

557
00:33:08,710 --> 00:33:10,240
在我检查行乘以列的时候

558
00:33:10,240 --> 00:33:13,880
就应该发现这个问题

559
00:33:13,880 --> 00:33:18,740
但这就是你们在这里的原因 挑我的错

560
00:33:18,740 --> 00:33:23,170
现在就发现 总比在测验中发现要好

561
00:33:25,020 --> 00:33:26,550
当然这只是一个小错误

562
00:33:26,550 --> 00:33:29,610
你不会为此付出太大代价

563
00:33:29,610 --> 00:33:36,220
好的 现在我们要进一步探讨分治算法

564
00:33:36,220 --> 00:33:39,220
目前为止我们完成了一些相对简单的例子

565
00:33:39,220 --> 00:33:42,480
实际上 时间效率最好的是归并排序

566
00:33:42,480 --> 00:33:43,670
因此 这些就显得不那么令人兴奋了

567
00:33:43,670 --> 00:33:45,310
因为它们都是logn时间的

568
00:33:45,310 --> 00:33:49,370
让我们离开logn的世界

569
00:33:49,370 --> 00:33:53,360
现在你们都记住了主方法 是吗

570
00:33:53,360 --> 00:33:55,680
所以我现在把这些都擦掉了

571
00:33:55,680 --> 00:34:02,450
好的 接下来将是一个很棒的测试

572
00:34:02,450 --> 00:34:04,590
下一个问题是矩阵乘法

573
00:34:04,590 --> 00:34:07,830
紧跟着这个2×2矩阵乘法

574
00:34:07,830 --> 00:34:12,440
让我们看看如何进行n×n矩阵乘法

575
00:34:12,440 --> 00:34:17,170
简单提一下 你们应当了解矩阵乘法

576
00:34:17,170 --> 00:34:21,010
但这里矩阵乘法的定义将被当做算法问题

577
00:34:21,010 --> 00:34:24,490
有两个矩阵 A和B 大写字母表示

578
00:34:24,490 --> 00:34:29,540
第ij项 第i行 第j列称为aij

579
00:34:29,540 --> 00:34:31,810
或者bij

580
00:34:31,810 --> 00:34:35,300
我们的目标是计算矩阵的乘积

581
00:34:35,300 --> 00:34:41,330
i和j的范围都是1到n

582
00:34:42,860 --> 00:34:44,940
因此它们是方阵

583
00:34:44,940 --> 00:34:47,870
输出矩阵用字母C表示

584
00:34:47,870 --> 00:34:54,060
它的每一项cij是A和B的对应乘积

585
00:34:54,530 --> 00:35:01,030
简单回顾一下 乘积的第ij项是

586
00:35:01,030 --> 00:35:07,630
A的第i行与B的第j列的内积

587
00:35:07,920 --> 00:35:13,300
但是你也可以写成这样的求和形式

588
00:35:13,300 --> 00:35:20,550
我们希望对每个i和j进行这样的计算

589
00:35:20,550 --> 00:35:23,290
这个问题最明显的算法是怎样的呢

590
00:35:23,290 --> 00:35:28,170
当然是对每个i和j分别求和

591
00:35:28,170 --> 00:35:29,240
分别计算出所有的乘积

592
00:35:29,240 --> 00:35:30,070
然后求和

593
00:35:30,070 --> 00:35:32,340
那么 这样看起来需要n步操作

594
00:35:32,340 --> 00:35:34,020
大概2n-1步操作吧

595
00:35:34,020 --> 00:35:36,450
这是线性阶的操作

596
00:35:36,450 --> 00:35:39,350
矩阵C共有n²项需要计算

597
00:35:39,350 --> 00:35:41,220
因此一共需要n³时间

598
00:35:41,220 --> 00:35:45,500
我把这个算法写下来 你们可以记一下

599
00:35:51,080 --> 00:35:52,330
伪代码如下

600
00:35:52,340 --> 00:35:54,370
我很少会把伪代码写下来

601
00:35:54,380 --> 00:35:58,250
这个算法很简单 我可以详细地写出来

602
00:35:59,170 --> 00:36:05,130
但如果你想编程 程序结构也是这样

603
00:36:05,130 --> 00:36:07,820
这是一个三层for循环

604
00:36:07,820 --> 00:36:16,780
看起来我犯了一个代码上的错误

605
00:36:16,780 --> 00:36:20,970
希望你们还没有记到这里

606
00:36:20,970 --> 00:36:23,310
我需要把cij初始化为0

607
00:36:23,310 --> 00:36:32,180
然后把对应的aik与bkj的乘积加到cij

608
00:36:32,180 --> 00:36:36,410
这就是这个算法

609
00:36:36,410 --> 00:36:39,510
关键是 这里需要嵌套的for循环

610
00:36:39,510 --> 00:36:41,550
从1循环到n 这将花费n³时间

611
00:36:41,550 --> 00:36:43,910
因为这和这是常数时间

612
00:36:44,070 --> 00:36:48,780
很简单 n³ 现在来做点改进

613
00:36:55,670 --> 00:36:58,190
当然 我们将要采用分治法

614
00:37:02,440 --> 00:37:04,680
现在 我们将如何分割一个矩阵呢

615
00:37:04,680 --> 00:37:09,210
矩阵里有很多数字 每个矩阵有n²个

616
00:37:09,210 --> 00:37:11,000
你有各种方式来分割

617
00:37:11,000 --> 00:37:13,070
目前为止所有的分治问题

618
00:37:13,070 --> 00:37:15,360
我们都是把规模为n的问题

619
00:37:15,360 --> 00:37:17,450
分割成规模为n/2的两部分

620
00:37:17,450 --> 00:37:21,720
那么让我们考虑某个n×n的矩阵

621
00:37:21,720 --> 00:37:25,870
我希望将它转化为n/2乘n/2规模

622
00:37:25,870 --> 00:37:28,070
我该怎么做呢 有没有什么建议

623
00:37:28,070 --> 00:37:33,780
对 确实 矩阵分块

624
00:37:33,780 --> 00:37:35,250
就是这样

625
00:37:35,250 --> 00:37:38,560
所以 这将是第一个分治算法

626
00:37:38,560 --> 00:37:43,850
还没有用 但这是我们首先需要的思想

627
00:37:43,850 --> 00:37:48,430
我们有一个n×n的矩阵

628
00:37:48,430 --> 00:37:52,310
我们可以这样看待它 你可以把它当作

629
00:37:52,310 --> 00:37:56,490
2×2的块矩阵 这才是真正需要的

630
00:37:59,690 --> 00:38:03,610
这个块矩阵的每个元素

631
00:38:03,610 --> 00:38:09,090
都是规模为n/2乘n/2的子矩阵块

632
00:38:19,960 --> 00:38:28,810
考虑C被分为四个部分 r, s, t和u

633
00:38:28,810 --> 00:38:32,840
我使用了小写字母 但实际都表示矩阵

634
00:38:32,840 --> 00:38:35,140
每个都是n/2乘n/2

635
00:38:35,140 --> 00:38:42,940
然后矩阵A 划分为a,b,c,d

636
00:38:42,950 --> 00:38:49,930
乘以矩阵B 划分为e,f,g,h

637
00:38:52,760 --> 00:38:55,370
为什么不呢 这当然是正确的

638
00:38:55,370 --> 00:38:56,980
只要你学过一点线性代数就会知道

639
00:38:56,980 --> 00:38:59,690
这是基本的矩阵操作

640
00:38:59,690 --> 00:39:03,680
现在我们可以假装这些矩阵是2×2的

641
00:39:03,680 --> 00:39:06,900
假装忘记这些小写字母也是矩阵的事实

642
00:39:06,900 --> 00:39:11,170
r是这一行和这一列的内积

643
00:39:11,170 --> 00:39:14,060
是ae+bg

644
00:39:14,070 --> 00:39:17,750
我把这些都写一下吧 很简单

645
00:39:17,750 --> 00:39:46,680
r=ae+bg, s=af+bh, t=ce+dg以及u=cf+dh

646
00:39:46,680 --> 00:39:48,800
你们自己做也并不难

647
00:39:48,800 --> 00:39:52,630
没错吧 很好

648
00:39:52,630 --> 00:39:57,010
所以 这是事实上展开这个乘积的方法

649
00:39:57,010 --> 00:39:59,240
因此现在我们有了一个递归的算法

650
00:39:59,240 --> 00:40:01,000
事实上 是一个分治的算法

651
00:40:01,000 --> 00:40:03,630
我们由n×n矩阵开始

652
00:40:03,630 --> 00:40:06,560
嗯 事实上我们有两个这样的矩阵

653
00:40:06,780 --> 00:40:14,570
我们将它们分8块: a,b,c,d,e,f,g,h

654
00:40:14,570 --> 00:40:18,510
然后计算这些 得到C

655
00:40:18,510 --> 00:40:20,160
只要把它们组合到一起就可以了

656
00:40:20,160 --> 00:40:22,580
现在 我们怎样来计算这些呢

657
00:40:22,580 --> 00:40:25,240
嗯 这些看上去很无辜的乘积

658
00:40:25,240 --> 00:40:26,320
也就是这两个小小的数的乘积

659
00:40:26,320 --> 00:40:28,970
事实上是递归的矩阵乘法

660
00:40:28,970 --> 00:40:32,960
因为这些字母实际上都是n/2乘n/2的矩阵

661
00:40:32,960 --> 00:40:34,920
因此我们需要递归地计算乘积

662
00:40:34,920 --> 00:40:49,950
看起来需要8次n/2乘n/2矩阵的递归乘积

663
00:40:49,950 --> 00:40:53,870
这看起来可不太妙

664
00:40:53,870 --> 00:40:55,820
然后 貌似还需要4次矩阵求和

665
00:40:55,820 --> 00:40:58,950
加上把各部分合并的一些简单操作

666
00:41:03,080 --> 00:41:08,490
两个矩阵相加需要多长时间呢

667
00:41:08,490 --> 00:41:12,260
n的平方 代价很低

668
00:41:12,260 --> 00:41:13,890
只需要n的平方

669
00:41:13,890 --> 00:41:17,660
我们想把总时间复杂度降到n³以下

670
00:41:17,660 --> 00:41:18,910
加法是一个多么简单的问题

671
00:41:18,910 --> 00:41:20,190
只需要对所有数字简单地相加

672
00:41:20,190 --> 00:41:21,980
没有办法做到比n平方更好

673
00:41:21,980 --> 00:41:24,520
因此它不是递归的 这一点很好

674
00:41:24,520 --> 00:41:28,380
但是讨厌的是需要8次这样的递归

675
00:41:28,380 --> 00:41:35,720
We have T(n)=8T(n/2)+Θ(n²).

676
00:41:28,380 --> 00:41:35,720
复杂度为T(n)=8T(n/2)+Θ(n²).

677
00:41:38,850 --> 00:41:43,090
我把主方法擦掉了 但是你们应该记得

678
00:41:43,090 --> 00:41:45,480
对于这样的递推该怎么办呢

679
00:41:52,600 --> 00:41:56,260
Θ(n³). That is annoying.

680
00:41:52,600 --> 00:41:56,260
Θ(n³) 这一点很讨厌

681
00:41:56,260 --> 00:42:01,650
a是8 b是2 以2为底的8的对数是3

682
00:42:01,650 --> 00:42:03,570
每个计算机科学家都要知道这个

683
00:42:06,180 --> 00:42:08,210
这个多项式的阶数比平方高

684
00:42:08,210 --> 00:42:11,600
因此符合主方法第一种情况

685
00:42:11,600 --> 00:42:16,460
谢谢 写在下面

686
00:42:16,460 --> 00:42:20,440
结果是n立方 并不比先前的算法优秀

687
00:42:20,440 --> 00:42:21,860
毫无用处

688
00:42:26,000 --> 00:42:31,930
现在回到最初分治的灵感上来

689
00:42:38,860 --> 00:42:41,860
考虑某种类似于斐波那契数的算法

690
00:42:41,860 --> 00:42:43,360
你只要坐下来略加思考

691
00:42:43,360 --> 00:42:46,860
就可以解决 这个问题不难

692
00:42:46,860 --> 00:42:50,230
我们用一种更巧妙的方式来观察这个矩阵

693
00:42:50,230 --> 00:42:52,120
然后问题就可以轻易解决了

694
00:42:52,120 --> 00:42:56,460
这个方法不容易想到 但却惊人地巧妙

695
00:42:56,460 --> 00:42:59,090
这是一个特别巧妙的算法

696
00:42:59,090 --> 00:43:02,340
你可能之前已经看过了

697
00:43:02,340 --> 00:43:06,270
但是这个算法真的很酷 值得你再看看

698
00:43:09,720 --> 00:43:12,540
那么斯特拉森是如何想出这个算法的呢

699
00:43:12,540 --> 00:43:14,880
他一定非常聪明

700
00:43:17,940 --> 00:43:23,540
关键思路是 我们得绕过这些乘法

701
00:43:23,540 --> 00:43:26,320
我并不介意多做几百次加法

702
00:43:26,320 --> 00:43:27,760
That only costs Θ(n²).

703
00:43:26,320 --> 00:43:27,760
它们只花费Θ(n²)

704
00:43:27,760 --> 00:43:31,630
关键是我需要把这里的8变小 事实上

705
00:43:31,630 --> 00:43:34,780
如果你尝试把矩阵分为3×3甚至更多块

706
00:43:34,780 --> 00:43:35,640
并不会带来任何帮助

707
00:43:35,640 --> 00:43:37,280
你会遇到同样的问题

708
00:43:37,280 --> 00:43:39,830
因为我们在使用同样的算法

709
00:43:39,830 --> 00:43:41,120
仅仅变化了顺序

710
00:43:41,120 --> 00:43:44,290
我们需要想办法减少乘法的次数

711
00:43:50,150 --> 00:43:52,230
把它减少到7

712
00:43:54,290 --> 00:43:57,270
这就意味着 如果我们有两个2×2矩阵

713
00:43:57,270 --> 00:44:00,370
我们可以只通过七次乘法得到它们的乘积

714
00:44:00,370 --> 00:44:01,190
如果真的可以这样的话

715
00:44:01,190 --> 00:44:05,600
这里的8就减少到了7 运行会快一些

716
00:44:05,600 --> 00:44:07,530
等一下我们来看看具体有多快

717
00:44:07,530 --> 00:44:10,080
你可以心算一下

718
00:44:10,080 --> 00:44:12,490
如果你百无聊赖而且喜欢计算对数的话

719
00:44:12,490 --> 00:44:16,680
那些是非整数的对数 好吧随便你

720
00:44:16,680 --> 00:44:20,370
好的 我们刚才讲到这里

721
00:44:20,410 --> 00:44:27,710
很不幸这个算法很长

722
00:44:27,710 --> 00:44:30,770
但是却只有七次乘法

723
00:44:43,710 --> 00:44:47,480
每个P都是两项相乘的结果

724
00:44:47,480 --> 00:44:52,530
每一项只涉及加减法 它们的复杂度是一样的

725
00:45:36,530 --> 00:45:39,280
一共有7次乘法

726
00:45:39,280 --> 00:45:44,170
我们可以在7T(n/2)时间内完成

727
00:45:44,170 --> 00:45:49,950
哦 事实上第六个写错了

728
00:45:49,950 --> 00:45:54,010
第六个写成和第七个一样了 很好

729
00:45:54,010 --> 00:45:55,730
要知道

730
00:45:55,730 --> 00:45:58,470
复制粘贴并不是什么很有挑战性的工作

731
00:45:59,960 --> 00:46:04,690
但如果你也成了一个像我一样走神的教授

732
00:46:04,690 --> 00:46:07,000
你就会知道这到底是难还是简单啦

733
00:46:07,000 --> 00:46:10,730
好 但愿我们都写对了

734
00:46:10,730 --> 00:46:13,680
继续 还没完

735
00:46:13,680 --> 00:46:14,880
当然我们有了7个结果

736
00:46:14,880 --> 00:46:17,690
明显我们还需要把它们搞成四项

737
00:46:17,700 --> 00:46:18,900
C的元素

738
00:46:18,900 --> 00:46:21,460
它们在这里 C的元素r s t u

739
00:46:21,460 --> 00:46:27,360
事实上r=P₅+P₄-P₂+P₆

740
00:46:27,360 --> 00:46:30,060
当然 你们都看到了吧

741
00:46:30,060 --> 00:46:35,030
这个很简单 s=P₁+P₂

742
00:46:37,510 --> 00:46:39,020
明显它们就是因为这个才被选为这样的

743
00:46:39,020 --> 00:46:44,250
u也有点技巧性

744
00:46:46,700 --> 00:46:53,910
好了 现在你们希望我检查哪一个

745
00:46:55,060 --> 00:46:58,280
心眼别太坏 s怎么样

746
00:46:58,280 --> 00:47:00,310
我可以秀给你们

747
00:47:01,690 --> 00:47:08,760
选哪个 u 哦 想看有没有符号错误

748
00:47:08,760 --> 00:47:10,920
很好

749
00:47:10,920 --> 00:47:12,180
你要检查过所有四个后

750
00:47:12,180 --> 00:47:13,690
才能认为这个算法确实可行

751
00:47:13,690 --> 00:47:16,320
我在讲义中做了

752
00:47:29,020 --> 00:47:31,190
那是P₅ 帮我核对下

753
00:47:31,190 --> 00:47:33,580
如果我搞乱了那麻烦了

754
00:47:33,580 --> 00:47:37,610
af-ah是P₁

755
00:47:37,610 --> 00:47:46,000
P₃前面有负号 是(ce+de)

756
00:47:46,000 --> 00:47:49,030
然后是负的P₇

757
00:47:49,030 --> 00:47:57,700
很长一串 (ae+af-ce-cf)

758
00:47:58,060 --> 00:48:00,780
现在我需要

759
00:48:00,780 --> 00:48:03,510
去掉相同的数 像放电影样

760
00:48:26,830 --> 00:48:35,540
还好这两个幸存下来 dh减负的cf

761
00:48:35,540 --> 00:48:40,080
如果我们幸运的话 这和写在这的一样

762
00:48:40,080 --> 00:48:41,610
只是顺序不一样

763
00:48:42,240 --> 00:48:46,920
很神奇吧 斯特拉森是怎么想出来的

764
00:48:46,920 --> 00:48:48,910
值得注意的是

765
00:48:48,910 --> 00:48:52,870
加法无所谓顺序反了因为加法是可交换的

766
00:48:52,870 --> 00:48:55,380
但是乘法可最好别反了

767
00:48:55,380 --> 00:48:57,910
因为矩阵乘法可不是可交换的

768
00:48:57,910 --> 00:49:02,100
检查一下cf dh 它们的顺序是对的

769
00:49:02,100 --> 00:49:06,480
我就不检查剩下三个了

770
00:49:06,480 --> 00:49:10,630
这就是小于立方级的矩阵乘法

771
00:49:10,630 --> 00:49:12,020
让我们写一下递推关系

772
00:49:12,020 --> 00:49:14,140
T(n)现在是7

773
00:49:14,140 --> 00:49:19,460
可能我应该把这个算法写下来

774
00:49:19,460 --> 00:49:26,230
为什么不呢 如果我有时间的话

775
00:49:28,470 --> 00:49:37,980
时间很宽裕 上节课我早了十分钟

776
00:49:37,980 --> 00:49:40,180
我为此道歉 我知道那让你们很无奈

777
00:49:37,980 --> 00:49:37,370
提前十分钟结束

778
00:49:40,180 --> 00:49:43,500
我并不知道课该上到什么时候结束

779
00:49:43,500 --> 00:49:46,140
所以今天我要晚下课十分钟

780
00:49:46,140 --> 00:49:48,860
很好 我很高兴你们都同意

781
00:49:48,860 --> 00:49:51,470
开玩笑的啦 别紧张

782
00:49:51,470 --> 00:49:56,180
这就是今天介绍的算法 斯特拉森算法

783
00:49:56,180 --> 00:50:04,340
首先我们"分" 然后"治" 然后合并

784
00:50:04,340 --> 00:50:10,620
和以前一样 我没有在别处写过 很好

785
00:50:10,620 --> 00:50:15,660
划分A和B 这个很平常

786
00:50:18,240 --> 00:50:35,130
然后我们计算一些乘积

787
00:50:35,130 --> 00:50:39,650
这意味着我们要计算所有的P

788
00:50:39,650 --> 00:50:45,150
a+b c+d g-e a+d e+h等等

789
00:50:45,150 --> 00:50:47,850
所有的项都在这儿 我们计算一下

790
00:50:47,850 --> 00:50:49,580
需要花费n平方的时间

791
00:50:49,580 --> 00:50:54,020
因为这只需要一些加减法

792
00:50:54,020 --> 00:50:57,610
很简单 常数次运算

793
00:50:57,610 --> 00:51:06,960
然后我们分别递归地处理所有的Pi

794
00:51:06,960 --> 00:51:12,300
得到七个乘积

795
00:51:12,300 --> 00:51:18,860
P₁ P₂一直到P₇

796
00:51:18,860 --> 00:51:28,760
最后把这些组合起来计算r,s,t,u

797
00:51:33,730 --> 00:51:36,810
现在也是些加减法运算

798
00:51:36,810 --> 00:51:38,550
总共需要n²次计算

799
00:51:38,550 --> 00:51:42,340
这就是整个算法

800
00:51:42,340 --> 00:51:45,250
这个算法在拆分和组合上面都不简单

801
00:51:45,250 --> 00:51:47,260
不过递归还是递归

802
00:51:47,260 --> 00:51:49,700
只是我们现在对第一步和第三步感兴趣

803
00:51:49,700 --> 00:51:55,160
递归式T(n)包含了7个递归的子问题

804
00:51:55,160 --> 00:51:57,570
每个子问题规模是n/2

805
00:51:57,570 --> 00:52:00,200
再加上n²规模的计算

806
00:52:00,200 --> 00:52:02,980
来完成所有额外的运算

807
00:52:02,980 --> 00:52:06,570
现在来算一下这个递归式子

808
00:52:06,570 --> 00:52:09,490
先计算一下n^logb(a)

809
00:52:09,490 --> 00:52:12,610
在这里这项是nlog2(7)

810
00:52:12,610 --> 00:52:18,600
因为以2为底8的对数是3

811
00:52:18,600 --> 00:52:21,660
那么log2(7)应该比3小一点

812
00:52:21,660 --> 00:52:23,560
但肯定是比2大的

813
00:52:23,560 --> 00:52:26,310
因为以2为底4的对数才是2

814
00:52:26,310 --> 00:52:30,570
所以它应该多项式地比n²大

815
00:52:30,580 --> 00:52:33,420
但是要比n的立方小

816
00:52:33,420 --> 00:52:35,460
所以说这个属于第一种情形

817
00:52:35,460 --> 00:52:37,210
这里我简写一下

818
00:52:37,210 --> 00:52:41,190
以2为底7的对数写成n^lg7

819
00:52:41,190 --> 00:52:42,920
这里lg就是代表以2为底的对数

820
00:52:42,920 --> 00:52:43,780
你要知道这个

821
00:52:43,780 --> 00:52:48,980
这种情况贯穿我们整个教材和作业

822
00:52:48,980 --> 00:52:54,210
我们用计算器具体计算下

823
00:53:00,780 --> 00:53:04,080
这个老式计算器还是很有效

824
00:53:08,080 --> 00:53:11,570
不好意思写错了

825
00:53:13,570 --> 00:53:16,380
这个严格小于2.81

826
00:53:16,380 --> 00:53:18,250
太棒了

827
00:53:18,250 --> 00:53:19,500
说明这个多项式要比3次方的算法好

828
00:53:19,500 --> 00:53:22,300
但还是没有n²的加法运算好

829
00:53:22,300 --> 00:53:23,390
我们一般认为达不到n²算法

830
00:53:23,390 --> 00:53:25,520
因为我们不知道矩阵对于乘法和除法运算

831
00:53:25,520 --> 00:53:27,200
速度是不是一样的

832
00:53:27,200 --> 00:53:31,500
不过 这也说不定

833
00:53:31,500 --> 00:53:35,080
它也可能发生 这里没有下限

834
00:53:35,080 --> 00:53:38,960
这个不是矩阵相乘最好的算法

835
00:53:38,960 --> 00:53:40,950
不过这个是比n³好的最简单的算法

836
00:53:40,950 --> 00:53:47,010
目前最好的大约是n^2.376

837
00:53:47,010 --> 00:53:50,970
正在向2进军

838
00:53:50,970 --> 00:53:55,500
可能会觉得这些数有点儿怪

839
00:53:55,500 --> 00:53:57,800
这里面的优化掌控在

840
00:53:57,800 --> 00:53:59,160
常数上面

841
00:53:59,160 --> 00:54:01,480
看起来优化了指数部分没什么

842
00:54:01,480 --> 00:54:05,140
但是当n变大的时候 指数部分影响很吓人

843
00:54:05,140 --> 00:54:08,970
对于很大的n来说n³算法就很不切实际

844
00:54:08,970 --> 00:54:11,090
当n足够大时

845
00:54:11,090 --> 00:54:16,850
斯特拉森算法比普通矩阵乘法好

846
00:54:16,850 --> 00:54:22,380
大概32左右就能看出差别了

847
00:54:22,380 --> 00:54:24,230
还有一些原因

848
00:54:24,230 --> 00:54:27,220
不仅是指数变小了 不过先就这样吧

849
00:54:27,260 --> 00:54:28,010
确实不错

850
00:54:28,010 --> 00:54:30,760
这个算法完全不切实际 别用这个

851
00:54:30,760 --> 00:54:33,460
我这里也没相关资料

852
00:54:33,460 --> 00:54:35,340
这个纯粹是理论上的改进

853
00:54:35,340 --> 00:54:37,750
可能还有更切实际一点儿的

854
00:54:37,750 --> 00:54:39,550
但肯定不是这个

855
00:54:39,550 --> 00:54:44,950
时间还很多 有问题没

856
00:54:44,960 --> 00:54:46,360
现在还没完

857
00:54:46,360 --> 00:54:50,400
关于矩阵乘法还有问题么

858
00:54:50,400 --> 00:54:57,820
好吧 下一个问题

859
00:55:13,230 --> 00:55:15,060
分治法的思想很普遍

860
00:55:15,060 --> 00:55:16,690
我意思是治理国家可以用它

861
00:55:16,690 --> 00:55:19,380
矩阵相乘也可以用它

862
00:55:19,380 --> 00:55:21,760
谁来想一下

863
00:55:21,760 --> 00:55:26,920
这有一个不同类型的问题

864
00:55:26,920 --> 00:55:28,430
你可以分治法思想解决

865
00:55:28,430 --> 00:55:31,010
虽然跟计算机有关

866
00:55:31,010 --> 00:55:35,210
不过不是严格的算法问题

867
00:55:35,210 --> 00:55:37,590
这个是超大规模集成电路(VLSI)

868
00:55:37,590 --> 00:55:42,460
超大规模的集成的芯片

869
00:55:42,460 --> 00:55:45,680
可能会更大规模 不过现在是这个叫法

870
00:55:45,680 --> 00:55:49,840
在集成电路布局时候显现出来一个问题

871
00:55:49,840 --> 00:55:52,520
我们不用考虑太细节

872
00:55:52,530 --> 00:55:54,940
现在就有一些电路

873
00:55:54,940 --> 00:55:58,840
这里我假设电路是个二叉树

874
00:55:58,840 --> 00:56:01,840
这个就是电路一部分

875
00:56:01,840 --> 00:56:07,730
假设现在这里有一个完全二叉树

876
00:56:07,730 --> 00:56:13,450
完全二叉树长这个样子

877
00:56:13,450 --> 00:56:15,810
在我教学生涯里

878
00:56:15,810 --> 00:56:19,840
我画这个图的次数最多

879
00:56:19,840 --> 00:56:21,440
这是我最喜欢的图

880
00:56:21,440 --> 00:56:23,640
四层高的完全二叉树

881
00:56:23,640 --> 00:56:26,230
就是这个 还有一些一样高的树

882
00:56:26,230 --> 00:56:30,740
我想在网格上 把它放到芯片布局上

883
00:56:30,740 --> 00:56:35,530
这个是有n个叶节点

884
00:56:37,750 --> 00:56:43,760
我想在网格上占据最小空间

885
00:56:43,760 --> 00:56:45,720
这个问题很有意思

886
00:56:45,720 --> 00:56:48,910
让你从另一个角度感受到

887
00:56:48,910 --> 00:56:54,050
分治这个强大而有效的工具

888
00:56:54,050 --> 00:56:56,810
现在这棵树我想这么画

889
00:56:56,810 --> 00:56:59,620
我想在网格上画出来

890
00:56:59,620 --> 00:57:04,470
就是说顶点是要放在网格上的点的

891
00:57:04,470 --> 00:57:05,920
现在说的都是正方形网格

892
00:57:05,920 --> 00:57:07,980
放在网格顶点上面去

893
00:57:07,980 --> 00:57:12,510
这些边组织成为正交路线

894
00:57:12,510 --> 00:57:14,850
在点和点之间

895
00:57:14,850 --> 00:57:17,220
有一条边而且不能交叉

896
00:57:17,220 --> 00:57:20,760
这么多限制 都是因为线不能交叉

897
00:57:25,610 --> 00:57:29,450
现在有一个明显的解决方案 还有一个正确的

898
00:57:29,450 --> 00:57:36,660
两个我都要讲

899
00:57:36,660 --> 00:57:38,250
两个方法都不是很显然

900
00:57:38,250 --> 00:57:40,990
不过分治法思想给你一个正确的提示

901
00:57:40,990 --> 00:57:46,990
朴素算法 我现在就用朴素的算法做下

902
00:57:46,990 --> 00:57:54,750
我准备从下往上画 这样简单点儿

903
00:57:54,750 --> 00:58:00,160
留出来3排网格然后开始画

904
00:58:00,160 --> 00:58:03,710
我可不知道这得变多大

905
00:58:03,710 --> 00:58:07,270
这里是我们树的底部

906
00:58:07,270 --> 00:58:10,300
看起来像是三个节点

907
00:58:10,300 --> 00:58:18,590
现在空出一个空白列 又一个

908
00:58:18,590 --> 00:58:20,570
我实际上不需要留出空白列

909
00:58:20,570 --> 00:58:22,380
不过好看点儿

910
00:58:25,120 --> 00:58:28,200
继续向上

911
00:58:35,740 --> 00:58:38,850
就是这个树 这里对齐在网格上

912
00:58:38,850 --> 00:58:40,870
没有交叉 都很好

913
00:58:40,870 --> 00:58:42,680
不过要占多大面积呢

914
00:58:49,200 --> 00:58:52,720
面积 我意思是说包围的方形面积

915
00:58:52,720 --> 00:58:55,450
虽然空白没用上 但还是要算进去

916
00:58:55,450 --> 00:58:57,530
所有空白都要算 虽然没用上

917
00:58:57,530 --> 00:59:00,520
先看一下高度

918
00:59:00,520 --> 00:59:03,560
记作H(n)

919
00:59:03,560 --> 00:59:08,840
然后看一下宽度 记作W(n)

920
00:59:08,840 --> 00:59:13,240
很显然 H(n)是logn级别

921
00:59:13,240 --> 00:59:15,320
W(n)差不多是n级别

922
00:59:15,320 --> 00:59:17,530
不过我要写成递归式

923
00:59:17,530 --> 00:59:20,420
因为有可能可以启发我们一下

924
00:59:22,850 --> 00:59:28,890
H(n) 我们把这个理解为递归树

925
00:59:28,890 --> 00:59:30,110
我们从这个大树开始

926
00:59:30,110 --> 00:59:33,650
分成两个部分

927
00:59:33,650 --> 00:59:35,810
这两个子树大小n/2

928
00:59:35,810 --> 00:59:37,770
因为我们会算上叶节点

929
00:59:37,770 --> 00:59:39,510
每一面都是n/2

930
00:59:39,510 --> 00:59:45,670
对于高度 它们是平行的没什么说的

931
00:59:45,670 --> 00:59:47,640
高度就是这个的高度

932
00:59:47,640 --> 00:59:49,740
每个子问题加一

933
00:59:49,740 --> 00:59:53,790
宽度 需要加在一块然后再加1

934
00:59:53,790 --> 00:59:56,920
这里不用加1 不过没什么关系

935
00:59:56,920 --> 00:59:58,460
最多是1

936
01:00:00,130 --> 01:00:05,670
H(n)=H(n/2)+Θ(1),

937
01:00:00,130 --> 01:00:05,670
H(n)=H(n/2)+Θ(1）

938
01:00:05,670 --> 01:00:07,060
这儿再加1

939
01:00:22,780 --> 01:00:25,840
常见的基本情况

940
01:00:25,840 --> 01:00:30,340
这个递归式我们知道而且喜欢

941
01:00:30,340 --> 01:00:35,070
这个是lgn 这个解答已经差不多了

942
01:00:35,070 --> 01:00:40,260
这个是线性

943
01:00:40,260 --> 01:00:44,650
这个是第一情况

944
01:00:44,650 --> 01:00:50,570
n^log2(2)=n 这个答案比1大

945
01:00:50,570 --> 01:00:55,990
这里n的lg1次方即n的0次方

946
01:00:55,990 --> 01:00:59,240
等于1 所以得到lgn

947
01:00:59,240 --> 01:01:04,710
面积是nlgn

948
01:01:07,290 --> 01:01:10,500
不过做芯片面积越小越好

949
01:01:10,500 --> 01:01:11,960
这样就能放更多的元件

950
01:01:11,960 --> 01:01:13,720
我们想找一下

951
01:01:13,720 --> 01:01:16,230
不过可以肯定不会有比n更好的

952
01:01:16,230 --> 01:01:18,200
现在是把叶节点放在下面

953
01:01:18,200 --> 01:01:19,710
已经看起来不错了

954
01:01:19,710 --> 01:01:22,390
只过是nlgn级别的 不过我们想要n

955
01:01:23,950 --> 01:01:26,300
不过怎么能到n呢

956
01:01:26,300 --> 01:01:29,390
关于改变布局有没有什么猜测

957
01:01:29,390 --> 01:01:31,260
先不说怎么弄 这个不是那么显然

958
01:01:31,260 --> 01:01:36,250
高度和宽度我们应该从哪入手

959
01:01:36,250 --> 01:01:39,290
让高度变得比lgn小看起来很困难

960
01:01:39,290 --> 01:01:41,760
因为这是棵树

961
01:01:41,760 --> 01:01:45,680
不可能让高度比lgn还小

962
01:01:45,680 --> 01:01:51,010
那我们怎么才能让乘积呈线性呢

963
01:01:54,010 --> 01:01:57,480
发散思维 什么样的两个函数乘积是n

964
01:02:05,880 --> 01:02:07,710
n的平方根和n的平方根

965
01:02:07,710 --> 01:02:10,200
不错 还有别的么

966
01:02:13,780 --> 01:02:16,200
n乘以常数 对 n乘常数也不错

967
01:02:16,200 --> 01:02:19,320
不过我刚才说了 这两个没法变常数

968
01:02:19,320 --> 01:02:23,050
应该关注n/lgn和lgn 这个更像一些

969
01:02:23,050 --> 01:02:24,450
不过这个不可能的

970
01:02:24,450 --> 01:02:28,140
n平方根乘n平方根是正确答案 我们来看一下

971
01:02:30,050 --> 01:02:31,710
n平方根乘n平方根

972
01:02:32,020 --> 01:02:36,100
我们还没见过解是n平方根的递归式子呢

973
01:02:36,100 --> 01:02:38,370
不过这个就是

974
01:02:42,000 --> 01:02:49,700
Let's say the goal is to get W(n) = Θ(root n)

975
01:02:42,000 --> 01:02:49,700
我们现在目标是让W(n)是n平方根复杂度的

976
01:02:49,700 --> 01:02:54,170
and to get H(n) = Θ(root n).

977
01:02:49,700 --> 01:02:54,170
然后让H(n)也是n平方根复杂度的

978
01:02:54,170 --> 01:02:56,270
如果能做到那就很开心了

979
01:02:56,270 --> 01:02:59,700
那样的话乘积 也就是面积 是线性的

980
01:03:01,020 --> 01:03:07,360
怎么办 主方法中哪种递归式拥有这样的形式

981
01:03:07,360 --> 01:03:09,990
然后解是n的平方根

982
01:03:12,890 --> 01:03:14,990
我意思是可以按这种方式思考

983
01:03:14,990 --> 01:03:16,510
这个递归式有些微妙

984
01:03:16,510 --> 01:03:18,490
想一下n^logb(a)

985
01:03:18,490 --> 01:03:26,710
什么时候n^logb(a)是根号n

986
01:03:26,710 --> 01:03:33,120
希望能够得到一个解是n平方根的递归式

987
01:03:34,890 --> 01:03:38,660
这个是通过分治法思想进行设计

988
01:03:38,660 --> 01:03:40,240
肯定会有类似这种样子的形式

989
01:03:40,240 --> 01:03:43,010
你知道了以后很简单

990
01:03:43,010 --> 01:03:46,510
先假设一个方向 然后可以进行尝试

991
01:03:46,510 --> 01:03:49,970
什么时候logb(a)等于1/2

992
01:03:49,970 --> 01:03:52,970
好多情况 我们来找出来

993
01:03:53,750 --> 01:03:56,110
4和2 不错 没错的话

994
01:03:58,300 --> 01:04:01,750
因为4的平方根是2

995
01:04:01,750 --> 01:04:06,580
所以以4为底2对数是1/2

996
01:04:06,680 --> 01:04:07,950
关注下这个

997
01:04:07,950 --> 01:04:12,030
怎么才能得到log4(2)呢

998
01:04:15,360 --> 01:04:17,410
这是b 这是a

999
01:04:17,410 --> 01:04:22,980
所以应该是2T(n/4)加上什么东西

1000
01:04:23,440 --> 01:04:26,800
如果我想让n^logb(a)占据主导

1001
01:04:26,800 --> 01:04:30,990
这部分应该多项式地小于n的平方根

1002
01:04:30,990 --> 01:04:37,210
所以这部分是n^(1/2-ε)

1003
01:04:37,210 --> 01:04:38,870
当然可以更小一些

1004
01:04:38,870 --> 01:04:41,180
可能是1 当然0更好

1005
01:04:41,180 --> 01:04:44,160
不过 这就想的太美了

1006
01:04:44,160 --> 01:04:45,870
所以 应该要小一点

1007
01:04:45,870 --> 01:04:48,350
多项式地严格小于n开方的多项式

1008
01:04:48,350 --> 01:04:51,040
这就是我们目标 见证奇迹时刻到了

1009
01:04:51,040 --> 01:04:55,300
如果你多研究过这个 你可能发现

1010
01:04:55,300 --> 01:04:56,100
我觉得在这里

1011
01:04:56,100 --> 01:04:59,910
当你解决一个大小为n的问题

1012
01:04:59,910 --> 01:05:04,100
两个子问题大小为n/4 你怎么做

1013
01:05:06,510 --> 01:05:10,440
如果你从平方入手的话

1014
01:05:10,440 --> 01:05:13,730
这就很自然了

1015
01:05:18,430 --> 01:05:22,200
这个叫H布局

1016
01:05:22,200 --> 01:05:24,490
你可以想一下怎么回事儿

1017
01:05:30,310 --> 01:05:35,750
要是有个点阵图板的话可能画的轻松些

1018
01:05:35,750 --> 01:05:38,050
如果真有的话

1019
01:05:43,890 --> 01:05:45,610
这是一个递归的布局

1020
01:05:45,610 --> 01:05:48,890
我就画两次迭代

1021
01:05:48,890 --> 01:05:50,900
希望你们能想象出一般的情形

1022
01:06:04,080 --> 01:06:06,680
现在画4个H

1023
01:06:06,680 --> 01:06:13,610
因为我想要问题的大小是n/4

1024
01:06:13,610 --> 01:06:17,740
这个有n/4叶节点 这个有n/4叶节点

1025
01:06:17,740 --> 01:06:20,620
这个是根节点 在中间

1026
01:06:20,620 --> 01:06:23,420
这个有n/4叶节点 这个有n/4叶节点

1027
01:06:23,420 --> 01:06:25,360
现在有4个大小是n/4的问题

1028
01:06:25,360 --> 01:06:27,600
我得把它减小到2

1029
01:06:27,600 --> 01:06:30,870
幸运的是 不论是从宽度还是从高度上看

1030
01:06:30,870 --> 01:06:32,860
确实只有两个问题

1031
01:06:32,860 --> 01:06:36,930
这两个 和这两个一起

1032
01:06:36,930 --> 01:06:40,550
它们是平行的 就像是和高度这里一样

1033
01:06:40,550 --> 01:06:44,140
现在一起得到了高度上和宽度上的结果

1034
01:06:44,140 --> 01:06:47,450
如果量一下 它们是相等的

1035
01:06:47,450 --> 01:06:49,340
那么可以叫长度

1036
01:06:49,340 --> 01:06:52,140
现在是L(n)×L(n)

1037
01:06:55,980 --> 01:06:59,160
如果算一下 L(n)是多少

1038
01:06:59,160 --> 01:07:01,240
这里是L(n/4)

1039
01:07:01,240 --> 01:07:03,780
因为这里只有1/4叶节点

1040
01:07:03,780 --> 01:07:04,840
这里还有那里

1041
01:07:04,840 --> 01:07:10,780
then I have a constant, Θ(1), no big deal,

1042
01:07:04,840 --> 01:07:10,780
还有常数项Θ(1) 这个很简单

1043
01:07:10,810 --> 01:07:13,730
现在又得到L(n/4)了

1044
01:07:13,730 --> 01:07:18,610
现在得到了我们想要的递归式子了

1045
01:07:24,570 --> 01:07:30,790
L(n)=2L(n/4)+Θ(1).

1046
01:07:24,570 --> 01:07:30,790
L(n)=2L(n/4)+Θ(1)

1047
01:07:32,630 --> 01:07:38,720
现在得到我们刚才说的结果n的平方根

1048
01:07:38,720 --> 01:07:42,970
现在又得到了主方法的第一种情况

1049
01:07:42,970 --> 01:07:46,780
很帅吧 这是非常紧凑的布局

1050
01:07:46,780 --> 01:07:48,770
查尔斯 是你发明的这种布局么

1051
01:07:48,770 --> 01:07:51,940
不是 不过我记得在你的博士论文里有

1052
01:07:51,940 --> 01:07:54,980
你把它从多个方向上扩展了

1053
01:07:54,980 --> 01:07:58,470
这是个传统的树的网格布局的好方法

1054
01:07:58,470 --> 01:08:01,320
也是分治法思想的另一个应用

1055
01:08:01,320 --> 01:08:04,390
我意思是不仅在算法上尤其有用

1056
01:08:04,390 --> 01:08:06,670
在VLSI布局上也相当有用

1057
01:08:06,670 --> 01:08:10,140
它提供给你更多思考的方式

1058
01:08:10,140 --> 01:08:11,700
如果你知道你想要的运行时间

1059
01:08:11,700 --> 01:08:13,790
就像小测和作业里面经常出现的

1060
01:08:13,790 --> 01:08:16,100
规定了你应该得到的运行时间

1061
01:08:16,100 --> 01:08:18,540
想一想你能得到什么样递归式

1062
01:08:18,540 --> 01:08:19,950
会对你有所启发

1063
01:08:19,950 --> 01:08:23,650
今天就这些 不要忘了周五复习课

1064
01:08:23,650 --> 01:08:26,760
周日作业实验室开放 周一没有课

1065
01:08:26,760 --> 01:08:28,050
下周三再见

