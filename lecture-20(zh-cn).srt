1
00:00:05,000 --> 00:00:09,160
快期末了 我们只剩下四次课了

2
00:00:09,230 --> 00:00:12,110
Demaine教授和我决定了

3
00:00:12,180 --> 00:00:19,050
接下来的课会介绍两个高级课题

4
00:00:19,110 --> 00:00:24,480
那么 我们准备在今天和星期三

5
00:00:24,560 --> 00:00:26,400
讨论并行算法

6
00:00:26,470 --> 00:00:28,850
这种算法会用到多个处理器

7
00:00:28,920 --> 00:00:32,170
并行地解决问题

8
00:00:32,250 --> 00:00:34,180
这个课题最近非常火

9
00:00:34,250 --> 00:00:37,540
因为现在的那些芯片制造商

10
00:00:37,610 --> 00:00:41,990
都在生产所谓的多核处理器

11
00:00:42,070 --> 00:00:47,000
每个芯片都有多于一个处理器

12
00:00:47,070 --> 00:00:50,350
所以 多了解这些知识有好处

13
00:00:50,430 --> 00:00:53,190
我们想讲的第二个课题是

14
00:00:53,270 --> 00:00:54,810
关于缓存的算法

15
00:00:54,890 --> 00:00:58,540
以及如何为有缓存机制的系统设计算法

16
00:00:58,610 --> 00:01:00,110
目前来说 我们在编程时

17
00:01:00,190 --> 00:01:02,060
都只用了单一的一层内存

18
00:01:02,120 --> 00:01:05,270
但对于某些问题

19
00:01:05,340 --> 00:01:07,870
这跟现实的模型不完全一样

20
00:01:07,950 --> 00:01:09,410
现实中你用到的模型

21
00:01:09,480 --> 00:01:11,790
需要考虑多级缓存怎么运作

22
00:01:11,870 --> 00:01:13,660
以及怎么利用好多层缓存

23
00:01:13,730 --> 00:01:19,060
这个领域人们也已经做了很多研究

24
00:01:19,130 --> 00:01:23,150
其实 这两个课题

25
00:01:23,220 --> 00:01:25,990
都在我的研究范围内

26
00:01:26,060 --> 00:01:27,520
我对这些东西很有爱

27
00:01:27,600 --> 00:01:30,410
实际上 大部分都很有趣

28
00:01:30,490 --> 00:01:38,000
那么 我们今天讨论的是并行算法

29
00:01:39,360 --> 00:01:44,310
关于这个课题 实际上

30
00:01:44,390 --> 00:01:48,210
我们有许多种不同的并行算法模型

31
00:01:48,280 --> 00:01:49,600
和并行化模型

32
00:01:49,670 --> 00:01:51,820
这样的原因是

33
00:01:51,890 --> 00:01:56,670
对于串行算法而言

34
00:01:56,750 --> 00:02:00,150
人们一般只有一种基础模型

35
00:02:00,220 --> 00:02:01,300
也就我们用的那种

36
00:02:01,390 --> 00:02:03,300
它有时候被称为随机存取机器模型

37
00:02:03,370 --> 00:02:07,600
我们之前的分析就是基于这个模型

38
00:02:07,660 --> 00:02:09,350
但是在并行的空间里

39
00:02:09,420 --> 00:02:12,410
还有很多其它的模型

40
00:02:12,490 --> 00:02:13,940
而且还没有一个共识

41
00:02:14,010 --> 00:02:16,120
认为哪一个才是最佳模型

42
00:02:16,200 --> 00:02:17,530
因为不同的模型

43
00:02:17,600 --> 00:02:20,520
它们有不同的构造

44
00:02:20,590 --> 00:02:23,740
而且人们甚至还没确定

45
00:02:23,810 --> 00:02:27,390
并行模型应该如何组织

46
00:02:27,470 --> 00:02:31,820
那么 我们准备研究一种并行模型

47
00:02:31,880 --> 00:02:40,280
它是属于动态多线程的一种

48
00:02:40,350 --> 00:02:48,230
适合用于多核机器中

49
00:02:48,290 --> 00:02:52,930
它是为内存共享的编程而设计的

50
00:02:53,010 --> 00:02:54,840
并不适用于所谓的

51
00:02:54,920 --> 00:02:57,790
分布式内存编程

52
00:02:57,870 --> 00:03:01,210
因为每个处理器都有访问内存的权限

53
00:03:01,280 --> 00:03:04,420
对于其他的情况 你需要学习更多相关的模型

54
00:03:04,480 --> 00:03:07,320
所以 让我们从一个简单的例子开始

55
00:03:07,390 --> 00:03:10,260
看看怎么写并行程序

56
00:03:10,340 --> 00:03:13,770
我准备给你一个程序

57
00:03:13,850 --> 00:03:18,480
这是用来计算第n个斐波拉契数的模型

58
00:03:18,550 --> 00:03:21,240
其实我接下来要讲的

59
00:03:21,320 --> 00:03:22,420
是一个很差的算法

60
00:03:22,500 --> 00:03:24,600
因为它的复杂度是指数级的

61
00:03:24,670 --> 00:03:30,670
然而我们在前两周就学会了

62
00:03:30,740 --> 00:03:34,850
计算Fibonacci数要花多少时间？

63
00:03:34,930 --> 00:03:39,740
log n的时间 节省了两个指数

64
00:03:39,820 --> 00:03:45,090
这才是你应该得到的结果 节省了两个指数

65
00:03:45,160 --> 00:03:49,490
好的 下面是伪代码

66
00:04:35,550 --> 00:04:42,780
好的 这个就是我们要写的伪代码

67
00:04:42,850 --> 00:04:44,930
我来解释一下

68
00:04:45,000 --> 00:04:47,430
有几个关键词我们从没见过

69
00:04:47,490 --> 00:04:50,890
特别是衍生(spawn)和同步(sync)

70
00:04:50,970 --> 00:04:56,800
好的 这个衍生其实就是指

71
00:04:56,870 --> 00:04:58,360
你正在调用一个子程序

72
00:04:58,450 --> 00:05:00,390
你把衍生作为一个关键字加在子程序前

73
00:05:00,490 --> 00:05:18,630
这样它就能跟父程序同时执行

74
00:05:21,530 --> 00:05:26,570
这里 我们说 x=spawn fib(n-1)

75
00:05:26,650 --> 00:05:28,930
我们立刻转到下一语句

76
00:05:29,020 --> 00:05:35,530
现在当我们在计算fib(n-1)的时候

77
00:05:35,590 --> 00:05:38,700
我们同时也在执行...

78
00:05:38,760 --> 00:05:41,740
下面这条语句 它本身也会衍生子程序

79
00:05:41,810 --> 00:05:46,060
好的 我们继续 然后我们碰到这个同步语句

80
00:05:46,140 --> 00:05:47,730
同步就是说

81
00:05:47,810 --> 00:05:58,190
等待至所有子程序完成

82
00:06:03,530 --> 00:06:06,450
所以 一旦你运行到这里

83
00:06:06,530 --> 00:06:10,340
你需要等到所有子程序完成后

84
00:06:10,400 --> 00:06:13,960
才能继续执行这个 x+y

85
00:06:14,030 --> 00:06:15,030
否则的话 你就要

86
00:06:15,090 --> 00:06:18,330
用还没算出来的x和y

87
00:06:18,400 --> 00:06:20,590
来执行x+y这个运算

88
00:06:20,660 --> 00:06:29,240
好的 这就是它的基础结构

89
00:06:29,320 --> 00:06:32,240
这是说... 注意了 我们还未曾说过

90
00:06:32,310 --> 00:06:35,250
我们要用到多少处理器神马的

91
00:06:35,330 --> 00:06:38,180
好吧 这实际上

92
00:06:38,250 --> 00:06:40,300
只是描述了并行的逻辑

93
00:06:49,430 --> 00:06:53,300
而不是我们实际的并行化执行

94
00:06:53,380 --> 00:07:04,420
所以 我们要用到一个调度器来决定

95
00:07:07,680 --> 00:07:25,720
如何把这个动态的 不断延伸的程序

96
00:07:28,820 --> 00:07:35,930
映射到可用的处理器上

97
00:07:35,990 --> 00:07:37,450
好的 那么今天实际上

98
00:07:37,560 --> 00:07:41,760
我们会集中讲关于调度的内容

99
00:07:41,830 --> 00:07:45,880
然后下一次 我们就会讨论

100
00:07:45,950 --> 00:07:48,060
一些特定的应用算法

101
00:07:48,120 --> 00:07:51,660
以及如何去分析它们

102
00:07:51,730 --> 00:08:00,560
那时 你们就能看到真真的多线程计算

103
00:08:08,890 --> 00:08:12,790
如果你看过并行指令流就知道

104
00:08:19,670 --> 00:08:25,660
它其实是一个有向非循环图

105
00:08:25,740 --> 00:08:28,970
那么 我来讲讲它是怎么工作的

106
00:08:29,030 --> 00:08:31,630
当我们有一个指令流

107
00:08:31,700 --> 00:08:33,910
我观察正在运行的每一个指令

108
00:08:33,980 --> 00:08:36,460
即使是个循环 我也不把它当做循环来看

109
00:08:36,540 --> 00:08:37,420
我只观察

110
00:08:37,500 --> 00:08:40,780
实际执行的指令序列

111
00:08:40,860 --> 00:08:42,960
我把它当成一个链来看

112
00:08:43,040 --> 00:08:44,710
在我执行一个指令之前

113
00:08:44,770 --> 00:08:47,080
我必须先执行完它前面的指令

114
00:08:47,160 --> 00:08:48,330
在我执行这个之前

115
00:08:48,410 --> 00:08:49,840
我已经执行完它前面的一条指令

116
00:08:49,900 --> 00:08:51,310
至少 大概是这样的

117
00:08:51,380 --> 00:08:53,170
如果你研究处理器

118
00:08:53,230 --> 00:08:55,150
你会知道有许多的小技巧

119
00:08:55,220 --> 00:08:59,080
来了解指令级别的并行机制

120
00:08:59,150 --> 00:09:00,120
以及你要如何

121
00:09:00,190 --> 00:09:03,420
让原本串行的指令流

122
00:09:03,490 --> 00:09:05,350
实际执行时变为并行

123
00:09:05,430 --> 00:09:07,050
但是我们要集中讨论的

124
00:09:07,090 --> 00:09:09,500
是逻辑上的并行机制

125
00:09:09,560 --> 00:09:11,480
以及在这个背景下 我们能做的事情

126
00:09:11,550 --> 00:09:20,670
那么 在这个DAG里 顶点代表的是线程

127
00:09:20,740 --> 00:09:33,750
所谓线程也就是最长的指令序列

128
00:09:33,810 --> 00:09:48,500
该序列中不包含任何并行控制

129
00:09:48,560 --> 00:09:50,120
这个并行控制

130
00:09:50,190 --> 00:09:53,800
我指的就是衍生和同步

131
00:09:53,860 --> 00:09:59,360
还有从一个衍生的子程序返回

132
00:09:59,430 --> 00:10:02,600
所以 我们就把线程标记为顶点

133
00:10:02,660 --> 00:10:05,980
那么 我们来标记这里的顶点

134
00:10:06,060 --> 00:10:09,790
这里有什么线程

135
00:10:09,870 --> 00:10:14,030
所以 当我们进入这个函数后

136
00:10:14,100 --> 00:10:18,000
我们基本上就执行这里

137
00:10:18,070 --> 00:10:20,950
基本上 这里 我们称这个线程A

138
00:10:21,020 --> 00:10:22,750
是以序列顺序执行的

139
00:10:22,810 --> 00:10:25,620
直到遇到返回为止

140
00:10:25,690 --> 00:10:30,000
或者是执行衍生指令fib(n-1)

141
00:10:30,070 --> 00:10:31,760
所以实际上 线程A包含了

142
00:10:31,860 --> 00:10:36,150
到求n-1这一步为止的运算

143
00:10:36,220 --> 00:10:38,160
也就是恰好在做子任务跳转前的一步

144
00:10:38,230 --> 00:10:40,130
这就是线程A

145
00:10:40,190 --> 00:10:43,020
线程B执行的是

146
00:10:43,090 --> 00:10:53,420
执行从fib到...不好意思

147
00:10:53,490 --> 00:10:56,870
那B就会从(这里)开始

148
00:10:57,520 --> 00:10:58,670
上面其实是做到衍生这一步

149
00:10:58,750 --> 00:11:01,050
我们已经做完了衍生的操作 A应该是到这儿

150
00:11:01,110 --> 00:11:05,310
所以 B是一直做到衍生y

151
00:11:05,390 --> 00:11:10,460
把fib(n-2)衍生出来 算出y的值

152
00:11:10,530 --> 00:11:13,460
现在 这里实际上是一个空线程

153
00:11:13,530 --> 00:11:17,060
我现在先忽略这个 实际上...

154
00:11:17,170 --> 00:11:20,320
接着 我们有...在做完同步后

155
00:11:20,400 --> 00:11:22,040
我们就取得x+y的返回值

156
00:11:22,120 --> 00:11:24,040
所以基本上 我们只是观察

157
00:11:24,110 --> 00:11:27,800
最长的串行指令序列

158
00:11:27,870 --> 00:11:31,110
而每一次执行并行指令时

159
00:11:31,180 --> 00:11:34,190
比如衍生 同步或从线程中返回

160
00:11:34,260 --> 00:11:36,760
都会结束当前的线程

161
00:11:36,830 --> 00:11:41,940
那么 我们可以把这些看是一些小线程组合

162
00:11:42,020 --> 00:11:44,520
对于很熟悉线程的人来说

163
00:11:44,620 --> 00:11:54,490
Java里面的线程或者POSIX线程 又叫P线程

164
00:11:54,490 --> 00:11:57,330
那些都是重量级的静态线程

165
00:11:57,390 --> 00:12:00,480
这个就要轻量很多

166
00:12:00,550 --> 00:12:03,540
这个模型用的是轻量级的

167
00:12:03,610 --> 00:12:09,950
好的 顶点代表的是线程

168
00:12:10,030 --> 00:12:13,880
现在 我来画一下这是怎么工作的

169
00:12:13,940 --> 00:12:16,110
看看这些边是从哪里来的

170
00:12:16,190 --> 00:12:20,050
那么 假设我们在计算fib(4)

171
00:12:22,540 --> 00:12:27,940
那么 我画一个水平的椭圆

172
00:12:28,020 --> 00:12:31,520
这对应的是程序的执行

173
00:12:31,600 --> 00:12:32,970
那么在这个程序里

174
00:12:33,050 --> 00:12:36,550
这里有三个线程

175
00:12:36,620 --> 00:12:37,950
我们从A开始

176
00:12:38,010 --> 00:12:46,810
所以 这就是我们初始的线程

177
00:12:46,890 --> 00:12:50,890
那么 当它要执行一个衍生

178
00:12:50,960 --> 00:12:54,090
好的 当它要衍生时

179
00:12:54,170 --> 00:12:55,520
我们就创建一个新的程序

180
00:12:55,590 --> 00:13:00,780
接着它会在递归地在新程序里

181
00:13:00,830 --> 00:13:03,480
执行一个新的A线程

182
00:13:03,540 --> 00:13:06,890
但是同一时间 我们还能够

183
00:13:06,960 --> 00:13:10,620
继续在父线程里执行B

184
00:13:10,700 --> 00:13:14,480
所以这个衍生 就实现了并行机制

185
00:13:14,550 --> 00:13:18,020
好的 这里有一条边

186
00:13:18,090 --> 00:13:20,920
这条边我们称它为衍生边

187
00:13:20,990 --> 00:13:25,460
然后 这一条是延续边

188
00:13:25,540 --> 00:13:29,670
因为这条边

189
00:13:29,750 --> 00:13:33,170
承接了一个程序内的执行

190
00:13:33,240 --> 00:13:41,080
那现在这里 我们有两样东西

191
00:13:41,150 --> 00:13:42,690
它们能够同时执行的

192
00:13:42,760 --> 00:13:43,770
一旦我执行了A

193
00:13:43,840 --> 00:13:46,330
我就有两样东西可以执行

194
00:13:46,390 --> 00:13:48,450
那么 这一个

195
00:13:48,530 --> 00:13:54,040
举个例子 可能会衍生出另外一个线程

196
00:13:54,110 --> 00:13:56,030
噢 这个是fib(3) 对吧?

197
00:13:56,090 --> 00:13:59,890
那这里是fib(2)

198
00:13:59,950 --> 00:14:04,360
好的 它这里衍生出另外一个东西

199
00:14:04,440 --> 00:14:08,900
同时 它可以继续执行这里的B

200
00:14:08,980 --> 00:14:12,420
好的 用一个延续边连接

201
00:14:12,490 --> 00:14:15,260
而实际上 B也能在这个点衍生

202
00:14:21,290 --> 00:14:25,770
这个也是fib(2)

203
00:14:30,830 --> 00:14:42,850
那现在 在这个点上 我们还不能执行C

204
00:14:42,940 --> 00:14:46,390
即使我将所有线程都衍生完了

205
00:14:46,470 --> 00:14:50,030
这是因为 还没轮到C

206
00:14:50,100 --> 00:14:53,750
未执行同步指令之前 还不能执行C

207
00:14:53,830 --> 00:14:59,150
要等到A和B都被执行完后 才开始同步

208
00:14:59,220 --> 00:15:03,530
所以 C只能坐等A、B完事

209
00:15:03,600 --> 00:15:07,070
连调度器也带不起它

210
00:15:07,140 --> 00:15:12,130
就算要强行搞起 这里也是什么都做不了 是吧?

211
00:15:12,200 --> 00:15:15,310
那么 我们继续

212
00:15:15,390 --> 00:15:23,930
我们来看 这里我们调用fib(1)

213
00:15:24,000 --> 00:15:27,270
fib(1)只会执行

214
00:15:27,350 --> 00:15:29,920
一个A线程

215
00:15:30,000 --> 00:15:33,310
当然 它这里已经没法继续

216
00:15:33,380 --> 00:15:35,630
因为只有一个A语句

217
00:15:35,700 --> 00:15:37,960
当我执行fib(1) 我们观察这代码

218
00:15:38,030 --> 00:15:43,020
它也不会再执行B或者C 以此类推

219
00:15:43,100 --> 00:15:56,000
这里也是执行fib(1)

220
00:15:56,070 --> 00:16:00,850
而这个 它也会衍生出一个fib(1)

221
00:16:07,950 --> 00:16:18,410
这线程可能也调用一个fib(1)

222
00:16:18,490 --> 00:16:23,440
然后这里也调用另一个

223
00:16:23,520 --> 00:16:27,020
这个将会变成fib(0) 对吧

224
00:16:27,100 --> 00:16:33,730
我又把♂指错地方了

225
00:16:33,810 --> 00:16:38,470
现在 一旦这些线程返回 好的

226
00:16:38,540 --> 00:16:42,490
比如它们返回到这里 我就可以执行C了

227
00:16:42,560 --> 00:16:45,520
但在这些都完成之前

228
00:16:45,600 --> 00:16:48,820
我是不能执行它的 这些都要完成才行

229
00:16:48,900 --> 00:16:50,660
那么 你们会发现

230
00:16:50,760 --> 00:16:54,320
我们在C之前会遇到一个同步点

231
00:16:54,390 --> 00:16:58,860
然后 同样地

232
00:16:58,940 --> 00:17:00,960
现在我们已经执行了这个和这个

233
00:17:01,030 --> 00:17:02,940
我们现在可以执行这里的C了

234
00:17:03,020 --> 00:17:10,600
然后 这些都返回到这里了

235
00:17:10,670 --> 00:17:15,090
像是这个地方 这东西现在能执行C

236
00:17:15,160 --> 00:17:19,700
一旦这两个都结束

237
00:17:19,760 --> 00:17:22,810
我们就可以执行这里的C

238
00:17:22,870 --> 00:17:27,830
然后 我们就完成了

239
00:17:27,890 --> 00:17:33,570
这是我们最后的线程

240
00:17:33,640 --> 00:17:38,130
那么 我这里应该标记下

241
00:17:38,200 --> 00:17:39,620
当我划出一条这样的边

242
00:17:39,690 --> 00:17:43,450
它就是一条返回边

243
00:17:43,530 --> 00:17:56,900
那么 边分为三类 有衍生 返回

244
00:17:56,980 --> 00:18:07,610
以及延续 好的 通过这个方式来描述

245
00:18:07,680 --> 00:18:10,800
我得到了一个展开的有向非循环图

246
00:18:10,870 --> 00:18:14,030
那么 相对于只有串行的执行序列

247
00:18:14,100 --> 00:18:18,200
我还得到了一些别的东西

248
00:18:18,270 --> 00:18:19,600
虽然它还保留了串行特性

249
00:18:19,670 --> 00:18:22,650
例如 一项工作必须先完成才能做下一项

250
00:18:22,720 --> 00:18:26,210
但同时也有些工作能够同时完成

251
00:18:26,320 --> 00:18:30,670
那么我们怎么做? 有问题?

252
00:18:30,740 --> 00:18:36,080
[学生]:......

253
00:18:36,140 --> 00:18:39,080
是否每个衍生的线程都被同步操作覆盖到？

254
00:18:39,160 --> 00:18:41,610
是的 就是这样

255
00:18:41,670 --> 00:18:44,250
这里实际上还有一些空线程在执行

256
00:18:44,330 --> 00:18:45,720
我没有特地写出来

257
00:18:45,790 --> 00:18:49,640
不过没错 但这基本上就不算并行了

258
00:18:49,710 --> 00:18:51,370
因为你衍生了它

259
00:18:51,430 --> 00:18:53,320
但在父线程里却什么也没做

260
00:18:53,380 --> 00:18:55,820
那就基本上

261
00:18:55,900 --> 00:18:59,170
跟串行差不多

262
00:18:59,250 --> 00:19:03,190
好的 你们可以看到 我们这里得到的

263
00:19:03,270 --> 00:19:06,850
其实就是一个嵌入树中的有向非循环图

264
00:19:06,910 --> 00:19:10,810
你有这么一棵树

265
00:19:10,870 --> 00:19:12,400
它代表了程序执行的结构

266
00:19:12,470 --> 00:19:13,980
而这树里面有一个DAG

267
00:19:14,040 --> 00:19:16,320
实际上 这个DAG相当复杂

268
00:19:16,400 --> 00:19:19,470
那么 我现在想做的就是

269
00:19:19,540 --> 00:19:21,560
既然知道底层有个DAG的存在

270
00:19:21,620 --> 00:19:24,260
我就想转而研究

271
00:19:24,330 --> 00:19:29,100
这一个DAG的各方面的执行性能

272
00:19:29,190 --> 00:19:32,050
好 来看一下性能评估

273
00:19:43,230 --> 00:19:47,340
那么 这里我们要用到的符号是

274
00:19:47,410 --> 00:19:50,700
我们设T_P为任意程序运算——

275
00:19:50,770 --> 00:20:00,860
——在P个处理器上的运行时间

276
00:20:03,540 --> 00:20:06,460
那么 T_P就等于

277
00:20:06,540 --> 00:20:09,000
在P个处理器上执行一个程序所用的时间

278
00:20:09,060 --> 00:20:10,590
一般来说 T_P并不是

279
00:20:10,700 --> 00:20:13,650
一个固定的常数

280
00:20:13,750 --> 00:20:17,980
因为我可以有不同的调度规则

281
00:20:18,040 --> 00:20:22,690
使得T_P会取得不同的数值 对吧?

282
00:20:22,760 --> 00:20:24,350
但是当我们讨论运行时间时

283
00:20:24,420 --> 00:20:25,920
我们还是会使用这个符号

284
00:20:26,000 --> 00:20:29,350
之后的讲解过程中 我会留个神

285
00:20:29,430 --> 00:20:31,640
确保上下文没有产生歧义

286
00:20:31,720 --> 00:20:33,650
而其中有几种T_P

287
00:20:33,730 --> 00:20:35,710
已经被完整地定义过了

288
00:20:35,790 --> 00:20:38,890
一个是...最基本的一个

289
00:20:38,960 --> 00:20:43,040
一个是T_1 那么 T_1就等于一个处理器上的运行时间

290
00:20:43,100 --> 00:20:46,190
好的 如果程序是由...

291
00:20:46,250 --> 00:20:48,890
一个处理器来执行 可想而知

292
00:20:48,960 --> 00:20:51,670
这就像是 我把所有的衍生和同步都去掉

293
00:20:51,750 --> 00:20:54,480
通通去掉 仅仅执行它

294
00:20:54,550 --> 00:20:57,570
这就会得到它的一个运行时间

295
00:20:57,640 --> 00:21:02,140
我们把一个处理器上的运行时间称为功

296
00:21:02,220 --> 00:21:06,770
也就是串行运行时间

297
00:21:09,580 --> 00:21:12,400
好的 当我们谈到一次计算的功时

298
00:21:12,470 --> 00:21:14,670
我们实际上就是指它的串行运行时间

299
00:21:14,740 --> 00:21:19,490
好的 另外一个有趣的评估值

300
00:21:19,550 --> 00:21:22,300
我们把它设为T_∞

301
00:21:22,380 --> 00:21:27,950
好的 这是关键路径长度

302
00:21:33,800 --> 00:21:43,850
也就是指DAG中的最长路径

303
00:21:43,930 --> 00:21:45,290
那么 举个例子

304
00:21:45,370 --> 00:21:52,220
我们看看这个例子的fib(4)

305
00:21:52,290 --> 00:21:55,380
它的T_1等于

306
00:21:55,460 --> 00:21:58,180
我们先假设有单位时间的线程

307
00:21:58,260 --> 00:22:00,290
我知道它们不是单位时间的 但先假设如此

308
00:22:00,370 --> 00:22:01,870
为了帮助理解

309
00:22:01,940 --> 00:22:07,350
每个线程消耗一个单位时间来运行

310
00:22:07,420 --> 00:22:12,800
这样的话计算出的功会是多少?

311
00:22:12,880 --> 00:22:18,640
17 对了

312
00:22:18,700 --> 00:22:22,740
因为我们做的加起来 3 6

313
00:22:22,810 --> 00:22:28,120
然后9 12 13 14 15 16 17

314
00:22:28,200 --> 00:22:29,880
所以这个例子里的功等于17

315
00:22:29,950 --> 00:22:31,270
如果线程都是单位时间的

316
00:22:31,340 --> 00:22:33,700
但一般来说 要求运行时间

317
00:22:33,710 --> 00:22:35,610
应该是求一共运行了多少条指令

318
00:22:35,620 --> 00:22:40,750
而T_∞则是最长路径的情况

319
00:22:40,820 --> 00:22:42,330
那么 也就是最长指令序列

320
00:22:42,400 --> 00:22:44,580
就算你有无限的处理器可用

321
00:22:44,660 --> 00:22:48,220
你仍然没办法一下子把所有事情完成

322
00:22:48,280 --> 00:22:50,600
因为有些事情需要一个接一个地完成

323
00:22:50,660 --> 00:22:53,500
但如果你有无数个处理器

324
00:22:53,580 --> 00:22:54,800
要多少有多少

325
00:22:54,870 --> 00:22:57,490
那么你执行这个的最快速度会是多少?

326
00:23:01,520 --> 00:23:06,230
开动脑筋 7?

327
00:23:06,290 --> 00:23:09,030
那么 你的7怎么算的?

328
00:23:09,100 --> 00:23:11,680
[学生]:......

329
00:23:11,740 --> 00:23:21,600
就是 1 2 3 4 5 6 7

330
00:23:21,670 --> 00:23:25,800
8 对 8才是最长路径长度

331
00:23:25,880 --> 00:23:32,810
那么 功和关键长度 我们将看到

332
00:23:32,880 --> 00:23:36,400
它们都是所有计算中的关键属性

333
00:23:36,480 --> 00:23:42,130
大致上说 噢这里要注明

334
00:23:42,200 --> 00:23:46,280
如果它们是单位时间线程

335
00:23:51,460 --> 00:23:56,030
那么 我们可以使用这两种方法

336
00:23:56,100 --> 00:24:00,650
来测量出T_P的下界

337
00:24:00,680 --> 00:24:06,700
当P处在1和无穷之间时

338
00:24:06,790 --> 00:24:08,200
对吧?

339
00:24:18,590 --> 00:24:22,090
好的 我们第一个推导出来的下界是

340
00:24:22,170 --> 00:24:26,750
T_P最小等于T_1/P

341
00:24:26,820 --> 00:24:38,110
为什么这个是下界?

342
00:24:38,160 --> 00:24:45,430
[学生]:......

343
00:24:45,490 --> 00:24:47,500
但如果我有P个处理器

344
00:24:47,550 --> 00:24:54,260
[学生]:......

345
00:24:54,340 --> 00:24:56,460
好吧 为什么我会有这个下界?

346
00:24:56,530 --> 00:25:02,310
[学生]:......

347
00:25:02,390 --> 00:25:04,360
好的 你的想法是对的

348
00:25:04,440 --> 00:25:08,240
但关于这个我们要说得更清楚一点

349
00:25:08,310 --> 00:25:11,420
没错 你希望用到所有的处理器

350
00:25:11,500 --> 00:25:13,720
如果你能用上所有的处理器

351
00:25:13,790 --> 00:25:16,520
为什么即使用上所有处理器

352
00:25:16,600 --> 00:25:18,920
都没法让T_P比这个更小?

353
00:25:18,990 --> 00:25:25,620
为什么它至少等于T_1/P

354
00:25:25,690 --> 00:25:30,450
我想要更加准确的说法

355
00:25:30,530 --> 00:25:32,210
你已经知道怎么做了

356
00:25:32,280 --> 00:25:34,500
但我需要更准确一点

357
00:25:34,560 --> 00:25:35,840
来说服班上的其他同学

358
00:25:35,920 --> 00:25:40,230
这个就是下界

359
00:25:40,300 --> 00:25:41,290
嗯?

360
00:25:41,360 --> 00:25:48,750
[学生]:......

361
00:25:48,820 --> 00:25:51,260
是的 你确实可以这样看

362
00:25:51,330 --> 00:25:54,610
如果你把所有的计算串行化

363
00:25:54,680 --> 00:25:57,500
无论你每一步都执行了什么语句

364
00:25:57,590 --> 00:26:00,230
你都要执行P次 如果把程序串行化的话

365
00:26:00,310 --> 00:26:02,660
你就相当于要用P步

366
00:26:02,720 --> 00:26:05,200
才能完成P核的一步执行

367
00:26:05,260 --> 00:26:08,690
P核也就是P个处理器

368
00:26:08,770 --> 00:26:11,170
所以说 对吧?

369
00:26:11,260 --> 00:26:13,330
好的 稍微详细了一点

370
00:26:13,400 --> 00:26:14,350
那位帅哥?

371
00:26:14,460 --> 00:26:27,130
[学生]:......

372
00:26:27,200 --> 00:26:31,290
很好 让我把这个讲清楚吧

373
00:26:31,350 --> 00:26:35,060
如果有P个处理器 我们怎么利用它们?

374
00:26:35,140 --> 00:26:44,720
P个处理器每一步最多能做P个功

375
00:26:44,800 --> 00:26:50,140
对吧？ 每一步它们最多只能做P的功

376
00:26:50,290 --> 00:26:53,730
再多就做不了了

377
00:26:53,790 --> 00:26:57,940
所以 如果它们每一步做功都能达到最大值P

378
00:26:58,000 --> 00:27:01,670
而且实际运行的步数

379
00:27:01,730 --> 00:27:03,050
要小于T_1/P的

380
00:27:03,110 --> 00:27:11,540
它们才能够在P步中做大于T_1的功

381
00:27:11,620 --> 00:27:13,440
但这里只需要做T_1的功

382
00:27:13,520 --> 00:27:17,440
好吧 我这个解释

383
00:27:17,520 --> 00:27:20,530
就跟你们给我的解释一样水

384
00:27:20,600 --> 00:27:24,230
好的 P个处理器可以

385
00:27:24,300 --> 00:27:27,960
在一步中做最多P的功 对吧？

386
00:27:28,040 --> 00:27:30,990
如果这里需要做T_1的功

387
00:27:31,070 --> 00:27:32,900
执行的步数

388
00:27:32,990 --> 00:27:37,270
至少等于T_1/P 是吧？

389
00:27:37,340 --> 00:27:41,030
我们继续 好的 其实不难

390
00:27:41,110 --> 00:27:42,590
它就是说 我有一定数目的功

391
00:27:42,660 --> 00:27:43,800
我有T_1的功要做

392
00:27:43,910 --> 00:27:46,590
如果我每一步最多能做P的功

393
00:27:46,660 --> 00:27:49,470
要做多少步  除一下就知道了

394
00:27:49,580 --> 00:27:52,730
所以T_P至少就是那么多

395
00:27:52,800 --> 00:27:54,800
成功说懵了

396
00:27:54,870 --> 00:27:58,050
另外一个下界T_P

397
00:27:58,130 --> 00:28:00,270
它大于等于T_∞

398
00:28:00,350 --> 00:28:10,350
有人来解释下为什么这个成立？

399
00:28:10,420 --> 00:28:14,360
[学生]:......

400
00:28:14,390 --> 00:28:16,220
是的  如果你有无数个处理器

401
00:28:16,290 --> 00:28:19,280
你肯定也有P个处理器

402
00:28:19,360 --> 00:28:23,400
如果用P个处理器 要一定的时间来处理

403
00:28:23,480 --> 00:28:24,880
你肯定也能在那段时间里

404
00:28:24,960 --> 00:28:26,390
用无限的处理器处理完

405
00:28:26,470 --> 00:28:28,170
好的 这就是要介绍的模型

406
00:28:28,250 --> 00:28:30,200
这个模型还有很多东西没有模拟

407
00:28:30,220 --> 00:28:33,550
比如说传输费用和接口

408
00:28:33,630 --> 00:28:35,730
以及其它别的东西 它虽然是一个简单的模型

409
00:28:35,740 --> 00:28:38,600
但实际运用起来也很好用

410
00:28:41,420 --> 00:28:43,780
你是不可能

411
00:28:43,850 --> 00:28:47,040
用P个处理器做功

412
00:28:47,110 --> 00:28:50,790
做得比无限个处理器还多

413
00:29:03,680 --> 00:29:13,900
好的 这些下界能有助我们理解

414
00:29:13,960 --> 00:29:18,900
因为当我们要优化程序速度时

415
00:29:18,980 --> 00:29:22,820
最好是弄清楚我们可以获得什么成果

416
00:29:22,900 --> 00:29:26,780
以免你45度仰天泪流满面

417
00:29:26,850 --> 00:29:29,130
问道：就只有这点速度吗？！

418
00:29:29,190 --> 00:29:33,250
也许就是其中一个下界在作怪

419
00:29:33,330 --> 00:29:37,570
好的 我们想知道怎样能运行得更快

420
00:29:37,650 --> 00:29:42,780
你使用多处理器的主要原因

421
00:29:42,860 --> 00:29:44,120
就是希望你比单处理器

422
00:29:44,200 --> 00:29:45,920
运行得更快

423
00:29:46,000 --> 00:29:51,250
那么 我们定义T_1/T_P

424
00:29:51,330 --> 00:30:00,290
为P个处理器上的加速比

425
00:30:00,370 --> 00:30:05,950
那我们问 究竟P个处理器

426
00:30:06,010 --> 00:30:08,400
比单处理器要快多少？

427
00:30:08,470 --> 00:30:19,040
好的 这就是加速比 如果T_1/T_P属于P阶

428
00:30:19,110 --> 00:30:23,850
我们就称它为线性加速

429
00:30:23,920 --> 00:30:30,060
好的 为什么这么说？

430
00:30:30,130 --> 00:30:36,370
因为这表示

431
00:30:36,440 --> 00:30:39,490
如果我在一个任务上用了P个处理器

432
00:30:39,550 --> 00:30:47,010
我得到的速度提升与P成正比

433
00:30:47,090 --> 00:30:51,290
好的 当我用P个处理器处理任务时

434
00:30:51,360 --> 00:30:54,270
我就有T_P  如果它是P阶的

435
00:30:54,340 --> 00:30:55,540
这说明 某种程度上

436
00:30:55,610 --> 00:30:57,250
每个处理器都贡献了

437
00:30:57,330 --> 00:31:02,220
它最大性能内的一定量的支持

438
00:31:02,280 --> 00:31:04,570
如果这个 实际上等于P的话

439
00:31:04,630 --> 00:31:06,630
我们可以称之为完美线性加速

440
00:31:06,710 --> 00:31:13,070
好的 但是这里 我们理论上

441
00:31:13,150 --> 00:31:14,520
假设有

442
00:31:14,600 --> 00:31:18,700
再大一点的常量

443
00:31:18,770 --> 00:31:27,380
如果说T_1/T_P大于P

444
00:31:27,450 --> 00:31:37,260
我们称之为超级线性加速

445
00:31:38,510 --> 00:31:42,140
好的 有人能告诉我

446
00:31:42,200 --> 00:31:45,820
怎么才能得到超级线性加速吗？

447
00:31:54,030 --> 00:31:58,030
什么时候我能得到超级线性加速？

448
00:31:58,100 --> 00:32:00,470
永远不可能 有理 为什么？

449
00:32:00,520 --> 00:32:03,500
[学生]:...

450
00:32:03,570 --> 00:32:06,140
嗯 如果我们认同这些下界

451
00:32:06,220 --> 00:32:07,560
那里的第一个下界

452
00:32:07,620 --> 00:32:11,520
T_P大于等于T_1/P

453
00:32:11,600 --> 00:32:14,740
如果我取T_1/T_P的话

454
00:32:14,810 --> 00:32:17,020
它是小于等于P的

455
00:32:17,090 --> 00:32:19,590
所以 它永远不可能

456
00:32:19,660 --> 00:32:22,460
好吧 对这个模型来说不可能

457
00:32:26,490 --> 00:32:29,510
但还有其他的一些模型

458
00:32:29,590 --> 00:32:31,660
有可能实现超级线性加速

459
00:32:31,730 --> 00:32:34,730
因为利用了类似缓存的机制

460
00:32:34,790 --> 00:32:36,480
但在这个简单的模型里

461
00:32:36,550 --> 00:32:39,400
我们无法得到超级线性加速

462
00:32:39,480 --> 00:32:45,080
阿迪王都不可能

463
00:32:45,150 --> 00:32:48,660
那可能的最大加速是多少？

464
00:32:56,630 --> 00:33:00,980
已知功的大小

465
00:33:01,060 --> 00:33:08,300
和关键路径的长度

466
00:33:08,380 --> 00:33:10,030
在任意数量的处理器上能取得的

467
00:33:10,120 --> 00:33:17,820
最大的加速会是多少？

468
00:33:17,890 --> 00:33:21,360
最大值可能是多少？

469
00:33:27,210 --> 00:33:30,940
不是 我是说 不管有多少处理器也好

470
00:33:31,020 --> 00:33:35,180
我能得到的最大加速是多少？

471
00:33:38,040 --> 00:33:46,920
T_1/T_∞ 因为这个是...

472
00:33:46,980 --> 00:33:50,960
T_1/T_∞是我能得到的最大值

473
00:33:51,030 --> 00:33:54,270
好的 如果我拿无数个处理器来处理问题

474
00:33:54,330 --> 00:33:56,380
那我就能得到最大的加速

475
00:33:56,460 --> 00:33:59,100
好的 我们称这个为并行化

476
00:34:02,770 --> 00:34:05,390
好的 这就是并行度的定义

477
00:34:05,460 --> 00:34:09,190
一个算法的并行度 本质上就是

478
00:34:09,270 --> 00:34:15,120
功除以关键路径长度

479
00:34:15,210 --> 00:34:17,460
从另一种角度上看

480
00:34:17,540 --> 00:34:27,360
就是在关键路径上——

481
00:34:27,430 --> 00:34:37,460
可以并行地完成的——

482
00:34:40,690 --> 00:34:49,580
平均分量的功

483
00:34:49,650 --> 00:34:56,670
我们定义它为P帽

484
00:34:56,740 --> 00:34:59,940
所以 别搞乱了

485
00:35:00,010 --> 00:35:04,330
其实P帽跟P没有什么关系

486
00:35:04,410 --> 00:35:05,890
好的 这里的P是指

487
00:35:05,910 --> 00:35:07,820
运作中的处理器的数目

488
00:35:07,890 --> 00:35:10,260
P帽则是要看

489
00:35:10,340 --> 00:35:12,110
你在执行的计算量

490
00:35:12,180 --> 00:35:15,200
而不是你的处理器

491
00:35:15,280 --> 00:35:20,200
好的 它就是关键路径上

492
00:35:20,270 --> 00:35:21,580
能够并行执行的

493
00:35:21,640 --> 00:35:24,080
功的平均分量

494
00:35:24,150 --> 00:35:28,980
好的 还有问题吗？

495
00:35:29,040 --> 00:35:31,590
目前 我们只是下了定义

496
00:35:31,650 --> 00:35:35,540
接下来是深入

497
00:35:35,620 --> 00:35:40,260
它有助于我们理解什么是并行度

498
00:35:40,330 --> 00:35:44,940
因为并行度就是

499
00:35:45,010 --> 00:35:47,580
你是不可能...

500
00:35:47,640 --> 00:35:50,740
获得比并行度更快的加速

501
00:35:50,810 --> 00:35:54,570
好的 所以如果给定一个计算

502
00:35:54,640 --> 00:35:56,980
你可能会说 噢 怎么没有变得更快？

503
00:35:57,050 --> 00:35:58,880
你投入了很多的处理器

504
00:35:58,950 --> 00:36:00,540
但为什么它不能变得更快？

505
00:36:00,620 --> 00:36:03,960
答案可能是 并行化到顶了

506
00:36:06,030 --> 00:36:12,590
抱歉导演 我忘词了

507
00:36:12,860 --> 00:36:19,190
想起来了 我们这里可以举个例子

508
00:36:19,270 --> 00:36:21,740
我们再谈谈这个模型

509
00:36:21,820 --> 00:36:24,530
现在 我们集中讨论DAG

510
00:36:24,610 --> 00:36:29,630
那么 我们下一次再来讨论编程模型

511
00:36:39,310 --> 00:36:42,730
好 我们来研究调度算法

512
00:36:42,810 --> 00:36:43,910
调度的目的是

513
00:36:43,980 --> 00:36:51,240
将计算分配到P个处理器上

514
00:36:51,300 --> 00:36:58,650
而且这通常是由一个运行时系统完成

515
00:36:58,730 --> 00:37:04,110
也就是我即将展示的

516
00:37:04,170 --> 00:37:08,960
在语言层下面运作的算法

517
00:37:09,050 --> 00:37:11,260
好的 程序员设计了

518
00:37:11,340 --> 00:37:14,030
使用衍生、同步指令的算法

519
00:37:14,090 --> 00:37:18,770
然而在底层 这个算法需要

520
00:37:18,850 --> 00:37:21,280
在实际运行中 将程序映射到

521
00:37:21,350 --> 00:37:24,820
计算机的处理器上

522
00:37:24,900 --> 00:37:26,890
这就是调度算法

523
00:37:26,950 --> 00:37:30,600
这一般是由编程语言的运行时系统来完成

524
00:37:30,670 --> 00:37:35,040
实际上 在线调度算法

525
00:37:37,120 --> 00:37:44,330
可以说很复杂

526
00:37:44,410 --> 00:37:47,150
它们肯定不是课后习题那种级别的

527
00:37:47,210 --> 00:37:49,330
但它们实际上也不可怕

528
00:37:49,400 --> 00:37:51,660
只是我们也不打算讲

529
00:37:51,730 --> 00:37:54,270
因为我们只有两节课的时间讲多线程

530
00:37:54,340 --> 00:37:55,990
取而代之 我们准备讲的

531
00:37:56,070 --> 00:38:07,870
是阐述离线调度的思想

532
00:38:14,200 --> 00:38:17,060
你们会从中了解

533
00:38:17,140 --> 00:38:21,560
调度算法的任务是什么

534
00:38:21,650 --> 00:38:25,150
你会发现 要把这些任务在线完成

535
00:38:25,210 --> 00:38:28,230
复杂度将会是骨灰级的

536
00:38:28,290 --> 00:38:30,080
而典型 在线调度算法

537
00:38:30,110 --> 00:38:33,010
目前比较强势的 是随机调度算法

538
00:38:33,090 --> 00:38:35,130
它有些强大的证明

539
00:38:35,200 --> 00:38:37,380
来证明它们的强大

540
00:38:37,460 --> 00:38:38,940
但是我们不准备讲那些

541
00:38:39,010 --> 00:38:41,430
节约脑细胞

542
00:38:51,760 --> 00:38:53,760
但我们会特别留意一种

543
00:38:53,820 --> 00:38:57,330
叫做贪心调度的调度算法

544
00:39:03,100 --> 00:39:07,030
如果你有一个要执行的DAG

545
00:39:07,100 --> 00:39:10,490
那调度算法的基本规则是

546
00:39:10,570 --> 00:39:15,030
只要DAG图中某一结点的前者没执行完

547
00:39:15,100 --> 00:39:19,700
你都不能执行那个节点

548
00:39:19,780 --> 00:39:24,590
所以 你要等到前面所有点都完成才行

549
00:39:24,660 --> 00:39:29,210
那么 这种贪心调度算法说

550
00:39:29,280 --> 00:39:34,150
不如每一步都尽可能多做一点吧？

551
00:39:47,080 --> 00:39:51,660
换句话说 它从不理会

552
00:39:51,740 --> 00:39:55,150
延迟下一步到底值不值得

553
00:39:55,220 --> 00:39:57,110
要活在当下

554
00:39:57,190 --> 00:40:01,020
而每一步

555
00:40:01,090 --> 00:40:04,000
又分别对应两种类型

556
00:40:04,070 --> 00:40:08,300
第一种 就是我们所说的完整步骤

557
00:40:08,370 --> 00:40:12,060
这样的步骤里

558
00:40:12,140 --> 00:40:22,290
至少有P个线程准备运行

559
00:40:22,350 --> 00:40:27,590
而我则会用P个处理器来执行

560
00:40:31,310 --> 00:40:36,350
至少有P个线程准备运行

561
00:40:36,410 --> 00:40:38,660
那么 这里的贪心策略是什么？

562
00:40:38,730 --> 00:40:45,070
我有P个处理器 也有至少P个线程

563
00:40:45,140 --> 00:40:52,830
跑任意P个线程  第一批P线程

564
00:40:52,900 --> 00:40:54,810
如果你有顺序强迫症的话

565
00:40:54,870 --> 00:40:57,020
那将会非常有意义

566
00:40:57,100 --> 00:40:59,850
但这里 我们将运行任意的P个线程

567
00:41:02,770 --> 00:41:06,830
虽然我们可能犯了一个错误

568
00:41:06,910 --> 00:41:09,270
因为可能有一个是特别的线程

569
00:41:09,340 --> 00:41:11,370
如果先运行的话

570
00:41:11,440 --> 00:41:14,070
后面可能会带来更多的并行度

571
00:41:14,140 --> 00:41:17,130
我们可能会错过那一个 因为我们不知道

572
00:41:17,200 --> 00:41:19,530
但基本上 我们要做的

573
00:41:19,610 --> 00:41:22,980
是不管三七二十一地运行任意P  所以的话

574
00:41:23,060 --> 00:41:26,650
如果你这样做 会带来一些不决定因素

575
00:41:26,730 --> 00:41:28,410
因为你执行操作

576
00:41:28,470 --> 00:41:31,870
不一定是个好选择

577
00:41:31,950 --> 00:41:35,850
第二种我们要说的步骤类型是

578
00:41:35,930 --> 00:41:44,540
不完整步骤  这种情况里

579
00:41:44,610 --> 00:41:47,650
我们有少于P个的线程要运行

580
00:41:54,350 --> 00:41:57,790
那这里要用什么策略？

581
00:42:01,230 --> 00:42:06,450
把它们全执行了就好 贪婪算法嘛

582
00:42:06,530 --> 00:42:09,430
啥都不干就没意义了

583
00:42:19,070 --> 00:42:25,760
如果我有多于P个线程要运行

584
00:42:25,830 --> 00:42:27,150
我就运行P个

585
00:42:27,220 --> 00:42:29,610
如果我有少于P个线程要运行

586
00:42:29,690 --> 00:42:31,470
我就把所有线程都运行了

587
00:42:31,530 --> 00:42:37,040
这实际上是一个很好的策略

588
00:42:37,120 --> 00:42:43,480
虽然不是完美的 但实际上

589
00:42:43,560 --> 00:42:51,870
要是想把DAG最完美地调度到P个处理器上

590
00:42:51,940 --> 00:42:55,480
是NP完全问题  也就是说 别想了

591
00:42:55,550 --> 00:42:59,460
打个广告 你们去上6.045和6.840的课吧

592
00:42:59,540 --> 00:43:02,070
强烈推荐

593
00:43:02,150 --> 00:43:05,040
最后一节课上 我们会更深入讨论

594
00:43:05,120 --> 00:43:06,280
我们会再谈谈

595
00:43:06,340 --> 00:43:11,140
未来的理论和工程的发展重心

596
00:43:11,200 --> 00:43:13,900
你们会学习NP完全问题

597
00:43:13,970 --> 00:43:15,710
以及如何证明这些问题

598
00:43:15,780 --> 00:43:18,070
找不到一个好的算法解决

599
00:43:18,150 --> 00:43:19,730
我们会意识到这些

600
00:43:19,800 --> 00:43:22,120
还有它究竟代表了什么

601
00:43:22,200 --> 00:43:23,720
那实际上

602
00:43:23,800 --> 00:43:26,820
这种调度问题原来

603
00:43:26,880 --> 00:43:29,940
是一个非常难以优化的复杂问题

604
00:43:30,010 --> 00:43:34,750
但也有个很不错的定理

605
00:43:37,780 --> 00:43:43,350
分别由Graham和Brent独立提出

606
00:43:43,410 --> 00:43:46,800
这个定理说 基本上

607
00:43:46,860 --> 00:44:05,380
一个贪婪调度算法执行任意计算G

608
00:44:05,850 --> 00:44:21,730
若功为T_1 关键路径长为T_∞

609
00:44:21,800 --> 00:44:33,360
那它的运行时间T_P ≤ T_1/P + T_∞

610
00:44:42,240 --> 00:44:45,510
这是P个处理器的情况

611
00:44:45,590 --> 00:44:52,470
这就是说

612
00:44:52,550 --> 00:44:56,180
我可以取得T_1/P + T_∞

613
00:44:56,260 --> 00:44:58,750
这又说明什么？

614
00:44:58,820 --> 00:45:02,510
如果我们仔细观察对比

615
00:45:02,570 --> 00:45:07,090
与我们运行时的下界相比 这个的效率如何？

616
00:45:07,170 --> 00:45:13,750
这跟最优的执行时间相比如何？

617
00:45:20,610 --> 00:45:23,950
对了 这是双竞争的

618
00:45:24,040 --> 00:45:26,820
它在最优时间的两倍以内

619
00:45:26,890 --> 00:45:29,160
因为这是一个下界

620
00:45:29,230 --> 00:45:32,550
这也是一个下界

621
00:45:32,630 --> 00:45:38,310
所以 取这两者中的最大值的两倍

622
00:45:38,390 --> 00:45:41,840
两倍于这两者的最大值

623
00:45:41,910 --> 00:45:45,860
它比这个和要大

624
00:45:45,940 --> 00:45:47,690
所以 T_P在任意情况下

625
00:45:47,750 --> 00:45:52,340
都小于等于 两个下界中更强那个的两倍

626
00:45:52,410 --> 00:45:54,000
所以它说 你得到的是

627
00:45:54,130 --> 00:45:57,240
在P处理器运行时中

628
00:45:57,310 --> 00:46:00,140
两倍以内的最优调度时间

629
00:46:00,210 --> 00:46:02,020
你们都清楚了吗？

630
00:46:02,090 --> 00:46:04,270
那我们来证明这个定理吧

631
00:46:04,340 --> 00:46:07,460
这是一个很优雅的定理

632
00:46:07,540 --> 00:46:09,490
这个定理不难 这也是一个优点

633
00:46:09,550 --> 00:46:11,740
另外 这星期的课

634
00:46:11,810 --> 00:46:13,870
没有什么特别难的

635
00:46:13,940 --> 00:46:16,450
只需要你们从不同角度思考

636
00:46:26,140 --> 00:46:29,930
好的 证明需要数一数

637
00:46:30,000 --> 00:46:32,860
我们共有多少完整步骤

638
00:46:32,950 --> 00:46:35,330
又有多少不完整步骤

639
00:46:35,400 --> 00:46:39,590
我们先来数完全步骤的数目

640
00:46:45,840 --> 00:46:50,280
谁能告诉我 我们可能取得的

641
00:46:50,360 --> 00:46:53,510
最大的完整步骤数目是多少？

642
00:46:57,040 --> 00:46:59,920
我听到了真理的低吟

643
00:47:02,580 --> 00:47:10,220
T_1/P  为什么是它？

644
00:47:15,690 --> 00:47:19,230
是的 完整步骤的数目 它的最大值

645
00:47:19,300 --> 00:47:21,290
为什么是T_1/P

646
00:47:21,360 --> 00:47:25,760
[学生]:

647
00:47:25,840 --> 00:47:30,150
没错 一旦你做完这么多步 你就做完T_1的功了

648
00:47:30,230 --> 00:47:33,710
因为每一步完整步骤我都做了P的功

649
00:47:33,790 --> 00:47:40,170
如果我做了T_1/P步

650
00:47:40,230 --> 00:47:43,590
那就没哟多余的功要做了

651
00:47:43,660 --> 00:47:45,700
所以 完整步骤的数目

652
00:47:45,770 --> 00:47:49,000
不可能比T_1/P大

653
00:48:08,020 --> 00:48:13,350
这个是完整步骤

654
00:48:13,420 --> 00:48:19,030
现在我们来数不完整步骤

655
00:48:19,090 --> 00:48:21,540
证明它是以T_∞为界

656
00:48:21,610 --> 00:48:24,380
我们来考虑一个不完整步骤

657
00:48:27,530 --> 00:48:41,600
看看会发生什么 我们令G’为

658
00:48:41,680 --> 00:48:56,730
G的其中一个要被执行的子图

659
00:48:56,800 --> 00:49:01,910
那我们来画个图

660
00:49:01,990 --> 00:49:04,170
假设我们有

661
00:49:04,260 --> 00:49:06,060
画在另一块板上吧

662
00:49:24,940 --> 00:49:29,870
这里 我们要画一幅图 我们的图G

663
00:49:29,940 --> 00:49:31,130
我们这里设P的值为

664
00:49:31,200 --> 00:49:32,780
这里就设 P=3 吧

665
00:49:32,860 --> 00:49:35,640
试想这就是图G

666
00:49:49,680 --> 00:49:53,610
我不在这里列举详细的步骤了

667
00:49:53,690 --> 00:49:57,140
因为这个定理对所有DAG都有效

668
00:49:57,220 --> 00:50:01,340
没有必要列举课程详细了

669
00:50:01,420 --> 00:50:04,320
我们关注的是线程

670
00:50:16,090 --> 00:50:28,640
我漏了个 好的 想象这是我们的DAG G

671
00:50:28,720 --> 00:50:33,560
再想象我已经执行到这一点了

672
00:50:33,640 --> 00:50:38,230
我之前执行了哪些？

673
00:50:45,270 --> 00:50:50,990
对了 我执行的是这些

674
00:50:51,050 --> 00:50:57,400
所以说 在G'里面的东西

675
00:50:57,480 --> 00:50:59,060
都还没被执行过

676
00:50:59,140 --> 00:51:03,060
这些是已经运作过的

677
00:51:06,800 --> 00:51:09,510
然后 我们假设他们全部

678
00:51:09,570 --> 00:51:12,120
都是单位时间线程 使其不失一般性

679
00:51:12,200 --> 00:51:14,820
所以这个定理是通用的 即使每一个结点

680
00:51:14,890 --> 00:51:18,840
可能都有一个特定的执行时间

681
00:51:18,910 --> 00:51:22,380
用相同的调度算法也没问题

682
00:51:22,460 --> 00:51:28,570
那我要怎么区分

683
00:51:28,630 --> 00:51:30,050
那些即将要执行的线程呢？

684
00:51:30,130 --> 00:51:34,190
这里有哪些线程

685
00:51:34,270 --> 00:51:35,790
是即将要执行的？

686
00:51:35,860 --> 00:51:42,890
我们看看  这个吗？

687
00:51:42,960 --> 00:51:46,570
不不  还没轮到这个

688
00:51:46,640 --> 00:51:52,090
因为它之前还有一个结点

689
00:51:52,160 --> 00:51:54,730
好的 这个才是即将执行的那个

690
00:51:54,810 --> 00:51:57,540
还有这个也即将执行

691
00:51:57,620 --> 00:52:04,350
那好 这两个线程即将要执行

692
00:52:04,420 --> 00:52:05,810
我怎么区分它们？

693
00:52:05,870 --> 00:52:06,980
它们有什么性质？

694
00:52:07,040 --> 00:52:11,440
这个图G’有着什么样的性质 能让我分辨出

695
00:52:11,510 --> 00:52:15,170
一个结点是否准备执行？

696
00:52:15,250 --> 00:52:17,740
没有前任结点

697
00:52:17,810 --> 00:52:20,280
换句话说 是什么性质？

698
00:52:24,700 --> 00:52:28,070
如果在图G’里没有前任结点

699
00:52:28,150 --> 00:52:29,320
对于一个节点来说

700
00:52:29,400 --> 00:52:31,430
在途中没有前任结点是什么意思？

701
00:52:31,500 --> 00:52:38,350
它的入度为0 是吧？意思是一样的

702
00:52:38,560 --> 00:52:55,290
那么在图G’中 入度为0的线程

703
00:52:55,360 --> 00:52:58,880
就是即将要被执行的线程

704
00:53:01,690 --> 00:53:07,970
那对于不完整步骤 我要怎么做？

705
00:53:08,030 --> 00:53:11,800
那我执行的就是...

706
00:53:11,860 --> 00:53:14,100
如果是不完整步骤 我就把它们全执行了

707
00:53:14,180 --> 00:53:18,340
我把它们全都执行了

708
00:53:18,400 --> 00:53:24,270
当我执行所有入度为0的线程时

709
00:53:24,340 --> 00:53:31,940
图中接下来要执行的关键路径

710
00:53:32,010 --> 00:53:33,980
又会有什么变化？

711
00:53:34,060 --> 00:53:40,090
会减1

712
00:53:40,150 --> 00:53:53,600
所以 接下来G'要执行的关键路径

713
00:53:53,670 --> 00:53:58,570
就要减去1

714
00:53:58,660 --> 00:54:05,020
每一次不完整步骤所剩下的关键路径

715
00:54:05,090 --> 00:54:08,370
它的长度总是要减1

716
00:54:08,450 --> 00:54:10,870
注意了 这里的下一步是个完整步骤

717
00:54:10,940 --> 00:54:13,100
因为我有四个即将执行的结点

718
00:54:13,180 --> 00:54:16,790
在某些执行情况里

719
00:54:16,870 --> 00:54:18,320
图的关键路径长度

720
00:54:18,380 --> 00:54:23,890
不会因此而减少

721
00:54:23,960 --> 00:54:27,570
但如果能把所有结点都执行了的话

722
00:54:27,650 --> 00:54:30,600
它也会减少关键路径的长度

723
00:54:30,660 --> 00:54:34,930
当然了 同一时间里 两种情况都可能发生

724
00:54:35,010 --> 00:54:37,800
但只要我有不完全步骤

725
00:54:37,870 --> 00:54:41,710
我就肯定会减少关键路径的长度

726
00:54:41,790 --> 00:54:53,290
这就意味着 不完全步骤的数目

727
00:54:53,360 --> 00:54:59,360
最大为T_∞  因此

728
00:54:59,430 --> 00:55:07,280
T_P就等于 完全步骤的数目

729
00:55:07,340 --> 00:55:11,070
加上不完全步骤的数目

730
00:55:11,160 --> 00:55:13,630
所以我们得到了上界

731
00:55:13,700 --> 00:55:15,750
这也算是一种平摊分析吧

732
00:55:15,820 --> 00:55:17,350
你可以这样认为

733
00:55:17,420 --> 00:55:19,480
在每一步中

734
00:55:19,550 --> 00:55:22,140
我或者是对功做平摊

735
00:55:22,210 --> 00:55:26,470
又或者是对关键路径长度做平摊

736
00:55:26,550 --> 00:55:27,940
又或者两者都有

737
00:55:28,010 --> 00:55:31,850
但我至少在每一步都做了其中一项

738
00:55:31,950 --> 00:55:33,160
所以最终

739
00:55:33,230 --> 00:55:39,710
我只需要把这两项相加就好了

740
00:55:39,790 --> 00:55:43,850
有没有什么问题？  顺便说下

741
00:55:43,930 --> 00:55:47,070
这个是所有调度算法的基础

742
00:55:47,130 --> 00:55:49,890
如果你以后还要学习调度算法

743
00:55:49,960 --> 00:55:54,450
这个基础的结论

744
00:55:54,530 --> 00:55:57,420
就是之后所有理论的基础

745
00:55:57,490 --> 00:55:59,260
人们的工作就是在此之上不断升华

746
00:55:59,340 --> 00:56:03,540
比如 在用到在线调度算法等的时候

747
00:56:03,620 --> 00:56:06,450
人们都会尝试去达到这个上界

748
00:56:06,530 --> 00:56:11,210
这个无敌的贪婪调度算法的上界

749
00:56:11,280 --> 00:56:15,750
你们会学到很多很多理论

750
00:56:15,830 --> 00:56:19,940
但这就是基础的部分

751
00:56:20,010 --> 00:56:22,690
它是调度领域里的真理

752
00:56:22,760 --> 00:56:27,990
我们快速地来做个推论

753
00:56:28,050 --> 00:56:31,090
这些我就不擦了

754
00:56:31,160 --> 00:56:37,850
那些内容太重要了 我擦这些吧

755
00:56:37,920 --> 00:56:41,440
这些也不能擦 好纠结啊

756
00:56:41,450 --> 00:56:43,870
我们还是回到上面吧

757
00:56:43,950 --> 00:56:45,010
算了 我还是把推论写在这里

758
00:56:45,080 --> 00:56:53,260
因为这只有一行而已

759
00:57:08,820 --> 00:57:12,330
这个推论说 你的加速是线性的

760
00:57:12,400 --> 00:57:17,420
如果你投入到运行中的处理器

761
00:57:17,500 --> 00:57:25,340
是以并行度为阶的话

762
00:57:27,590 --> 00:57:33,360
所以 贪婪调度算法能给你带来线性的加速

763
00:57:33,360 --> 00:57:40,790
如果你的处理器数量是等于或少于并行度的话

764
00:57:40,840 --> 00:57:44,120
我们来分析下为什么

765
00:57:44,180 --> 00:57:48,430
希望这里能写得下

766
00:57:48,500 --> 00:57:53,780
所以 P帽等于T_1/T_∞

767
00:57:53,860 --> 00:57:58,530
这隐含了

768
00:57:58,610 --> 00:58:04,720
如果P是O（T_1/T_∞）的话

769
00:58:04,790 --> 00:58:10,880
那么我们移个项

770
00:58:10,960 --> 00:58:21,410
得出T_∞=O（T_1/P） 大家看懂没？

771
00:58:21,470 --> 00:58:23,030
这是代数运算

772
00:58:23,100 --> 00:58:29,220
这个是并行度的定义

773
00:58:29,300 --> 00:58:32,230
T_1/T_∞

774
00:58:32,300 --> 00:58:35,130
如果P是并行度阶的

775
00:58:35,200 --> 00:58:37,720
也就是O（T_1/T_∞）

776
00:58:37,800 --> 00:58:39,610
现在 我们来移个项

777
00:58:39,670 --> 00:58:41,450
变成T_∞等于O（T_1/P）

778
00:58:41,530 --> 00:58:46,130
推出T_∞等于O（T_∞）

779
00:58:46,210 --> 00:58:57,450
那么因此 我们在这边继续证明

780
00:58:57,520 --> 00:59:08,650
因为 T_P最大为T_1/P + T_∞

781
00:59:08,730 --> 00:59:13,270
s所以说 如果这也是T_1/P阶的话

782
00:59:13,340 --> 00:59:16,500
那么整个东西就也是T_1/P

783
00:59:16,570 --> 00:59:30,260
好的 我现在有T_P是O(T_1/P)的

784
00:59:30,340 --> 00:59:37,320
我们再来计算下T_1/T_P

785
00:59:37,400 --> 00:59:41,160
这就等于O(P)

786
00:59:45,600 --> 00:59:47,290
大家看懂没？

787
00:59:47,360 --> 00:59:48,500
这也就是说

788
00:59:48,570 --> 00:59:50,520
如果我有一定量的并行度

789
00:59:50,600 --> 00:59:52,800
如果我投入了

790
00:59:52,870 --> 00:59:55,480
恰好少于并行度的处理器

791
00:59:55,540 --> 00:59:58,590
我用贪婪调度就能得到线性的加速

792
00:59:58,660 --> 01:00:04,250
如果我投入的处理器比并行度要多

793
01:00:04,320 --> 01:00:06,600
我就可能浪费了

794
01:00:06,680 --> 01:00:08,990
因为我投入的额外的处理器

795
01:00:09,070 --> 01:00:11,530
并不能给我带来加速效果

796
01:00:11,590 --> 01:00:14,830
所以 一项任务的并行度可以理解为

797
01:00:14,890 --> 01:00:16,700
是一个极限

798
01:00:16,770 --> 01:00:18,550
处理器数量的极限

799
01:00:18,610 --> 01:00:19,840
实际上 我可以到达这个极限

800
01:00:19,920 --> 01:00:21,330
什么问题？

801
01:00:21,400 --> 01:00:38,120
[学生]:......

802
01:00:38,190 --> 01:00:39,470
[教授]:没错 某种意义上

803
01:00:39,540 --> 01:00:41,690
这应该是Ω(P)才对

804
01:00:41,760 --> 01:00:43,310
不过还好

805
01:00:43,380 --> 01:00:46,710
这个问题是... 请继续说

806
01:00:46,780 --> 01:01:02,140
[学生]:......

807
01:01:02,210 --> 01:01:04,630
[教授]:不不 仅当它有一个常数上界

808
01:01:04,690 --> 01:01:07,390
但T_1和T_∞并不是常数

809
01:01:07,460 --> 01:01:11,460
在这里 它们是常数

810
01:01:11,530 --> 01:01:17,080
我们这里是在做多变量的渐近分析

811
01:01:17,150 --> 01:01:18,880
这里讨论的东西都可能

812
01:01:18,950 --> 01:01:20,100
与别的东西有函数关系

813
01:01:20,170 --> 01:01:22,950
都可能符合我们预期的增长

814
01:01:23,030 --> 01:01:23,730
我们说

815
01:01:23,770 --> 01:01:25,060
给定某一个东西

816
01:01:25,130 --> 01:01:27,090
我们不是真的给定一个数字

817
01:01:27,160 --> 01:01:29,560
我们是给定一整套的DAG图

818
01:01:29,630 --> 01:01:31,370
不管什么大小也好

819
01:01:31,450 --> 01:01:33,220
这才是我们讨论的东西

820
01:01:33,280 --> 01:01:34,980
这样我才能看清它的增长率

821
01:01:35,050 --> 01:01:36,370
我们这里讨论的

822
01:01:36,440 --> 01:01:42,450
是并行度的增长率

823
01:01:42,510 --> 01:01:48,910
抱歉 是运行时间T_P的增长率

824
01:01:48,990 --> 01:01:52,260
它是关于T_1和T_∞的函数值

825
01:01:52,320 --> 01:01:57,870
我们讨论的是这个的增长率 好吧？

826
01:02:00,230 --> 01:02:08,000
好的 我们开始来证明

827
01:02:08,070 --> 01:02:12,080
实际上...我要回来这边写

828
01:02:12,150 --> 01:02:14,360
现在我要给你们讲讲

829
01:02:14,430 --> 01:02:15,980
我自己的一些研究

830
01:02:16,060 --> 01:02:21,570
还有我是怎样把它应用到我的工作中去

831
01:02:21,650 --> 01:02:28,160
我们开发了一种动态多线程语言

832
01:02:28,220 --> 01:02:30,280
叫做Cilk 以C打头

833
01:02:30,360 --> 01:02:32,390
以为这是基于C开发的

834
01:02:32,460 --> 01:02:34,540
它不是一个缩写词哦

835
01:02:34,620 --> 01:02:39,030
因为丝绸是好的线嘛

836
01:02:39,120 --> 01:02:47,590
曾经我的学生有过华山论"线"

837
01:02:47,660 --> 01:02:52,760
讨论Cilk是什么的缩写

838
01:02:52,830 --> 01:02:56,320
但得出结果却是

839
01:02:56,400 --> 01:03:00,100
“错爱理科”

840
01:03:00,170 --> 01:03:06,000
反正我是信了 如果你了解过它

841
01:03:06,080 --> 01:03:12,450
你就能发现其中的一些东西

842
01:03:17,760 --> 01:03:21,890
它实际上用到了

843
01:03:21,960 --> 01:03:24,010
这些超复杂的调度算法中的一个

844
01:03:24,090 --> 01:03:29,950
是一种随机在线调度算法

845
01:03:33,730 --> 01:03:36,930
如果你看到

846
01:03:37,000 --> 01:03:41,530
它在P个处理器上跑的预期时间

847
01:03:41,600 --> 01:03:43,820
它实际上

848
01:03:43,880 --> 01:03:50,620
可以证明是T_1/P + O(T_∞)

849
01:03:57,380 --> 01:03:59,820
经验告诉我们

850
01:03:59,890 --> 01:04:03,280
如果你真要通过运行时间

851
01:04:03,350 --> 01:04:05,580
以此来调查大O所隐含的算式

852
01:04:05,650 --> 01:04:10,500
其实你会发现 T_P约等于T_1/P + T_∞

853
01:04:10,570 --> 01:04:14,420
从经验来看 T_∞的常数因子非常接近1

854
01:04:16,640 --> 01:04:18,300
虽然不能保证

855
01:04:18,370 --> 01:04:21,460
但这一条式真的是一个非常好的上界

856
01:04:21,540 --> 01:04:24,140
你有时候会发现T_∞的系数的大小

857
01:04:24,210 --> 01:04:27,290
可能接近4神马的

858
01:04:27,360 --> 01:04:29,140
但一般来说 它都不会

859
01:04:29,210 --> 01:04:30,950
比4更大了

860
01:04:31,010 --> 01:04:32,660
大多数情况下 它大概就是那么多

861
01:04:32,730 --> 01:04:35,980
如果你做个线性回归的曲线拟合

862
01:04:36,050 --> 01:04:38,550
你就会求出 这个常数为1

863
01:04:38,630 --> 01:04:42,430
那么 有了这个

864
01:04:42,500 --> 01:04:49,010
如果用这条式来做你的运算时间模型

865
01:04:49,080 --> 01:04:50,650
就近乎完美了

866
01:04:50,710 --> 01:04:53,820
你将获得几乎完美的线性加速

867
01:04:56,710 --> 01:05:02,090
如果你运行的处理器的数量

868
01:05:02,160 --> 01:05:05,010
远小于你的平均并行度的话

869
01:05:05,080 --> 01:05:06,560
当然了

870
01:05:06,640 --> 01:05:11,220
如果T_∞远小于T_1/P

871
01:05:11,290 --> 01:05:14,950
结果也一样

872
01:05:15,020 --> 01:05:17,970
那么 这里的意思就是

873
01:05:18,060 --> 01:05:22,030
当P远小于P_∞时 又或者

874
01:05:22,100 --> 01:05:24,420
T_∞远小于T_1/P

875
01:05:24,490 --> 01:05:27,930
这一项就变得不重要了

876
01:05:28,010 --> 01:05:31,070
然后你的加速就很好

877
01:05:31,130 --> 01:05:34,000
好的 事实上 几乎是线性的

878
01:05:34,090 --> 01:05:37,540
这种情况下 每个处理器都会发挥到作用

879
01:05:37,610 --> 01:05:39,440
只要总的处理器数量

880
01:05:39,500 --> 01:05:41,030
还在这个范围里

881
01:05:41,100 --> 01:05:46,230
就是远小于并行度这个范围

882
01:05:46,310 --> 01:05:51,450
现在 这个语言多年以前

883
01:05:51,530 --> 01:05:53,790
你们还在打酱油的时候

884
01:05:53,850 --> 01:05:57,660
就已经很强势了

885
01:05:57,730 --> 01:06:03,080
我们写了一堆象棋程序

886
01:06:05,270 --> 01:06:16,330
比如说有"苏格拉底之星"和"Cilk象棋"

887
01:06:16,410 --> 01:06:19,060
还有一些别的

888
01:06:19,140 --> 01:06:22,890
这些程序都已经是棋灵王的境界了

889
01:06:22,980 --> 01:06:25,490
说到我们的辉煌史

890
01:06:25,550 --> 01:06:31,050
我们是1995年象棋世锦赛香港站的第一

891
01:06:31,120 --> 01:06:34,280
但后来再复赛中惜败了

892
01:06:34,350 --> 01:06:35,990
惜败的惜啊

893
01:06:36,070 --> 01:06:39,260
我们差点就用并行计算机征服象棋界了

894
01:06:39,340 --> 01:06:42,520
可能你们曾经听说过

895
01:06:42,600 --> 01:06:45,920
IBM的"深蓝"象棋程序

896
01:06:45,990 --> 01:06:47,860
那次香港的比赛

897
01:06:47,930 --> 01:06:53,750
是它在跟世界冠军Kasparov对战前

898
01:06:53,810 --> 01:06:56,350
最后一次跟机器的对弈

899
01:06:56,410 --> 01:06:58,470
它那次才只是第三而已

900
01:06:58,550 --> 01:07:01,780
所以说我们更虎一点

901
01:07:01,860 --> 01:07:03,830
虽然说 在一对一单挑的时候

902
01:07:03,890 --> 01:07:05,480
我们输了

903
01:07:05,560 --> 01:07:07,860
我们直到决赛时都还是

904
01:07:07,930 --> 01:07:10,190
只尝一败

905
01:07:10,270 --> 01:07:12,380
它们一负一平

906
01:07:12,470 --> 01:07:15,100
很多人都觉得深蓝实际上

907
01:07:15,180 --> 01:07:17,290
还不够资格作为世界冠军的对手

908
01:07:17,360 --> 01:07:21,660
毕竟是Kasparov大神

909
01:07:21,730 --> 01:07:25,340
它可以跟大神进行对战

910
01:07:25,400 --> 01:07:27,310
完全是因为土豪IBM舍得扔钱

911
01:07:27,370 --> 01:07:33,660
所以 我们开发了一个象棋程序

912
01:07:33,730 --> 01:07:37,250
我们的开发之路是

913
01:07:37,330 --> 01:07:41,580
我要好好讲讲"苏格拉底之星"

914
01:07:41,640 --> 01:07:45,490
我们有个很有趣的异常状况

915
01:07:45,550 --> 01:07:51,440
我们当时用了

916
01:07:51,510 --> 01:08:01,740
MIT的32核的计算机来开发

917
01:08:01,800 --> 01:08:05,950
后来我们用的是512核的机子

918
01:08:06,030 --> 01:08:19,570
伊利诺斯大学那的国家超级计算机 去参加比赛

919
01:08:19,650 --> 01:08:21,300
我们有这么一个大机子

920
01:08:21,370 --> 01:08:22,820
虽然他们不是很想借给我们

921
01:08:22,890 --> 01:08:25,700
但我们在MIT也有一个相对小点的机子

922
01:08:25,770 --> 01:08:28,210
我们就在这上面开发

923
01:08:28,290 --> 01:08:30,300
有时我们又可以在这上面跑

924
01:08:30,360 --> 01:08:33,530
而最后的竞赛就是我们开发的目标

925
01:08:33,600 --> 01:08:39,120
那么 我来告诉你们有什么异常情况发生了吧

926
01:08:47,060 --> 01:08:50,520
我们的程序有个版本

927
01:08:50,580 --> 01:08:52,410
我们称之为原始程序

928
01:08:52,480 --> 01:09:01,440
因为后来我们有优化程序

929
01:09:01,520 --> 01:09:09,860
加了一些新特性进去

930
01:09:09,940 --> 01:09:12,660
它理论上应该跑得更快些

931
01:09:12,740 --> 01:09:24,200
所以 我们给原始程序在32核的机子上计时

932
01:09:24,280 --> 01:09:27,230
用了我们65秒

933
01:09:27,310 --> 01:09:34,140
用新程序计时的话

934
01:09:34,220 --> 01:09:37,050
把它叫做T'_32

935
01:09:37,050 --> 01:09:40,730
鉴于我们用的是32核

936
01:09:40,810 --> 01:09:42,800
它跑了40秒

937
01:09:42,870 --> 01:09:46,800
来完成我们的一个基准测试

938
01:09:46,880 --> 01:09:50,090
好吧 我承认我撒谎了

939
01:09:50,160 --> 01:09:53,470
实际数字不好计算 我简化了下

940
01:09:53,540 --> 01:09:55,330
但意思是一样的

941
01:09:55,400 --> 01:09:56,920
只是数字有点出入

942
01:09:56,990 --> 01:10:01,450
这看上去应该

943
01:10:01,530 --> 01:10:04,940
是一个重要的改进

944
01:10:05,010 --> 01:10:08,690
但我们否决了这个优化

945
01:10:17,810 --> 01:10:21,770
我们否决的原因

946
01:10:21,840 --> 01:10:23,300
是因为我们知道

947
01:10:23,380 --> 01:10:26,300
功和关键路径的事

948
01:10:26,360 --> 01:10:28,390
我来讲讲当时的分析

949
01:10:28,470 --> 01:10:31,290
分析就是

950
01:10:31,370 --> 01:10:33,300
其实 如果我们观察我们的指标

951
01:10:33,370 --> 01:10:36,730
在对于原程序 功是2048

952
01:10:36,810 --> 01:10:42,090
关键路径是1秒

953
01:10:42,170 --> 01:10:45,630
而这边的优化程序

954
01:10:45,700 --> 01:10:49,640
功是1024

955
01:10:49,730 --> 01:10:54,960
但关键路径是8

956
01:10:55,020 --> 01:11:00,350
如果我们把它带入我们的简单模型

957
01:11:00,420 --> 01:11:05,060
我们上面这个 有近似步骤的那个模型

958
01:11:05,140 --> 01:11:17,670
我们有T_32等于T_1/32+T_∞

959
01:11:17,740 --> 01:11:20,070
那就等于

960
01:11:20,130 --> 01:11:24,560
功是2048除以32

961
01:11:24,640 --> 01:11:25,790
那是多少？

962
01:11:25,860 --> 01:11:32,400
64 好的 再加上关键路径 那就是65

963
01:11:32,470 --> 01:11:34,760
这跟我们看到的事实吻合

964
01:11:34,830 --> 01:11:36,740
真的 我们的确做到了

965
01:11:36,820 --> 01:11:37,970
而且确实吻合

966
01:11:38,030 --> 01:11:40,360
非常非常接近 所以这边

967
01:11:40,440 --> 01:11:51,540
T'_32就是T'_1/32

968
01:11:51,600 --> 01:11:54,920
加上T'_∞

969
01:11:54,980 --> 01:12:02,230
这就等于1024除以32 就是32

970
01:12:02,300 --> 01:12:07,030
再加上8的关键路径 所以是40

971
01:12:07,100 --> 01:12:09,150
这个也吻合

972
01:12:09,220 --> 01:12:11,170
那么现在我们说

973
01:12:11,240 --> 01:12:14,060
我们来看看在超级计算机上如何吧

974
01:12:14,130 --> 01:12:17,020
这些东西在超级计算机上跑得有多快？

975
01:12:17,080 --> 01:12:23,660
那这次 我们有T_512

976
01:12:23,720 --> 01:12:29,910
它等于T_1/512+T_∞

977
01:12:29,990 --> 01:12:35,150
所以说 2048/512

978
01:12:35,230 --> 01:12:38,950
等于4 加上T_∞ 也就是1

979
01:12:39,010 --> 01:12:40,900
一共为5

980
01:12:40,970 --> 01:12:43,740
我们这次算的真的很快

981
01:12:43,800 --> 01:12:54,250
而这边 T'_514等于T'_1/512

982
01:12:54,330 --> 01:12:57,270
再加上T’_∞  就等于

983
01:12:57,350 --> 01:13:03,320
我算算 1024除以512

984
01:13:03,390 --> 01:13:07,220
等于2 再加上关键路径8 就是10

985
01:13:08,950 --> 01:13:13,260
那么 你可以看到在大机子上

986
01:13:13,330 --> 01:13:15,250
我们的优化

987
01:13:15,330 --> 01:13:18,550
比原程序还要慢一倍

988
01:13:18,620 --> 01:13:23,550
这就是所谓的"优化"

989
01:13:23,620 --> 01:13:27,310
因为我们的并行度已经用尽了

990
01:13:27,370 --> 01:13:32,690
而这个却增加了关键路径

991
01:13:32,750 --> 01:13:34,610
我们需要一种方法

992
01:13:34,690 --> 01:13:36,200
来减少我们的功

993
01:13:36,270 --> 01:13:37,630
确实 它减少了很多

994
01:13:37,700 --> 01:13:39,370
但关键路径却变长了

995
01:13:39,450 --> 01:13:41,650
使得程序的并行化

996
01:13:41,730 --> 01:13:43,970
变得远离了我们希望做到的目标

997
01:13:44,040 --> 01:13:47,730
整整慢了一倍 一倍啊亲

998
01:13:47,800 --> 01:13:51,810
这个道理告诉我们 功和关键路径长度

999
01:13:51,880 --> 01:13:55,510
对于性能的预测比单单运行时间要好

1000
01:13:55,580 --> 01:13:58,170
因为你需要可扩展性

1001
01:13:58,240 --> 01:14:00,880
这些机器的可扩展性是一个大问题

1002
01:14:00,950 --> 01:14:03,830
虽然不是经常 但你有时不需要考虑到它

1003
01:14:03,910 --> 01:14:04,880
有时你就在乎

1004
01:14:04,950 --> 01:14:06,860
如果我们在比赛中

1005
01:14:06,930 --> 01:14:09,440
用的是32核的机子

1006
01:14:09,510 --> 01:14:11,050
我们就会接受这个优化

1007
01:14:11,130 --> 01:14:13,230
这是一个不错的权衡条件

1008
01:14:13,310 --> 01:14:17,000
但因为我们知道

1009
01:14:17,070 --> 01:14:19,970
我们要在一个更多处理器的机子上跑

1010
01:14:20,060 --> 01:14:22,200
我们几乎把并行度都用光了

1011
01:14:22,270 --> 01:14:23,410
这样的话

1012
01:14:23,480 --> 01:14:26,010
增加关键路径长度就很不科学

1013
01:14:26,080 --> 01:14:27,640
这样就减少了

1014
01:14:27,710 --> 01:14:32,150
我们运算的并行度

1015
01:14:32,230 --> 01:14:36,910
好的 下次课

1016
01:14:36,990 --> 01:14:40,190
先问问还有没有问题？

1017
01:14:40,270 --> 01:14:42,360
好的 下次课 现在我们了解了

1018
01:14:42,430 --> 01:14:45,530
运算执行的模型

1019
01:14:45,600 --> 01:14:47,640
下一步我们将看看

1020
01:14:47,720 --> 01:14:50,600
一些特定算法的性能

1021
01:14:50,660 --> 01:14:54,980
我们将会用动态多线程的风格来改写它们

1022
01:04:45,580 --> 01:04:46,470
[学生]:...

