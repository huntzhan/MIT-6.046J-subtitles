1
00:00:12,750 --> 00:00:14,500
Good morning everyone.

2
00:00:19,040 --> 00:00:24,620
Today we are going to do some algorithms, back to algorithms,

3
00:00:24,620 --> 00:00:27,500
and we are going to use a lot of the,

4
00:00:27,500 --> 00:00:29,040
well, some of the simpler mathematics

5
00:00:29,040 --> 00:00:30,430
that we developed last class

6
00:00:30,430 --> 00:00:31,470
like the master theorem for solving recurrences.

7
00:00:31,470 --> 00:00:32,930
We are going to use this a lot.

8
00:00:32,930 --> 00:00:35,730
Because we are going to talk about recursive algorithms today.

9
00:00:35,820 --> 00:00:37,090
And so we will find their running time

10
00:00:37,090 --> 00:00:39,810
using the master theorem.

11
00:00:39,810 --> 00:00:41,230
This is just the same as it was last time, I hope,

12
00:00:41,230 --> 00:00:43,530
unless I made a mistake.

13
00:00:47,460 --> 00:00:49,080
A couple of reminders.

14
00:00:49,080 --> 00:00:51,240
You should all go to recitation on Friday.

15
00:00:51,240 --> 00:00:52,000
That is required.

16
00:00:52,000 --> 00:00:52,870
If you want to,

17
00:00:52,870 --> 00:00:54,850
you can go to homework lab on Sunday.

18
00:00:54,850 --> 00:00:56,990
That may be a good excuse for you

19
00:00:56,990 --> 00:01:00,160
to actually work on your problem set a few hours early.

20
00:01:00,160 --> 00:01:02,000
Well, actually, it's still on Wednesday

21
00:01:02,000 --> 00:01:03,720
so you have lots of time.

22
00:01:04,030 --> 00:01:06,200
And there is no class on Monday.

23
00:01:06,200 --> 00:01:07,980
It is the holiday known as Student Holiday,

24
00:01:07,980 --> 00:01:09,230
so don't come.

25
00:01:09,800 --> 00:01:18,380
Today we are going to cover something called Divide and Conquer.

26
00:01:25,090 --> 00:01:27,930
also known as divide and rule.

27
00:01:27,930 --> 00:01:32,950
or divide et impera for those of you who know Latin,

28
00:01:32,950 --> 00:01:36,060
which is a tried and tested way

29
00:01:36,060 --> 00:01:38,040
of conquering a land

30
00:01:38,040 --> 00:01:40,690
by dividing it into sections of some kind.

31
00:01:40,690 --> 00:01:42,200
It could be different political factions,

32
00:01:42,200 --> 00:01:43,390
different whatever.

33
00:01:43,390 --> 00:01:46,180
And then somehow making them no longer like each other.

34
00:01:46,180 --> 00:01:47,600
Like starting a family feud

35
00:01:47,600 --> 00:01:48,690
is always a good method.

36
00:01:48,690 --> 00:01:51,160
You should remember this on your quiz.

37
00:01:51,160 --> 00:01:52,220
I'm kidding.

38
00:01:52,220 --> 00:01:55,550
And if you can separate this big power structure

39
00:01:55,560 --> 00:01:57,980
into little power structures

40
00:01:57,980 --> 00:02:00,160
such that you dominate each little power structure

41
00:02:00,160 --> 00:02:02,160
then you can conquer all of them individually,

42
00:02:02,160 --> 00:02:03,690
as long as you make sure they don't get back together.

43
00:02:03,690 --> 00:02:07,550
That is divide and conquer as practiced, say, by the British.

44
00:02:07,550 --> 00:02:10,670
But today we are going to do divide and conquer as practiced in

45
00:02:10,670 --> 00:02:14,310
Cormen, Leiserson, Rivest and Stein

46
00:02:14,310 --> 00:02:15,640
or every other algorithm textbook.

47
00:02:15,640 --> 00:02:18,040
This is a very basic

48
00:02:18,040 --> 00:02:21,770
and very powerful algorithm design technique.

49
00:02:21,770 --> 00:02:25,140
So, this is our first real algorithm design experience.

50
00:02:25,140 --> 00:02:27,190
We are still sort of mostly in the analysis mode,

51
00:02:27,190 --> 00:02:28,950
but we are going to do some actual design.

52
00:02:28,950 --> 00:02:32,470
We're going to cover maybe only three or four major design techniques.

53
00:02:32,470 --> 00:02:33,560
This is one of them,

54
00:02:33,560 --> 00:02:35,920
so it is really important.

55
00:02:35,920 --> 00:02:39,770
And it will lead to all sorts of recurrences,

56
00:02:39,770 --> 00:02:44,200
so we will get to use everything from last class

57
00:02:44,200 --> 00:02:48,030
and see why it is useful.

58
00:02:49,830 --> 00:02:53,250
As you might expect, the first step in divide-and-conquer is

59
00:02:53,250 --> 00:02:55,720
divide and the second step is conquer.

60
00:02:55,720 --> 00:02:58,590
But you may not have guessed that there are three steps.

61
00:02:58,590 --> 00:03:00,560
And I am leaving some blank space here,

62
00:03:00,560 --> 00:03:02,540
so you should, too.

63
00:03:05,850 --> 00:03:08,780
Divide-and-conquer is an algorithmic technique.

64
00:03:08,780 --> 00:03:10,880
You are given some big problem you want to solve,

65
00:03:10,880 --> 00:03:13,360
you don't really know how to solve it in an efficient way,

66
00:03:13,360 --> 00:03:15,460
so you are going to split it up into subproblems.

67
00:03:15,460 --> 00:03:17,340
That is the divide.

68
00:03:19,680 --> 00:03:21,890
You are going to divide that problem,

69
00:03:21,890 --> 00:03:25,760
or more precisely the instance of that problem,

70
00:03:26,710 --> 00:03:31,810
the particular instance of that problem you have into subproblems.

71
00:03:35,880 --> 00:03:40,290
And those subproblems should be smaller in some sense.

72
00:03:40,470 --> 00:03:43,760
And smaller means normally that

73
00:03:43,760 --> 00:03:46,930
the value of n is smaller than it was in the original problem.

74
00:03:46,930 --> 00:03:47,990
So, you sort of made some progress.

75
00:03:47,990 --> 00:03:48,870
Now you have one,

76
00:03:48,870 --> 00:03:52,700
or more likely you have several subproblems you need to solve.

77
00:03:52,700 --> 00:03:53,990
Each of them is smaller.

78
00:03:53,990 --> 00:03:56,080
So, you recursively solve each subproblem.

79
00:03:56,310 --> 00:03:58,300
That is the conquer step.

80
00:03:58,300 --> 00:04:04,930
You conquer each subproblem recursively.

81
00:04:04,930 --> 00:04:09,050
And then somehow you combine those solutions into

82
00:04:09,050 --> 00:04:12,000
a solution for the whole problem.

83
00:04:20,930 --> 00:04:25,120
So, this is the general divide-and-conquer paradigm.

84
00:04:25,120 --> 00:04:27,270
And lots of algorithms fit it.

85
00:04:27,270 --> 00:04:30,390
You have already seen one algorithm that fits this paradigm,

86
00:04:30,390 --> 00:04:32,380
if you can remember. Merge sort, good.

87
00:04:32,380 --> 00:04:34,070
Wow, you are all awake.

88
00:04:34,070 --> 00:04:35,000
I'm impressed.

89
00:04:35,000 --> 00:04:36,600
So, we saw merge sort.

90
00:04:36,600 --> 00:04:40,320
And, if I am clever, I could fit it in this space.

91
00:04:40,320 --> 00:04:42,600
Sure. Let's be clever.

92
00:04:46,010 --> 00:04:48,480
A quick review on merge sort.

93
00:04:48,480 --> 00:04:51,830
Phrased in this 1, 2, 3 kind of method.

94
00:04:51,830 --> 00:04:55,480
The first step was to divide your array into two halves.

95
00:04:55,480 --> 00:05:00,700
This really doesn't mean anything because you just sort of think,

96
00:05:00,700 --> 00:05:03,790
oh, I will pretend my array is divided into two halves.you don't have ..

97
00:05:03,790 --> 00:05:05,090
There is no work here.

98
00:05:05,090 --> 00:05:07,570
This is zero time. You just look at your array.

99
00:05:08,300 --> 00:05:09,480
Here is your array.

100
00:05:09,480 --> 00:05:13,370
I guess maybe you compute n/2 and take the floor.

101
00:05:13,370 --> 00:05:15,340
That takes constant time.

102
00:05:18,410 --> 00:05:20,570
And you say OK, I am pretending my array is

103
00:05:20,570 --> 00:05:23,180
now divided into the left part and the right part.

104
00:05:23,730 --> 00:05:27,060
And then the interesting part is that you recursively solve each one.

105
00:05:27,060 --> 00:05:28,920
That's the conquer.

106
00:05:31,140 --> 00:05:42,010
We recursively sort each subarray.

107
00:05:44,660 --> 00:05:49,320
And then the third step is to combine those solutions.

108
00:05:49,730 --> 00:05:52,010
And so here we really see what this means.

109
00:05:52,010 --> 00:05:55,930
We now have a sorted version of this array by induction.

110
00:05:55,930 --> 00:05:58,260
We have a sorted version of this array by induction.

111
00:05:58,260 --> 00:05:59,900
We now want the sorted version of the whole array.

112
00:05:59,900 --> 00:06:04,770
And we saw that was the merge problem, merging two sorted arrays.

113
00:06:04,770 --> 00:06:07,910
And that we saw how to do in linear time, order n time.

114
00:06:12,080 --> 00:06:13,720
I am not going to repeat that,

115
00:06:13,720 --> 00:06:17,580
but the point is it falls into that framework.

116
00:06:19,840 --> 00:06:26,030
I want to write the running time and merge sort as a recurrence.

117
00:06:26,380 --> 00:06:28,220
You have already seen the recurrence,

118
00:06:28,220 --> 00:06:29,670
you have already been told the solution,

119
00:06:29,670 --> 00:06:32,930
but now we actually know how to solve it.

120
00:06:32,930 --> 00:06:34,100
And, furthermore,

121
00:06:34,100 --> 00:06:38,080
every algorithm that follows the divide-and-conquer paradigm

122
00:06:38,080 --> 00:06:41,540
will have a recurrence of pretty much the same form,

123
00:06:41,540 --> 00:06:44,800
very much like our good friend the master method.

124
00:06:44,800 --> 00:06:48,130
Let's do it for merge sort where we sort of already

125
00:06:48,130 --> 00:06:50,940
know the answer and get a bit of practice.

126
00:06:57,310 --> 00:06:59,390
This is the merge sort recurrence.

127
00:06:59,390 --> 00:07:01,830
You should know and love this recurrence

128
00:07:01,830 --> 00:07:04,210
because it comes up all over the place.

129
00:07:04,210 --> 00:07:07,420
It comes from this general approach

130
00:07:07,420 --> 00:07:10,810
by just seeing what are the sizes of the subproblems

131
00:07:10,810 --> 00:07:12,900
you are solving and how many there are

132
00:07:12,900 --> 00:07:14,660
and how much extra work you are doing.

133
00:07:14,660 --> 00:07:18,540
You have here the size of the subproblems.

134
00:07:19,920 --> 00:07:25,360
It happens here that both subproblems have the same size roughly.

135
00:07:25,360 --> 00:07:28,120
There is this sloppiness that we have,

136
00:07:28,130 --> 00:07:32,290
which really should be T of floor of n over 2 plus T of ceiling of n over 2.

137
00:07:32,290 --> 00:07:35,980
And when you go to recitation on Friday you will see why that is OK,

138
00:07:35,980 --> 00:07:37,440
the floors and ceilings don't matter.

139
00:07:37,440 --> 00:07:40,670
There is a theorem you can prove that that's happy.

140
00:07:40,670 --> 00:07:42,300
You can assume that n is a power of 2,

141
00:07:44,360 --> 00:07:46,410
but we are just going to assume that for now.

142
00:07:46,410 --> 00:07:48,720
We just have two problems with size n over 2.

143
00:07:48,720 --> 00:07:54,320
This 2 is the number of subproblems.

144
00:07:57,610 --> 00:08:01,310
And this order n is all the extra work we are doing.

145
00:08:01,310 --> 00:08:04,150
Now, what is the extra work potentially?

146
00:08:04,150 --> 00:08:07,150
Well, the conquering is always just recursion.

147
00:08:07,150 --> 00:08:10,080
There is sort of no work there except this lead part.

148
00:08:10,080 --> 00:08:12,530
The dividing in this case is trivial,

149
00:08:12,530 --> 00:08:13,990
but in general it might involve some work.

150
00:08:13,990 --> 00:08:16,780
And the combining here involves linear work.

151
00:08:16,780 --> 00:08:23,760
So, this is the divide-and-conquer running times.

152
00:08:26,600 --> 00:08:29,100
So, this is the nonrecursive work.

153
00:08:29,100 --> 00:08:31,120
And that is generally

154
00:08:31,120 --> 00:08:33,540
how you convert a divide-and-conquer algorithm into a recurrence.

155
00:08:33,540 --> 00:08:36,930
It's really easy and you usually get to apply the master method.

156
00:08:36,930 --> 00:08:43,590
Here we are in Case 2. Very good.

157
00:08:43,590 --> 00:08:50,120
This is Case 2. And k is zero here.

158
00:08:50,120 --> 00:08:51,460
And so in the recursion tree,

159
00:08:51,460 --> 00:08:55,030
all of the costs are roughly the same.

160
00:08:55,030 --> 00:08:56,900
They are all n to the log base b of a.

161
00:08:56,900 --> 00:09:01,360
Here n to the log base 2 of 2 is just n.

162
00:09:01,360 --> 00:09:02,880
So these are equal.

163
00:09:02,880 --> 00:09:04,470
We get an extra log factor

164
00:09:04,470 --> 00:09:07,250
because of the number of levels in the recursion tree.

165
00:09:07,790 --> 00:09:09,700
Remember the intuition behind the master method.

166
00:09:09,700 --> 00:09:12,040
This is n log n.

167
00:09:12,830 --> 00:09:13,960
and that is good.

168
00:09:13,960 --> 00:09:16,360
Merge sort is a fast sorting algorithm n log n.

169
00:09:16,360 --> 00:09:18,320
Insertion sort was n squared.

170
00:09:18,320 --> 00:09:21,330
In some sense, n log n is the best you can do.

171
00:09:21,330 --> 00:09:24,220
We will cover that in two lectures from now,

172
00:09:24,220 --> 00:09:25,840
but just foreshadowing.

173
00:09:26,260 --> 00:09:29,770
Today we are going to do different divide-and-conquer algorithms.

174
00:09:29,770 --> 00:09:31,350
Sorting is one problem.

175
00:09:31,350 --> 00:09:33,100
There are all sorts of problems we might want to solve.

176
00:09:33,100 --> 00:09:37,360
It turns out a lot of them you can apply divide-and-conquer to.

177
00:09:37,550 --> 00:09:39,280
Not every problem.

178
00:09:39,280 --> 00:09:42,100
Like how to wake up in the morning,

179
00:09:42,100 --> 00:09:44,330
it's not so easy to solve a divide-and-conquer,

180
00:09:44,330 --> 00:09:51,460
although maybe that's a good problem set problem.

181
00:09:56,400 --> 00:09:58,520
The next divide-and-conquer algorithm

182
00:09:58,520 --> 00:10:03,010
we are going to look at is even simpler than sorting,

183
00:10:03,010 --> 00:10:04,490
even simpler than merge sort,

184
00:10:04,490 --> 00:10:09,230
but it drives home the point of when you have only one subproblem.

185
00:10:09,230 --> 00:10:12,610
How many people have seen binary search before?

186
00:10:12,610 --> 00:10:15,810
Anyone hasn't? One, OK.

187
00:10:15,810 --> 00:10:18,070
I will go very quickly then.

188
00:10:18,070 --> 00:10:19,560
You have some element x.

189
00:10:19,560 --> 00:10:24,150
You want to find x in a sorted array.

190
00:10:27,140 --> 00:10:30,130
How many people had not seen it before they saw it in recitation?

191
00:10:30,130 --> 00:10:31,550
No one, OK. Good.

192
00:10:31,550 --> 00:10:33,620
You have seen it in another class,

193
00:10:33,620 --> 00:10:34,910
probably 6.001 or something.

194
00:10:34,910 --> 00:10:36,550
Very good. You took the prerequisites.

195
00:10:36,890 --> 00:10:41,400
OK. I just want to phrase it as a divide-and-conquer

196
00:10:41,400 --> 00:10:43,150
because you don't normally see it that way.

197
00:10:43,150 --> 00:10:51,890
The divide step is you compare x with the middle element in your array.

198
00:10:52,000 --> 00:10:54,190
Then the conquer step.

199
00:10:54,190 --> 00:10:57,880
Here is your array. Here is the middle element.

200
00:10:57,880 --> 00:10:59,750
You compare x with this thing

201
00:10:59,750 --> 00:11:03,750
if let's say x is smaller than the middle element in your array.

202
00:11:03,750 --> 00:11:05,960
You know that x is in the left half

203
00:11:05,960 --> 00:11:08,290
because it is sorted,

204
00:11:08,290 --> 00:11:10,840
a nice loop invariant there, whatever,

205
00:11:10,840 --> 00:11:13,160
but we are just going to think of that as recursively

206
00:11:13,160 --> 00:11:17,020
I am going to solve the problem of finding x in this subarray.

207
00:11:18,550 --> 00:11:22,320
We recurse in one subarray,

208
00:11:22,320 --> 00:11:26,370
unlike merge sort where we had two recursions.

209
00:11:26,370 --> 00:11:33,040
And then the combined step we don't do anything.

210
00:11:37,180 --> 00:11:39,040
I mean if you find x in here

211
00:11:39,040 --> 00:11:42,190
then you've found x in the whole array.

212
00:11:42,190 --> 00:11:45,600
There is nothing to bring it back up really.

213
00:11:45,600 --> 00:11:52,930
So, this is just phrasing binary search as in the divide-and-conquer paradigm.

214
00:11:52,930 --> 00:11:54,180
It is kind of a trivial example,

215
00:11:54,180 --> 00:11:55,600
but there are lots of circumstances

216
00:11:55,600 --> 00:11:57,860
where you only need to recurse in one side.

217
00:11:57,860 --> 00:11:59,780
And it is important to see

218
00:11:59,780 --> 00:12:06,040
how much of a difference making one recursion versus making two recursions can be.

219
00:12:06,040 --> 00:12:12,760
This is the recurrence for binary search.

220
00:12:12,760 --> 00:12:14,240
We start with a problem size n.

221
00:12:14,240 --> 00:12:15,320
We reduce it to 1.

222
00:12:15,320 --> 00:12:17,970
There is an implicit 1 factor here.

223
00:12:17,970 --> 00:12:22,230
One subproblem of size n over 2.

224
00:12:22,230 --> 00:12:23,610
Roughly again, floors and ceilings don't matter.

225
00:12:23,610 --> 00:12:27,230
Plus a constant which is to compare x with the middle element,

226
00:12:27,230 --> 00:12:28,770
so it is actually like one comparison.

227
00:12:28,770 --> 00:12:36,720
This has a solution, log n.

228
00:12:36,720 --> 00:12:41,490
And you all know the running time of binary search,

229
00:12:41,490 --> 00:12:44,100
but here it is at solving the recurrence.

230
00:12:44,100 --> 00:12:46,000
I mean, there are a couple of differences here.

231
00:12:46,000 --> 00:12:48,330
We don't have the additive order n term.

232
00:12:48,330 --> 00:12:52,230
If we did, it would be linear, the running the time.

233
00:12:52,230 --> 00:12:53,640
Still better than n log n.

234
00:12:53,640 --> 00:12:56,660
So, we are getting rid of the 2, bringing it down to a 1,

235
00:12:56,660 --> 00:12:58,650
taking the n and bringing it down to a 1.

236
00:12:58,650 --> 00:13:01,410
That is making the running time a lot faster,

237
00:13:01,410 --> 00:13:02,480
the whole factor of n faster.

238
00:13:02,480 --> 00:13:03,540
No big surprise there.

239
00:13:03,540 --> 00:13:06,160
Let's do some more interesting algorithms.

240
00:13:16,370 --> 00:13:25,420
The powering a number problem is I give you a number x.

241
00:13:25,420 --> 00:13:30,600
I give that as like a real number or floating point number or whatever.

242
00:13:30,600 --> 00:13:39,030
And I give you an integer n, at least zero.

243
00:13:39,030 --> 00:13:41,810
I want to compute x to the power n.

244
00:13:45,960 --> 00:13:48,570
So, it's a very simple problem.

245
00:13:48,570 --> 00:13:51,200
It is, in some sense, even easier than all of these.

246
00:13:51,200 --> 00:13:52,720
But here it is.

247
00:13:52,720 --> 00:13:54,870
And divide-and-conquer is sort of the right thing to do.

248
00:13:54,870 --> 00:13:59,650
So, the naive algorithm is very simple.

249
00:13:59,650 --> 00:14:01,790
How do you compute x to the power n?

250
00:14:01,790 --> 00:14:04,070
Well, the definition of x to the power n is

251
00:14:04,070 --> 00:14:07,680
I take x and I multiply by x n times.

252
00:14:07,680 --> 00:14:15,020
So, I take x times x times x times x where there are n copies of x totally.

253
00:14:15,020 --> 00:14:17,080
And that's x to the n.

254
00:14:17,080 --> 00:14:19,500
No big surprise.

255
00:14:19,500 --> 00:14:22,800
That is n multiplications, or n minus 1 multiplications,

256
00:14:22,800 --> 00:14:24,560
theta n time.

257
00:14:32,210 --> 00:14:35,620
But that's not the best you can do for this problem.

258
00:14:35,620 --> 00:14:39,870
Any suggestions on what we might do using divide-and-conquer?

259
00:14:43,250 --> 00:14:46,760
Has anyone seen this algorithm before?

260
00:14:46,760 --> 00:14:51,500
A few, OK. For the rest?

261
00:14:53,110 --> 00:14:57,680
Testing on the spot creativity, which is very difficult,

262
00:14:57,680 --> 00:15:01,340
but I always like a challenge.

263
00:15:01,340 --> 00:15:02,630
I mean random ideas.

264
00:15:02,630 --> 00:15:08,810
What could we possibly do to solve this problem in less than linear time?

265
00:15:08,810 --> 00:15:10,780
How is this sort of a divide-and-conquer problem?

266
00:15:10,780 --> 00:15:14,110
We have two inputs, x and n. Yeah?

267
00:15:16,540 --> 00:15:18,860
We could try to divide on x.

268
00:15:18,860 --> 00:15:23,450
It seems a bit hard. It is just some number.

269
00:15:23,450 --> 00:15:25,340
Or, we could try to divide on n.

270
00:15:28,050 --> 00:15:29,200
Any guesses?

271
00:15:29,200 --> 00:15:32,870
Look at x to the n over 2, very good.

272
00:15:32,870 --> 00:15:37,000
That is exactly the idea of the divide-and-conquer algorithm.

273
00:15:46,430 --> 00:15:48,460
We would like to look at x to the n over 2.

274
00:15:48,460 --> 00:15:50,310
This is going to be a little bit tricky.

275
00:15:50,310 --> 00:15:52,410
Now we are going to have to pay attention to floors and ceilings.

276
00:15:52,410 --> 00:15:54,270
What I would like to say is

277
00:15:54,270 --> 00:15:57,590
while x to the n is x to the n over 2

278
00:15:57,600 --> 00:16:00,920
times x to the n over 2.

279
00:16:00,920 --> 00:16:04,350
And this is true if n is even.

280
00:16:07,170 --> 00:16:10,000
If it is odd then I need to be a little bit more careful.

281
00:16:10,000 --> 00:16:12,320
But let's just think about the intuition

282
00:16:12,320 --> 00:16:14,320
why this is a good divide-and-conquer algorithm.

283
00:16:14,320 --> 00:16:16,880
We have a problem of size n, let's say.

284
00:16:16,880 --> 00:16:21,930
We convert it into, it looks like two subproblems of size n over 2,

285
00:16:21,930 --> 00:16:24,310
but in fact they are the same subproblems.

286
00:16:24,310 --> 00:16:25,500
So, I only have to solve one of them.

287
00:16:25,500 --> 00:16:26,820
If I compute x to the n over 2.

288
00:16:26,820 --> 00:16:28,650
Yeah, I know x to the n over 2.

289
00:16:28,650 --> 00:16:32,130
So, there is one conversive call, problem of size n over 2,

290
00:16:32,130 --> 00:16:33,800
then I square that number.

291
00:16:33,800 --> 00:16:35,310
And that is one computation.

292
00:16:35,310 --> 00:16:38,070
So, exactly the same recurrence as binary search,

293
00:16:38,070 --> 00:16:40,300
log n time much better than n.

294
00:16:40,300 --> 00:16:41,460
Cool.

295
00:16:41,460 --> 00:16:44,350
I also have to solve the odd case.

296
00:16:44,860 --> 00:16:51,720
So, n is odd. I will look at n minus 1 over 2.

297
00:16:51,720 --> 00:16:54,270
N minus 1 better be even.

298
00:16:58,180 --> 00:17:01,760
And then I am missing another factor of x.

299
00:17:02,310 --> 00:17:03,700
If n is odd,

300
00:17:03,700 --> 00:17:07,730
I am going to have to do one recursive call and two multiplications.

301
00:17:07,730 --> 00:17:09,400
The same recurrence.

302
00:17:11,250 --> 00:17:16,410
One recursive problem of size n over 2, plus constant time.

303
00:17:16,410 --> 00:17:22,040
The dividing work here is dividing by 2

304
00:17:22,040 --> 00:17:25,920
and the combination work is doing one or possibly two multiplications.

305
00:17:25,920 --> 00:17:28,140
And this is lg n.

306
00:17:28,140 --> 00:17:32,850
And if all you are allowed to do is multiply numbers,

307
00:17:32,850 --> 00:17:35,130
lg n is the best you can do.

308
00:17:35,560 --> 00:17:41,140
Good. Simple but powerful.

309
00:17:42,280 --> 00:17:46,150
Whenever you want to compute a power of a number, now you know what to do.

310
00:17:53,010 --> 00:17:55,980
Does anyone not know the definition of Fibonacci numbers

311
00:17:55,980 --> 00:17:57,750
and is willing to admit it?

312
00:17:57,750 --> 00:18:00,590
OK, so this is a good old friend.

313
00:18:00,590 --> 00:18:03,700
I will write down the definition as just a reminder.

314
00:18:03,700 --> 00:18:05,280
And, in particular, the base cases.

315
00:18:15,430 --> 00:18:17,760
Fibonacci numbers, I will claim, are very important

316
00:18:17,760 --> 00:18:21,700
because it appears throughout nature.

317
00:18:21,700 --> 00:18:24,210
You look at certain fruits, you see the Fibonacci sequence.

318
00:18:24,210 --> 00:18:26,380
If you count the number of little bumps around each ring.

319
00:18:26,380 --> 00:18:28,550
If you look at the sand on the beach

320
00:18:28,550 --> 00:18:29,880
and how the waves hit it,

321
00:18:29,880 --> 00:18:31,790
it's the Fibonacci sequence I am told.

322
00:18:31,790 --> 00:18:34,800
If you look all over the place, Fibonacci sequence is there.

323
00:18:34,800 --> 00:18:39,590
How does nature compute the Fibonacci sequence?

324
00:18:39,600 --> 00:18:41,440
Well, that is a different class.

325
00:18:41,440 --> 00:18:45,880
But how are we going to compute the Fibonacci sequence as fast as possible?

326
00:18:45,880 --> 00:18:48,080
You have probably seen two algorithms.

327
00:18:48,080 --> 00:18:56,960
The most naive algorithm is the recursive algorithm.

328
00:19:00,930 --> 00:19:05,140
Where you say OK, f of n. I say well, if n is zero, return zero,

329
00:19:05,140 --> 00:19:06,220
if n is 1, return one.

330
00:19:06,220 --> 00:19:07,960
Otherwise, recursively compute

331
00:19:07,960 --> 00:19:11,230
f of n minus 1 and f of n minus 2,

332
00:19:11,230 --> 00:19:12,030
add them together.

333
00:19:12,640 --> 00:19:15,600
How much time does this algorithm take,

334
00:19:15,600 --> 00:19:17,910
for those who have seen it before?

335
00:19:17,910 --> 00:19:20,660
This is not obvious to guess.

336
00:19:20,660 --> 00:19:23,930
It doesn't have to be exact.

337
00:19:28,760 --> 00:19:32,460
OK. And how many people have seen this algorithm before and analyzed it?

338
00:19:32,460 --> 00:19:35,200
Half, OK. So what is the running time?

339
00:19:35,200 --> 00:19:37,880
Really, really long, very good.

340
00:19:37,880 --> 00:19:41,970
Anymore precise answers? What's that?

341
00:19:41,970 --> 00:19:44,550
Exponential, yes.

342
00:19:44,550 --> 00:19:49,340
That is also correct and more precise.

343
00:19:49,340 --> 00:19:51,190
I will be even more precise.

344
00:19:51,190 --> 00:19:52,920
Maybe you haven't seen this analysis before.

345
00:19:52,920 --> 00:19:55,600
It's phi to the n

346
00:19:55,600 --> 00:19:57,390
where phi is the Golden Ratio.

347
00:19:57,390 --> 00:20:02,330
Again, Golden Ratio appears throughout the world in mathematics.

348
00:20:02,330 --> 00:20:08,020
This is probably the only time in this class, I'm afraid, but there we go.

349
00:20:08,020 --> 00:20:10,360
It made its cameo so we are happy.

350
00:20:10,360 --> 00:20:13,110
This is called exponential time.

351
00:20:13,110 --> 00:20:17,270
This is bigger than one, that's all you need to know.

352
00:20:17,270 --> 00:20:19,200
This is exponential time.

353
00:20:19,200 --> 00:20:23,180
Exponential time means basically some constant to the power n.

354
00:20:24,050 --> 00:20:27,750
Exponential time is a very long time.

355
00:20:27,750 --> 00:20:34,040
It's bad. Polynomial time is good. [LAUGHTER]

356
00:20:34,040 --> 00:20:39,620
This is what we want, polynomial time algorithms.

357
00:20:39,620 --> 00:20:42,730
This class is basically entirely about polynomial time algorithms.

358
00:20:42,730 --> 00:20:43,730
Question?

359
00:20:45,210 --> 00:20:48,120
Oh, say what the algorithm does again.

360
00:20:48,120 --> 00:20:52,340
Define function Fibonacci of n?

361
00:20:52,340 --> 00:20:54,180
I check for the base cases.

362
00:20:54,180 --> 00:20:57,410
Otherwise, I recursively call Fibonacci of n minus 1.

363
00:20:57,410 --> 00:20:59,290
I recursively call Fibonacci of n minus 2

364
00:20:59,290 --> 00:21:00,370
and add those two numbers together.

365
00:21:00,370 --> 00:21:01,890
So, you get this branching tree.

366
00:21:01,890 --> 00:21:04,400
You are solving two subproblems of almost the same size,

367
00:21:04,400 --> 00:21:07,140
just additively smaller by one or two.

368
00:21:07,140 --> 00:21:10,700
I mean you are almost not reducing the problem size at all,

369
00:21:10,700 --> 00:21:13,230
so that's intuitively why it is exponential.

370
00:21:13,230 --> 00:21:15,200
You can draw a recursion tree

371
00:21:15,230 --> 00:21:17,200
and you will see how big it gets and how quickly.

372
00:21:17,200 --> 00:21:19,000
I mean by n over two levels,

373
00:21:19,000 --> 00:21:23,470
you've only reduced on one branch the problem from n to n over 2.

374
00:21:23,470 --> 00:21:26,830
The other one, maybe you've gotten from n down to one,

375
00:21:26,830 --> 00:21:29,650
but none of the branches have stopped after n of two levels.

376
00:21:29,650 --> 00:21:32,140
You have at least 2 to the power n over 2

377
00:21:32,140 --> 00:21:35,180
which is like square root of 2 to the power n,

378
00:21:35,180 --> 00:21:38,510
which is getting close to phi to the n.

379
00:21:38,510 --> 00:21:40,340
So, this is definitely exponential.

380
00:21:40,340 --> 00:21:43,450
And exponential is bad. We want polynomial.

381
00:21:43,450 --> 00:21:47,180
N squared, n cubed, log n would be nice.

382
00:21:47,180 --> 00:21:51,140
Anything that is bounded above by a polynomial is good.

383
00:21:51,140 --> 00:21:53,330
This is an old idea.

384
00:21:53,330 --> 00:21:57,200
It goes back to one of the main people

385
00:21:57,200 --> 00:21:58,980
who said polynomial is good,

386
00:21:58,980 --> 00:22:04,600
Jack Edmonds who is famous in the combinatorial optimization world.

387
00:22:04,600 --> 00:22:07,470
He is my academic grandfather on one side.

388
00:22:13,280 --> 00:22:17,930
He is a very interesting guy.

389
00:22:29,870 --> 00:22:32,860
OK, so that's a really bad algorithm.

390
00:22:32,870 --> 00:22:36,960
You have probably seen a somewhat better algorithm,

391
00:22:36,960 --> 00:22:40,410
which you might think of as the bottom-up implantation of that recursive algorithm.

392
00:22:47,020 --> 00:22:49,070
Or, another way to think of it is

393
00:22:49,070 --> 00:22:52,500
if you build out the recursion tree for Fibonacci of n,

394
00:22:52,500 --> 00:22:54,790
you will see that there are lots of common subtrees

395
00:22:54,790 --> 00:22:55,970
that you are just wasting time on.

396
00:22:55,970 --> 00:22:58,370
When you solve Fibonacci of n minus 1,

397
00:22:58,370 --> 00:23:00,370
it again solves Fibonacci of n minus 2.

398
00:23:00,370 --> 00:23:02,880
Why solve it twice? You only need to solve it once.

399
00:23:02,880 --> 00:23:06,120
So, it is really easy to do that if you do it bottom-up.

400
00:23:06,120 --> 00:23:09,500
But you could also do it recursively with some cache of things

401
00:23:09,500 --> 00:23:10,350
you have already computed.

402
00:23:14,760 --> 00:23:16,480
So, no big surprise.

403
00:23:16,480 --> 00:23:20,090
You compute the Fibonacci numbers in order.

404
00:23:20,090 --> 00:23:23,170
And each time, when you compute Fibonacci of n,

405
00:23:23,170 --> 00:23:25,880
let's say, you have already computed the previous two,

406
00:23:25,880 --> 00:23:27,590
you add them together, it takes constant time.

407
00:23:27,590 --> 00:23:33,270
So, the running time here is linear, linear in n,

408
00:23:33,270 --> 00:23:36,080
and as our input. Great.

409
00:23:36,080 --> 00:23:39,550
Is that the best we can do? No.

410
00:23:39,550 --> 00:23:46,970
Any ideas on how we could compute Fibonacci of n faster than linear time?

411
00:23:46,970 --> 00:23:51,670
Now we should diverge from what you have already seen, most of you.

412
00:23:51,670 --> 00:23:56,430
Any ideas using techniques you have already seen? Yes?

413
00:24:01,040 --> 00:24:05,590
Yes. We can use the mathematical trick of phi and psi to the nth powers.

414
00:24:05,590 --> 00:24:09,460
In fact, you can just use phi, phi, pi, pho, phum,

415
00:24:09,460 --> 00:24:12,060
whatever you want to call this Greek letter.

416
00:24:12,060 --> 00:24:17,100
Good. Here is the mathematical trick.

417
00:24:17,100 --> 00:24:18,980
And, indeed, this is cheating, as you have said.

418
00:24:18,980 --> 00:24:23,800
This is no good, but so it is. We will call it

419
00:24:23,800 --> 00:24:28,480
naive recursive squaring and say well, we know recursive squaring.

420
00:24:28,480 --> 00:24:30,780
Recursive squaring takes log n time.

421
00:24:30,780 --> 00:24:32,280
Let's use recursive squaring.

422
00:24:33,280 --> 00:24:36,370
And if you happen to know lots of properties of the Fibonacci numbers,

423
00:24:36,370 --> 00:24:37,440
you don't have to,

424
00:24:37,440 --> 00:24:39,400
but here is one of them.

425
00:24:39,600 --> 00:24:43,170
If you take phi to the n divided by root 5

426
00:24:43,170 --> 00:24:46,630
and you round it to the nearest integer

427
00:24:46,630 --> 00:24:49,070
that is the nth Fibonacci number.

428
00:24:55,840 --> 00:24:59,590
This is pretty cool. Fibonacci of n is basically phi to the n.

429
00:25:02,520 --> 00:25:06,440
We could apply recursive squaring

430
00:25:06,440 --> 00:25:08,090
to compute phi to the n in log n time,

431
00:25:08,090 --> 00:25:12,470
divide by root 5, assume that our computer has an operation

432
00:25:12,470 --> 00:25:15,260
that rounds a number to its nearest integer

433
00:25:15,260 --> 00:25:16,480
and poof, we are done.

434
00:25:19,270 --> 00:25:22,720
That doesn't work for many different reasons.

435
00:25:22,720 --> 00:25:24,620
On a real machine,

436
00:25:24,620 --> 00:25:27,430
probably you would represent phi and root 5 as floating point numbers

437
00:25:27,430 --> 00:25:30,420
which have some fixed amount of precise bits.

438
00:25:30,420 --> 00:25:31,850
And if you do this computation,

439
00:25:31,850 --> 00:25:33,700
you will lose some of the important bits.

440
00:25:33,700 --> 00:25:36,230
And when you round to the nearest integer you won't get the right answer.

441
00:25:36,230 --> 00:25:39,180
So, floating point round off will kill you on a floating point machine.

442
00:25:39,180 --> 00:25:42,690
On a theoretical machine where we magically have numbers

443
00:25:42,690 --> 00:25:44,690
that can do crazy things like this,

444
00:25:44,690 --> 00:25:49,590
I mean it really takes more than constant time per multiplication.

445
00:25:49,590 --> 00:25:51,160
So, we are sort of in a different model.

446
00:25:51,160 --> 00:25:54,160
You cannot multiply phi times phi in constant time.

447
00:25:54,160 --> 00:25:56,690
I mean that's sort of outside the boundaries of this course,

448
00:25:56,690 --> 00:25:58,300
but that's the way it is.

449
00:26:01,270 --> 00:26:04,380
In fact, in a normal machine,

450
00:26:04,380 --> 00:26:07,140
some problems you can only solve in exponential time.

451
00:26:07,140 --> 00:26:09,260
In a machine where you can multiply real numbers

452
00:26:09,260 --> 00:26:10,950
and round them to the nearest integers,

453
00:26:10,950 --> 00:26:12,350
you can solve them in polynomial time.

454
00:26:12,350 --> 00:26:13,770
So, it really breaks the model.

455
00:26:13,770 --> 00:26:15,890
You can do crazy things if you were allowed to do this.

456
00:26:15,890 --> 00:26:18,210
This is not allowed.

457
00:26:21,180 --> 00:26:24,020
And I am foreshadowing like three classes ahead,

458
00:26:24,020 --> 00:26:27,820
or three courses ahead, so I shouldn't talk more about it.

459
00:26:27,820 --> 00:26:31,430
But it turns out we can use recursive squaring in a different way

460
00:26:31,430 --> 00:26:36,570
if we use a different property of Fibonacci numbers.

461
00:26:36,570 --> 00:26:40,340
And then we will just stick with integers and everything will be happy.

462
00:26:41,470 --> 00:26:44,610
Don't forget to go to recitation and if you want to homework lab.

463
00:26:44,610 --> 00:26:47,590
Don't come here on Monday. That is required.

464
00:26:51,000 --> 00:26:55,670
This is sort of the right recursive squaring algorithm.

465
00:26:55,670 --> 00:26:58,080
And this is a bit hard to guess if you haven't already seen it,

466
00:26:58,080 --> 00:27:01,530
so I will just give it to you.

467
00:27:05,980 --> 00:27:08,130
turns out ...I will call this a theorem.

468
00:27:08,130 --> 00:27:12,250
It's the first time I get to use the word theorem in this class.

469
00:27:15,020 --> 00:27:20,820
It turns out the nth Fibonacci number is the nth power of this matrix.

470
00:27:21,310 --> 00:27:26,130
Cool. If you look at it a little bit you say oh, yeah, of course.

471
00:27:26,130 --> 00:27:27,950
And we will prove this theorem in a second.

472
00:27:27,950 --> 00:27:29,560
But once we have this theorem,

473
00:27:29,560 --> 00:27:33,840
we can compute f of n by computing the nth power of this matrix.

474
00:27:33,840 --> 00:27:35,030
It's a two-by-two matrix.

475
00:27:35,030 --> 00:27:37,040
You multiply two two-by-two matrixes together,

476
00:27:37,040 --> 00:27:38,550
you get a two-by-two matrix.

477
00:27:38,550 --> 00:27:40,720
So that is constant size, four numbers.

478
00:27:40,720 --> 00:27:42,320
I can handle four numbers.

479
00:27:42,320 --> 00:27:46,210
We don't have crazy precision problems on the floating point side.

480
00:27:46,210 --> 00:27:47,650
There are only four numbers to deal with.

481
00:27:47,650 --> 00:27:49,320
Matrixes aren't getting bigger.

482
00:27:49,320 --> 00:27:52,200
So, the running time of this divide-and-conquer algorithm

483
00:27:52,200 --> 00:27:53,640
will still be log n

484
00:27:53,640 --> 00:27:58,090
because it takes a constant time per two-by-two matrix multiplication. Yes?

485
00:28:01,610 --> 00:28:05,570
Oh, yes. Thank you. I have a type error.

486
00:28:06,000 --> 00:28:13,230
Sorry about that. F of n is indeed the upper left corner, I hope.

487
00:28:13,230 --> 00:28:18,440
I better check I don't have it off by one. I do.

488
00:28:18,440 --> 00:28:21,800
It's F_n upper right corner, indeed. That's what you said.

489
00:28:22,650 --> 00:28:27,060
F of n. I need more space. Sorry.

490
00:28:31,550 --> 00:28:35,070
I really ought to have a two-by-two matrix on the left-hand side there.

491
00:28:35,070 --> 00:28:36,570
Thank you.

492
00:28:39,280 --> 00:28:45,890
So, I compute this nth power of a matrix in log n time,

493
00:28:45,890 --> 00:28:49,180
I take the upper right corner or the lower left corner, your choice,

494
00:28:49,180 --> 00:28:51,250
that is the nth Fibonacci number.

495
00:28:51,250 --> 00:28:55,290
This implies an order log n time algorithm

496
00:28:55,290 --> 00:28:58,360
with the same recurrence as the last two,

497
00:28:58,360 --> 00:29:02,780
binary search and really the recursive squaring algorithm.

498
00:29:02,780 --> 00:29:05,070
It is log n plus a constant, so log n.

499
00:29:05,070 --> 00:29:08,630
Let's prove that theorem.

500
00:29:28,950 --> 00:29:32,420
Any suggestions on what techniques we might use for proving this theorem,

501
00:29:32,420 --> 00:29:35,380
or what technique, singular?

502
00:29:37,730 --> 00:29:39,760
Induction, very good.

503
00:29:39,760 --> 00:29:43,010
I think any time I ask that question the answer is induction.

504
00:29:43,010 --> 00:29:48,360
Hint for the future in this class.

505
00:29:52,640 --> 00:29:53,350
A friend of mine,

506
00:29:53,350 --> 00:29:56,270
when he took an analysis class, whenever the professor asked,

507
00:29:56,270 --> 00:29:58,840
and what is the answer to this question, the answer was always zero.

508
00:29:58,990 --> 00:30:02,580
If you have taken analysis class that is funny. [LAUGHTER]

509
00:30:04,760 --> 00:30:06,690
Maybe I will try to ask some questions

510
00:30:06,690 --> 00:30:12,390
whose answers are zero just for our own amusement.

511
00:30:12,390 --> 00:30:17,140
We are going to induct on n. It's pretty much the obvious thing to do.

512
00:30:17,140 --> 00:30:19,860
But we have to check some cases.

513
00:30:19,860 --> 00:30:24,950
So, the base case is we have this to the first power.

514
00:30:24,950 --> 00:30:28,150
And that is itself [(1, 1), (1, 0)].

515
00:30:28,150 --> 00:30:31,500
And I should have said n is at least 1.

516
00:30:31,500 --> 00:30:33,850
And you can check.

517
00:30:33,850 --> 00:30:38,690
This is supposed to be F_2, F_1, F_1, F_0.

518
00:30:38,690 --> 00:30:43,440
And you can check it is, F_0 is 0, F_1 is 1 and F_2 is 1. Good.

519
00:30:43,440 --> 00:30:50,450
Base case is correct, step case is about as exciting,

520
00:30:50,450 --> 00:30:53,430
but you've got to prove that your algorithm works.

521
00:30:56,320 --> 00:31:02,820
Suppose this is what we want to compute.

522
00:31:05,160 --> 00:31:14,850
I am just going to sort of, well, there are many ways I can do this.

523
00:31:14,850 --> 00:31:18,470
I will just do it the fast way because it's really not that exciting.

524
00:31:18,470 --> 00:31:22,570
Which direction? Let's do this direction.

525
00:31:22,570 --> 00:31:25,610
I want to use induction on n.

526
00:31:25,610 --> 00:31:28,410
If I want to use induction on n,

527
00:31:28,410 --> 00:31:31,440
presumably I should use what I already know is true.

528
00:31:31,440 --> 00:31:35,020
If I decrease n by 1, I have this property

529
00:31:35,020 --> 00:31:39,280
that this thing is going to be [(1, 1), (1, 0)] to the power n minus 1.

530
00:31:39,280 --> 00:31:44,240
This I already know, by the induction hypothesis,

531
00:31:44,240 --> 00:31:46,490
[(1, 1), (1, 0)] to the n minus 1.

532
00:31:46,490 --> 00:31:48,440
So, presumably I should use it in some way.

533
00:31:48,440 --> 00:31:51,880
This equality is not yet true, you may have noticed.

534
00:31:51,880 --> 00:31:54,060
So, I need to add something on.

535
00:31:54,060 --> 00:31:57,320
What could I possibly add on to be correct?

536
00:31:57,320 --> 00:31:59,910
Well, another factor of [(1, 1), (1, 0)].

537
00:31:59,910 --> 00:32:06,720
The way I am developing this proof is the only way it could possibly be,

538
00:32:06,720 --> 00:32:08,010
in some sense.

539
00:32:08,010 --> 00:32:09,980
If you know its induction, this is all that you could do.

540
00:32:09,980 --> 00:32:13,970
And then you check. Indeed, this equality holds conveniently.

541
00:32:13,970 --> 00:32:18,020
For example, F_(n plus 1) is the product of these two things.

542
00:32:18,020 --> 00:32:20,880
It is this row times this column.

543
00:32:21,050 --> 00:32:24,140
So, it is F_n times 1 plus F_(n minus 1) times 1,

544
00:32:24,140 --> 00:32:26,280
which is indeed the definition of F_(n plus 1).

545
00:32:26,410 --> 00:32:28,200
And you could check four of the entries.

546
00:32:28,200 --> 00:32:30,000
This is true. Great.

547
00:32:30,000 --> 00:32:34,530
If that is true then I would just put these together.

548
00:32:34,530 --> 00:32:37,370
That is [(1, 1), (1, 0)] to the n minus 1

549
00:32:37,380 --> 00:32:39,420
times [(1, 1), (1, 0)],

550
00:32:39,420 --> 00:32:43,720
which is [(1, 1), (1, 0)] to the n, end of proof.

551
00:32:43,720 --> 00:32:44,950
A very simple proof,

552
00:32:44,950 --> 00:32:49,600
but you have to do that in order to know if this algorithm really works.

553
00:32:51,130 --> 00:32:56,120
Good. Question?

554
00:33:00,260 --> 00:33:01,590
Oh, yes. Thank you.

555
00:33:01,590 --> 00:33:06,210
This, in the lower right, we should have F_(n minus 1).

556
00:33:06,210 --> 00:33:08,710
This is why you should really check your proofs.

557
00:33:08,710 --> 00:33:10,240
We would have discovered that

558
00:33:10,240 --> 00:33:13,880
when I checked that this was that row times that column,

559
00:33:13,880 --> 00:33:18,740
but that is why you are here, to fix my bugs.

560
00:33:18,740 --> 00:33:23,170
That's the great thing about being up here instead of in a quiz.

561
00:33:25,020 --> 00:33:26,550
But that is a minor mistake.

562
00:33:26,550 --> 00:33:29,610
You wouldn't lose much for that.

563
00:33:29,610 --> 00:33:36,220
All right. More divide-and-conquer algorithms.

564
00:33:36,220 --> 00:33:39,220
Still, we have done relatively simple ones so far.

565
00:33:39,220 --> 00:33:42,480
In fact, the fanciest has been merge sort, which we already saw.

566
00:33:42,480 --> 00:33:43,670
So, that is not too exciting.

567
00:33:43,670 --> 00:33:45,310
The rest have all be log n time.

568
00:33:45,310 --> 00:33:49,370
Let's break out of the log n world.

569
00:33:49,370 --> 00:33:53,360
Well, you all have the master method memorized, right,

570
00:33:53,360 --> 00:33:55,680
so I can erase that.

571
00:33:55,680 --> 00:34:02,450
Good. This will be a good test.

572
00:34:02,450 --> 00:34:04,590
Next problem is matrix multiplication,

573
00:34:04,590 --> 00:34:07,830
following right up on this two-by-two matrix multiplication.

574
00:34:07,830 --> 00:34:12,440
Let's see how we can compute n-by-n matrix multiplications.

575
00:34:12,440 --> 00:34:17,170
Just for a recap, you should know how to multiply matrixes,

576
00:34:17,170 --> 00:34:21,010
but here is the definition, so we can turn it into an algorithm.

577
00:34:21,010 --> 00:34:24,490
You have two matrixes, A and B, which are capital levels.

578
00:34:24,490 --> 00:34:29,540
The ijth entry. Ith row, jth column is called little aij

579
00:34:29,540 --> 00:34:31,810
or little bij.

580
00:34:31,810 --> 00:34:35,300
And your goal is to compute the products of those matrixes.

581
00:34:35,300 --> 00:34:41,330
I should probably say that i and j range from 1 to n.

582
00:34:42,860 --> 00:34:44,940
So, they are square matrixes.

583
00:34:44,940 --> 00:34:47,870
The output is to compute C

584
00:34:47,870 --> 00:34:54,060
which has entry cij which is the product of A and B.

585
00:34:54,530 --> 00:35:01,030
And, for a recap, the ijth entry of the product is

586
00:35:01,030 --> 00:35:07,630
the inner product of the ith row of A with the jth column of B.

587
00:35:07,920 --> 00:35:13,300
But you can write that out as a sum like so.

588
00:35:13,300 --> 00:35:20,550
We want to compute this thing for every i and j.

589
00:35:20,550 --> 00:35:23,290
What is the obvious algorithm for doing this?

590
00:35:23,290 --> 00:35:28,170
Well, for every i and j you compute the sum.

591
00:35:28,170 --> 00:35:29,240
You compute all the products.

592
00:35:29,240 --> 00:35:30,070
You compute the sum.

593
00:35:30,070 --> 00:35:32,340
So, it's like n operations here roughly.

594
00:35:32,340 --> 00:35:34,020
I mean like 2n minus 1, whatever.

595
00:35:34,020 --> 00:35:36,450
It is order n operations.

596
00:35:36,450 --> 00:35:39,350
There are n² entries of C that I need to compute,

597
00:35:39,350 --> 00:35:41,220
so that's n³ time.

598
00:35:41,220 --> 00:35:45,500
I will write this out just for the programmers at heart.

599
00:35:51,080 --> 00:35:52,330
Here is the pseudocode.

600
00:35:52,340 --> 00:35:54,370
It's rare that I will write pseudocode.

601
00:35:54,380 --> 00:35:58,250
And this is a simple enough algorithm that I can write it in gory detail.

602
00:35:59,170 --> 00:36:05,130
But it gives you some basis for this analysis if you like to program.

603
00:36:05,130 --> 00:36:07,820
It is a triply nested for loop.

604
00:36:07,820 --> 00:36:16,780
And I made a coding error.

605
00:36:16,780 --> 00:36:20,970
Hopefully you haven't written that far yet.

606
00:36:20,970 --> 00:36:23,310
I need cij to be initialized to zero.

607
00:36:23,310 --> 00:36:32,180
And then I add to cij the appropriate product, a_ik, b_kj.

608
00:36:32,180 --> 00:36:36,410
That is the algorithm.

609
00:36:36,410 --> 00:36:39,510
And the point is you have a nesting of n for loops

610
00:36:39,510 --> 00:36:41,550
from 1 to n. That takes n³ time

611
00:36:41,550 --> 00:36:43,910
because this is constant and that is constant.

612
00:36:44,070 --> 00:36:48,780
So, very simple, n³. Let's do better.

613
00:36:55,670 --> 00:36:58,190
And, of course, we are going to use divide-and-conquer.

614
00:37:02,440 --> 00:37:04,680
Now, how are we going to divide a matrix?

615
00:37:04,680 --> 00:37:09,210
There are a lot of numbers in a matrix, n² of them in each one.

616
00:37:09,210 --> 00:37:11,000
There are all sorts of ways you could divide.

617
00:37:11,000 --> 00:37:13,070
So far all of the divide-and-conquers

618
00:37:13,070 --> 00:37:15,360
we have done have been problems of size n into

619
00:37:15,360 --> 00:37:17,450
some number of problems of size n over 2.

620
00:37:17,450 --> 00:37:21,720
I am going to say I start with some matrixes of size n-by-n.

621
00:37:21,720 --> 00:37:25,870
I want to convert it down to something like n/2-by-n/2.

622
00:37:25,870 --> 00:37:28,070
Any suggestions how I might do that?

623
00:37:28,070 --> 00:37:33,780
Yeah? Block form the matrix, indeed.

624
00:37:33,780 --> 00:37:35,250
That is the right answer.

625
00:37:35,250 --> 00:37:38,560
So, this is the first divide-and-conquer algorithm.

626
00:37:38,560 --> 00:37:43,850
This will not work, but it has the first idea that we need.

627
00:37:43,850 --> 00:37:48,430
We have a n-by-n matrix.

628
00:37:48,430 --> 00:37:52,310
We can view it, this equality is more, you can think of it as,

629
00:37:52,310 --> 00:37:56,490
it's really the thing, a two-by-two block matrix

630
00:37:59,690 --> 00:38:03,610
where each entry in this two-by-two block matrix

631
00:38:03,610 --> 00:38:09,090
is a block of n/2-by-n/2 submatrixes.

632
00:38:19,960 --> 00:38:28,810
I will think of C as being divided into three parts, r, s, t and u.

633
00:38:28,810 --> 00:38:32,840
Even though I write them as lower case letters they are really matrixes.

634
00:38:32,840 --> 00:38:35,140
Each is n/2-by-n/2.

635
00:38:35,140 --> 00:38:42,940
And A, I will split into a, b, c, d,

636
00:38:42,950 --> 00:38:49,930
times B, I will split into e, f, g, h.

637
00:38:52,760 --> 00:38:55,370
Why not? This is certainly true.

638
00:38:55,370 --> 00:38:56,980
And if you've seen some linear algebra,

639
00:38:56,980 --> 00:38:59,690
this is basically what you can do with matrixes.

640
00:38:59,690 --> 00:39:03,680
Now I can pretend these are two-by-two and sort of forget the fact

641
00:39:03,680 --> 00:39:06,900
that these little letters are matrixes and say well,

642
00:39:06,900 --> 00:39:11,170
r is the inner product of this row with this column.

643
00:39:11,170 --> 00:39:14,060
It is ae times bg.

644
00:39:14,070 --> 00:39:17,750
Let me not cheat or else it will be too easy.

645
00:39:17,750 --> 00:39:46,680
r=ae+bg, s=af+bh, t=ce+dg and u=cf+dh.

646
00:39:46,680 --> 00:39:48,800
It's nothing like making it too hard on yourself.

647
00:39:48,800 --> 00:39:52,630
OK, got them right. Good.

648
00:39:52,630 --> 00:39:57,010
I mean this is just a fact about how you would expand out this product.

649
00:39:57,010 --> 00:39:59,240
And so now we have a recursive algorithm.

650
00:39:59,240 --> 00:40:01,000
In fact, we have a divide-and-conquer algorithm.

651
00:40:01,000 --> 00:40:03,630
We start with our n-by-n matrix.

652
00:40:03,630 --> 00:40:06,560
Well, we have two of them actually.

653
00:40:06,780 --> 00:40:14,570
We divide it into eight little pieces, a, b, c, d, e, f, g, h.

654
00:40:14,570 --> 00:40:18,510
Then we compute these things and that gives us C,

655
00:40:18,510 --> 00:40:20,160
just by sticking them together.

656
00:40:20,160 --> 00:40:22,580
Now, how do we compute these things?

657
00:40:22,580 --> 00:40:25,240
Well, these innocent-looking little products

658
00:40:25,240 --> 00:40:26,320
between these two little numbers

659
00:40:26,320 --> 00:40:28,970
are actually recursive matrix multiplications.

660
00:40:28,970 --> 00:40:32,960
Because each of these little letters is an n/2-by-n/2 matrix

661
00:40:32,960 --> 00:40:34,920
so I have to recursively compute the product.

662
00:40:34,920 --> 00:40:49,950
There are like eight recursive multiplications of n/2-by-n/2 matrixes.

663
00:40:49,950 --> 00:40:53,870
That is what bites us.

664
00:40:53,870 --> 00:40:55,820
And then there are like four additions,

665
00:40:55,820 --> 00:40:58,950
plus minor work of gluing things together.

666
00:41:03,080 --> 00:41:08,490
How long does it take to add two matrixes together?

667
00:41:08,490 --> 00:41:12,260
n². This is cheap.

668
00:41:12,260 --> 00:41:13,890
It just takes n².

669
00:41:13,890 --> 00:41:17,660
Remember, we are trying to beat n³ for our matrix multiplication.

670
00:41:17,660 --> 00:41:18,910
Addition is a really easy problem.

671
00:41:18,910 --> 00:41:20,190
You just have to add every number.

672
00:41:20,190 --> 00:41:21,980
There is no way you can do better than n².

673
00:41:21,980 --> 00:41:24,520
So, that is not recursive. That is the nice thing.

674
00:41:24,520 --> 00:41:28,380
But the bad thing is we have eight of these recursions.

675
00:41:38,850 --> 00:41:43,090
And I have erased the master method, but you should all have it memorized.

676
00:41:43,090 --> 00:41:45,480
What is the solution to this recurrence?

677
00:41:56,260 --> 00:42:01,650
All right. A is 8, b is 2, log base 2 of 8 is 3.

678
00:42:01,650 --> 00:42:03,570
Every computer scientist should know that.

679
00:42:03,570 --> 00:42:06,180
n^log_b(a)=n³.

680
00:42:03,570 --> 00:42:06,180
n^logb(a)=n³

681
00:42:06,180 --> 00:42:08,210
That is polynomially larger than n²,

682
00:42:08,210 --> 00:42:11,600
so we are in Case 1.

683
00:42:11,600 --> 00:42:16,460
Thank you. Let's get them upside down.

684
00:42:16,460 --> 00:42:20,440
This is n³, no better than our previous algorithm.

685
00:42:20,440 --> 00:42:21,860
That kind of sucks.

686
00:42:26,000 --> 00:42:31,930
And now comes the divine inspiration. Let's go over here.

687
00:42:38,860 --> 00:42:41,860
There are some algorithms like this Fibonacci algorithm

688
00:42:41,860 --> 00:42:43,360
where if you sat down for a little while,

689
00:42:43,360 --> 00:42:46,860
it's no big deal, you would figure it out.

690
00:42:46,860 --> 00:42:50,230
I mean it is kind of clever to look at that matrix

691
00:42:50,230 --> 00:42:52,120
and then everything works happily.

692
00:42:52,120 --> 00:42:56,460
It is not obvious but it is not that amazingly clever.

693
00:42:56,460 --> 00:42:59,090
This is an algorithm that is amazingly clever.

694
00:42:59,090 --> 00:43:02,340
You may have seen it before which steals the thunder a little bit,

695
00:43:02,340 --> 00:43:06,270
but it is still really, really cool so you should be happy to see it again.

696
00:43:09,720 --> 00:43:12,540
And how Strassen came up with this algorithm,

697
00:43:12,540 --> 00:43:14,880
he must have been very clever.

698
00:43:17,940 --> 00:43:23,540
The idea is we've got to get rid of these multiplications.

699
00:43:23,540 --> 00:43:26,320
I don't really care. I could do a hundred additions.

700
00:43:27,760 --> 00:43:31,630
I have to reduce this 8 to something smaller. It turns out,

701
00:43:31,630 --> 00:43:34,780
if you try to split the matrices into three-by-three or something,

702
00:43:34,780 --> 00:43:35,640
that doesn't help you.

703
00:43:35,640 --> 00:43:37,280
You get the same problem

704
00:43:37,280 --> 00:43:39,830
because we're using fundamentally the same algorithm,

705
00:43:39,830 --> 00:43:41,120
just in a different order.

706
00:43:41,120 --> 00:43:44,290
We have got to somehow reduce the number of multiplications.

707
00:43:50,150 --> 00:43:52,230
We are going to reduce it to 7.

708
00:43:54,290 --> 00:43:57,270
The claim is that if we have two two-by-two matrices

709
00:43:57,270 --> 00:44:00,370
we can take their product using seven multiplications.

710
00:44:00,370 --> 00:44:01,190
If that were true,

711
00:44:01,190 --> 00:44:05,600
we would reduce the 8 to a 7 and presumably make things run faster.

712
00:44:05,600 --> 00:44:07,530
We will see how fast in a moment.

713
00:44:07,530 --> 00:44:10,080
You can compute it in your head.

714
00:44:10,080 --> 00:44:12,490
If you are bored and like computing logs

715
00:44:12,490 --> 00:44:16,680
that are non-integral logs then go ahead.

716
00:44:16,680 --> 00:44:20,370
All right. Here we are.

717
00:44:20,410 --> 00:44:27,710
This algorithm is unfortunately rather long,

718
00:44:27,710 --> 00:44:30,770
but it is only seven multiplications.

719
00:44:43,710 --> 00:44:47,480
Each of these P's is a product of two things

720
00:44:47,480 --> 00:44:52,530
which only involves addition or subtraction, the same thing.

721
00:45:36,530 --> 00:45:39,280
Those are seven multiplications.

722
00:45:39,280 --> 00:45:44,170
And I can compute those in 7T(n/2).

723
00:45:44,170 --> 00:45:49,950
Oh, indeed it is. Six was wrong.

724
00:45:49,950 --> 00:45:54,010
Six and seven are the same, very good.

725
00:45:54,010 --> 00:45:55,730
You know, you think that

726
00:45:55,730 --> 00:45:58,470
copying something would not be such a challenging task.

727
00:45:59,960 --> 00:46:04,690
But when you become an absent-minded professor like me

728
00:46:04,690 --> 00:46:07,000
then you will know how easy it is.

729
00:46:07,000 --> 00:46:10,730
OK. We have them all correct, hopefully.

730
00:46:10,730 --> 00:46:13,680
We continue. That wasn't enough.

731
00:46:13,680 --> 00:46:14,880
Of course we had seven things.

732
00:46:14,880 --> 00:46:17,690
Clearly we have to reduce this down to four things,

733
00:46:17,700 --> 00:46:18,900
the elements of C.

734
00:46:18,900 --> 00:46:21,460
Here they are, the elements of C, r, s, t, u.

735
00:46:21,460 --> 00:46:27,360
It turns out r=P5+P4-P2+P6.

736
00:46:27,360 --> 00:46:30,060
Of course. Didn't you all see that?

737
00:46:30,060 --> 00:46:35,030
I mean this one is really easy, s=P1+P2.

738
00:46:35,030 --> 00:46:37,510
t=P3+P4.

739
00:46:35,030 --> 00:46:37,510
t=P₃+P₄

740
00:46:37,510 --> 00:46:39,020
I mean that is clearly how they were chosen.

741
00:46:39,020 --> 00:46:44,250
And then u is another tricky one,

742
00:46:44,250 --> 00:46:46,700
u=P5+P1-P3-P7.

743
00:46:44,250 --> 00:46:46,700
u=P₅+P₁-P₃-P₇

744
00:46:46,700 --> 00:46:53,910
OK. Now, which one of these would you like me to check?

745
00:46:55,060 --> 00:46:58,280
Don't be so nice. How about s?

746
00:46:58,280 --> 00:47:00,310
I can show you s is right.

747
00:47:01,690 --> 00:47:08,760
Any preferences? u. Oh, no, sign errors.

748
00:47:08,760 --> 00:47:10,920
OK. Here we go.

749
00:47:10,920 --> 00:47:12,180
The claim that this really works is

750
00:47:12,180 --> 00:47:13,690
you have to check all four of them.

751
00:47:13,690 --> 00:47:16,320
And I did in my notes.

752
00:47:17,720 --> 00:47:28,690
u=P5. P5=(ae + ah + de + dh).

753
00:47:17,720 --> 00:47:28,690
u=P₅=(ae+ah+de+dh)

754
00:47:29,020 --> 00:47:31,190
That is P_5. Check me.

755
00:47:31,190 --> 00:47:33,580
If I screw up, I am really hosed.

756
00:47:33,580 --> 00:47:37,610
(af - ah)=P1.

757
00:47:37,610 --> 00:47:46,000
P3 has a minus sign in front, so that is (ce + de).

758
00:47:46,000 --> 00:47:49,030
And then we have minus P_7,

759
00:47:49,030 --> 00:47:57,700
which is a big one, (ae+af-ce-cf).

760
00:47:58,060 --> 00:48:00,780
OK. Now I need like the assistant

761
00:48:00,780 --> 00:48:03,510
that crosses off things in parallel like the movie, right?

762
00:48:05,760 --> 00:48:26,830
ah, de, af, ce, ae, thank you,

763
00:48:05,760 --> 00:48:26,830
ah de af ce ae

764
00:48:26,830 --> 00:48:35,540
and hopefully these survive, dh minus minus cf.

765
00:48:35,540 --> 00:48:40,080
And, if we are lucky, that is exactly what is written here,

766
00:48:40,080 --> 00:48:41,610
except in the opposite order.

767
00:48:42,240 --> 00:48:46,920
Magic, right? Where the hell did Strassen get this?

768
00:48:46,920 --> 00:48:48,910
You have to be careful.

769
00:48:48,910 --> 00:48:52,870
It is OK that the plus is in the wrong order because plus is commutative,

770
00:48:52,870 --> 00:48:55,380
but the multiplications better not be in the wrong order

771
00:48:55,380 --> 00:48:57,910
because multiplication over matrixes is not commutative.

772
00:48:57,910 --> 00:49:02,100
I check cf, OK, dh, they are in the right order.

773
00:49:02,100 --> 00:49:06,480
I won't check the other three.

774
00:49:06,480 --> 00:49:10,630
That is matrix multiplication in hopefully subcubic time.

775
00:49:10,630 --> 00:49:12,020
Let's write down the recurrence.

776
00:49:12,020 --> 00:49:14,140
T(n) is now 7.

777
00:49:14,140 --> 00:49:19,460
Maybe I should write down the algorithm for kicks.

778
00:49:19,460 --> 00:49:26,230
Why not? Assuming I have time.

779
00:49:28,470 --> 00:49:37,980
Lots of time. Last lecture I was ten minutes early.

780
00:49:37,980 --> 00:49:40,180
I apologize for that. I know it really upsets you.

781
00:49:37,980 --> 00:49:37,370
I ended ten minutes early.

782
00:49:40,180 --> 00:49:43,500
And I didn't realize exactly when the class was supposed to end.

783
00:49:43,500 --> 00:49:46,140
So, today, I get to go ten minutes late.

784
00:49:46,140 --> 00:49:48,860
OK. Good. I'm glad you all agree.

785
00:49:48,860 --> 00:49:51,470
I am kidding. Don't worry. OK.

786
00:49:51,470 --> 00:49:56,180
Algorithm. This is Strassen.

787
00:49:56,180 --> 00:50:04,340
First we divide, then we conquer and then we combine.

788
00:50:04,340 --> 00:50:10,620
As usual, I don't have it written anywhere here. Fine.

789
00:50:10,620 --> 00:50:15,660
Divide A and B. This is sort of trivial.

790
00:50:18,240 --> 00:50:35,130
Then we compute the terms -- -- for the products.

791
00:50:35,130 --> 00:50:39,650
This means we get ready to compute all the P's.

792
00:50:39,650 --> 00:50:45,150
We compute a+b, c+d, g-e, a+d, e+h and so on.

793
00:50:45,150 --> 00:50:47,850
All of the terms that appear in here, we compute those.

794
00:50:47,850 --> 00:50:49,580
That takes n2 time

795
00:50:49,580 --> 00:50:54,020
because it is just a bunch of additions and subtractions.

796
00:50:54,020 --> 00:50:57,610
No big deal. A constant number of them.

797
00:50:57,610 --> 00:51:06,960
Then we conquer by recursively computing all the Pi's.

798
00:51:06,960 --> 00:51:12,300
That is each our product of seven of them.

799
00:51:12,300 --> 00:51:18,860
We have P1, P2 up to P7

800
00:51:18,860 --> 00:51:28,760
And, finally, we combine, which is to compute r, s, t and u.

801
00:51:33,730 --> 00:51:36,810
And those are just additions and subtractions again,

802
00:51:36,810 --> 00:51:38,550
so they take n² times.

803
00:51:38,550 --> 00:51:42,340
So, here we finally get an algorithm

804
00:51:42,340 --> 00:51:45,250
that is nontrivial both in dividing and in combining.

805
00:51:45,250 --> 00:51:47,260
Recursion is always recursion,

806
00:51:47,260 --> 00:51:49,700
but now we have interesting steps one and three.

807
00:51:49,700 --> 00:51:55,160
The recurrence T(n) is seven recursive subproblems,

808
00:51:55,160 --> 00:51:57,570
each are size n/2

809
00:51:57,570 --> 00:52:00,200
plus order n²,

810
00:52:00,200 --> 00:52:02,980
to do all this addition work.

811
00:52:02,980 --> 00:52:06,570
Now we need to solve this recurrence.

812
00:52:06,570 --> 00:52:09,490
We compute n^logb(a),

813
00:52:09,490 --> 00:52:12,610
which here is nlog2(7).

814
00:52:12,610 --> 00:52:18,600
And we know log base 2 of 8 is 3.

815
00:52:18,600 --> 00:52:21,660
Log base 2 of 7 is going be a little bit less than 3

816
00:52:21,660 --> 00:52:23,560
but still bigger than 2

817
00:52:23,560 --> 00:52:26,310
because log base 2 of 4 is 2.

818
00:52:26,310 --> 00:52:30,570
So, it is going to be polynomially larger than n²

819
00:52:30,580 --> 00:52:33,420
but polynomially smaller than n³.

820
00:52:33,420 --> 00:52:35,460
We are again in Case 1.

821
00:52:35,460 --> 00:52:37,210
And this is the cheating way

822
00:52:37,210 --> 00:52:41,190
to write n log base 2 of 7, nlg7.

823
00:52:41,190 --> 00:52:42,920
lg means log base 2.

824
00:52:42,920 --> 00:52:43,780
You should know that.

825
00:52:43,780 --> 00:52:48,980
It is all over the textbook and in our problem sets and what not, nlg7.

826
00:52:48,980 --> 00:52:54,210
And, in particular, if I have my calculator here.

827
00:53:00,780 --> 00:53:04,080
This is a good old-fashion calculator.

828
00:53:08,080 --> 00:53:11,570
No, that is wrong. Sorry.

829
00:53:13,570 --> 00:53:16,380
It is strictly less than 2.81.

830
00:53:16,380 --> 00:53:18,250
That is cool.

831
00:53:18,250 --> 00:53:19,500
I mean it is polynomially better than n³.

832
00:53:19,500 --> 00:53:22,300
Still not as good as addition, which is n².

833
00:53:22,300 --> 00:53:23,390
It is generally believed,

834
00:53:23,390 --> 00:53:25,520
although we don't know whether you can multiply as fast as

835
00:53:25,520 --> 00:53:27,200
you can divide for matrices.

836
00:53:27,200 --> 00:53:31,500
We think you cannot get n², but who knows?

837
00:53:31,500 --> 00:53:35,080
It could still happen. There are no lower bounds.

838
00:53:35,080 --> 00:53:38,960
This is not the best algorithm for matrix multiplication.

839
00:53:38,960 --> 00:53:40,950
It is sort of the simplest that beats n³.

840
00:53:40,950 --> 00:53:47,010
The best so far is like n^2.376.

841
00:53:47,010 --> 00:53:50,970
Getting closer to 2.

842
00:53:50,970 --> 00:53:55,500
You might think these numbers are a bit weird.

843
00:53:55,500 --> 00:53:57,800
Maybe the constants out here dominate the improvement

844
00:53:57,800 --> 00:53:59,160
you are getting in the exponent.

845
00:53:59,160 --> 00:54:01,480
It turns out improving the exponent is a big deal.

846
00:54:01,480 --> 00:54:05,140
I mean, as n gets larger exponents really come out to bite you.

847
00:54:05,140 --> 00:54:08,970
So, n³ is pretty impractical for any very large values of n.

848
00:54:08,970 --> 00:54:11,090
And we known that Strassen will beat normal matrix multiplication

849
00:54:11,090 --> 00:54:16,850
if n is sufficiently large.

850
00:54:16,850 --> 00:54:22,380
The claim is that roughly at about 32 or so already you get an improvement,

851
00:54:22,380 --> 00:54:24,230
for other reasons,

852
00:54:24,230 --> 00:54:27,220
not just because the exponent gets better, but there you go.

853
00:54:27,260 --> 00:54:28,010
So, this is pretty good.

854
00:54:28,010 --> 00:54:30,760
This is completely impractical, so don't use whatever this algorithm is.

855
00:54:30,760 --> 00:54:33,460
I don't have the reference handy,

856
00:54:33,460 --> 00:54:35,340
but it is just trying to get a theoretical improvement.

857
00:54:35,340 --> 00:54:37,750
There may be others that are in between and more reasonable

858
00:54:37,750 --> 00:54:39,550
but that is not it.

859
00:54:39,550 --> 00:54:44,950
Wow, lots of time. Any questions?

860
00:54:44,960 --> 00:54:46,360
We're not done yet,

861
00:54:46,360 --> 00:54:50,400
but any questions before we move on for matrix multiplication?

862
00:54:50,400 --> 00:54:57,820
OK. I have one more problem.

863
00:55:13,230 --> 00:55:15,060
Divide-and-conquer is a pretty general idea.

864
00:55:15,060 --> 00:55:16,690
I mean, you can use it to dominate countries.

865
00:55:16,690 --> 00:55:19,380
You can use it to multiply matrices.

866
00:55:19,380 --> 00:55:21,760
I mean, who would have thought?

867
00:55:21,760 --> 00:55:26,920
Here is a very different kind of problem

868
00:55:26,920 --> 00:55:28,430
you can solve with divide-and-conquer.

869
00:55:28,430 --> 00:55:31,010
It is not exactly an algorithmic problem,

870
00:55:31,010 --> 00:55:35,210
although it is computer science.

871
00:55:35,210 --> 00:55:37,590
That is clear. This is very large-scale integration.

872
00:55:37,590 --> 00:55:42,460
The chips, they are very large scale integrated.

873
00:55:42,460 --> 00:55:45,680
Probably even more these days, but that is the catch phrase.

874
00:55:45,680 --> 00:55:49,840
Here is a problem, and it arises in VLSI layout.

875
00:55:49,840 --> 00:55:52,520
We won't get into too many details why,

876
00:55:52,530 --> 00:55:54,940
but you have some circuit.

877
00:55:54,940 --> 00:55:58,840
And here I am going to assume that the circuit is a binary tree.

878
00:55:58,840 --> 00:56:01,840
This is just part of a circuit.

879
00:56:01,840 --> 00:56:07,730
Assume for now here that it is just a complete binary tree.

880
00:56:07,730 --> 00:56:13,450
A complete binary tree looks like this.

881
00:56:13,450 --> 00:56:15,810
In all of my teachings,

882
00:56:15,810 --> 00:56:19,840
I have drawn this figure for sure the most.

883
00:56:19,840 --> 00:56:21,440
It is my favorite figure,

884
00:56:21,440 --> 00:56:23,640
the height four complete binary tree.

885
00:56:23,640 --> 00:56:26,230
OK, there it is. I have some tree like that as some height.

886
00:56:26,230 --> 00:56:30,740
I want to imbed it into some chip layout on a grid.

887
00:56:30,740 --> 00:56:35,530
Let's say it has n leaves.

888
00:56:37,750 --> 00:56:43,760
I want to imbed it into a grid with minimum area.

889
00:56:43,760 --> 00:56:45,720
This is a very cute problem

890
00:56:45,720 --> 00:56:48,910
and it really shows you another way in

891
00:56:48,910 --> 00:56:54,050
which divide-and-conquer is a useful and powerful tool.

892
00:56:54,050 --> 00:56:56,810
So, I have this tree. I like to draw it in this way.

893
00:56:56,810 --> 00:56:59,620
I want to somehow draw it on the grid.

894
00:56:59,620 --> 00:57:04,470
What that means is the vertices have to be imbedded onto dots on the grid,

895
00:57:04,470 --> 00:57:05,920
and I am talking about the square grid.

896
00:57:05,920 --> 00:57:07,980
It has to go to vertices of the grid.

897
00:57:07,980 --> 00:57:12,510
And these edges have to be routed as sort of orthogonal paths

898
00:57:12,510 --> 00:57:14,850
between one dot and another,

899
00:57:14,850 --> 00:57:17,220
so that should be an edge and they shouldn't cross

900
00:57:17,220 --> 00:57:20,760
and all these good things because wires do not like to cross.

901
00:57:25,610 --> 00:57:29,450
There is the obvious way to solve this problem and there is the right way.

902
00:57:29,450 --> 00:57:36,660
And let's talk about both of them.

903
00:57:36,660 --> 00:57:38,250
Neither of them is particularly obvious,

904
00:57:38,250 --> 00:57:40,990
but divide-and-conquer sort of gives you a hint in the right direction.

905
00:57:40,990 --> 00:57:46,990
So, the naive embedding. I seem to like the word naive here.

906
00:57:46,990 --> 00:57:54,750
I am going to draw this bottom up because it is easier,

907
00:57:54,750 --> 00:58:00,160
so leave three grid lines and then start drawing.

908
00:58:00,160 --> 00:58:03,710
I don't know how big that is going to be.

909
00:58:03,710 --> 00:58:07,270
Here is the bottom of our tree.

910
00:58:07,270 --> 00:58:10,300
This is like the little three nodes there.

911
00:58:10,300 --> 00:58:18,590
And then I leave a blank column and then a blank column.

912
00:58:18,590 --> 00:58:20,570
I don't actually need to leave those blank columns,

913
00:58:20,570 --> 00:58:22,380
but it makes a prettier drawing.

914
00:58:25,120 --> 00:58:28,200
And then we work our way up.

915
00:58:35,740 --> 00:58:38,850
There is the tree, which should be aligned, on a grid.

916
00:58:38,850 --> 00:58:40,870
No crossings. Everything is happy.

917
00:58:40,870 --> 00:58:42,680
How much area does it take?

918
00:58:49,200 --> 00:58:52,720
By area, I mean sort of the area of the bounding box.

919
00:58:52,720 --> 00:58:55,450
So, I count this blank space even though I am not using it

920
00:58:55,450 --> 00:58:57,530
and I count all this blank space even though I am not using it.

921
00:58:57,530 --> 00:59:00,520
I want to look at the height.

922
00:59:00,520 --> 00:59:03,560
Let's call this H(n).

923
00:59:03,560 --> 00:59:08,840
And to look at the width, which I will call W(n).

924
00:59:08,840 --> 00:59:13,240
Now, it is probably pretty obvious that H(n) is like log n,

925
00:59:13,240 --> 00:59:15,320
W(n) is like n or whatever.

926
00:59:15,320 --> 00:59:17,530
But I want to write it as a recurrence

927
00:59:17,530 --> 00:59:20,420
because that will inspire us to do the right thing.

928
00:59:22,850 --> 00:59:28,890
H(n). Well, if you think of this as a recursion-tree, in some sense.

929
00:59:28,890 --> 00:59:30,110
We start with the big tree.

930
00:59:30,110 --> 00:59:33,650
We split it into two halves,

931
00:59:33,650 --> 00:59:35,810
two subtrees of size n/2 indeed

932
00:59:35,810 --> 00:59:37,770
because we are counting leaves.

933
00:59:37,770 --> 00:59:39,510
It is exactly n/2 on each side.

934
00:59:39,510 --> 00:59:45,670
Then for height they are in parallel so it is no big deal.

935
00:59:45,670 --> 00:59:47,640
The height is just the height of this thing,

936
00:59:47,640 --> 00:59:49,740
one of these subproblems plus one.

937
00:59:49,740 --> 00:59:53,790
The width, you have to add together the two widths and also add on 1.

938
00:59:53,790 --> 00:59:56,920
You don't have to add on 1 here, but it doesn't matter.

939
00:59:56,920 --> 00:59:58,460
It is certainly at most 1.

940
01:00:05,670 --> 01:00:07,060
there you do have to add 1,

941
01:00:07,060 --> 01:00:22,780
and W(n)=2W(n/2)+O(1).

942
01:00:07,060 --> 01:00:22,780
W(n)=2W(n/2)+O(1)

943
01:00:22,780 --> 01:00:25,840
The usual base cases.

944
01:00:25,840 --> 01:00:30,340
I mean, these are recurrences we should know and love.

945
01:00:30,340 --> 01:00:35,070
This is log n, I sort of have already given away the answers,

946
01:00:35,070 --> 01:00:40,260
and this better be linear.

947
01:00:40,260 --> 01:00:44,650
This is again Case 1.

948
01:00:44,650 --> 01:00:50,570
And to the log base 2 of 2 is n, which is the answer, much bigger than 1.

949
01:00:50,570 --> 01:00:55,990
And here n to the log base 2 of 1 is n to the zero,

950
01:00:55,990 --> 01:00:59,240
which is 1, which is the same so we get log n.

951
01:00:59,240 --> 01:01:04,710
The area is n log n,

952
01:01:07,290 --> 01:01:10,500
but if you are making chips you want the area as small as possible

953
01:01:10,500 --> 01:01:11,960
so you can fit more good stuff in there.

954
01:01:11,960 --> 01:01:13,720
So, we would like to aim for, well,

955
01:01:13,720 --> 01:01:16,230
we certainly cannot do a better area than n.

956
01:01:16,230 --> 01:01:18,200
You've got to put the leaves down somewhere,

957
01:01:18,200 --> 01:01:19,710
but this is already pretty good.

958
01:01:19,710 --> 01:01:22,390
It is only a log factor off, but we want to aim for n.

959
01:01:23,950 --> 01:01:26,300
How could we get n?

960
01:01:26,300 --> 01:01:29,390
Any guesses on what needs to change in this layout?

961
01:01:29,390 --> 01:01:31,260
Not how to do it because that is not obvious,

962
01:01:31,260 --> 01:01:36,250
but in terms of height and width what should we do?

963
01:01:36,250 --> 01:01:39,290
It is pretty hard to get the height smaller than log n,

964
01:01:39,290 --> 01:01:41,760
I will tell you, because this is a tree.

965
01:01:41,760 --> 01:01:45,680
It cannot really get its width down to less than log n.

966
01:01:45,680 --> 01:01:51,010
What could we do to make the product linear?

967
01:01:54,010 --> 01:01:57,480
Just random ideas. What are two functions whose product is n?

968
01:02:05,880 --> 01:02:07,710
Square root of n and square root of n.

969
01:02:07,710 --> 01:02:10,200
That is a good choice. Were there other suggestions?

970
01:02:13,780 --> 01:02:16,200
n times constant. Yeah, n times constant would be nice.

971
01:02:16,200 --> 01:02:19,320
But I claim you cannot get either of these down to less than a constant.

972
01:02:19,320 --> 01:02:23,050
You could aim for n over log n by log n, that is more likely,

973
01:02:23,050 --> 01:02:24,450
but I think that is almost impossible.

974
01:02:24,450 --> 01:02:28,140
Root n by root n is the right answer, so let's go with that.

975
01:02:30,050 --> 01:02:31,710
So, root n by root n.

976
01:02:32,020 --> 01:02:36,100
We haven't seen any recurrences whose solution is root n,

977
01:02:36,100 --> 01:02:38,370
but surely they are out there.

978
01:02:54,170 --> 01:02:56,270
If we did that we would be happy,

979
01:02:56,270 --> 01:02:59,700
because then the area is the product is linear.

980
01:03:01,020 --> 01:03:07,360
How? What is a recurrence that is in the usual master method

981
01:03:07,360 --> 01:03:09,990
form whose solution is root n?

982
01:03:12,890 --> 01:03:14,990
I mean, you could think of it that way.

983
01:03:14,990 --> 01:03:16,510
Recurrence is a bit tricky,

984
01:03:16,510 --> 01:03:18,490
but let's just think of n^logb(a).

985
01:03:18,490 --> 01:03:26,710
When is log base b of a ? Because then n^log_b(a) is root n.

986
01:03:26,710 --> 01:03:33,120
And there is some hope that I could get a root n solution to recurrence.

987
01:03:34,890 --> 01:03:38,660
This is designed by knowing that it is divide-and-conquer,

988
01:03:38,660 --> 01:03:40,240
and therefore it must be something like this.

989
01:03:40,240 --> 01:03:43,010
It is easy once you know

990
01:03:43,010 --> 01:03:46,510
the approach you are supposed to take and you can try this approach.

991
01:03:46,510 --> 01:03:49,970
When is log base b of a 1/2?

992
01:03:49,970 --> 01:03:52,970
Lots of solutions, shout them out.

993
01:03:53,750 --> 01:03:56,110
4 and 2, that is a good one. I better get this right.

994
01:03:58,300 --> 01:04:01,750
Log base 4 of 2 is a half

995
01:04:01,750 --> 01:04:06,580
because the square root of 4 is 2.

996
01:04:06,680 --> 01:04:07,950
So, let's aim for this. Why not?

997
01:04:07,950 --> 01:04:12,030
When would we get log base 4 of 2?

998
01:04:15,360 --> 01:04:17,410
This is b, this is a,

999
01:04:17,410 --> 01:04:22,980
so it should be 2T(n/4) plus something.

1000
01:04:23,440 --> 01:04:26,800
And if I want the n^logb(a) to dominate,

1001
01:04:26,800 --> 01:04:30,990
it has got to be polynomially smaller than root n.

1002
01:04:30,990 --> 01:04:37,210
So, this should be n^1/2-epsilon.

1003
01:04:37,210 --> 01:04:38,870
But it could be smaller.

1004
01:04:38,870 --> 01:04:41,180
It could be 1. Zero would be nice,

1005
01:04:41,180 --> 01:04:44,160
but that is probably too much to hope for.

1006
01:04:44,160 --> 01:04:45,870
So, something smaller,

1007
01:04:45,870 --> 01:04:48,350
strictly polynomially smaller than root n.

1008
01:04:48,350 --> 01:04:51,040
That is our goal. And now comes the magic.

1009
01:04:51,040 --> 01:04:55,300
If you played with this for a while you would find it,

1010
01:04:55,300 --> 01:04:56,100
I think, at this point.

1011
01:04:56,100 --> 01:04:59,910
When you know that you are somehow solve this problem of size n

1012
01:04:59,910 --> 01:05:04,100
with two subproblems of size n/4 what could you do?

1013
01:05:06,510 --> 01:05:10,440
Well, if you start thinking of things as squares,

1014
01:05:10,440 --> 01:05:13,730
this is the natural thing that happens.

1015
01:05:18,430 --> 01:05:22,200
This is called the H layout.

1016
01:05:22,200 --> 01:05:24,490
You can imagine why.

1017
01:05:30,310 --> 01:05:35,750
It would be much easier to draw if I had a grid board, a graph board,

1018
01:05:35,750 --> 01:05:38,050
whatever, if that exists.

1019
01:05:43,890 --> 01:05:45,610
This is a recursive layout.

1020
01:05:45,610 --> 01:05:48,890
I am only going to draw a couple iterations,

1021
01:05:48,890 --> 01:05:50,900
but hopefully you can imagine the generalization.

1022
01:06:04,080 --> 01:06:06,680
I take four Hs,

1023
01:06:06,680 --> 01:06:13,610
a good plan because I want problems of size n/4.

1024
01:06:13,610 --> 01:06:17,740
This has n/4 leaves. This has n/4 leaves.

1025
01:06:17,740 --> 01:06:20,620
This is the root, by the way, in the middle.

1026
01:06:20,620 --> 01:06:23,420
This has n/4 leaves.This has n/4 leaves.

1027
01:06:23,420 --> 01:06:25,360
So, I have four problems of size n/4.

1028
01:06:25,360 --> 01:06:27,600
Somehow I have got to get that down to two.

1029
01:06:27,600 --> 01:06:30,870
Thankfully, if I look at width or if I look at height,

1030
01:06:30,870 --> 01:06:32,860
there are only two that matter.

1031
01:06:32,860 --> 01:06:36,930
And these two matter and these two get along for free.

1032
01:06:36,930 --> 01:06:40,550
They are going in parallel, just like we had with height over here.

1033
01:06:40,550 --> 01:06:44,140
But I get that both in height and in width.

1034
01:06:44,140 --> 01:06:47,450
If I measure, well, now they are equal,

1035
01:06:47,450 --> 01:06:49,340
so I will just call them the length.

1036
01:06:49,340 --> 01:06:52,140
We have L(n)-by-L(n).

1037
01:06:55,980 --> 01:06:59,160
And if I compute well, what is L(n)?

1038
01:06:59,160 --> 01:07:01,240
I have here L(n/4)

1039
01:07:01,240 --> 01:07:03,780
because there are only a quarter of the leaves

1040
01:07:03,780 --> 01:07:04,840
in this one or in that one,

1041
01:07:10,810 --> 01:07:13,730
and then I have L(n/4) again.

1042
01:07:13,730 --> 01:07:18,610
So, I get the recurrence that I wanted.

1043
01:07:32,630 --> 01:07:38,720
And that has solution square root of n, as we claimed before.

1044
01:07:38,720 --> 01:07:42,970
Again, we are in Case 1 of the master method.

1045
01:07:42,970 --> 01:07:46,780
Cool, ha? This is a much more compact layout.

1046
01:07:46,780 --> 01:07:48,770
Charles, did you invent this layout?

1047
01:07:48,770 --> 01:07:51,940
No. But I know it appears on your PhD thesis

1048
01:07:51,940 --> 01:07:54,980
and you extended it in various directions.

1049
01:07:54,980 --> 01:07:58,470
So, this is sort of a classic cool layout of trees into grids

1050
01:07:58,470 --> 01:08:01,320
and another application of divide-and-conquer.

1051
01:08:01,320 --> 01:08:04,390
I mean this is not particularly useful for algorithms directly.

1052
01:08:04,390 --> 01:08:06,670
It is useful for VLSI layout directly.

1053
01:08:06,670 --> 01:08:10,140
But it gives you more flavor of how you should think.

1054
01:08:10,140 --> 01:08:11,700
If you know what running time you are aiming for,

1055
01:08:11,700 --> 01:08:13,790
like in problem sets in quizzes often

1056
01:08:13,790 --> 01:08:16,100
we say here is the running time you have got to get,

1057
01:08:16,100 --> 01:08:18,540
think about the recurrence that will get you there.

1058
01:08:18,540 --> 01:08:19,950
And that could inspire you.

1059
01:08:19,950 --> 01:08:23,650
And that is it. Recitation Friday.

1060
01:08:23,650 --> 01:08:26,760
Homework lab Sunday. No class Monday.

1061
01:08:26,760 --> 01:08:28,050
See you Wednesday.

