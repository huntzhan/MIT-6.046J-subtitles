1
00:00:05,580 --> 00:00:08,460
Good morning. Today we're going to talk about

2
00:00:08,560 --> 00:00:10,890
a new balanced search structure,

3
00:00:10,950 --> 00:00:13,260
so a data structure that maintains a dynamic set

4
00:00:13,310 --> 00:00:15,090
subject to insertion, deletion,

5
00:00:15,160 --> 00:00:17,410
and search called skip lists.

6
00:00:19,630 --> 00:00:23,230
So, I'll call this a dynamic search structure

7
00:00:23,320 --> 00:00:24,350
because it's a data structure.

8
00:00:24,410 --> 00:00:28,680
It supports search, and it's dynamic, meaning insert and delete.

9
00:00:31,460 --> 00:00:34,100
So, what other dynamic search structures do we know,

10
00:00:34,150 --> 00:00:38,220
just for sake of comparison, and to wake everyone up?

11
00:00:39,910 --> 00:00:42,950
Shout them out, efficient, I should say,

12
00:00:43,050 --> 00:00:48,390
also good, logarithmic time per operation.

13
00:00:53,200 --> 00:00:57,830
So, this is a really easy question to get us off the ground.

14
00:01:00,540 --> 00:01:01,970
You've seen them all in the last week,

15
00:01:02,070 --> 00:01:05,040
so it shouldn't be so hard.

16
00:01:05,140 --> 00:01:08,250
Treap, good. On the problems that we saw treaps.

17
00:01:08,310 --> 00:01:09,860
That's, in some sense,

18
00:01:09,950 --> 00:01:12,470
the simplest dynamic search structure

19
00:01:12,570 --> 00:01:13,740
you can get from first principles

20
00:01:13,800 --> 00:01:16,630
because all we needed was a bound

21
00:01:16,740 --> 00:01:18,860
on a randomly constructed binary search tree.

22
00:01:18,950 --> 00:01:20,440
And then treaps did well.

23
00:01:21,800 --> 00:01:23,940
So, that was sort of the first one you saw depending on

24
00:01:24,030 --> 00:01:28,060
when you did your problem set. What else?

25
00:01:32,750 --> 00:01:34,020
Charles?

26
00:01:34,130 --> 00:01:35,700
[Charles]Red black trees,

27
00:01:35,790 --> 00:01:39,020
[Erik]Red black trees, it's a good answer.

28
00:01:40,660 --> 00:01:45,100
So, that was exactly one week ago. I hope you still remember it.

29
00:01:45,210 --> 00:01:46,930
They have guaranteed log n performance.

30
00:01:47,080 --> 00:01:48,790
So, this was an expected bound.

31
00:01:48,850 --> 00:01:51,850
This was a worst-case order log n per operation,

32
00:01:51,980 --> 00:01:53,610
insert, delete, and search.

33
00:01:53,730 --> 00:01:55,690
And, there was one more

34
00:02:00,660 --> 00:02:06,760
for those who want to recitation on Friday: B trees, good.

35
00:02:07,680 --> 00:02:10,660
And, by B trees, I also include two-three trees,

36
00:02:10,760 --> 00:02:12,720
two-three-four trees, and all those guys.

37
00:02:12,810 --> 00:02:14,110
So, if B is a constant,

38
00:02:14,200 --> 00:02:17,700
or if you want your B trees knows a little bit cleverly,

39
00:02:17,760 --> 00:02:21,380
that these have guaranteed order log n performance,

40
00:02:21,480 --> 00:02:23,280
so, worst case, order log n.

41
00:02:23,340 --> 00:02:24,800
So, you should know this.

42
00:02:24,860 --> 00:02:28,550
These are all balanced search structures.

43
00:02:28,650 --> 00:02:30,920
They are dynamic. They support insertions and deletions.

44
00:02:31,020 --> 00:02:33,710
They support searches, finding a given key.

45
00:02:33,810 --> 00:02:36,590
And if you don't find the key, you find its predecessor

46
00:02:36,700 --> 00:02:39,510
and successor pretty easily in all of these structures.

47
00:02:39,610 --> 00:02:41,530
If you want to augment some data structure,

48
00:02:41,630 --> 00:02:44,950
you should think about which one of these is easiest to augment

49
00:02:45,040 --> 00:02:46,640
as in Monday's lecture.

50
00:02:46,740 --> 00:02:51,300
So, the question I want to pose to you is supposed

51
00:02:51,410 --> 00:02:55,140
I gave you all a laptop right now, which would be great.

52
00:02:55,240 --> 00:02:57,000
Then I asked you,

53
00:02:57,060 --> 00:02:59,680
in order to keep this laptop you have to implement

54
00:02:59,740 --> 00:03:04,930
one of these data structures, let's say, within this class hour.

55
00:03:05,040 --> 00:03:07,660
Do you think you could do it?

56
00:03:07,760 --> 00:03:09,620
How many people think you could do it?

57
00:03:09,680 --> 00:03:14,820
A couple people, a few people, OK, all front row people, good.

58
00:03:14,910 --> 00:03:18,130
I could probably do it. My preference would be B trees.

59
00:03:18,190 --> 00:03:20,380
They're sort of the simplest in my mind.

60
00:03:20,430 --> 00:03:22,140
This is without using the textbook.

61
00:03:22,290 --> 00:03:24,730
This would be a closed book exam.

62
00:03:24,780 --> 00:03:27,660
I don't have enough laptops to do it, unfortunately.

63
00:03:27,770 --> 00:03:30,910
So, B trees are pretty reasonable.

64
00:03:31,020 --> 00:03:32,790
Deletion, you have to remember

65
00:03:32,870 --> 00:03:35,600
stealing from a sibling and whatnot.

66
00:03:35,700 --> 00:03:36,850
So, deletions are a bit tricky.

67
00:03:36,950 --> 00:03:38,890
Red black trees, I can never remember it.

68
00:03:38,950 --> 00:03:41,520
I'd have to look it up, or re-derive the three cases.

69
00:03:41,570 --> 00:03:44,180
treaps are a bit fancy.

70
00:03:44,270 --> 00:03:47,420
So, that would take a little while

71
00:03:47,480 --> 00:03:48,760
to remember exactly how those work.

72
00:03:48,820 --> 00:03:50,510
You'd have to solve your problem set again,

73
00:03:50,530 --> 00:03:51,940
if you don't have it memorized.

74
00:03:52,050 --> 00:03:53,840
Skip lists, on the other hand,

75
00:03:53,860 --> 00:03:56,580
are a data structure you will never forget,

76
00:03:56,580 --> 00:04:00,300
and something you can implement within an hour, no problem.

77
00:04:00,400 --> 00:04:03,740
I've made this claim a couple times before,

78
00:04:03,830 --> 00:04:07,580
and I always felt bad because I had never actually done it.

79
00:04:07,640 --> 00:04:09,920
So, this morning, I implemented skip lists,

80
00:04:09,970 --> 00:04:14,060
and it took me ten minutes to implement a linked list,

81
00:04:14,160 --> 00:04:16,220
and 30 minutes to implement skip lists.

82
00:04:16,280 --> 00:04:21,840
And another 30 minutes debugging them. There you go.

83
00:04:21,940 --> 00:04:24,480
It can be done. Skip lists are really simple.

84
00:04:24,560 --> 00:04:27,180
And, at no point writing the code did I have to think,

85
00:04:27,270 --> 00:04:30,410
whereas every other structure I would have to think.

86
00:04:30,510 --> 00:04:33,950
There was one moment when I thought, ah, how do I flip a coin?

87
00:04:34,050 --> 00:04:36,730
That was the entire amount of thinking.

88
00:04:36,790 --> 00:04:39,260
So, skip lists are a randomized structure.

89
00:04:39,370 --> 00:04:42,560
Let's add in another adjective here,

90
00:04:45,490 --> 00:04:48,410
and let's also add in simple.

91
00:04:49,820 --> 00:04:52,390
So, we have a simple, efficient, dynamic,

92
00:04:52,500 --> 00:04:55,420
randomized search structure: all those things together.

93
00:04:55,510 --> 00:04:57,650
So, it's sort of like treaps

94
00:04:57,740 --> 00:05:00,570
and that the bound is only a randomized bound.

95
00:05:00,670 --> 00:05:01,670
But today, we're going to see

96
00:05:01,770 --> 00:05:04,050
a much stronger bound than an expectation bound.

97
00:05:04,100 --> 00:05:05,180
So, in particular,

98
00:05:05,280 --> 00:05:08,020
skip lists will run in order log n expected time.

99
00:05:13,190 --> 00:05:15,270
So, the running time for each operation

100
00:05:15,380 --> 00:05:17,390
will be order log n in expectation.

101
00:05:19,940 --> 00:05:21,800
But, we're going to prove a much stronger result

102
00:05:21,900 --> 00:05:24,760
that their order log n, with high probability.

103
00:05:33,940 --> 00:05:39,880
So, this is a very strong claim. And it means that

104
00:05:39,980 --> 00:05:41,640
the running time of each operation,

105
00:05:41,740 --> 00:05:43,920
the running time of every operation,

106
00:05:43,970 --> 00:05:48,000
is order log n almost always in a certain sense.

107
00:05:49,390 --> 00:05:51,840
Why don't I foreshadow that?

108
00:05:55,900 --> 00:06:01,530
So, it's something like, the probability that it's order log n

109
00:06:01,630 --> 00:06:05,560
is at least one minus one over some polynomial, and n.

110
00:06:05,670 --> 00:06:08,320
And, you get to set the polynomial however large you like.

111
00:06:08,440 --> 00:06:12,260
So, what this basically means is that almost all the time,

112
00:06:12,360 --> 00:06:13,570
you take your skip lists,

113
00:06:13,690 --> 00:06:15,740
you do a polynomial number of operations on it,

114
00:06:15,850 --> 00:06:18,010
because presumably you are running a polynomial time algorithm

115
00:06:18,110 --> 00:06:19,180
that using this data structure.

116
00:06:19,310 --> 00:06:21,520
Do polynomial numbers of inserts, delete searches,

117
00:06:21,520 --> 00:06:23,440
every single one of them

118
00:06:23,500 --> 00:06:26,600
will take order log n time, almost guaranteed.

119
00:06:26,690 --> 00:06:30,550
So this is a really strong bound on the tail of the distribution.

120
00:06:30,620 --> 00:06:33,470
The mean is order log n. That's not so exciting.

121
00:06:33,620 --> 00:06:34,810
But, in fact,

122
00:06:34,820 --> 00:06:37,440
almost all of the weight of this probability distribution

123
00:06:37,540 --> 00:06:40,390
is right around the log n, just tiny little epsilons,

124
00:06:40,390 --> 00:06:44,000
very tiny probabilities you could be bigger than log n.

125
00:06:45,520 --> 00:06:49,900
So that's where we are going.

126
00:06:50,000 --> 00:06:55,280
This is a data structure by Pugh in 1989.

127
00:06:55,370 --> 00:06:56,900
This is the most recent.

128
00:06:56,990 --> 00:07:00,110
Actually, no, sorry, treaps are more recent.

129
00:07:00,210 --> 00:07:02,290
They were like '93 or so,

130
00:07:03,380 --> 00:07:05,450
but a fairly recent data structure

131
00:07:06,950 --> 00:07:08,460
for just insert, delete, search.

132
00:07:08,470 --> 00:07:13,090
And, it's very simple. You can derive it

133
00:07:13,090 --> 00:07:14,690
if you don't know anything about data structures,

134
00:07:14,750 --> 00:07:17,280
well, almost nothing.

135
00:07:17,380 --> 00:07:20,730
Now, analyzing that the performance is log n,

136
00:07:20,820 --> 00:07:22,930
that, of course, takes our sophistication.

137
00:07:22,980 --> 00:07:25,240
But the data structure itself is very simple.

138
00:07:26,540 --> 00:07:27,870
We're going to start from scratch.

139
00:07:33,920 --> 00:07:37,160
Suppose you don't know what a red black tree is.

140
00:07:37,260 --> 00:07:38,650
You don't know what a B tree is.

141
00:07:39,840 --> 00:07:42,020
Suppose you don't even know what a tree is.

142
00:07:42,540 --> 00:07:44,610
What is the simplest data structure

143
00:07:44,670 --> 00:07:49,820
for storing a bunch of items for storing a dynamic set?

144
00:07:51,290 --> 00:07:53,770
A list, good, a linked list.

145
00:07:53,870 --> 00:07:57,190
Now, suppose that it's a sorted linked list.

146
00:07:57,300 --> 00:07:59,100
So, I'm going to be a little bit fancier there.

147
00:08:02,790 --> 00:08:06,190
So, if you have a linked list of items, here it is,

148
00:08:06,290 --> 00:08:09,170
maybe we'll make it doubly linked just for kicks,

149
00:08:11,350 --> 00:08:14,520
how long does it take to search in a sorted linked list?

150
00:08:22,480 --> 00:08:25,960
Log n is one answer. n is the other answer.

151
00:08:26,060 --> 00:08:29,300
Which one is right? n is the right answer.

152
00:08:29,400 --> 00:08:31,500
So, even though it's sorted, we can't do binary search

153
00:08:31,550 --> 00:08:33,810
because we don't have random-access into a linked list.

154
00:08:33,870 --> 00:08:36,350
So, suppose I'm only given a pointer to the head.

155
00:08:36,410 --> 00:08:38,570
Otherwise, I'm assuming it's an array.

156
00:08:38,690 --> 00:08:41,010
So, in a sorted array you can search in log n.

157
00:08:41,040 --> 00:08:42,410
Sorted linked list: you've still

158
00:08:42,470 --> 00:08:43,830
got to scan through the darn thing.

159
00:08:43,920 --> 00:08:49,070
So, theta n, worst case search.

160
00:08:49,170 --> 00:08:54,290
Not so good, but if we just try to improve it a little bit,

161
00:08:54,400 --> 00:08:56,600
we will discover skip lists automatically.

162
00:08:58,050 --> 00:09:03,090
So, this is our starting point: sorted linked lists, theta n time.

163
00:09:03,200 --> 00:09:04,440
And, I'm not going to think too much

164
00:09:04,490 --> 00:09:06,130
about insertions and deletions for the moment.

165
00:09:06,230 --> 00:09:10,960
Let's just get search better, and then we'll worry about updates.

166
00:09:11,460 --> 00:09:13,490
Updates are where randomization will come in.

167
00:09:13,490 --> 00:09:14,810
Search: pretty easy idea.

168
00:09:14,900 --> 00:09:16,920
So, how can we make a linked list better?

169
00:09:16,970 --> 00:09:20,440
Suppose all we know about our linked lists.

170
00:09:20,540 --> 00:09:22,670
What can I do to make it faster?

171
00:09:23,680 --> 00:09:25,050
This is where you need a little bit

172
00:09:25,140 --> 00:09:28,350
of innovation, some creativity.

173
00:09:30,100 --> 00:09:34,620
More links: that's a good idea. So, I could try to

174
00:09:34,720 --> 00:09:40,490
maybe add pointers to go a couple steps ahead.

175
00:09:40,630 --> 00:09:44,690
If I had log n pointers, I could do all powers of two ahead.

176
00:09:44,780 --> 00:09:48,680
That's a pretty good search structure. Some people use that;

177
00:09:49,030 --> 00:09:51,540
like, some peer-to-peer networks use that idea.

178
00:09:51,600 --> 00:09:53,570
But that's a little too fancy for me.

179
00:09:53,570 --> 00:09:58,750
[Student]Inaudible.

180
00:09:58,840 --> 00:10:03,160
Ah, good. You could try to build a tree on this linear structure.

181
00:10:03,270 --> 00:10:05,040
That's essentially where we're going.

182
00:10:05,100 --> 00:10:07,750
So, you could try to put pointers to,

183
00:10:07,870 --> 00:10:10,290
like, the middle of the list from the roots.

184
00:10:10,350 --> 00:10:12,290
So, you search between either here.

185
00:10:12,350 --> 00:10:16,080
You point to the median, so you can compare against the median,

186
00:10:16,140 --> 00:10:18,160
and know whether you should go in the first half or the second half

187
00:10:18,220 --> 00:10:20,320
that's definitely on the right track,

188
00:10:20,380 --> 00:10:21,920
also a bit too sophisticated.

189
00:10:25,020 --> 00:10:28,590
Another list: yes. Yes, good.

190
00:10:28,700 --> 00:10:30,500
So, we are going to use two lists.

191
00:10:30,590 --> 00:10:35,040
That's sort of the next simplest thing you could do.

192
00:10:38,080 --> 00:10:39,450
OK, and as you suggested,

193
00:10:39,520 --> 00:10:41,910
we could maybe have pointers between them.

194
00:10:41,960 --> 00:10:44,420
So, maybe we have some elements down here,

195
00:10:44,480 --> 00:10:46,990
some of the elements up here.

196
00:10:47,090 --> 00:10:49,980
We want to have pointers between the lists.

197
00:10:50,090 --> 00:10:55,760
OK, it gets a little bit crazy in how exactly you might do that.

198
00:10:55,810 --> 00:10:57,430
But somehow, this feels good.

199
00:10:57,430 --> 00:10:58,820
So this is one linked list: L_1.

200
00:10:58,910 --> 00:11:01,190
This is another linked list: L_2.

201
00:11:01,250 --> 00:11:02,820
And, to give you some inspiration,

202
00:11:09,830 --> 00:11:12,950
I want to give you, so let's play a game.

203
00:11:14,180 --> 00:11:15,980
The game is, what is this sequence?

204
00:11:20,480 --> 00:11:23,070
So, the sequence is 14...

205
00:11:23,160 --> 00:11:25,480
If you know the answer, shout it out.

206
00:11:36,240 --> 00:11:39,840
Anyone yet? OK, it's tricky.

207
00:11:52,340 --> 00:11:54,200
It's a bit of a small class,

208
00:11:54,250 --> 00:11:56,500
so I hope someone knows the answer.

209
00:12:07,510 --> 00:12:09,840
How many TA's know the answer?

210
00:12:11,100 --> 00:12:13,630
Just a couple, OK, if you're looking at the slides,

211
00:12:13,730 --> 00:12:15,400
probably you know the answer.

212
00:12:15,490 --> 00:12:18,420
That's cheating. OK, I'll give you a hint.

213
00:12:18,470 --> 00:12:20,050
It is not a mathematical sequence.

214
00:12:20,160 --> 00:12:26,500
This is a real-life sequence. Yeah?

215
00:12:29,230 --> 00:12:33,260
Yeah, and what city? New York, yeah, this is the 7th Ave line.

216
00:12:33,350 --> 00:12:36,570
This is my favorite subway line in New York.

217
00:12:36,670 --> 00:12:41,500
But, what's a cool feature of the New York City subway?

218
00:12:43,500 --> 00:12:46,130
OK, it's a skip list. Good answer.

219
00:12:46,230 --> 00:12:47,740
[LAUGHTER]

220
00:12:47,840 --> 00:12:54,530
Indeed it is. Skip lists are so practical.

221
00:12:54,620 --> 00:12:59,740
They've been implemented in the subway system. How cool is that?

222
00:12:59,830 --> 00:13:06,820
OK, Boston subway is pretty cool because it's the oldest subway

223
00:13:06,930 --> 00:13:10,520
definitely in the United States, maybe in the world.

224
00:13:11,240 --> 00:13:13,340
New York is close,

225
00:13:13,510 --> 00:13:16,420
and it has other nice features like it's open 24 hours.

226
00:13:16,510 --> 00:13:17,800
That's a definite plus,

227
00:13:17,920 --> 00:13:20,930
but it also has this feature of express lines.

228
00:13:21,030 --> 00:13:23,380
So, it's a bit of an abstraction,

229
00:13:23,450 --> 00:13:26,240
but the 7th Ave line has essentially two kinds of cars.

230
00:13:26,330 --> 00:13:28,630
These are street numbers by the way.

231
00:13:28,690 --> 00:13:33,310
This is, Penn Station, Times Square, and so on.

232
00:13:36,790 --> 00:13:38,090
So, there are essentially two lines.

233
00:13:38,180 --> 00:13:39,000
There's the express line

234
00:13:39,100 --> 00:13:42,320
which goes 14, to 34, to 42, to 72, to 96.

235
00:13:42,420 --> 00:13:46,370
And then, there's the local line which stops at every stop.

236
00:13:46,460 --> 00:13:49,660
And, they accomplish this with four sets of tracks.

237
00:13:49,770 --> 00:13:52,850
So, I mean, the express lines have their own dedicated track.

238
00:13:52,950 --> 00:13:57,320
If you want to go to stop 59 from, let's say, Penn Station,

239
00:13:57,410 --> 00:14:00,680
well, let's say from lower west side,

240
00:14:00,780 --> 00:14:03,050
you get on the express line.

241
00:14:03,100 --> 00:14:05,470
You jump to 42 pretty quickly,

242
00:14:05,530 --> 00:14:07,640
and then you switch over to the local line,

243
00:14:07,690 --> 00:14:10,980
and go on to 59 or wherever I said I was going.

244
00:14:11,070 --> 00:14:17,610
OK, so this is express and local lines,

245
00:14:17,710 --> 00:14:20,640
and we can represent that with a couple of lists.

246
00:14:20,730 --> 00:14:22,230
We have one list,

247
00:14:24,050 --> 00:14:27,710
sure, we have one list on the bottom,

248
00:14:29,360 --> 00:14:30,980
so leave some space up here.

249
00:14:32,570 --> 00:14:35,760
This is the local line, L_2,

250
00:14:35,860 --> 00:14:58,620
34, 42, 50, 59, 66, 72, 79, and so on.

251
00:15:00,170 --> 00:15:02,460
And then we had the express line on top,

252
00:15:04,130 --> 00:15:15,490
which only stops at 14, 34, 42, 72, and so on.

253
00:15:16,530 --> 00:15:20,140
I'm not going to redraw the whole list. You get the idea.

254
00:15:20,240 --> 00:15:22,610
And so, what we're going to do is put links between

255
00:15:22,660 --> 00:15:28,540
in the local and express lines, wherever they happen to meet.

256
00:15:28,660 --> 00:15:34,920
And, that's our two linked list structure.

257
00:15:35,020 --> 00:15:36,740
So, that's what I actually meant

258
00:15:36,840 --> 00:15:38,620
what I was trying to draw some picture.

259
00:15:38,740 --> 00:15:40,400
Now, this has a property that in one list,

260
00:15:40,500 --> 00:15:43,130
the bottom list, every element occurs.

261
00:15:43,190 --> 00:15:46,450
And the top list just copies some of those elements.

262
00:15:46,540 --> 00:15:49,200
And we're going to preserve that property.

263
00:15:49,300 --> 00:15:53,600
So, L_2 stores all the elements,

264
00:15:59,890 --> 00:16:03,000
and L_1 stores some subset.

265
00:16:03,100 --> 00:16:06,400
And, it's still open which ones we should store.

266
00:16:06,950 --> 00:16:09,280
That's the one thing we need to think about.

267
00:16:09,330 --> 00:16:13,500
But, our inspiration is from the New York subway system.

268
00:16:14,890 --> 00:16:17,120
OK, there, that the idea.

269
00:16:17,210 --> 00:16:19,530
Of course, we're also going to use more than two lists.

270
00:16:19,590 --> 00:16:23,600
OK, we also have links.

271
00:16:25,180 --> 00:16:38,980
Let's say it links between equal keys in L_1 and L_2.

272
00:16:43,060 --> 00:16:46,170
Good. So, just for the sake of completeness,

273
00:16:46,220 --> 00:16:48,710
and because we will need this later, let's talk about searches

274
00:16:48,800 --> 00:16:51,540
before we worry about how these lists are actually constructed.

275
00:16:56,980 --> 00:16:59,390
Of course, if I wanted that board.

276
00:17:00,560 --> 00:17:07,090
So, if you want to search for an element, x, what do you do?

277
00:17:07,830 --> 00:17:09,900
Well, this is the taking the subway algorithm.

278
00:17:10,010 --> 00:17:12,090
And, suppose you always start

279
00:17:12,150 --> 00:17:14,070
in the upper left corner of the subway system,

280
00:17:14,150 --> 00:17:18,030
if you're always in the lower west side, 14th St,

281
00:17:18,160 --> 00:17:22,120
and I don't know exactly where that is, but more or less,

282
00:17:22,220 --> 00:17:24,680
somewhere down at the bottom of Manhattan.

283
00:17:24,740 --> 00:17:28,800
And, you want to go to a particular station like 59.

284
00:17:28,850 --> 00:17:32,340
Well, you'd stay on the express line as long as you can

285
00:17:32,430 --> 00:17:34,830
because it happens that we started on the express line.

286
00:17:34,880 --> 00:17:36,090
And then, you go down.

287
00:17:36,160 --> 00:17:38,370
And then you take the local line the rest of the way.

288
00:17:38,470 --> 00:17:39,920
That's clearly the right thing to do

289
00:17:40,050 --> 00:17:43,310
if you always start in the top left corner.

290
00:17:43,410 --> 00:17:49,350
So, I'm going to write that down in some kind of an algorithm

291
00:17:49,410 --> 00:17:50,950
because we will be generalizing it.

292
00:17:52,250 --> 00:17:56,730
It's pretty obvious at this point. It will remain obvious.

293
00:17:58,970 --> 00:18:02,650
So, I want to walk right in the top list

294
00:18:03,820 --> 00:18:06,060
until that would go too far.

295
00:18:13,390 --> 00:18:16,160
So, you imagine giving someone directions

296
00:18:16,280 --> 00:18:18,800
on the subway system they've never been on.

297
00:18:18,910 --> 00:18:21,650
So, you say, OK, you start at 14th. Take the express line,

298
00:18:21,750 --> 00:18:24,560
and when you get to 72nd, you've gone too far.

299
00:18:24,610 --> 00:18:27,950
Go back one, and then go down to the local line.

300
00:18:28,050 --> 00:18:29,570
It's really annoying directions.

301
00:18:29,670 --> 00:18:31,140
But this is what an algorithm has to do

302
00:18:31,200 --> 00:18:32,750
because it's never taken the subway before.

303
00:18:32,870 --> 00:18:38,780
So, it's going to check, so let's do it here.

304
00:18:40,680 --> 00:18:43,560
So, suppose I'm aiming for 59.

305
00:18:44,310 --> 00:18:47,740
So, I started 14, say the first thing I do is go to 34.

306
00:18:47,840 --> 00:18:50,480
Then from there, I go to 42.

307
00:18:50,580 --> 00:18:53,000
Still good because 59 is bigger than 42.

308
00:18:53,060 --> 00:18:58,410
I go right again. I say, oops, 72 is too big. That was too far.

309
00:19:00,450 --> 00:19:02,890
So, I go back to where it just was.

310
00:19:02,960 --> 00:19:05,990
Then I go down and then I keep going right

311
00:19:06,110 --> 00:19:07,570
until I find the element that I want,

312
00:19:07,680 --> 00:19:09,330
or discover that it's not in the bottom list

313
00:19:09,430 --> 00:19:10,940
because bottom list has everyone.

314
00:19:14,880 --> 00:19:15,760
So, that's the algorithm.

315
00:19:15,870 --> 00:19:18,000
Stop when going right would go too far,

316
00:19:18,050 --> 00:19:19,820
and you discover that with a comparison.

317
00:19:19,880 --> 00:19:25,560
Then you walk down to L_2.

318
00:19:27,160 --> 00:19:38,240
And then you walk right in L_2 until you find x,

319
00:19:39,640 --> 00:19:41,220
or you find something greater than x,

320
00:19:41,290 --> 00:19:43,560
in which case x is definitely not on your list.

321
00:19:43,610 --> 00:19:45,470
And you found the predecessor and successor,

322
00:19:45,530 --> 00:19:47,390
which may be your goal.

323
00:19:47,450 --> 00:19:48,440
If you didn't find where x was,

324
00:19:48,530 --> 00:19:50,850
you should find where it would go if it were there,

325
00:19:50,910 --> 00:19:52,240
because then maybe you could insert there.

326
00:19:52,340 --> 00:19:55,390
We're going to use this algorithm in insertion.

327
00:19:57,440 --> 00:20:00,150
OK, but that search: pretty easy at this point.

328
00:20:00,250 --> 00:20:03,060
Now, what we haven't discussed is

329
00:20:03,160 --> 00:20:05,090
how fast the search algorithm is,

330
00:20:05,140 --> 00:20:06,810
and it depends, of course,

331
00:20:06,920 --> 00:20:09,270
which elements we're going to store in L_1,

332
00:20:09,330 --> 00:20:11,590
which subset of elements should go in L_1.

333
00:20:13,060 --> 00:20:15,970
Now, in the subway system,

334
00:20:16,060 --> 00:20:19,230
you probably put all the popular stations in L_1.

335
00:20:19,330 --> 00:20:21,630
But here, we want worst-case performance.

336
00:20:21,680 --> 00:20:24,290
So, we don't have some probability distribution on the nodes.

337
00:20:24,390 --> 00:20:26,670
We just like every node to be accessed

338
00:20:26,720 --> 00:20:29,540
sort of as quickly as possible, uniformly.

339
00:20:29,640 --> 00:20:34,790
So, we want to minimize the maximum time over all queries.

340
00:20:35,890 --> 00:20:39,000
So, any ideas what we should do with L_1?

341
00:20:42,230 --> 00:20:44,830
Should I put all the nodes of L_1 in the beginning?

342
00:20:44,940 --> 00:20:47,450
OK, it's a strict subset.

343
00:20:47,560 --> 00:20:50,030
Suppose I told you what the size of L_1 was.

344
00:20:50,120 --> 00:20:52,200
I can tell you, I could afford to build this many express stops.

345
00:20:52,300 --> 00:20:57,020
How should you distribute them among the elements of L_2?

346
00:20:58,040 --> 00:21:07,990
Uniformly, good. So, what nodes, sorry, what keys,

347
00:21:08,040 --> 00:21:11,580
let's say, go in L_1?

348
00:21:13,280 --> 00:21:17,460
Well, definitely the best thing to do is

349
00:21:17,510 --> 00:21:19,920
to spread them out uniformly,

350
00:21:28,490 --> 00:21:32,860
OK, which is definitely not what the 7th Ave line looks like.

351
00:21:32,980 --> 00:21:35,870
But, let's imagine that we could reengineer everything.

352
00:21:35,980 --> 00:21:37,480
So, we're going to try to

353
00:21:37,580 --> 00:21:39,630
space these things out a little bit more.

354
00:21:39,730 --> 00:21:41,710
So, 34 and 42nd are way too close.

355
00:21:41,770 --> 00:21:43,680
We'll take a few more stops.

356
00:21:43,740 --> 00:21:47,520
And, now we can start to analyze things.

357
00:21:47,580 --> 00:21:50,670
OK, as a function of the length of L_1.

358
00:21:51,830 --> 00:22:01,600
So, the cost of a search is now roughly,

359
00:22:01,720 --> 00:22:03,910
so, I want a function of the length of L_1,

360
00:22:03,970 --> 00:22:06,550
and the length of L_2, which is all the elements, n.

361
00:22:09,160 --> 00:22:10,470
What is the cost of the search

362
00:22:10,570 --> 00:22:16,740
if I spread out all the elements in L_1 uniformly? Yeah?

363
00:22:16,840 --> 00:22:24,030
[Student]Inaudible.

364
00:22:25,080 --> 00:22:27,340
[Professor]Right, the total number of elements in the top lists,

365
00:22:27,400 --> 00:22:30,690
plus the division between the bottom and the top.

366
00:22:30,790 --> 00:22:33,010
So, I'll write the length of L_1

367
00:22:33,060 --> 00:22:37,840
plus the length of L_2 divided by the length of L_1.

368
00:22:37,900 --> 00:22:39,750
OK, this is roughly, I mean,

369
00:22:39,810 --> 00:22:41,800
there's maybe a plus one or so here

370
00:22:41,860 --> 00:22:45,240
because in the worst case, I have to search through all of L_1

371
00:22:45,320 --> 00:22:48,510
because the station I could be looking for could be the max.

372
00:22:49,300 --> 00:22:50,850
OK, and maybe I'm not lucky,

373
00:22:50,960 --> 00:22:52,980
and the max is not on the express line.

374
00:22:53,090 --> 00:22:55,090
So then, I have to go down to the local line.

375
00:22:55,150 --> 00:22:57,500
And how many stops will I have to go on the local line?

376
00:22:57,550 --> 00:23:00,510
Well, L_1 just evenly partitions L_2.

377
00:23:00,620 --> 00:23:03,870
So this is the number of consecutive stations

378
00:23:03,930 --> 00:23:06,110
between two express stops.

379
00:23:06,170 --> 00:23:09,720
So, I take the express, possibly this long,

380
00:23:09,820 --> 00:23:16,580
but I take the local possibly this long. So this is in L1

381
00:23:16,620 --> 00:23:19,490
And, this is an L_2. And there is, plus, a constant,

382
00:23:19,590 --> 00:23:21,330
for example, go walking down.

383
00:23:21,390 --> 00:23:25,520
But that's basically the number of nodes that I visit.

384
00:23:25,610 --> 00:23:28,120
So, I'd like to minimize this function.

385
00:23:28,810 --> 00:23:31,550
Now, L_2, I'm going to call that n

386
00:23:32,530 --> 00:23:33,890
because that's the total number of elements.

387
00:23:33,950 --> 00:23:36,130
L_1, I can choose to be whatever I want.

388
00:23:41,260 --> 00:23:43,470
So, let's go over here.

389
00:23:59,720 --> 00:24:09,670
So, I want to minimize L_1 plus n over L_1.

390
00:24:09,730 --> 00:24:12,590
And I get to choose L_1.

391
00:24:12,640 --> 00:24:16,620
Now, I could differentiate this, set it to zero, and go crazy.

392
00:24:16,730 --> 00:24:20,270
Or, I could realize that, I mean, that's not hard.

393
00:24:20,390 --> 00:24:23,140
But, that's a little bit too fancy for me.

394
00:24:23,240 --> 00:24:27,510
So, I could say, well, this is clearly best when L_1 is small.

395
00:24:27,620 --> 00:24:30,070
And this is clearly best when L_1 is large.

396
00:24:30,130 --> 00:24:31,450
So, there's a trade-off there.

397
00:24:31,550 --> 00:24:35,560
And, the trade-off will be roughly minimized up

398
00:24:35,660 --> 00:24:38,400
to constant factors when these two terms are equal.

399
00:24:38,500 --> 00:24:40,700
That's when I have pretty good balance

400
00:24:40,750 --> 00:24:43,320
between the two ends of the trade-off.

401
00:24:43,420 --> 00:24:51,320
So, this is up to constant factors.

402
00:24:54,710 --> 00:25:02,180
I can let L_1 equal n over L_1, OK,

403
00:25:02,180 --> 00:25:04,080
because at most I'm losing a factor of two there

404
00:25:04,090 --> 00:25:06,290
when they happen to be equal.

405
00:25:06,870 --> 00:25:09,470
So now, I just solve this. This is really easy.

406
00:25:09,560 --> 00:25:13,800
This is (L_1)^2 equals n.

407
00:25:13,890 --> 00:25:17,750
So, L_1 is the square root of n.

408
00:25:20,510 --> 00:25:23,270
OK, so the cost that I'm getting over here,

409
00:25:23,370 --> 00:25:28,350
L_1 plus L_2 over L_1 is the square root of n plus n over root n,

410
00:25:28,440 --> 00:25:29,560
which is, again, root n.

411
00:25:29,610 --> 00:25:36,260
So, I get two root n. So, search cost,

412
00:25:37,340 --> 00:25:39,320
and I'm caring about the constant here,

413
00:25:39,390 --> 00:25:40,860
because it will matter in a moment.

414
00:25:40,960 --> 00:25:42,840
Two square root of n:

415
00:25:42,900 --> 00:25:45,400
I'm not caring about the additive constant,

416
00:25:45,460 --> 00:25:47,140
but the multiplicative constant I care about.

417
00:25:48,430 --> 00:25:52,340
OK, that seems good.

418
00:25:52,430 --> 00:25:55,990
We started with a linked list that searched in n time,

419
00:25:56,090 --> 00:25:57,480
theta n time per operation.

420
00:25:57,580 --> 00:26:01,430
Now we have two linked lists, search in theta root n time.

421
00:26:01,540 --> 00:26:04,790
It seems pretty good. This is what the structure looks like.

422
00:26:04,880 --> 00:26:11,330
We have root n guys here. This is in the local line.

423
00:26:11,390 --> 00:26:14,890
And, we have one express stop which represents that.

424
00:26:14,990 --> 00:26:22,670
But we have another root n values in the local line.

425
00:26:22,780 --> 00:26:25,490
And we have one express stop that represents that.

426
00:26:25,580 --> 00:26:27,880
And these two are linked, and so on.

427
00:26:38,670 --> 00:26:42,800
Well, I should put some dot, dot, dots in there.

428
00:26:43,850 --> 00:26:47,380
OK, so each of these chunks has length root n,

429
00:26:47,490 --> 00:26:50,910
and the number of representatives up here is square root of n.

430
00:26:50,960 --> 00:26:53,280
The number of express stops is square root of n.

431
00:26:53,340 --> 00:26:54,700
So clearly, things are balanced now.

432
00:26:54,800 --> 00:26:56,590
I search for, at most, square root of n up here.

433
00:26:56,650 --> 00:26:58,160
Then I search in one of these lists for,

434
00:26:58,270 --> 00:26:59,140
at most, square root of n.

435
00:26:59,230 --> 00:27:01,310
So, every search takes, at most, two root n.

436
00:27:03,710 --> 00:27:05,570
Cool, what should we do next?

437
00:27:07,090 --> 00:27:08,300
So, again, ignore insertions and deletions.

438
00:27:08,410 --> 00:27:09,490
I want to make searches faster

439
00:27:09,580 --> 00:27:12,230
because square root of n is not so hot as we know.

440
00:27:18,230 --> 00:27:20,050
Sorry?

441
00:27:20,160 --> 00:27:22,670
More lines. Let's add a super express line,

442
00:27:22,760 --> 00:27:25,330
or another linked list.

443
00:27:25,440 --> 00:27:29,010
OK, this was two. Why not do three?

444
00:27:36,620 --> 00:27:38,960
So, we started with a sorted linked list.

445
00:27:39,020 --> 00:27:40,750
Then we went to two.

446
00:27:44,170 --> 00:27:46,580
This gave us two square root of n.

447
00:27:47,480 --> 00:27:53,600
Now, I want three sorted linked lists. I didn't pluralize here.

448
00:27:55,340 --> 00:27:57,360
Any guesses what the running time might be?

449
00:27:58,180 --> 00:28:00,360
This is just guesswork. Don't think.

450
00:28:01,980 --> 00:28:07,990
From two square root of n, you would go to, sorry?

451
00:28:07,990 --> 00:28:14,930
[Student]Inaudible.

452
00:28:15,020 --> 00:28:16,730
[Professor]Two square root of two, fourth root of n?

453
00:28:16,860 --> 00:28:18,100
That's on the right track.

454
00:28:18,200 --> 00:28:22,770
Both the constant and the root change, but not quite so fancily.

455
00:28:24,650 --> 00:28:26,690
Three times the cubed root: good.

456
00:28:27,900 --> 00:28:29,350
Intuition is very helpful here.

457
00:28:30,000 --> 00:28:31,780
It doesn't matter what the right answer is.

458
00:28:31,840 --> 00:28:33,130
Use your intuition.

459
00:28:33,230 --> 00:28:34,900
You can prove that. It's not so hard.

460
00:28:34,970 --> 00:28:36,560
You now have three lists,

461
00:28:36,700 --> 00:28:39,960
and what you want to balance are at the length of the top list,

462
00:28:40,060 --> 00:28:42,350
the ratio between the top two lists,

463
00:28:42,400 --> 00:28:44,080
and the ratio between the bottom two lists.

464
00:28:44,140 --> 00:28:48,850
So, you want these three to multiply out to n,

465
00:28:50,130 --> 00:28:53,300
because the top times the ratio times the ratio...

466
00:28:53,390 --> 00:28:54,750
that has to equal n.

467
00:28:54,850 --> 00:28:57,270
And, so that's where you get the cubed root of n.

468
00:28:57,370 --> 00:28:58,840
Each of these should be equal.

469
00:28:58,890 --> 00:29:01,290
So, you set them because the cost

470
00:29:01,410 --> 00:29:02,900
is the sum of those three things.

471
00:29:03,020 --> 00:29:04,740
So, you set each of them to cubed root of n,

472
00:29:04,840 --> 00:29:05,830
and there are three of them.

473
00:29:05,890 --> 00:29:09,730
OK, check it at home if you want to be more sure.

474
00:29:12,100 --> 00:29:14,160
Obviously, we want a few more.

475
00:29:14,230 --> 00:29:15,830
So, let's think about k sorted lists.

476
00:29:15,900 --> 00:29:19,350
k sorted lists will be k times the k'th root of n.

477
00:29:19,480 --> 00:29:21,520
You probably guessed that by now.

478
00:29:21,580 --> 00:29:24,020
So, what should we set k to?

479
00:29:30,720 --> 00:29:32,610
I don't want the exact minimum.

480
00:29:32,700 --> 00:29:36,120
What's a good value for k?

481
00:29:36,250 --> 00:29:39,200
Should I set it to n? n's kind of nice,

482
00:29:39,300 --> 00:29:40,560
because the n'th root of n is just one.

483
00:29:40,660 --> 00:29:45,480
Now that's n. So, this is why I cared about the lead constant

484
00:29:45,580 --> 00:29:47,800
because it's going to grow as I add more lists.

485
00:29:54,090 --> 00:29:56,810
What's the biggest reasonable value of k that I could use?

486
00:29:58,450 --> 00:30:02,860
Log n, because I have a k out there.

487
00:30:02,970 --> 00:30:04,580
I certainly don't want to use more than log n.

488
00:30:04,630 --> 00:30:08,830
So, log n times the log n'th root,

489
00:30:08,940 --> 00:30:11,550
and this is a little hard to draw of n.

490
00:30:11,660 --> 00:30:13,960
Now, what is the log n'th root of n?

491
00:30:14,820 --> 00:30:17,040
That's what you're all thinking about.

492
00:30:24,920 --> 00:30:27,690
What is the log n'th root of n minus two?

493
00:30:32,460 --> 00:30:34,800
It's one of these good questions whose answer is?

494
00:30:39,420 --> 00:30:43,200
Oh man. Remember the definition of root?

495
00:30:43,260 --> 00:30:46,700
OK, the root is n to the one over log n.

496
00:30:48,020 --> 00:30:51,920
OK, good, remember the definition of having a power, A to the B?

497
00:30:52,020 --> 00:30:54,810
It was like two to the power, B log A?

498
00:30:54,900 --> 00:30:56,690
Does that sound familiar?

499
00:30:56,750 --> 00:31:02,420
So, this is two to the log n over log n,

500
00:31:03,280 --> 00:31:11,490
which is, I hope you can get it at this point, two.

501
00:31:13,170 --> 00:31:17,290
Wow, so the log n'th root of n minus two is zero:

502
00:31:17,390 --> 00:31:18,820
my favorite answer.

503
00:31:18,920 --> 00:31:25,750
OK, this is two. So this whole thing is two log n: pretty nifty.

504
00:31:25,850 --> 00:31:28,900
So, you could be a little fancier and tweak this a little bit,

505
00:31:29,000 --> 00:31:30,910
but two log n is plenty good for me.

506
00:31:30,970 --> 00:31:34,140
We clearly don't want to use any more lists,

507
00:31:34,230 --> 00:31:36,060
but log n lists sounds pretty good.

508
00:31:36,150 --> 00:31:38,830
I get, now, logarithmic search time. Let's check.

509
00:31:38,940 --> 00:31:40,880
I mean, we sort of did this all intuitively.

510
00:31:40,940 --> 00:31:46,810
Let's draw what the list looks like. But, it will work.

511
00:31:57,110 --> 00:32:01,300
So, I'm going to redraw this example

512
00:32:01,390 --> 00:32:03,600
because you have to, also.

513
00:32:05,810 --> 00:32:08,800
So, let's redesign that New York City subway system.

514
00:32:08,890 --> 00:32:13,300
And, I want you to leave three blank lines up here.

515
00:32:17,190 --> 00:32:22,160
So, you should have this memorized by now. But I don't.

516
00:32:30,110 --> 00:32:32,430
So, we are not allowed to change the local line,

517
00:32:34,800 --> 00:32:37,520
though it would be nice, add a few more stops there.

518
00:32:40,540 --> 00:32:44,620
OK, we can stop at 79th Street. That's enough.

519
00:32:44,720 --> 00:32:47,830
So now, we have log n lists.

520
00:32:48,040 --> 00:32:49,740
And here, log n is about four.

521
00:32:49,840 --> 00:32:52,690
So, I want to make a bunch of lists here.

522
00:32:52,790 --> 00:32:55,100
In particular, 14 will appear on all of them.

523
00:32:55,740 --> 00:32:58,220
So, why don't I draw those in?

524
00:33:02,240 --> 00:33:04,600
And, the question is, which elements go in here?

525
00:33:04,650 --> 00:33:07,340
So, I have log n lists. And, my goal is

526
00:33:07,430 --> 00:33:09,960
to balance the number of items up here,

527
00:33:10,050 --> 00:33:16,200
and the ratio between these two lists

528
00:33:16,260 --> 00:33:17,950
I want all these things to be balanced.

529
00:33:18,000 --> 00:33:19,470
There are log n of them.

530
00:33:19,560 --> 00:33:25,050
So, the product of all those ratios better be n,

531
00:33:25,140 --> 00:33:26,910
the number of elements down here.

532
00:33:26,970 --> 00:33:29,650
So, the product of all these ratios is n.

533
00:33:29,750 --> 00:33:33,430
And there's log n of them; how big is each ratio?

534
00:33:36,750 --> 00:33:39,630
So, I'll call the ratio r. The ratio's r.

535
00:33:39,720 --> 00:33:43,090
I should have r to the power of log n equals n.

536
00:33:43,960 --> 00:33:54,040
What's r? What's r minus two?

537
00:33:56,400 --> 00:34:02,620
Zero. OK, this should be two to the power of log n.

538
00:34:02,710 --> 00:34:05,210
So, if the ratio between the number of elements here and here

539
00:34:05,300 --> 00:34:07,210
is two all the way down,

540
00:34:07,310 --> 00:34:10,710
then I will have an elements at the bottom, which is what I want.

541
00:34:10,800 --> 00:34:12,440
So, in other words, I want half the elements here,

542
00:34:12,540 --> 00:34:14,060
a quarter of the elements here,

543
00:34:14,160 --> 00:34:15,690
an eighth of the elements here, and so on.

544
00:34:15,750 --> 00:34:19,090
So, I'm going to take half of the elements evenly spaced out:

545
00:34:20,600 --> 00:34:27,030
34th, 50th, 66th, 79th, and so on.

546
00:34:28,620 --> 00:34:33,200
So, this is our new semi-express line: not terribly fast,

547
00:34:33,290 --> 00:34:35,620
but you save a factor of two for going up there.

548
00:34:37,640 --> 00:34:41,460
And, when you're done, you go down,

549
00:34:41,550 --> 00:34:42,550
and you walk, at most, one step.

550
00:34:42,640 --> 00:34:44,440
And you find what you're looking for.

551
00:34:44,440 --> 00:34:48,510
OK, and then we do the same thing over and over and over

552
00:34:48,610 --> 00:34:54,120
until we run out of elements. I can't read my own writing.

553
00:34:54,210 --> 00:35:10,840
It's 79th. OK, if I had a bigger example,

554
00:35:10,930 --> 00:35:11,970
I would be more levels,

555
00:35:12,030 --> 00:35:13,680
but this is just barely enough.

556
00:35:13,770 --> 00:35:15,470
Let's say two elements is where I stop.

557
00:35:16,670 --> 00:35:17,580
So, this looks good.

558
00:35:17,680 --> 00:35:18,790
Does this look like a structure

559
00:35:18,880 --> 00:35:25,140
you've seen before, at all, vaguely? Yes?

560
00:35:25,240 --> 00:35:28,220
A tree: yes. It looks a lot like a binary tree.

561
00:35:28,310 --> 00:35:31,820
I'll just leave it at that. In your problem set,

562
00:35:31,910 --> 00:35:34,130
you'll understand why skip lists are really like trees.

563
00:35:34,190 --> 00:35:37,440
But it's more or less a tree.

564
00:35:37,530 --> 00:35:41,660
Let's say at this level, it looks sort of like binary search.

565
00:35:41,760 --> 00:35:44,180
You look at 14; you look at 15,

566
00:35:44,230 --> 00:35:45,590
and therefore, you decide whether you are

567
00:35:45,680 --> 00:35:47,220
in the left half for the right half.

568
00:35:47,310 --> 00:35:49,020
And that's sort of like a tree.

569
00:35:49,080 --> 00:35:50,360
It's not quite a tree

570
00:35:50,450 --> 00:35:52,790
because we have this element repeated all over.

571
00:35:52,840 --> 00:35:55,980
But more or less, this is a binary tree.

572
00:35:56,070 --> 00:35:59,280
At depth I, we have two to the I nodes,

573
00:35:59,380 --> 00:36:02,890
just like a tree, just like a balanced tree.

574
00:36:02,980 --> 00:36:06,030
I'm going to call this structure an ideal skip list.

575
00:36:08,160 --> 00:36:10,230
And, if all we are doing our searches,

576
00:36:10,330 --> 00:36:13,110
ideal skip lists are pretty good.

577
00:36:14,480 --> 00:36:17,680
Maybe at practice: not quite as good as a binary search tree,

578
00:36:17,770 --> 00:36:20,490
but up to constant factors: just as good.

579
00:36:23,000 --> 00:36:25,720
So, for example, I mean, we can generalize search,

580
00:36:25,810 --> 00:36:27,840
just check that it's log n.

581
00:36:28,860 --> 00:36:31,400
So, the search procedure is you start at the top left.

582
00:36:31,490 --> 00:36:33,650
So, let's say we are looking for 72.

583
00:36:35,650 --> 00:36:39,040
You start at the top left. 14 is smaller than 72,

584
00:36:39,130 --> 00:36:41,820
so I try to go right. 79 is too big.

585
00:36:41,910 --> 00:36:46,040
So, I follow this arrow, but I say, oops, that's too much.

586
00:36:46,150 --> 00:36:49,180
So, instead, I go down 14 still.

587
00:36:49,270 --> 00:36:52,630
I go to the right: oh, 50, that's still smaller than 72: OK.

588
00:36:52,720 --> 00:36:55,770
I tried to go right again. Oh: 79, that's too big.

589
00:36:55,860 --> 00:37:00,000
That's no good. So, I go down. So, I get 50.

590
00:37:00,100 --> 00:37:03,060
I do the same thing over and over.

591
00:37:03,150 --> 00:37:05,130
I try to go to the right: oh, 66, that's OK.

592
00:37:05,220 --> 00:37:08,380
Try to go to the right: oh, 79, that's too big. So I go down.

593
00:37:08,480 --> 00:37:11,040
Now I go to the right and, oh, 72: done.

594
00:37:11,140 --> 00:37:13,990
Otherwise, I'd go too far and try to go down and say,

595
00:37:14,080 --> 00:37:15,830
oops, element must not be there.

596
00:37:15,890 --> 00:37:19,100
It's a very simple search algorithm: same as here

597
00:37:19,190 --> 00:37:21,550
except just remove the L_1 and L_2.

598
00:37:21,610 --> 00:37:24,020
Go right until that would go too far. Then go down.

599
00:37:24,110 --> 00:37:26,220
Then go right until we'd go too far, and then go down.

600
00:37:26,270 --> 00:37:27,510
You might have to do this log n times.

601
00:37:27,600 --> 00:37:30,950
In each level, you're clearly only walking a couple of steps

602
00:37:31,040 --> 00:37:34,370
because the ratio between these two sizes is only two.

603
00:37:35,870 --> 00:37:39,090
So, this will cost two log n for search.

604
00:37:39,180 --> 00:37:41,120
Good, I mean, so that was to check

605
00:37:41,210 --> 00:37:44,280
because we were using intuition over here; a little bit shaky.

606
00:37:47,290 --> 00:37:49,490
So, this is an ideal skip list,

607
00:37:49,580 --> 00:37:51,620
we have to support insertions and deletions.

608
00:37:51,670 --> 00:37:53,440
As soon as we do an insert and delete,

609
00:37:53,500 --> 00:37:55,230
there's no way we're going to maintain the structure.

610
00:37:55,290 --> 00:37:58,630
It's a bit too special.

611
00:37:58,710 --> 00:37:59,620
There is only one of these

612
00:37:59,720 --> 00:38:03,570
where everything is perfectly spaced out,

613
00:38:03,660 --> 00:38:06,940
and everything is beautiful. So, we can't do that.

614
00:38:07,030 --> 00:38:11,590
We're going to maintain roughly this structure as best we can.

615
00:38:14,590 --> 00:38:15,830
And, if anyone of you knows

616
00:38:15,920 --> 00:38:19,670
someone in New York City subway planning,

617
00:38:19,760 --> 00:38:23,580
you can tell them this. OK, so: skip lists.

618
00:38:33,220 --> 00:38:36,000
So, I mean, this is basically our data structure.

619
00:38:36,090 --> 00:38:37,430
You could use this as a starting point,

620
00:38:37,530 --> 00:38:39,860
but then you start using skip lists.

621
00:38:42,410 --> 00:38:46,760
And, we need to somehow implement insertions and deletions,

622
00:38:49,210 --> 00:38:52,120
and maintain roughly this structure well enough

623
00:38:52,210 --> 00:38:56,560
that the search still costs order log n time.

624
00:39:01,620 --> 00:39:03,440
So, let's focus on insertions.

625
00:39:04,290 --> 00:39:05,970
If we do insertions right,

626
00:39:06,060 --> 00:39:08,680
it turns out deletions are really trivial.

627
00:39:26,360 --> 00:39:27,910
And again, this is all from first principles.

628
00:39:28,000 --> 00:39:29,680
We're not allowed to use anything fancy.

629
00:39:32,030 --> 00:39:34,130
But, it would be nice if we used some good chalk.

630
00:39:34,990 --> 00:39:36,620
This one looks better.

631
00:39:39,330 --> 00:39:41,550
So, suppose you want to insert an element, x.

632
00:39:41,610 --> 00:39:44,730
We said how to search for an element. So, how do we insert it?

633
00:39:46,230 --> 00:39:48,430
Well, the first thing we should do is figure out where it goes.

634
00:39:48,520 --> 00:39:55,140
So, we search for x. We call search of x to find

635
00:39:55,250 --> 00:40:00,630
where x fits in the bottom list, not just any list.

636
00:40:00,720 --> 00:40:03,130
Pretty easy to find out where it fits in the top list.

637
00:40:03,180 --> 00:40:06,260
That takes, like, constant time. What we want to know:

638
00:40:06,360 --> 00:40:09,040
because the top list has constant length,

639
00:40:09,140 --> 00:40:12,210
we want to know where x goes in the bottom list.

640
00:40:12,270 --> 00:40:15,230
So, let's say we want to insert a search for 80.

641
00:40:15,330 --> 00:40:19,280
Well, it is a bit too big. Let search for 75.

642
00:40:19,360 --> 00:40:21,720
So, we'll find the 75 fits right here

643
00:40:21,810 --> 00:40:24,320
between 72 and 79 using the same path.

644
00:40:26,630 --> 00:40:30,330
OK, if it's there already, we complain because I'm going to

645
00:40:30,420 --> 00:40:31,910
assume all keys are distinct for now

646
00:40:32,010 --> 00:40:34,350
just so the picture stays simple. But this works fine

647
00:40:34,400 --> 00:40:37,880
even if you are inserting the same key over and over.

648
00:40:41,090 --> 00:40:43,080
So, that seems good.

649
00:40:43,180 --> 00:40:48,570
One thing we should clearly do is insert x into the bottom list.

650
00:40:49,410 --> 00:40:54,840
We now know where it fits. It should go there.

651
00:40:56,540 --> 00:40:59,300
Because we want to maintain this invariant,

652
00:40:59,360 --> 00:41:04,670
that the bottom list contains all the elements.

653
00:41:04,670 --> 00:41:07,120
So, there we go. We've maintained the invariant.

654
00:41:16,120 --> 00:41:19,740
The bottom list contains all the elements. So, we search for 75.

655
00:41:19,840 --> 00:41:22,800
We say, oh, 75 goes here, and we just sort of link in 75.

656
00:41:22,900 --> 00:41:24,820
You know how to do a linked list, I hope.

657
00:41:25,550 --> 00:41:27,080
Let me just erase that pointer.

658
00:41:27,180 --> 00:41:28,850
All the work in implementing skip lists

659
00:41:28,900 --> 00:41:30,930
is the linked list manipulation.

660
00:41:33,810 --> 00:41:38,190
Is that enough? No, it would be fine for now

661
00:41:38,290 --> 00:41:40,700
because now there's only a chain of length three here

662
00:41:40,790 --> 00:41:41,710
that you'd have to walk over

663
00:41:41,770 --> 00:41:44,270
if you're looking for something in this range.

664
00:41:44,360 --> 00:41:48,470
But if I just keep inserting 75, and 76, than 76 plus epsilon,

665
00:41:48,560 --> 00:41:50,600
76 plus two epsilon, and so on,

666
00:41:50,650 --> 00:41:52,390
just pack a whole bunch of elements in here,

667
00:41:52,440 --> 00:41:53,660
this chain will get really long.

668
00:41:53,760 --> 00:41:56,670
Now, suddenly, things are not so balanced. If I do a search,

669
00:41:56,770 --> 00:42:01,220
I'll pay an arbitrarily long amount time here to search for someone.

670
00:42:01,320 --> 00:42:03,050
If I insert k things, it'll take k time.

671
00:42:03,100 --> 00:42:05,390
I want it to stay log n.

672
00:42:06,250 --> 00:42:08,970
If I only insert log n items, it's OK for now.

673
00:42:09,060 --> 00:42:14,330
What I want to do is decide which of these lists contain 75.

674
00:42:14,420 --> 00:42:16,820
So, clearly it goes on the bottom.

675
00:42:16,870 --> 00:42:18,090
Every element goes in the bottom.

676
00:42:18,150 --> 00:42:24,840
Should it go up a level? Maybe. It depends. It's not clear yet.

677
00:42:24,940 --> 00:42:26,050
If I insert a few items here,

678
00:42:26,140 --> 00:42:28,390
definitely some of them should go on the next level.

679
00:42:28,440 --> 00:42:33,070
Should I go to levels up? Maybe, but even less likely.

680
00:42:33,170 --> 00:42:36,990
So, what should I do?

681
00:42:48,350 --> 00:42:58,310
Yeah? [Student]Inaudible.

682
00:42:58,400 --> 00:43:01,030
Right, so you maintain the ideal partition size,

683
00:43:01,120 --> 00:43:02,680
which may be like the length of this chain.

684
00:43:02,770 --> 00:43:05,050
And you see, well, if that gets too long,

685
00:43:05,140 --> 00:43:07,760
then I should split it in the middle,

686
00:43:07,840 --> 00:43:09,270
promote that guy up to the next level,

687
00:43:09,360 --> 00:43:11,240
and do the same thing up here.

688
00:43:11,290 --> 00:43:12,380
If this chain gets too long

689
00:43:12,470 --> 00:43:14,940
between two consecutive next level express stops,

690
00:43:15,030 --> 00:43:17,840
then I'll promote the middle guy.

691
00:43:17,920 --> 00:43:20,430
And that's what you'll do in your problem set.

692
00:43:20,530 --> 00:43:25,830
That's too fancy for me. I don't need no stinking counters.

693
00:43:29,760 --> 00:43:31,270
What else could I do?

694
00:43:37,770 --> 00:43:44,170
[Student]Inaudible.

695
00:43:44,460 --> 00:43:47,310
I could try to maintain the ideal skip list structure.

696
00:43:47,410 --> 00:43:48,380
That will be too expensive.

697
00:43:48,430 --> 00:43:50,740
Like I say, 75 is the guy that gets promoted,

698
00:43:50,790 --> 00:43:52,930
and this guy gets demoted all the way down.

699
00:43:52,990 --> 00:43:55,140
But that will propagate everything to the right.

700
00:43:55,190 --> 00:43:59,590
And that could cost linear time for update. Other idea?

701
00:43:59,930 --> 00:44:02,140
[Student]Inaudible.

702
00:44:02,240 --> 00:44:04,680
[Professor]If I only want half of them to go up, I could flip a coin.

703
00:44:04,770 --> 00:44:11,490
Good idea. All right, for that, I will give you a quarter.

704
00:44:11,580 --> 00:44:19,440
It's a good one. It's the old line state, Maryland.

705
00:44:19,550 --> 00:44:24,870
There you go. However, you have to

706
00:44:24,960 --> 00:44:26,850
perform some services for that quarter,

707
00:44:26,900 --> 00:44:29,530
namely, flip the coin.

708
00:44:29,620 --> 00:44:33,690
Can you flip a coin? Good. What did you get?

709
00:44:33,780 --> 00:44:36,890
Tails, OK, that's the first random bit.

710
00:44:38,870 --> 00:44:40,520
But we are going to do is build a skip list.

711
00:44:40,600 --> 00:44:43,990
Maybe I should tell you how first.

712
00:44:44,080 --> 00:44:46,600
OK, but the idea is flip a coin.

713
00:44:46,700 --> 00:44:50,120
If it's heads, so, sorry, if it's heads,

714
00:44:50,210 --> 00:44:54,920
we will promote it to the next level, and flip again.

715
00:44:56,530 --> 00:44:59,040
So, this is an answer to the question,

716
00:44:59,140 --> 00:45:07,950
which other lists should store x?

717
00:45:09,450 --> 00:45:11,710
How many other lists should we add x to?

718
00:45:11,770 --> 00:45:14,160
Well, the algorithm is, flip a coin,

719
00:45:16,920 --> 00:45:22,990
and if it comes out heads, then promote x

720
00:45:23,080 --> 00:45:33,560
to the next level up, and flip again.

721
00:45:33,660 --> 00:45:36,440
OK, that's key because we might

722
00:45:36,530 --> 00:45:38,850
want this element to go arbitrarily high.

723
00:45:38,850 --> 00:45:40,980
But for starters, we flip a coin.

724
00:45:41,080 --> 00:45:42,340
It doesn't go to the next level.

725
00:45:42,430 --> 00:45:44,370
Well, we'd like it to go up

726
00:45:44,460 --> 00:45:46,170
to the next level with probability one half

727
00:45:46,270 --> 00:45:49,550
because we want the ratio between these two sizes to be a half,

728
00:45:49,650 --> 00:45:53,100
or sorry, two, depending which way you take the ratio.

729
00:45:53,190 --> 00:45:55,730
So, I want roughly half the elements up here. So, I flip a coin.

730
00:45:55,830 --> 00:45:57,590
If it comes up heads, I go up here.

731
00:45:57,710 --> 00:46:01,380
This is a fair coin. So I want it 50-50.

732
00:46:01,470 --> 00:46:06,570
OK, then how many should that element go up to the next level up?

733
00:46:06,670 --> 00:46:09,770
Well, with 50% probability again. So, I flip another coin.

734
00:46:09,860 --> 00:46:11,720
If it comes up heads, I'll go up another level.

735
00:46:11,780 --> 00:46:14,220
And that will maintain the approximate ratio

736
00:46:14,320 --> 00:46:16,720
between these two guys as being two.

737
00:46:16,770 --> 00:46:18,840
The expected ratio will definitely

738
00:46:18,930 --> 00:46:21,140
be two, and so on, all the way up.

739
00:46:21,190 --> 00:46:23,310
If I go up to the top and flip a coin,

740
00:46:23,400 --> 00:46:25,660
it comes up heads, I'll make another level.

741
00:46:25,710 --> 00:46:29,220
This is the insertion algorithm: dead simple.

742
00:46:31,460 --> 00:46:33,970
The fancier one you will see on your problem set.

743
00:46:37,240 --> 00:46:38,730
So, let's do it.

744
00:46:47,620 --> 00:46:51,120
OK, I also need someone to generate random numbers.

745
00:46:51,210 --> 00:46:52,780
Who can generate random numbers?

746
00:46:53,850 --> 00:46:56,960
Pseudo-random? I'll give you a quarter.

747
00:46:58,400 --> 00:47:00,300
I have one here. Here you go.

748
00:47:00,350 --> 00:47:01,850
That's a boring quarter.

749
00:47:01,940 --> 00:47:03,180
Who would like to generate random numbers?

750
00:47:05,580 --> 00:47:07,820
Someone volunteering someone else:

751
00:47:07,880 --> 00:47:10,660
that's a good way to do it. Here you go.

752
00:47:10,750 --> 00:47:12,740
You get a quarter, but you're not allowed to flip it.

753
00:47:14,270 --> 00:47:17,400
No randomness for you; well, OK, you can generate bits,

754
00:47:17,400 --> 00:47:18,550
and then compute a number.

755
00:47:19,190 --> 00:47:21,890
So, give me a number. 44, good answer.

756
00:47:22,910 --> 00:47:25,930
OK, we already flipped a coin and I got tails.

757
00:47:26,030 --> 00:47:28,880
Done. That's the insertion algorithm.

758
00:47:28,980 --> 00:47:32,190
I'm going to make some more space actually, put it way down here.

759
00:47:33,120 --> 00:47:35,800
OK, so 44 does not get promoted because we got a tails.

760
00:47:35,900 --> 00:47:37,630
So, give me another number.

761
00:47:37,760 --> 00:47:41,530
Nine, OK, I search for nine in this list.

762
00:47:41,620 --> 00:47:52,450
I should mention one other thing, sorry. I need a small change.

763
00:47:53,140 --> 00:47:56,310
This is just to make sure searches still work.

764
00:47:56,400 --> 00:48:00,160
So, the worry is suppose I insert something bigger

765
00:48:00,250 --> 00:48:01,680
and then I promote it.

766
00:48:01,770 --> 00:48:04,970
This would look very bad for a skip list data structure

767
00:48:05,070 --> 00:48:06,140
because I always want to start at the top left,

768
00:48:06,230 --> 00:48:07,750
and now there's no top left.

769
00:48:07,840 --> 00:48:12,440
So, just minor change: just let me remember that.

770
00:48:14,230 --> 00:48:15,500
The minor change is that I'm going to

771
00:48:15,590 --> 00:48:19,510
store a special value minus infinity in every list.

772
00:48:20,580 --> 00:48:25,160
So, minus infinity always gets promoted all the way to the top,

773
00:48:25,250 --> 00:48:26,930
whatever the top happens to be now.

774
00:48:29,390 --> 00:48:32,170
So, initially, that way I'll always have a top left.

775
00:48:32,910 --> 00:48:34,480
Sorry, I forgot to mention that.

776
00:48:34,580 --> 00:48:36,540
So, initially I'll just have minus infinity.

777
00:48:36,620 --> 00:48:40,600
Then I insert 44. I say, OK, 44 goes there, no promotion, done.

778
00:48:40,690 --> 00:48:44,010
Now, we're going to insert nine. Nine goes here.

779
00:48:47,360 --> 00:48:53,830
So, minus infinity to nine, flip your coin, heads.

780
00:48:56,400 --> 00:48:58,090
Did he actually flip it?

781
00:48:58,180 --> 00:49:01,330
OK, good. He flipped it before, yeah, sure.

782
00:49:01,890 --> 00:49:04,910
I'm just... giving me a hard time. So, we have nine up here.

783
00:49:05,000 --> 00:49:07,160
We need to maintain this minus infinity

784
00:49:07,220 --> 00:49:11,300
just to make sure it gets promoted along with everything else.

785
00:49:11,390 --> 00:49:12,340
So, that looks like a nice skip list.

786
00:49:12,440 --> 00:49:15,890
Flip it again. Tails, good.

787
00:49:15,980 --> 00:49:20,450
OK, so this looks like an ideal skip list. Isn't that great?

788
00:49:20,540 --> 00:49:24,160
It works every time. OK, give me another number. 26,

789
00:49:24,250 --> 00:49:27,350
OK, so I search for 26. 26 goes here.

790
00:49:27,440 --> 00:49:29,510
It clearly goes on the bottom list.

791
00:49:31,110 --> 00:49:37,870
Here we go, 26, and then I you raised 44. Flip.

792
00:49:37,970 --> 00:49:46,690
Tails, OK, another number. 50, oh, a big one.

793
00:49:46,780 --> 00:49:51,880
It costs me a little while to search, and I get over here. 50.

794
00:49:51,970 --> 00:49:59,510
Flip. Heads, good. So 50 gets promoted. Flip it again.

795
00:50:02,750 --> 00:50:05,610
Tails, OK, still a reasonable number.

796
00:50:05,700 --> 00:50:09,330
Another number? 12, it takes a little while to get exciting here.

797
00:50:09,420 --> 00:50:12,080
OK, 12 goes here between nine and 26.

798
00:50:16,100 --> 00:50:20,880
You're giving me a hard time here. OK, flip.

799
00:50:22,640 --> 00:50:24,850
Heads, OK, 12 gets promoted.

800
00:50:24,900 --> 00:50:26,910
I know you have to work a little bit,

801
00:50:26,960 --> 00:50:28,960
but we just came here to search for 12.

802
00:50:29,010 --> 00:50:31,770
So, we know that nine was the last point we went down.

803
00:50:31,870 --> 00:50:36,150
So, we promote 12. It gets inserted up here.

804
00:50:36,240 --> 00:50:39,320
We are just inserting into this particular linked list:

805
00:50:39,420 --> 00:50:40,890
nothing fancy.

806
00:50:40,980 --> 00:50:42,740
We link the two twelves together.

807
00:50:42,790 --> 00:50:43,990
It still looks kind of like a linked list.

808
00:50:44,080 --> 00:50:55,030
Flip again. OK, tails, another number. 37. Jeez.

809
00:50:58,660 --> 00:51:03,250
It's a good test of memory. 37, what was it, 44 and 50?

810
00:51:05,810 --> 00:51:08,220
And 50 was at the next level up.

811
00:51:08,320 --> 00:51:10,670
I think I should just keep appending elements

812
00:51:10,760 --> 00:51:11,840
and have you flip coins.

813
00:51:11,940 --> 00:51:17,790
OK, we just inserted 37. Tails.

814
00:51:17,890 --> 00:51:20,670
OK, that's getting to be a long chain.

815
00:51:20,770 --> 00:51:21,610
That looks a bit worse.

816
00:51:21,710 --> 00:51:28,030
OK, give me another number larger than 50. 51, good answer.

817
00:51:31,480 --> 00:51:43,450
Thank you. OK, flip again.（Heads) And again. Tails. Another number.

818
00:51:43,550 --> 00:51:47,080
Wait, someone else should pick a number. It's not working.

819
00:51:47,170 --> 00:51:57,350
What did you say? 52, good answer. Flip. Tails, not surprising.

820
00:51:57,440 --> 00:51:59,000
We've gotten a lot of heads there.

821
00:51:59,090 --> 00:52:01,620
OK, another number. 53, thank you.

822
00:52:01,680 --> 00:52:16,560
Flip. Heads, heads, OK. Heads, heads, you didn't flip.

823
00:52:16,650 --> 00:52:20,610
All right, 53, you get the idea.

824
00:52:20,700 --> 00:52:23,310
If you get two consecutive heads,

825
00:52:23,410 --> 00:52:24,720
then the guy goes up two levels.

826
00:52:25,960 --> 00:52:27,480
OK, now flip for real.

827
00:52:30,570 --> 00:52:36,160
Heads. Finally. Heads we've been waiting for.

828
00:52:36,250 --> 00:52:39,210
If you flipped three heads in a row, you go three levels.

829
00:52:39,300 --> 00:52:41,220
And each time, we keep promoting minus infinity.

830
00:52:43,320 --> 00:52:49,190
Look again. Heads, oh my God. Where were they before?

831
00:52:50,790 --> 00:52:58,330
Flip again. It better be tails this time. Tails, good.

832
00:52:58,380 --> 00:53:00,760
OK, you get the idea. Eventually you run out of board space.

833
00:53:00,850 --> 00:53:03,090
Now, it's pretty rare that you go too high.

834
00:53:03,150 --> 00:53:05,400
What's the probability that you go higher than log n?

835
00:53:08,600 --> 00:53:10,380
Another easy log computation.

836
00:53:12,880 --> 00:53:16,170
Each time, I have a 50% probability of going up.

837
00:53:16,260 --> 00:53:19,630
One in n probability of going up log n levels

838
00:53:19,730 --> 00:53:23,230
because half to the power of log n is one out of n.

839
00:53:23,320 --> 00:53:28,430
So, it depends on n, but I'm not going to go too high.

840
00:53:28,520 --> 00:53:34,270
And, intuitively, this is not so bad. So, these are skip lists.

841
00:53:41,560 --> 00:53:44,440
You have the ratios right in expectation,

842
00:53:45,290 --> 00:53:46,790
which is a pretty weak statement.

843
00:53:46,880 --> 00:53:48,890
This doesn't say anything about the lengths of these change.

844
00:53:48,980 --> 00:53:52,530
But intuitively, it's pretty good.

845
00:53:56,210 --> 00:53:58,110
Let's say pretty good on average.

846
00:53:58,900 --> 00:54:02,570
So, I had two semi-random processes going on here.

847
00:54:02,660 --> 00:54:04,730
One is picking the numbers, and that,

848
00:54:04,780 --> 00:54:06,270
I don't want to assume anything about.

849
00:54:06,360 --> 00:54:08,310
The numbers could be adversarial. It could be sequential.

850
00:54:08,360 --> 00:54:11,360
It could be reverse sorted. It could be random. I don't know.

851
00:54:12,370 --> 00:54:14,030
So, it didn't matter what he said.

852
00:54:14,120 --> 00:54:15,460
At least, it shouldn't matter.

853
00:54:16,110 --> 00:54:19,050
I mean, it matters here. Don't worry. You're still loved.

854
00:54:19,050 --> 00:54:20,550
You still get your $0.25.

855
00:54:20,650 --> 00:54:23,360
But what the algorithm cares about is

856
00:54:23,440 --> 00:54:24,790
the outcomes of these coins.

857
00:54:24,880 --> 00:54:26,290
And the probability, the statement that

858
00:54:26,360 --> 00:54:29,280
this data structure is fast with high probability

859
00:54:29,330 --> 00:54:30,690
is only about the random coins.

860
00:54:30,750 --> 00:54:32,940
Right, it doesn't matter what the adversary chooses for numbers

861
00:54:33,000 --> 00:54:34,840
as long as those coins are random,

862
00:54:34,890 --> 00:54:36,320
and the adversary doesn't know the coins.

863
00:54:37,050 --> 00:54:38,530
It doesn't know the outcomes of the coins.

864
00:54:39,260 --> 00:54:41,470
So, in that case, on average,

865
00:54:41,530 --> 00:54:44,120
overall of the coin flips, you should be OK.

866
00:54:46,270 --> 00:54:50,220
But the claim is not just that it's pretty good on average.

867
00:54:50,320 --> 00:54:54,710
But, it's really, really good almost always.

868
00:55:00,310 --> 00:55:05,660
OK, with really high probability it's log n.

869
00:55:06,240 --> 00:55:10,330
So, for example, with probability, one minus one over n,

870
00:55:10,420 --> 00:55:12,340
it's order of log n,

871
00:55:12,400 --> 00:55:15,310
with probability one minus one over n^2 it's log n,

872
00:55:15,400 --> 00:55:18,870
probability one minus one over n^100, it's order log n.

873
00:55:18,960 --> 00:55:22,060
All those statements are true for any value of 100.

874
00:55:22,160 --> 00:55:27,980
So, that's where we're going.

875
00:55:29,710 --> 00:55:33,430
OK, I should mention, how do you delete in a skip list?

876
00:55:33,520 --> 00:55:36,120
Find the element. You delete it all the way.

877
00:55:36,210 --> 00:55:40,300
There's nothing fancy with delete.

878
00:55:40,400 --> 00:55:42,710
Because we have all these independent, random choices,

879
00:55:42,760 --> 00:55:45,080
all of these elements are sort of independent from each other.

880
00:55:45,170 --> 00:55:49,350
We don't really care. So, delete an element, just throw it away.

881
00:55:49,450 --> 00:55:52,660
The tricky part is insertion. When I insert an element,

882
00:55:52,750 --> 00:55:55,130
I'm just going to randomly see how high it should go.

883
00:55:55,190 --> 00:55:57,960
With probability one over two to the i, it will go to height i.

884
00:56:00,700 --> 00:56:06,800
Good, that's my time. I've been having too much fun here.

885
00:56:08,050 --> 00:56:11,970
I've got to go a little bit faster, OK.

886
00:56:22,470 --> 00:56:25,050
So here's the theorem.

887
00:56:25,880 --> 00:56:28,030
Let's see exactly what we are proving first.

888
00:56:29,400 --> 00:56:31,450
With high probability,

889
00:56:32,680 --> 00:56:36,650
this is a formal notion which I will define a second.

890
00:56:38,600 --> 00:56:51,820
Every search in n elements skip lists costs order of log n.

891
00:56:57,510 --> 00:56:59,230
So, that's the theorem.

892
00:56:59,330 --> 00:57:01,210
Now I need to define with high probability.

893
00:57:03,480 --> 00:57:05,460
So, with high probability.

894
00:57:10,540 --> 00:57:14,600
And, it's a bit of a long phrase. So, often we will,

895
00:57:14,690 --> 00:57:17,200
and you can abbreviate it WHP.

896
00:57:22,090 --> 00:57:26,300
So, if I have a random event, and the random event here is that

897
00:57:26,390 --> 00:57:29,460
every search in an n element skip list costs order log n,

898
00:57:30,140 --> 00:57:31,030
I want to know what it means

899
00:57:31,080 --> 00:57:33,640
for that event E to occur with high probability.

900
00:57:45,250 --> 00:57:46,660
So this is the definition.

901
00:57:53,630 --> 00:57:55,360
So, the statement is that

902
00:57:55,450 --> 00:57:58,750
for any alpha greater than or equal to one,

903
00:57:59,440 --> 00:58:01,240
there is a suitable choice of constants

904
00:58:14,900 --> 00:58:17,660
for which the event, E,

905
00:58:17,760 --> 00:58:20,950
occurs with this probability I keep mentioning.

906
00:58:29,830 --> 00:58:35,480
So, the probability at least one minus one over n to the alpha.

907
00:58:44,070 --> 00:58:46,840
So, this is a bit imprecise,

908
00:58:46,930 --> 00:58:48,550
but it will suffice for our purposes.

909
00:58:48,650 --> 00:58:50,940
If you want to really formal definition,

910
00:58:50,990 --> 00:58:52,490
you can read the lecture notes.

911
00:58:52,580 --> 00:58:53,710
There are special lecture notes

912
00:58:53,800 --> 00:58:57,850
for this lecture on the stellar site.

913
00:58:58,030 --> 00:59:00,460
And, there's the PowerPoint notes on the SMA site.

914
00:59:02,060 --> 00:59:05,040
But, right, there's a bit of a subtlety

915
00:59:05,130 --> 00:59:06,720
in the choice of constants here.

916
00:59:06,840 --> 00:59:08,330
There is a choice of this constant.

917
00:59:08,430 --> 00:59:10,740
And there's a choice of this constant.

918
00:59:10,820 --> 00:59:13,100
And, these are related.

919
00:59:13,150 --> 00:59:16,520
And, there's alpha, which we get to whatever we want.

920
00:59:16,610 --> 00:59:17,990
But the bottom line is,

921
00:59:18,180 --> 00:59:21,690
we get to choose what probability we want this to be true.

922
00:59:21,780 --> 00:59:23,930
If I want it to be true,

923
00:59:24,020 --> 00:59:27,200
with probability one minus one over n^100, I can do that.

924
00:59:28,180 --> 00:59:34,020
I just said alpha to a hundred, and up to this little constant

925
00:59:34,110 --> 00:59:36,980
that's going to grow much slower than n to the alpha.

926
00:59:37,070 --> 00:59:39,740
I get the error probability.

927
00:59:39,840 --> 00:59:41,810
So this thing is called the error probability.

928
00:59:41,860 --> 00:59:48,630
The probability that I fail is polynomially small,

929
00:59:48,730 --> 00:59:50,520
for any polynomial I want.

930
00:59:50,580 --> 00:59:54,080
Now, with the same data structure, right,

931
00:59:54,170 --> 00:59:55,870
I fixed the data structure. It doesn't depend on alpha.

932
00:59:55,960 --> 00:59:59,580
Anything you want, any alpha value you want,

933
00:59:59,690 --> 01:00:02,990
this data structure will take order of log n time.

934
01:00:03,090 --> 01:00:05,070
Now, this constant will depend on alpha.

935
01:00:05,120 --> 01:00:08,520
So, you know, you want error probability one over n^100

936
01:00:08,610 --> 01:00:12,400
is probably going to be, like, 100 log n. It's still log n.

937
01:00:12,490 --> 01:00:16,010
OK, this is a very strong claim

938
01:00:16,110 --> 01:00:20,040
about the tail of the distribution of the running time of search

939
01:00:20,100 --> 01:00:21,730
Very strong.

940
01:00:21,820 --> 01:00:24,520
Let me give you an idea of how strong it is.

941
01:00:30,410 --> 01:00:34,380
How many people know what Boole's inequality is?

942
01:00:36,820 --> 01:00:39,750
How many people know what the union bound is in probability?

943
01:00:42,770 --> 01:00:47,700
You should. It's in appendix c.

944
01:00:48,660 --> 01:00:51,430
Maybe you'll know it by the theorem.

945
01:00:52,530 --> 01:00:54,160
It's good to know it by name.

946
01:00:54,260 --> 01:00:56,260
It's sort of like linearity of expectations.

947
01:00:56,320 --> 01:00:58,130
It's a lot easier to communicate to someone.

948
01:00:59,540 --> 01:01:01,580
Linearity of expectations: instead of saying,

949
01:01:01,670 --> 01:01:03,070
you know that thing where you sum up

950
01:01:03,160 --> 01:01:04,940
all the expectations of things,

951
01:01:05,030 --> 01:01:06,920
and that's the expectation of the sum?

952
01:01:06,980 --> 01:01:09,550
It's a lot easier to say linearity of expectation.

953
01:01:11,740 --> 01:01:14,920
So, let me quiz you in a different way.

954
01:01:17,290 --> 01:01:18,570
So, if I take a bunch of events,

955
01:01:18,660 --> 01:01:19,860
and I take their union,

956
01:01:19,950 --> 01:01:23,270
either this happens or this happens, or so on.

957
01:01:23,370 --> 01:01:26,510
So, this is the inclusive OR of k events.

958
01:01:26,610 --> 01:01:28,910
And, instead, I look at

959
01:01:29,000 --> 01:01:31,600
the sum of the probabilities of those events.

960
01:01:35,130 --> 01:01:37,090
OK, easy question: are these equal?

961
01:01:38,900 --> 01:01:40,690
No, unless they are independent.

962
01:01:41,420 --> 01:01:45,390
But can I say anything about them, any relation?

963
01:01:46,800 --> 01:01:51,650
Smaller, yeah. This is less than or equal to that.

964
01:01:52,130 --> 01:01:53,980
OK, this should be intuitive to you

965
01:01:54,040 --> 01:01:55,370
from a probability point of view.

966
01:01:55,470 --> 01:01:56,550
Look at the textbook.

967
01:01:56,650 --> 01:02:00,150
OK: very basic result, trivial result almost.

968
01:02:03,080 --> 01:02:04,520
What does this tell us?

969
01:02:04,580 --> 01:02:07,680
Well, suppose that E_i is some kind of error event.

970
01:02:07,780 --> 01:02:09,120
We don't want it to happen.

971
01:02:09,800 --> 01:02:14,490
OK, and suppose, mix some letters here.

972
01:02:14,580 --> 01:02:16,340
Suppose I have a bunch of events

973
01:02:16,390 --> 01:02:17,800
which occur with high probability.

974
01:02:19,330 --> 01:02:21,740
OK, call those E_i complement.

975
01:02:22,400 --> 01:02:27,100
So, suppose, so this is the end of that statement,

976
01:02:27,200 --> 01:02:32,100
E_i complement occurs with high probability.

977
01:02:34,040 --> 01:02:35,930
OK, so then the probability of E_i

978
01:02:35,980 --> 01:02:39,450
is very small, polynomially small.

979
01:02:39,540 --> 01:02:42,060
One over n to the alpha for any alpha I want.

980
01:02:42,150 --> 01:02:45,580
Now, suppose I take a whole bunch of these events,

981
01:02:45,670 --> 01:02:48,930
and let's say that k is polynomial in n.

982
01:02:50,020 --> 01:02:53,330
So, I take a bunch of events, which I'd like to happen.

983
01:02:53,420 --> 01:02:55,070
They all occur with high probability.

984
01:02:55,160 --> 01:02:57,000
There is only polynomially many of them.

985
01:02:57,050 --> 01:03:00,260
So let's say, let me give this constant a name. Let's call it c.

986
01:03:00,350 --> 01:03:03,050
Let's say I take n to the c such events.

987
01:03:03,150 --> 01:03:06,260
Well, what's the probability that

988
01:03:06,360 --> 01:03:07,970
all those events occur together?

989
01:03:08,080 --> 01:03:11,190
Because they should most of the time occurred together

990
01:03:11,280 --> 01:03:13,780
because each one occurs most of the time,

991
01:03:13,870 --> 01:03:15,230
occurs with high probability.

992
01:03:15,330 --> 01:03:23,610
So, I want to look at E_1 bar intersect, E_2 bar, and so on.

993
01:03:24,210 --> 01:03:25,720
So, each of these occurs as high probability.

994
01:03:25,780 --> 01:03:27,690
What's the chance that they all occur?

995
01:03:28,640 --> 01:03:33,130
It's also with high probability. I'm changing the alpha.

996
01:03:33,230 --> 01:03:35,150
So, the union bound tells me

997
01:03:35,200 --> 01:03:38,390
the probability of any one of these failing,

998
01:03:38,490 --> 01:03:39,820
the probability of this failing,

999
01:03:39,910 --> 01:03:41,440
or this failing, or this failing,

1000
01:03:41,490 --> 01:03:43,480
which is this thing, is, at most,

1001
01:03:43,540 --> 01:03:46,070
the sum of the probabilities of each failure.

1002
01:03:46,160 --> 01:03:47,570
These are the error probabilities.

1003
01:03:47,660 --> 01:03:49,540
I know that each of them is,

1004
01:03:49,630 --> 01:03:52,250
at most, one over n to the alpha, with a constant in front.

1005
01:03:52,330 --> 01:03:56,430
If I add them all up, there's only n to the c of them.

1006
01:03:56,520 --> 01:04:01,870
So, I take this error probability, and I multiply by n to the c.

1007
01:04:01,960 --> 01:04:04,450
So, I get like n to the c over n to the alpha,

1008
01:04:04,550 --> 01:04:07,820
which is one over n to the alpha minus c.

1009
01:04:07,920 --> 01:04:10,020
I can set alpha as big as I want.

1010
01:04:10,070 --> 01:04:12,800
So, I said it much, much bigger than c,

1011
01:04:12,900 --> 01:04:15,750
and this event occurs with high probability.

1012
01:04:16,680 --> 01:04:20,240
I sort of made a mess here,

1013
01:04:20,330 --> 01:04:25,300
but this event occurs with high probability because of this.

1014
01:04:25,390 --> 01:04:29,180
Whatever the constant is here, however many events I'm taking,

1015
01:04:29,270 --> 01:04:31,990
I just set alpha to be bigger than that.

1016
01:04:32,080 --> 01:04:35,060
And, this event will occur with high probability, too.

1017
01:04:35,150 --> 01:04:37,860
So, when I say here that

1018
01:04:37,950 --> 01:04:40,910
every search of cost order log n with high probability,

1019
01:04:41,010 --> 01:04:43,230
not only do I mean that if you look at one search,

1020
01:04:43,290 --> 01:04:45,100
it costs order log n with high probability.

1021
01:04:45,190 --> 01:04:46,230
You look at another search,

1022
01:04:46,330 --> 01:04:48,010
and it costs log n with high probability.

1023
01:04:48,100 --> 01:04:49,920
I mean, if you take every search,

1024
01:04:49,970 --> 01:04:54,510
all of them take order log n time with high probability.

1025
01:04:54,610 --> 01:04:59,420
So, this event that every single search you do takes order log n,

1026
01:05:00,480 --> 01:05:02,830
is true with high probability.

1027
01:05:02,830 --> 01:05:05,540
Assuming the number of searches you are doing is polynomial in n.

1028
01:05:05,590 --> 01:05:08,930
So, I'm assuming that I'm not using this data structure forever,

1029
01:05:09,020 --> 01:05:11,100
just for a polynomial amount of time.

1030
01:05:11,160 --> 01:05:14,930
But, who's got more than a polynomial amount of time anyway?

1031
01:05:15,020 --> 01:05:19,430
This is MIT. So, hopefully that's clear.

1032
01:05:19,530 --> 01:05:21,130
We'll see it a few more times. Yeah?

1033
01:05:21,130 --> 01:05:23,890
[Student]Inaudible.

1034
01:05:23,980 --> 01:05:26,360
[Professor]The algorithm doesn't depend on Alpha.

1035
01:05:26,450 --> 01:05:28,420
The question is how do you choose alpha in the algorithm.

1036
01:05:28,470 --> 01:05:32,510
So, we don't need to. This is just sort of for an analysis tool.

1037
01:05:32,600 --> 01:05:34,230
This is saying that the farther out you get,

1038
01:05:34,330 --> 01:05:37,840
so you say, well, what's the probability that more than ten log n.

1039
01:05:37,930 --> 01:05:42,020
Well, it's like one over n^10. Let's say it's linear.

1040
01:05:42,110 --> 01:05:44,930
Well, what's the chance that you're more than 20 log n?

1041
01:05:45,020 --> 01:05:46,670
Well that's one over n^20.

1042
01:05:47,020 --> 01:05:48,540
So, the point is the tail of this distribution

1043
01:05:48,630 --> 01:05:50,370
is getting a really small, really fast.

1044
01:05:50,420 --> 01:05:53,060
And, such using alpha is more like

1045
01:05:53,160 --> 01:05:55,290
sort of for your own feeling good.

1046
01:05:55,350 --> 01:06:01,100
OK, you can set it to 100, and then n is at least two.

1047
01:06:01,190 --> 01:06:06,370
So, that's like one over 2^100 chance that you fail.

1048
01:06:06,460 --> 01:06:09,670
That's damn small. If you've got a real random number generator,

1049
01:06:09,760 --> 01:06:10,870
the chance that you're going to

1050
01:06:10,960 --> 01:06:13,870
hit one over 2^200 is pretty tiny, right?

1051
01:06:15,040 --> 01:06:18,640
So, let's say you set alpha to 256,

1052
01:06:18,730 --> 01:06:19,920
which is always a good number.

1053
01:06:20,020 --> 01:06:21,940
2^256 is much bigger than

1054
01:06:22,030 --> 01:06:24,350
the number of particles in the known universe,

1055
01:06:24,410 --> 01:06:26,530
so, the light matter.

1056
01:06:26,590 --> 01:06:28,600
So, actually I think this

1057
01:06:28,700 --> 01:06:30,590
even accounts for some notion of dark matter.

1058
01:06:30,650 --> 01:06:32,410
So, this is really, really, really big.

1059
01:06:32,460 --> 01:06:35,500
So, the chance that you pick a random particle in the universe

1060
01:06:35,590 --> 01:06:38,450
that happens to be your favorite particle, this one right here,

1061
01:06:38,550 --> 01:06:42,180
that's over one over 2^256, or even smaller.

1062
01:06:42,270 --> 01:06:48,140
So, set alpha to 256, the chance to your algorithm

1063
01:06:48,240 --> 01:06:50,900
takes more than order log n time is a lot smaller

1064
01:06:50,990 --> 01:06:53,090
than the chance that a meteor

1065
01:06:53,150 --> 01:06:56,140
strikes your computer at the same time

1066
01:06:56,230 --> 01:06:57,940
that it has a floating point error,

1067
01:06:58,050 --> 01:07:01,270
at the same time that the earth explodes

1068
01:07:01,380 --> 01:07:04,940
because they're putting a transport through this part

1069
01:07:05,040 --> 01:07:06,950
of the solar system at the same time,

1070
01:07:07,000 --> 01:07:08,470
I mean, I could go on, right?

1071
01:07:08,580 --> 01:07:10,950
It's really, really unlikely that you are more than log n.

1072
01:07:11,000 --> 01:07:13,100
And how unlikely: you get to choose.

1073
01:07:13,160 --> 01:07:16,370
But it's just in the analysis the algorithm doesn't depend on it.

1074
01:07:16,460 --> 01:07:18,440
It's the same algorithm, very cool.

1075
01:07:18,490 --> 01:07:21,480
Sometimes, with high probability, bounds depends on alpha.

1076
01:07:21,570 --> 01:07:24,820
I mean, the algorithm depends on alpha. But here, it will not.

1077
01:07:26,440 --> 01:07:35,500
OK, away we go. So now you all understand the claim.

1078
01:07:40,160 --> 01:07:44,780
So let's do a warm up. We will also need this fact.

1079
01:07:46,450 --> 01:07:51,260
But it's pretty easy. The lemma is that with high probability,

1080
01:07:52,560 --> 01:07:57,180
the number of levels in the skip list is order log n.

1081
01:08:02,000 --> 01:08:05,670
I think it's order log n, certainly.

1082
01:08:09,090 --> 01:08:13,020
So, how do we prove that something happens with high probability?

1083
01:08:14,700 --> 01:08:17,750
Compute the probability that it happened; show that it's high.

1084
01:08:17,840 --> 01:08:21,290
Even if you don't know what high probability means,

1085
01:08:21,380 --> 01:08:24,360
in fact, I used to ask that earlier on.

1086
01:08:26,130 --> 01:08:29,310
So, let's compute the chance that it doesn't happen,

1087
01:08:29,400 --> 01:08:31,020
the error probability,

1088
01:08:31,140 --> 01:08:35,470
because that's just a one minus the cleaner.

1089
01:08:36,260 --> 01:08:38,610
So, I'd like to say, let's say,

1090
01:08:38,700 --> 01:08:40,800
that it's, at most, c log n levels.

1091
01:08:40,860 --> 01:08:43,960
So, what's the error probability for that event?

1092
01:08:44,870 --> 01:08:46,610
This is sort of an event.

1093
01:08:46,670 --> 01:08:50,090
I'll put it in squiggles just for, all set.

1094
01:08:50,180 --> 01:08:51,340
This is the probability that

1095
01:08:51,430 --> 01:08:54,550
they are strictly greater than c log n levels.

1096
01:08:54,640 --> 01:08:56,400
So, I want to say that

1097
01:08:56,490 --> 01:09:00,020
that probability is particularly small, polynomially small.

1098
01:09:02,550 --> 01:09:05,280
Well, how do I make levels?

1099
01:09:05,370 --> 01:09:08,260
When I insert an element, the probability half, it goes up.

1100
01:09:09,500 --> 01:09:11,590
And, the number of levels in the skip list

1101
01:09:11,680 --> 01:09:14,200
is the max over all the elements of how high it goes up.

1102
01:09:14,930 --> 01:09:17,820
But, max, oh, that's a mess.

1103
01:09:17,910 --> 01:09:19,940
All right, you can compute the expectation of the max

1104
01:09:19,990 --> 01:09:22,030
if you have a bunch of unknown variables;

1105
01:09:22,120 --> 01:09:24,990
there is expectation there is a constant, and you take the max.

1106
01:09:25,080 --> 01:09:27,140
It's like log n in expectation,

1107
01:09:27,230 --> 01:09:29,520
but we want a much stronger statement.

1108
01:09:29,570 --> 01:09:31,080
And, we have this Boole's inequality

1109
01:09:31,170 --> 01:09:33,660
that says I have a bunch of things,

1110
01:09:33,760 --> 01:09:36,190
polynomially many things. Let's say we have n items.

1111
01:09:36,280 --> 01:09:39,780
Each one independently, I don't even care if it's a dependent.

1112
01:09:39,880 --> 01:09:42,780
But each one potentially goes up some amount.

1113
01:09:42,880 --> 01:09:44,380
If it goes up more than c log n,

1114
01:09:44,470 --> 01:09:46,480
yeah, the number of levels is more than c log n.

1115
01:09:46,570 --> 01:09:51,440
So, this is, at most, and then I want to know,

1116
01:09:51,540 --> 01:09:55,740
do any of those events happen for any of the n elements?

1117
01:09:55,830 --> 01:09:57,530
So, I just multiplied by n.

1118
01:09:57,630 --> 01:09:59,190
It's certainly, at most,

1119
01:09:59,290 --> 01:10:02,940
n times the probability that x gets promoted,

1120
01:10:09,090 --> 01:10:12,160
this much here, greater than or equal to log n times.

1121
01:10:16,510 --> 01:10:18,260
OK, if I pick, for any element, x,

1122
01:10:18,350 --> 01:10:19,470
because it's the same for each element.

1123
01:10:19,560 --> 01:10:20,660
They are done independently.

1124
01:10:20,750 --> 01:10:22,490
So, I'm just summing over x here,

1125
01:10:22,580 --> 01:10:25,490
and that's just a factor of n. Clear?

1126
01:10:25,590 --> 01:10:26,830
This is Boole's inequality.

1127
01:10:26,880 --> 01:10:29,920
Now, what's the probability that x gets promoted c log n times?

1128
01:10:30,020 --> 01:10:33,260
We did this before for log n. It was one over n.

1129
01:10:33,350 --> 01:10:40,410
For c log n, it's one over n to the c. OK, this is n times two.

1130
01:10:42,720 --> 01:10:46,250
Let's be nicer: one half to the power of c log n.

1131
01:10:46,340 --> 01:10:50,440
One half to the power of c log n is one over two to the c log n.

1132
01:10:50,540 --> 01:10:53,930
The log n comes out here, becomes an n.  We get n to the c.

1133
01:10:54,030 --> 01:10:59,870
So, this is n divided by n to the c,

1134
01:10:59,970 --> 01:11:02,710
which is n to the c minus one.

1135
01:11:03,690 --> 01:11:06,730
And, I get to choose c to be whatever I want.

1136
01:11:06,830 --> 01:11:17,310
So, I choose c minus one to be alpha. I think exactly that.

1137
01:11:18,480 --> 01:11:22,300
Oh, sorry, one over n to the c minus one. Thank you.

1138
01:11:22,400 --> 01:11:27,020
It better be small. This is an upper bound.

1139
01:11:27,110 --> 01:11:30,450
So, probability is polynomially small. I get to choose,

1140
01:11:30,560 --> 01:11:31,450
and this is a bit of the trick.

1141
01:11:31,550 --> 01:11:35,810
I'm choosing this constant to be large, large enough for alpha.

1142
01:11:35,910 --> 01:11:39,320
The point is, as c grows, alpha grows.

1143
01:11:39,410 --> 01:11:41,170
Therefore, I can set alpha to be whatever I want,

1144
01:11:41,170 --> 01:11:42,720
set c accordingly.

1145
01:11:42,770 --> 01:11:45,400
So, there's a little bit more words that have to go here.

1146
01:11:45,500 --> 01:11:47,620
But, they're in the notes.

1147
01:11:47,680 --> 01:11:51,270
I can set alpha to be as large as I want.

1148
01:11:51,360 --> 01:11:52,850
So, I can make this probability

1149
01:11:52,950 --> 01:11:54,760
as small as I want in the polynomial sets.

1150
01:11:56,150 --> 01:11:59,060
So, that's it. Number of levels, order log n: wasn't that easy?

1151
01:11:59,150 --> 01:12:01,460
Rules and equality, the point is that when you're dealing

1152
01:12:01,560 --> 01:12:03,530
with high probability, use Boole's inequality.

1153
01:12:03,590 --> 01:12:05,390
And, anything that's true for one element

1154
01:12:05,450 --> 01:12:07,750
is true for all of them, just like that.

1155
01:12:08,450 --> 01:12:11,240
Just lose a factor of n, but that's just one in the alpha,

1156
01:12:11,330 --> 01:12:15,110
and alpha is big: big constant, but it's big.

1157
01:12:15,880 --> 01:12:19,110
OK, so let's prove the theorem.

1158
01:12:20,680 --> 01:12:23,040
High probability searches cost order log n.

1159
01:12:23,130 --> 01:12:24,500
We now know the height is order log n,

1160
01:12:24,590 --> 01:12:27,070
but it depends how balanced this thing is.

1161
01:12:27,170 --> 01:12:29,200
It depends how long the chains are

1162
01:12:29,260 --> 01:12:31,270
to really know that a search costs log n.

1163
01:12:31,320 --> 01:12:33,390
Just knowing a bound on the height is not enough,

1164
01:12:33,480 --> 01:12:35,330
unlike a binary tree.

1165
01:12:37,820 --> 01:12:42,110
So, we have one cool idea for this analysis.

1166
01:12:47,810 --> 01:12:50,750
And it's called backwards analysis.

1167
01:12:55,180 --> 01:12:56,450
So, normally you think of a search

1168
01:12:56,550 --> 01:12:58,090
as starting in the top left corner

1169
01:12:58,180 --> 01:13:00,530
going left[right] and down until you get to

1170
01:13:00,630 --> 01:13:02,300
the item that you're looking for.

1171
01:13:02,390 --> 01:13:03,880
I'm going to look at the reverse process.

1172
01:13:03,970 --> 01:13:05,480
You start at the item you're looking for,

1173
01:13:05,540 --> 01:13:10,690
and you go left and up until you get to the top left corner.

1174
01:13:12,030 --> 01:13:14,390
The number of steps in those two walks is the same.

1175
01:13:14,490 --> 01:13:16,500
And, I'm not implementing an algorithm here,

1176
01:13:16,600 --> 01:13:17,740
I'm just doing analysis.

1177
01:13:17,830 --> 01:13:20,570
So, those are the same processes, just in reverse.

1178
01:13:21,510 --> 01:13:24,970
So, here's what it looks like. You have a search,

1179
01:13:25,060 --> 01:13:27,940
and it starts, which really means that

1180
01:13:28,030 --> 01:13:35,580
it ends at a node in the bottom list.

1181
01:13:39,350 --> 01:13:44,600
Then, each time you visit a node in this search,

1182
01:13:44,700 --> 01:13:46,830
you either go left or up.

1183
01:13:50,230 --> 01:13:51,820
And, when do you go left or up?

1184
01:13:51,910 --> 01:13:53,830
Well, it depends with the coin flip was.

1185
01:13:55,660 --> 01:13:59,060
So, if the node wasn't promoted at this level.

1186
01:14:01,320 --> 01:14:03,670
So, if it wasn't promoted higher,

1187
01:14:05,880 --> 01:14:08,600
and that happened exactly when we got a tails.

1188
01:14:11,270 --> 01:14:19,680
Then, we go left, which really means we came from the left.

1189
01:14:21,470 --> 01:14:24,210
Or, if we got a heads,

1190
01:14:25,630 --> 01:14:29,080
so if this node was promoted to the next level,

1191
01:14:31,180 --> 01:14:34,850
which happened whenever we got a heads at that particular moment.

1192
01:14:35,540 --> 01:14:38,460
This is in the past some time when we did the insertion.

1193
01:14:38,550 --> 01:14:47,310
Then we go, or came from, up. And, we stop at the root.

1194
01:14:48,460 --> 01:14:52,320
This is really where we start; same thing.

1195
01:14:55,460 --> 01:14:59,590
So, either at the root or I'm also going to think of this

1196
01:14:59,690 --> 01:15:01,330
as stopping at minus infinity.

1197
01:15:01,850 --> 01:15:05,130
OK, that was a bit messy, but let me review.

1198
01:15:05,230 --> 01:15:07,220
So, normally we start up here.

1199
01:15:07,280 --> 01:15:08,720
Well, just looking at everything backwards,

1200
01:15:08,770 --> 01:15:10,800
and in brackets is what's really happening.

1201
01:15:10,860 --> 01:15:14,870
So, this search ends at the node you were looking for.

1202
01:15:14,960 --> 01:15:16,220
It's always in the bottom list.

1203
01:15:18,340 --> 01:15:20,570
Then it says, well, was this node promoted higher?

1204
01:15:20,660 --> 01:15:24,240
If it was, I came from above. If not, I came to the left.

1205
01:15:24,330 --> 01:15:26,310
It must have been in the bottom chain somewhere.

1206
01:15:26,370 --> 01:15:28,390
OK, and that's true at every node you visit.

1207
01:15:28,440 --> 01:15:30,740
It depends whether that quite slipped heads or tails

1208
01:15:30,840 --> 01:15:33,870
at the time that you inserted that node into that level.

1209
01:15:33,970 --> 01:15:40,040
But, these are just a bunch of events. I'm just going to check,

1210
01:15:40,130 --> 01:15:42,380
what is the probability that it's heads,

1211
01:15:42,470 --> 01:15:43,560
and what is the probability that it's tails?

1212
01:15:43,660 --> 01:15:45,860
It's always a half. Every time I look at a coin flip,

1213
01:15:45,960 --> 01:15:47,460
when it was flipped,

1214
01:15:47,560 --> 01:15:49,550
there was a probability of half going out of their way.

1215
01:15:50,890 --> 01:15:52,940
That's the magic.

1216
01:15:54,700 --> 01:15:58,180
And, I'm not using that these events are independent anyway.

1217
01:15:58,270 --> 01:15:59,460
For every element that I search for,

1218
01:15:59,530 --> 01:16:03,260
for every value, x, that's another search.

1219
01:16:03,360 --> 01:16:06,580
Those events may not be independent.

1220
01:16:06,680 --> 01:16:08,790
I can still use Boole's inequality and conclude that

1221
01:16:08,850 --> 01:16:11,740
all of them are order log n with high probability.

1222
01:16:11,840 --> 01:16:12,750
As long as I can prove that

1223
01:16:12,840 --> 01:16:15,310
any one event happens with high probability.

1224
01:16:15,400 --> 01:16:19,110
So, I don't need independence between,

1225
01:16:19,210 --> 01:16:21,560
I knew that these coin flips in a single search are independent,

1226
01:16:21,610 --> 01:16:24,780
but everything else, for different searches I don't care.

1227
01:16:41,480 --> 01:16:43,560
So, how long can this process go on?

1228
01:16:43,620 --> 01:16:45,940
We want to know how many times can I make this walk?

1229
01:16:45,990 --> 01:16:48,170
Well, when I hit the root node, I'm done.

1230
01:16:49,940 --> 01:16:52,030
Well, how quickly would I hit the root node?

1231
01:16:52,130 --> 01:16:54,680
Well, with probability, a half, I go up each step.

1232
01:16:54,780 --> 01:16:57,030
The number of times I go up is,

1233
01:16:57,120 --> 01:17:00,020
at most, the number of levels minus one.

1234
01:17:00,820 --> 01:17:02,510
And that's order log n with high probability.

1235
01:17:02,600 --> 01:17:05,400
So, this is the only other idea.

1236
01:17:05,500 --> 01:17:07,570
So, we are now proving this theorem.

1237
01:17:13,500 --> 01:17:17,150
So, the number of up moves in a search,

1238
01:17:17,250 --> 01:17:19,190
which are really down moves, but same thing,

1239
01:17:19,800 --> 01:17:21,670
is less than the number of levels.

1240
01:17:23,410 --> 01:17:24,450
Certainly, you can't go up

1241
01:17:24,540 --> 01:17:26,220
more than there are levels in the search.

1242
01:17:26,320 --> 01:17:27,820
And in insert, you can go arbitrarily high.

1243
01:17:27,920 --> 01:17:30,400
But a search: as high as you can go.

1244
01:17:30,490 --> 01:17:33,010
And this is, at most, c log n with high probability.

1245
01:17:33,100 --> 01:17:34,660
This is what we proved in the lemma.

1246
01:17:41,840 --> 01:17:44,380
So, we have a bound on the number of up moves.

1247
01:17:44,870 --> 01:17:47,040
Half of the moves, roughly, are going to be up moves.

1248
01:17:47,100 --> 01:17:48,850
So, this pretty much bounds to the number of moves.

1249
01:17:48,950 --> 01:17:53,580
Not quite. So, what this means is that with high probability,

1250
01:17:53,680 --> 01:17:55,660
so this is the same probability,

1251
01:17:55,750 --> 01:17:57,020
but I could choose that as high

1252
01:17:57,120 --> 01:17:58,780
as I want by setting c large enough.

1253
01:18:00,250 --> 01:18:02,500
The number of moves, in other words, the cost of the search

1254
01:18:04,660 --> 01:18:08,490
is at most the number of coin flips

1255
01:18:10,150 --> 01:18:17,510
until we get c log n heads, right,

1256
01:18:17,610 --> 01:18:20,230
because in every step of the search, I make a move,

1257
01:18:20,320 --> 01:18:22,170
and then I flip another coin, conceptually.

1258
01:18:22,230 --> 01:18:24,700
There is another independent coin lying there.

1259
01:18:24,800 --> 01:18:27,270
And it's either heads or tails. Each of those is independent.

1260
01:18:27,370 --> 01:18:29,620
So, how many independent coin flips does it take

1261
01:18:29,680 --> 01:18:31,210
until I get c log n heads?

1262
01:18:31,320 --> 01:18:35,820
The claim is that that's order log n with high probability.

1263
01:18:35,910 --> 01:18:41,830
But we need to prove that. So, this is a claim.

1264
01:18:46,900 --> 01:18:48,810
So, if you just sit there with a coin,

1265
01:18:48,860 --> 01:18:51,070
and you want to know how many times does it take

1266
01:18:51,130 --> 01:18:58,510
until I get c log n heads, the claim is that

1267
01:18:58,610 --> 01:19:01,910
that number is order log n with high probability.

1268
01:19:02,720 --> 01:19:04,280
As long as I prove that,

1269
01:19:04,380 --> 01:19:07,750
I know that the total number of steps I make,

1270
01:19:07,840 --> 01:19:11,880
which is the number of heads and tails is order log n

1271
01:19:11,980 --> 01:19:14,230
because I definitely know the number of heads is,

1272
01:19:14,330 --> 01:19:15,610
at most, c log n.

1273
01:19:15,710 --> 01:19:18,150
The claim is that the number of tails can't be too much bigger.

1274
01:19:18,250 --> 01:19:21,550
Notice, I can't just say c here.

1275
01:19:21,650 --> 01:19:25,250
OK, it's really important that I have log n. Why?

1276
01:19:25,350 --> 01:19:27,810
Because with high probability, it depends on n.

1277
01:19:27,910 --> 01:19:29,850
This notion depends on n.

1278
01:19:29,940 --> 01:19:35,210
Log n: it's true. Anything bigger that log n: it's true, like n.

1279
01:19:35,310 --> 01:19:37,150
If I put n here, this is also true.

1280
01:19:37,270 --> 01:19:40,060
But, if I put a constant or a log log n, this is not true.

1281
01:19:40,160 --> 01:19:43,060
It's really important that I have log n here

1282
01:19:43,150 --> 01:19:45,640
because my notion of high probability

1283
01:19:45,740 --> 01:19:48,380
depends on what's written here.

1284
01:19:49,600 --> 01:19:53,930
OK, it's clear so far. We're almost done,

1285
01:19:54,020 --> 01:19:56,340
which is good because I just ran out of time.

1286
01:19:56,390 --> 01:19:59,430
Sorry, we're going to go a couple minutes over.

1287
01:20:02,000 --> 01:20:05,420
So, I want to compute the error probability here.

1288
01:20:05,510 --> 01:20:07,950
So, I want to compute the probability that

1289
01:20:08,050 --> 01:20:10,400
there is less than c log n heads.

1290
01:20:14,560 --> 01:20:17,670
Let me skip this step. So, I will be approximate and say,

1291
01:20:17,760 --> 01:20:22,420
what's the probability that there is, at most, c log n heads?

1292
01:20:30,080 --> 01:20:32,890
So, I need to say how many coins we are flipping here

1293
01:20:32,990 --> 01:20:35,390
for what this event is.

1294
01:20:35,440 --> 01:20:37,000
So, I need to specify this constant.

1295
01:20:37,100 --> 01:20:43,070
Let's say we flip ten c log n coins.

1296
01:20:43,700 --> 01:20:46,780
Now I want to look at the error probability under that event.

1297
01:20:47,580 --> 01:20:51,430
The probability that there is at most c log n heads

1298
01:20:52,640 --> 01:20:56,760
among those ten c log n flips.

1299
01:20:56,850 --> 01:20:58,650
So, the claim is this should be pretty small.

1300
01:20:58,710 --> 01:21:00,050
It's going to depend on ten.

1301
01:21:00,150 --> 01:21:01,880
Then I'll choose ten to be arbitrarily large,

1302
01:21:01,980 --> 01:21:05,000
and I'll be done, OK, make my life a little bit easier.

1303
01:21:05,950 --> 01:21:10,630
Well, I would ask you normally, but this is 6.042 material.

1304
01:21:17,760 --> 01:21:19,430
So, what's the probability that we have,

1305
01:21:19,520 --> 01:21:21,210
at most, this many heads?

1306
01:21:21,320 --> 01:21:25,260
Well, that means that nine c log n of the coins,

1307
01:21:25,350 --> 01:21:28,660
because there are ten c log n flips, c log n heads at most,

1308
01:21:28,750 --> 01:21:31,330
nine c log n at least better be tails.

1309
01:21:31,420 --> 01:21:34,650
So this is the probability that all those other guys become tails,

1310
01:21:35,120 --> 01:21:36,390
which is already pretty small.

1311
01:21:36,480 --> 01:21:39,090
And then, there is this permutation thing.

1312
01:21:39,180 --> 01:21:42,070
So, if I had exactly c log n heads, this would be

1313
01:21:42,160 --> 01:21:44,170
the number of ways to rearrange c log n heads

1314
01:21:44,220 --> 01:21:47,410
among ten c log n coin flips.

1315
01:21:48,120 --> 01:21:49,960
OK, that's just the number of permutations.

1316
01:21:50,550 --> 01:21:52,320
So, this is a bit big, which is kind of annoying.

1317
01:21:52,410 --> 01:21:53,710
This is really, really small.

1318
01:21:53,810 --> 01:21:55,960
The claim is this is much smaller than that is big.

1319
01:22:13,390 --> 01:22:16,030
So, this is just some math. I'm going to whiz through it.

1320
01:22:16,120 --> 01:22:19,200
So, you don't have to stay too long. But you should go over it.

1321
01:22:19,300 --> 01:22:22,730
You should know that y choose x is,

1322
01:22:22,820 --> 01:22:27,650
at most, ey over x to the x, good fact.

1323
01:22:27,740 --> 01:22:33,030
Therefore, this is, at most, ten c log n over c log n,

1324
01:22:34,450 --> 01:22:36,190
also known as ten.

1325
01:22:36,780 --> 01:22:40,050
These cancel. There's an e out here.

1326
01:22:40,150 --> 01:22:42,190
And then I raise that to the c log n power.

1327
01:22:43,010 --> 01:22:47,020
OK, then I divide by two to the power, nine c log n.

1328
01:22:47,120 --> 01:22:49,480
OK, so what's this?

1329
01:22:49,530 --> 01:22:53,900
This is e times ten to the c log n

1330
01:22:53,990 --> 01:22:56,720
divided by two to the nine c log n.

1331
01:22:57,780 --> 01:23:01,160
OK, claim this is very big. This is not so big,

1332
01:23:01,260 --> 01:23:04,570
because I have a nine here. So, let's work it out.

1333
01:23:04,660 --> 01:23:09,910
This e times ten, that's a good number, we can put upstairs.

1334
01:23:10,620 --> 01:23:16,040
So, we get log of e times ten, ten times, e, and then c log n.

1335
01:23:16,820 --> 01:23:20,720
And then, we have over two to the nine c log n.

1336
01:23:21,230 --> 01:23:26,130
So, we have this two to the c log n in both cases.

1337
01:23:27,980 --> 01:23:32,310
So, this is two to the log,

1338
01:23:32,890 --> 01:23:41,860
ten e minus nine, c, log n: some basic algebra.

1339
01:23:42,730 --> 01:23:46,850
So, I'm going to set, not quite.

1340
01:23:47,530 --> 01:23:52,610
This is one over two to the nine minus log:

1341
01:23:54,370 --> 01:23:57,170
so, just inverting everything here, negating the sign in here.

1342
01:23:58,470 --> 01:24:03,860
And, this is my alpha because the rest is n.

1343
01:24:03,950 --> 01:24:06,480
So, this is one over n to the alpha

1344
01:24:06,600 --> 01:24:08,860
when alpha is this particular value:

1345
01:24:08,910 --> 01:24:12,420
nine minus log of ten times e times c.

1346
01:24:12,520 --> 01:24:16,260
It's a bit of a strange thing. But, the point is,

1347
01:24:16,360 --> 01:24:18,420
as ten goes to infinity,

1348
01:24:19,720 --> 01:24:23,850
nine here is the number one smaller than ten, right?

1349
01:24:23,950 --> 01:24:25,910
We subtracted one somewhere along the way.

1350
01:24:25,970 --> 01:24:27,450
So, as ten goes to infinity,

1351
01:24:27,550 --> 01:24:29,560
this is basically, this is ten minus one.

1352
01:24:29,610 --> 01:24:33,170
This is log of ten times e. e doesn't really matter.

1353
01:24:33,270 --> 01:24:35,000
The point is, this is logarithmic in ten.

1354
01:24:35,050 --> 01:24:36,670
This is linear in ten.

1355
01:24:36,770 --> 01:24:39,010
The thing that's linear in ten is much bigger

1356
01:24:39,070 --> 01:24:40,780
than the thing that's logarithmic in ten.

1357
01:24:40,840 --> 01:24:42,080
This is called abusive notation.

1358
01:24:42,690 --> 01:24:44,420
OK, as ten goes to infinity,

1359
01:24:44,480 --> 01:24:47,850
this goes to infinity, gets bigger.

1360
01:24:47,940 --> 01:24:49,530
And, there is a c out here.

1361
01:24:49,630 --> 01:24:51,300
But, for any value of c that you want,

1362
01:24:51,390 --> 01:24:53,610
whatever value of c you wanted in that claim,

1363
01:24:53,670 --> 01:24:56,740
I can make alpha arbitrarily large

1364
01:24:56,830 --> 01:25:00,140
by changing the constant in the big O, which here was ten.

1365
01:25:01,410 --> 01:25:04,200
OK, so that claim is true with high probability.

1366
01:25:04,290 --> 01:25:07,410
Whatever probability you want, which tells you alpha,

1367
01:25:07,500 --> 01:25:12,710
you set a constant in front of the log N to be this number,

1368
01:25:12,810 --> 01:25:16,690
which grows, and you're done.

1369
01:25:16,790 --> 01:25:18,560
You get the claim that is order log N heads,

1370
01:25:18,650 --> 01:25:20,870
order log N flips with the high probability, therefore.

1371
01:25:20,970 --> 01:25:22,220
Number of the steps in the search

1372
01:25:22,310 --> 01:25:23,820
is order log N with high probability.

1373
01:25:23,910 --> 01:25:26,010
Really cool stuff; read the notes.

1374
01:25:26,100 --> 01:25:27,790
Sorry I went so fast at the end.

