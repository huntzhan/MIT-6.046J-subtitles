1
00:00:07,920 --> 00:00:11,190
今天我们花两个课时来学习哈希表

2
00:00:14,890 --> 00:00:22,960
哈希是一项强大的技术  在很多地方都有用到

3
00:00:24,540 --> 00:00:26,480
那我们用一个问题引入

4
00:00:26,700 --> 00:00:31,740
这个问题经常出现在编译器里

5
00:00:34,970 --> 00:00:36,890
就是“符号表问题”了

6
00:00:39,200 --> 00:00:45,670
现在有一个表S

7
00:00:48,270 --> 00:00:56,390
里面放着n条记录  对于每条记录

8
00:00:56,680 --> 00:00:58,940
这里要说得更清楚一点

9
00:01:00,400 --> 00:01:04,010
每条记录都会有一些

10
00:01:05,860 --> 00:01:13,170
这是记录x  x通常是一个指向实际数据的指针

11
00:01:13,670 --> 00:01:15,820
当我们提到记录x的时候

12
00:01:16,020 --> 00:01:17,960
它通常代表着指向数据x的指针

13
00:01:18,290 --> 00:01:21,240
在记录里  而不是数据中

14
00:01:21,560 --> 00:01:27,190
这是一条记录  这个键叫记录x的键

15
00:01:28,130 --> 00:01:30,190
在某些编程语言里

16
00:01:30,470 --> 00:01:34,010
它用x.key或x→key表示

17
00:01:34,660 --> 00:01:38,450
这不过是不同语言里  不同的表示而已

18
00:01:38,800 --> 00:01:43,150
通常还会有一些额外的数据  称为卫星数据

19
00:01:46,650 --> 00:01:49,540
这些数据属于键的附加数据

20
00:01:49,880 --> 00:01:52,720
排序时也有这种情况  只不过你是对记录排序

21
00:01:52,820 --> 00:01:56,130
而不是对键排序

22
00:01:58,960 --> 00:02:02,810
现在我们要进行一系列的操作

23
00:02:02,950 --> 00:02:07,880
我们想对这张表上的数据进行一系列的操作

24
00:02:09,940 --> 00:02:16,290
想要在表里插入一条记录x

25
00:02:16,700 --> 00:02:18,590
本质上讲

26
00:02:18,660 --> 00:02:22,900
就是通过添加元素x  来更新这个表

27
00:02:24,130 --> 00:02:30,590
我们想要从表里删除一条记录

28
00:02:36,440 --> 00:02:39,510
也就是从集合里移除记录x

29
00:02:39,920 --> 00:02:48,060
我们还想要用给定的键k进行搜索

30
00:02:48,660 --> 00:03:00,030
那么当x的键值为k时  这个函数返回x

31
00:03:01,090 --> 00:03:06,030
如果没有相应的记录则返回nil（注：空值）

32
00:03:12,000 --> 00:03:17,430
现在我们已经能添加记录、删除记录

33
00:03:17,590 --> 00:03:19,930
还能查找有特定键值的记录

34
00:03:20,470 --> 00:03:23,830
要注意  删除不是删除键值  而是删除整条记录

35
00:03:25,020 --> 00:03:27,360
好了   如果你想删除有特定键值的记录

36
00:03:27,520 --> 00:03:29,590
而又没有它的位置指针

37
00:03:29,720 --> 00:03:34,340
那就必须先把它找出来  然后再删除

38
00:03:39,080 --> 00:03:43,770
当一个集合可以进行操作时

39
00:03:46,490 --> 00:03:51,370
就例如删除之类的改变集合的操作

40
00:03:53,140 --> 00:03:55,020
把这个集合称之为“动态集”

41
00:03:55,970 --> 00:03:58,870
这两种操作将集合动态化了

42
00:03:58,970 --> 00:04:00,260
这些集合会因时而变

43
00:04:00,480 --> 00:04:03,670
有时你想要建一个固定的数据结构

44
00:04:04,030 --> 00:04:05,460
你需要一个静态的集合

45
00:04:05,660 --> 00:04:09,000
你所需要做的就是  诸如“查阅”之类的操作

46
00:04:09,330 --> 00:04:15,040
但在更多的情况下  在像编程之类的工作中

47
00:04:15,190 --> 00:04:16,380
我们希望集合是动态的

48
00:04:16,480 --> 00:04:18,120
想要向它添加记录

49
00:04:18,330 --> 00:04:19,850
或者删除记录等等

50
00:04:20,550 --> 00:04:23,520
还有一些别的能修改集合的操作

51
00:04:23,970 --> 00:04:25,760
或者改变集合里的成员关系

52
00:04:26,580 --> 00:04:32,840
其实最简单的实现  也最容易被忽视

53
00:04:32,970 --> 00:04:36,270
实际上  我对人们常使用复杂的数据结构感到惊讶

54
00:04:36,450 --> 00:04:38,210
其实简单的数据结构已经能完成工作

55
00:04:38,660 --> 00:04:43,320
这个简单的结构叫“直接映射表”  它不是总能起作用

56
00:04:43,810 --> 00:04:46,740
但我这里会列出它能发挥作用的情况

57
00:04:51,560 --> 00:04:57,990
当键值的分布比较小的时候  它就能发挥作用

58
00:04:58,500 --> 00:05:11,520
就假设这些键是来自一个有m个元素的集合U

59
00:05:12,650 --> 00:05:14,270
从0到m-1

60
00:05:15,570 --> 00:05:18,700
我们假定这些键是相互独立

61
00:05:28,940 --> 00:05:31,710
直接映射表是这样工作的

62
00:05:31,980 --> 00:05:44,000
当你建立一个从0到m-1的数组T

63
00:05:45,900 --> 00:05:51,940
来表示动态集合S

64
00:05:55,940 --> 00:06:01,540
这样的话  T[k]=x

65
00:06:04,040 --> 00:06:13,710
当且仅当x在这个集合里  而且它的键值为k

66
00:06:14,000 --> 00:06:17,710
否则T[k]为空

67
00:06:22,210 --> 00:06:24,000
就例如你有一个数组

68
00:06:25,120 --> 00:06:32,110
你有一条记录  它的键是某个k值

69
00:06:32,600 --> 00:06:34,320
比如键值是15

70
00:06:34,560 --> 00:06:40,150
如果存在某条记录的键值是15  那槽15就存在

71
00:06:40,620 --> 00:06:43,290
如果集合里没有键值为15的记录  那么槽15就是空的

72
00:06:43,760 --> 00:06:47,540
非常简单的数据结构  首先插入

73
00:06:47,760 --> 00:06:53,840
就是把相应位置的值设成要插入的值

74
00:06:54,200 --> 00:06:55,630
至于删除  就是直接移除那里的值

75
00:06:55,690 --> 00:06:59,510
还有查看  就是通过索引来查看槽的内容

76
00:06:59,900 --> 00:07:03,580
非常简单的数据结构

77
00:07:05,540 --> 00:07:08,380
所有的这些操作

78
00:07:09,140 --> 00:07:14,960
在最坏情况下的时间复杂度都是常数量

79
00:07:19,610 --> 00:07:21,500
但在实际应用上

80
00:07:22,040 --> 00:07:24,810
你能用到这个策略的地方却非常有限

81
00:07:25,850 --> 00:07:32,780
这个数据结构的局限性是什么呢？

82
00:07:31,870 --> 00:07:39,630
[教授]对  这当然也是一个局限性

83
00:07:32,780 --> 00:07:31,270
[学生]。。。

84
00:07:40,090 --> 00:07:42,240
但事实上它还有一个更严重的局限性

85
00:07:42,240 --> 00:07:47,970
[学生]。。。

86
00:07:47,970 --> 00:07:50,360
[教授]你的意思是  它很难从表里取值？

87
00:08:03,300 --> 00:08:09,580
不  m-1可能是个很大的数

88
00:08:10,090 --> 00:08:13,590
比如  假设我想要

89
00:08:13,710 --> 00:08:18,430
我的集合的数据都是64位的值

90
00:08:18,850 --> 00:08:21,020
就是储存在我表里的东西

91
00:08:21,320 --> 00:08:23,030
是一组长度为64位的数字

92
00:08:23,920 --> 00:08:26,780
然后  它可能只是一个小集合

93
00:08:27,060 --> 00:08:32,160
可能我只有几千个元素

94
00:08:33,890 --> 00:08:36,320
但它们有64位的值

95
00:08:36,600 --> 00:08:39,470
然而这个数据结构却要求我

96
00:08:39,620 --> 00:08:45,290
有一个从0到2^64 - 1的数组

97
00:08:45,650 --> 00:08:48,570
2^64-1有多大？用手指头算算？

98
00:08:49,670 --> 00:08:54,340
这个数很庞大  大约有1800亿个亿那么大

99
00:08:56,200 --> 00:08:59,870
我的意思是  大到你不相信

100
00:08:59,960 --> 00:09:02,690
已经超过了我们经常用的数以亿计的概念

101
00:09:03,550 --> 00:09:09,650
不是十亿也不是万亿  是1800亿个亿

102
00:09:10,030 --> 00:09:11,400
确实是一个超级大的数

103
00:09:12,240 --> 00:09:15,590
更糟糕的是  假设这些键

104
00:09:15,680 --> 00:09:17,510
取自字符串

105
00:09:19,400 --> 00:09:21,450
比如人名之类的

106
00:09:21,570 --> 00:09:23,990
情况就会变得非常糟糕

107
00:09:24,110 --> 00:09:26,170
因为这样的话  表就有大量的空槽

108
00:09:26,250 --> 00:09:29,510
远超出我们需要保存的数据量

109
00:09:31,300 --> 00:09:33,310
但我们所希望的是保存东西之余

110
00:09:33,410 --> 00:09:35,080
还能让表的规模尽可能的小

111
00:09:35,300 --> 00:09:37,890
同时还然能保留某些特性

112
00:09:38,380 --> 00:09:40,540
这时我们就需要哈希表出场了

113
00:09:41,670 --> 00:10:00,520
所谓的哈希法  就是用一个哈希函数H来随机映射那些键

114
00:10:01,160 --> 00:10:02,500
我帮"随机"加个引号

115
00:10:02,690 --> 00:10:10,520
因为它不是完全的随机  把键映射到哈希表T的槽

116
00:10:13,110 --> 00:10:20,360
这种情况下数组的索引称为“槽”

117
00:10:20,880 --> 00:10:23,020
你可以把它想成一个大的表

118
00:10:23,160 --> 00:10:26,140
表里的槽储存的就是你的数值

119
00:10:28,310 --> 00:10:33,520
我们可能有一个很大的键的全域，我们称之为U

120
00:10:36,680 --> 00:10:38,570
这里有一个表

121
00:10:39,780 --> 00:10:48,830
由我们建立的  有m个槽的表

122
00:10:53,760 --> 00:10:58,990
实际上这里有一个集合

123
00:10:59,100 --> 00:11:00,970
我们用S来表示

124
00:11:01,670 --> 00:11:07,050
假设是这全域里很小的一块

125
00:11:09,490 --> 00:11:13,620
我们要做的是  从这里取出一个键

126
00:11:13,860 --> 00:11:18,840
映射到哈希表的那里  然后再取另外一个

127
00:11:19,310 --> 00:11:23,890
我们将这个键代入哈希函数

128
00:11:24,320 --> 00:11:26,590
然后哈希函数将会返回给我们

129
00:11:26,780 --> 00:11:29,030
会给我们一个特定的槽

130
00:11:29,340 --> 00:11:31,130
这个键可能会映射到上面这里

131
00:11:31,460 --> 00:11:35,030
另外一个键可能映射到下面这里

132
00:11:38,070 --> 00:11:47,600
这样  我们将键分布到整个表里

133
00:11:48,120 --> 00:11:53,480
那映射的过程中会发生什么问题呢？

134
00:11:55,020 --> 00:11:57,450
到目前为止  我们都比较幸运

135
00:11:57,890 --> 00:12:00,250
但潜在的问题是什么呢？

136
00:12:07,390 --> 00:12:11,070
是的  当有两个键在S里  更准确地说

137
00:12:11,300 --> 00:12:12,990
被赋予了同样的哈希值

138
00:12:13,080 --> 00:12:16,520
某个键有可能映射到一个槽

139
00:12:16,660 --> 00:12:18,360
但这个槽已经有另外一个键映射在那了

140
00:12:18,490 --> 00:12:21,490
当这种情况发生时  我们称之为“碰撞”

141
00:12:27,220 --> 00:12:31,670
我们试图将这些键映射到一个小的集合里

142
00:12:31,970 --> 00:12:34,810
但我们可能在映射过程中遭遇不顺

143
00:12:35,190 --> 00:12:37,950
尤其是  当我们映射足够多的键时

144
00:12:38,210 --> 00:12:39,680
它们不会全部一一对应

145
00:12:41,070 --> 00:12:59,180
当一个记录要插入映射表时

146
00:12:59,600 --> 00:13:05,580
却被映射到一个早已有记录的槽时

147
00:13:17,920 --> 00:13:20,950
碰撞发生了

148
00:13:30,890 --> 00:13:34,610
所以  看起来这个方法并不是很好

149
00:13:35,210 --> 00:13:38,060
但实际上  我们可以对它做些小改动

150
00:13:38,560 --> 00:13:42,670
当两个键映射到同一个槽时  我们该怎么办？

151
00:13:44,250 --> 00:13:46,400
我们要表示整个集合

152
00:13:46,770 --> 00:13:50,320
你不能丢弃任何数据  不能把它当成缓存

153
00:13:50,600 --> 00:13:53,310
虽然缓存用的也是哈希结构

154
00:13:53,680 --> 00:13:55,710
但在缓存里  你只是剔除数据

155
00:13:56,130 --> 00:13:59,220
因为你不在乎数据集的完整性

156
00:13:59,650 --> 00:14:03,060
但当你的编程用到了哈希表时

157
00:14:03,230 --> 00:14:05,480
你希望你用到的数据

158
00:14:05,660 --> 00:14:07,580
就是集合里的这些数据

159
00:14:07,740 --> 00:14:10,150
这样你才能分辨哪些数据是属于这个集合的

160
00:14:10,530 --> 00:14:12,440
那么一个好的策略是什么呢？

161
00:14:13,650 --> 00:14:18,930
对每个槽创建一个链表  把所有映射到这个槽的元素

162
00:14:19,090 --> 00:14:21,590
都存到这个槽的链表里面去

163
00:14:22,060 --> 00:14:32,300
这就是用来解决碰撞的链接法

164
00:14:36,470 --> 00:14:51,880
方法是把相同的哈希值的记录放到一个链表里储存

165
00:14:54,110 --> 00:14:57,620
打个比方  想像一下

166
00:14:57,710 --> 00:15:02,220
这是我的哈希表  这个是槽i

167
00:15:04,760 --> 00:15:08,140
这里是一些键

168
00:15:11,230 --> 00:15:21,220
我先把把键值写进去——这些属于S集合的键

169
00:15:21,400 --> 00:15:26,490
之前就已经插入到这个表里了

170
00:15:26,770 --> 00:15:30,650
我们要做的只是将他们链接起来

171
00:15:34,920 --> 00:15:37,060
这里是个空指针

172
00:15:37,490 --> 00:15:39,760
这些是卫星数据，这些是键

173
00:15:41,280 --> 00:15:44,070
如果它们全部都是链接到槽i的话

174
00:15:44,510 --> 00:15:50,060
那么运用哈希函数,h(49)

175
00:15:50,190 --> 00:15:52,810
就等于h(86)

176
00:15:53,220 --> 00:15:56,730
也等于h(52)  也就是多少呢？

177
00:16:06,720 --> 00:16:11,020
就是我们一直没用到的数值，i

178
00:16:11,230 --> 00:16:12,800
不错  即使你不理解它

179
00:16:12,930 --> 00:16:15,040
你的做题的经验也会告诉你

180
00:16:15,370 --> 00:16:18,620
他还没有用到i  那这里就应该用到i

181
00:16:19,090 --> 00:16:21,520
我想说的是当我计算49的哈希值时

182
00:16:21,820 --> 00:16:25,750
h(49)生成了哈希表的某个索引  比如i

183
00:16:26,040 --> 00:16:29,830
而其它所有哈希值相同的键

184
00:16:30,060 --> 00:16:32,520
也都一起链接到一同一个链表里

185
00:16:33,880 --> 00:16:39,750
包括每个记录  对于这个机制还有什么问题没有？

186
00:16:40,020 --> 00:16:41,490
我希望你们大部分人  都已经（在书上）看过这些

187
00:16:41,690 --> 00:16:45,700
在课程6.001里看过哈希  基础哈希  对吧？

188
00:16:45,920 --> 00:16:48,200
在哪里讲到？他们以前在6.001讲过这个

189
00:16:48,280 --> 00:16:51,880
对，有人说是，也许是吧

190
00:16:52,950 --> 00:16:54,680
他们以前讲过这个

191
00:16:54,990 --> 00:17:03,340
好的  我们来分析这个策略

192
00:17:04,510 --> 00:17:11,470
首先做最坏情况分析

193
00:17:15,800 --> 00:17:19,970
最坏情况下会发生什么？  对哈希而言

194
00:17:21,690 --> 00:17:25,440
举起你的手  那样我才能叫你回答问题

195
00:17:25,770 --> 00:17:35,530
对  所有哈希键  所有S里的键

196
00:17:35,780 --> 00:17:39,650
我恰好选择了一个集合S  通过哈希函数

197
00:17:39,780 --> 00:17:44,320
生成的哈希值都是一样的  那就非常糟糕

198
00:17:44,740 --> 00:17:54,560
所有键哈希映射到同一个槽

199
00:17:58,540 --> 00:18:01,470
如果这种情况发生了

200
00:18:01,800 --> 00:18:03,710
那么本质上  我所建立的

201
00:18:03,830 --> 00:18:09,200
就只是一个拥有这种数据结构的奇怪链表

202
00:18:09,660 --> 00:18:13,210
所有跟该哈希表相关的东西  哈希过程等等  都无关紧要了

203
00:18:13,660 --> 00:18:16,550
真正有用的  就只是这个长的链表而已

204
00:18:17,940 --> 00:18:19,930
访问一次要花多少时间呢？

205
00:18:20,470 --> 00:18:23,800
插入一些记录要花我多长时间  或者。。。

206
00:18:23,930 --> 00:18:26,200
更重要的是  查找要花多少时间

207
00:18:26,310 --> 00:18:29,010
在最坏情况下  查看某个记录是否在表里

208
00:18:30,840 --> 00:18:32,440
是的  它需要的时间为θ(n)

209
00:18:32,850 --> 00:18:35,190
因为全部都在一个链表里  我们只有一个链表

210
00:18:35,340 --> 00:18:43,300
所以访问需要θ(n)

211
00:18:45,120 --> 00:18:49,230
如果我们假设S的大小等于n

212
00:18:52,310 --> 00:18:56,700
从最坏情况的角度来看  这个数据结构并不是很好

213
00:18:58,150 --> 00:19:00,410
我们会看到其他数据结构

214
00:19:00,560 --> 00:19:03,260
它们在最坏的情况下比哈希更出色

215
00:19:03,620 --> 00:19:08,420
但它们在平均情况下不如哈希好

216
00:19:08,710 --> 00:19:10,590
我们来分析一下平均情况

217
00:19:15,660 --> 00:19:20,060
为了分析平均情况  我必须。。。

218
00:19:20,220 --> 00:19:22,680
无论你是平均情况也好  其他可能情况也罢

219
00:19:22,810 --> 00:19:24,480
你必须声明你的假设

220
00:19:25,860 --> 00:19:29,270
对于系统的行为而言

221
00:19:29,440 --> 00:19:31,310
你必须说清楚  假设条件是什么

222
00:19:31,600 --> 00:19:33,280
这是非常难的

223
00:19:33,430 --> 00:19:36,160
因为你不知道哈希函数的必然性是什么

224
00:19:36,530 --> 00:19:39,170
我们来想像一个理想的哈希函数

225
00:19:39,480 --> 00:19:41,360
一个理想的哈希函数要做什么呢？

226
00:19:52,330 --> 00:19:57,310
对，将键基本随机映射到一个槽上

227
00:19:58,600 --> 00:20:01,490
应该真正随机分布

228
00:20:01,740 --> 00:20:17,360
我们把这种假设情况称为——简单均匀哈希

229
00:20:22,060 --> 00:20:34,620
它的意思是  每个属于集合S的键值K都有相同的几率

230
00:20:39,330 --> 00:20:49,610
被哈希映射到表T的任意一个槽里

231
00:20:51,920 --> 00:20:54,360
实际上  我们还有必要做个独立性的假设

232
00:20:54,550 --> 00:21:05,020
每个键与其他被哈希的记录或键之间相互独立

233
00:21:16,710 --> 00:21:17,880
我们要做的就是这种简单均匀哈希的假设

234
00:21:18,010 --> 00:21:23,390
而且还包含一个独立性假设

235
00:21:23,590 --> 00:21:26,030
那如果我有两个键

236
00:21:26,140 --> 00:21:29,070
它们被哈希映射到同一个槽的概率是多少呢？

237
00:21:32,820 --> 00:21:35,370
在我们刚才所说的这种假设下

238
00:21:35,460 --> 00:21:39,260
它们映射到同一个槽的概率是多少 假如我有m个槽的话？

239
00:21:41,410 --> 00:21:47,290
1/m， 那么一个键被哈希映射到槽15的概率又是多少？

240
00:21:50,410 --> 00:21:54,200
也是1/m， 因为它们是独立的

241
00:21:54,320 --> 00:21:56,190
而特定的两个键

242
00:21:56,330 --> 00:21:58,950
被哈希映射到同一个槽的概率 也是1/m

243
00:22:05,890 --> 00:22:14,220
有什么问题吗？

244
00:22:14,850 --> 00:22:34,740
没有 好的 我们定义一个存放n个键、有m个槽的哈希表

245
00:22:38,350 --> 00:22:43,020
它的装载因子是 α = n/m

246
00:22:43,350 --> 00:22:45,380
如果你仔细想想

247
00:22:45,530 --> 00:22:48,520
它就是  每个槽里键的平均数量

248
00:22:56,150 --> 00:22:59,410
所以α是每个槽里键的平均数量

249
00:22:59,550 --> 00:23:01,740
我们把它称为哈希表的装载因子

250
00:23:02,090 --> 00:23:05,420
也就是平均每个槽有多少个键

251
00:23:05,880 --> 00:23:16,970
我们先看看  失败搜索的预计用时

252
00:23:20,100 --> 00:23:22,350
所谓的“失败搜索”是指...

253
00:23:22,450 --> 00:23:24,910
我要查找的东西并不在哈希表里的

254
00:23:25,280 --> 00:23:28,520
最终返回结果是nil  因为搜索的键并不在表里

255
00:23:30,370 --> 00:23:37,740
那预计用时是多少？这等于...

256
00:23:37,960 --> 00:23:40,530
当然  即使搜索不到我们也要做一轮运算

257
00:23:40,640 --> 00:23:43,630
比如计算哈希值之类的

258
00:23:43,850 --> 00:23:47,380
所以 这至少等于θ(1 +...

259
00:23:47,730 --> 00:23:50,120
因为我还要搜索这个链表

260
00:23:50,890 --> 00:23:54,150
平均情况下要搜索的链表有多大呢？

261
00:23:57,940 --> 00:24:00,920
搜索这个链表的平均花费是多少？

262
00:24:01,060 --> 00:24:03,440
一般来说 假设是我们是随机地搜索

263
00:24:04,480 --> 00:24:08,610
如果我搜索的是一个并不存在于这个哈希表的键

264
00:24:12,220 --> 00:24:15,520
那不管是哪个键 我都必须把整个链表搜索一遍 是吧？

265
00:24:16,650 --> 00:24:19,530
那整条链表搜索一遍平均花费是多少？

266
00:24:21,340 --> 00:24:26,810
α？对 就是α

267
00:24:26,900 --> 00:24:28,770
它是链表的平均长度

268
00:24:31,650 --> 00:24:37,200
这里的“1”是指 把键指哈希映射到槽

269
00:24:39,130 --> 00:24:41,170
所需要的时间

270
00:24:43,850 --> 00:24:47,760
而α是搜索槽对应的链表 所花费的时间

271
00:24:52,530 --> 00:24:56,160
所以预计失败搜索的时间

272
00:24:56,600 --> 00:25:00,230
基本与α是成比例的

273
00:25:00,560 --> 00:25:03,130
如果α大于1 这个近似于θ（α）

274
00:25:03,230 --> 00:25:05,610
如果α小于1 它近似于一个常数量

275
00:25:12,300 --> 00:25:25,940
什么情况下预计搜索时间  等于θ（1）

276
00:25:31,950 --> 00:25:34,970
什么时候会是θ（1）

277
00:25:44,810 --> 00:25:46,530
顺便说一下 这是个简单的问题

278
00:25:46,940 --> 00:25:49,650
我问的问题都很简单 可能有些人会问很难的问题

279
00:25:50,720 --> 00:25:56,070
[教授]或者我们先分两个步来解答这个问题

280
00:25:56,300 --> 00:25:57,900
α在什么情况下 搜索时间等于θ（1）

281
00:25:59,110 --> 00:26:02,660
答案是α恰好是一个常数量时

282
00:26:05,960 --> 00:26:08,760
当然 α也可以不是常数量 它可能比常数量还要小

283
00:26:09,130 --> 00:26:12,420
也就是α= O（1） 或者也可以说

284
00:26:12,570 --> 00:26:21,810
正如你所说的 如果n＝O(m)

285
00:26:24,560 --> 00:26:30,280
也就是说  如果哈希表里键的数量n

286
00:26:31,610 --> 00:26:34,570
不会超过槽的数量m的常数倍

287
00:26:34,990 --> 00:26:36,950
那么搜索花费的时间就是一个常数量

288
00:26:37,070 --> 00:26:38,160
所以很多人会跟你说

289
00:26:38,280 --> 00:26:42,040
一个哈希表的运行时间是固定值

290
00:26:42,730 --> 00:26:44,320
实际上那是错误的

291
00:26:44,670 --> 00:26:47,650
它其实取决于哈希表的装载因子

292
00:26:49,470 --> 00:26:51,390
正是由于对哈希表的这个错误理解

293
00:26:51,510 --> 00:26:53,520
人们在编程时就会犯一些错误

294
00:26:55,080 --> 00:26:57,250
因为他们的哈希表太小了

295
00:26:58,000 --> 00:26:59,850
相对于他们要放进去的键的数量而言没有帮助

296
00:27:00,630 --> 00:27:07,420
键的数量有可能会增加

297
00:27:08,430 --> 00:27:12,600
因为这是θ（1+n/m）  它是随着n增加而增加的

298
00:27:12,880 --> 00:27:15,440
除非你能保证m跟n一起增长

299
00:27:18,740 --> 00:27:20,760
否则  θ并不保持常数量

300
00:27:24,140 --> 00:27:27,010
事实上 一个成功搜索的运行时间也是θ（1+α)

301
00:27:28,710 --> 00:27:31,240
但证明这个你必须做一点数学运算

302
00:27:31,850 --> 00:27:34,100
因为这次的条件不同了

303
00:27:34,280 --> 00:27:36,930
这次搜索的数据是存在哈希表中的

304
00:27:37,200 --> 00:27:39,270
虽然结果也是1+α

305
00:27:39,390 --> 00:27:42,180
你可以从书里读到相关的内容

306
00:27:42,440 --> 00:27:45,170
当然也有一些更严格的证明

307
00:27:45,310 --> 00:27:49,820
不过我在这里就不列出完整的证明过程了

308
00:27:49,990 --> 00:27:52,770
只是给出一些直观上的解释

309
00:27:52,990 --> 00:27:55,770
这些应该对照课本里的内容看一下

310
00:28:01,290 --> 00:28:04,840
上述内容也是为什么哈希这么受欢迎的一个原因

311
00:28:04,930 --> 00:28:07,760
主要是你能在θ（1）的运行时间内

312
00:28:07,920 --> 00:28:12,580
完成动态集合里的操作

313
00:28:12,710 --> 00:28:16,110
比如插入、删除等 每个操作的运行时间都是一个常数量

314
00:28:16,260 --> 00:28:18,220
只要你哈希表的大小

315
00:28:19,150 --> 00:28:22,800
不要远小于你要放在里面

316
00:28:22,940 --> 00:28:24,710
所保存的记录个数

317
00:28:26,190 --> 00:28:29,600
那么所有操作都只需一个常数量的运行时间

318
00:28:30,670 --> 00:28:31,700
但很大程度上

319
00:28:31,820 --> 00:28:35,230
这种情况是建立在“简单均匀哈希”的假设上

320
00:28:36,560 --> 00:28:40,880
因为不论你用的是什么哈希函数

321
00:28:42,200 --> 00:28:48,360
我总是能找到一些元素

322
00:28:48,480 --> 00:28:50,490
使得哈希映射出的结果很糟糕

323
00:28:51,980 --> 00:28:54,530
例如我可以制造出一堆元素

324
00:28:54,640 --> 00:28:56,740
代入到哈希函数里 看看它们会被映射到哪个槽

325
00:28:56,820 --> 00:29:00,100
然而最后它们却都映射到了同一个槽里

326
00:29:00,270 --> 00:29:03,420
所以我们要反过来想什么是才好的哈希函数

327
00:29:03,500 --> 00:29:11,240
但在实际应用中 我们知道绝大多数的程序用到的

328
00:29:11,480 --> 00:29:14,590
并不是真正由逆向工程得到的哈希函数

329
00:29:14,900 --> 00:29:16,840
另外，有些非常简单的哈希函数

330
00:29:16,940 --> 00:29:19,390
在现实中似乎能起到很好的作用

331
00:29:22,090 --> 00:29:24,250
如何选择一个哈希函数

332
00:29:30,950 --> 00:29:44,830
我们想要把键 均匀分布到槽里

333
00:29:49,220 --> 00:29:57,140
而键本身的一些分布的特性

334
00:30:04,480 --> 00:30:10,260
不会影响到它在哈希表中分布的均匀性

335
00:30:12,780 --> 00:30:16,640
举个例子 你经常见的一个分布特性是

336
00:30:16,740 --> 00:30:19,540
所有插入的键值都是偶数

337
00:30:20,900 --> 00:30:24,300
碰巧某些人的数据有这样的属性

338
00:30:24,820 --> 00:30:26,710
他们只插入偶数值的键

339
00:30:27,000 --> 00:30:29,560
实际上 因为在很多机器上使用的是字节指针

340
00:30:29,720 --> 00:30:33,200
如果它们是按照...比如

341
00:30:33,310 --> 00:30:36,960
按照数组的索引来分类的话

342
00:30:37,070 --> 00:30:41,660
这些数据大多数都会被分配到能被四或者被八整除的索引里

343
00:30:44,110 --> 00:30:46,780
你不希望键的这种特性

344
00:30:46,880 --> 00:30:49,000
会影响到它在槽的分布均匀性

345
00:30:49,760 --> 00:30:52,430
那也许用于快速哈希函数里

346
00:30:52,530 --> 00:30:54,840
最受欢迎的方法

347
00:30:54,910 --> 00:30:58,160
就是我们说的“除法哈希法”了

348
00:31:05,680 --> 00:31:07,480
具体实现是这样的

349
00:31:07,560 --> 00:31:13,700
让 h(k)=k mod m （k对m取余）

350
00:31:14,090 --> 00:31:16,750
m 是哈希表里槽的数量

351
00:31:22,570 --> 00:31:26,340
实际上这个函数的实现很合理

352
00:31:26,470 --> 00:31:29,670
但你必须注意你选择的除数（即m）

353
00:31:29,820 --> 00:31:31,840
换句话说 它并不是都能...

354
00:31:31,980 --> 00:31:35,090
适用于任意大小的哈希表

355
00:31:35,350 --> 00:31:37,130
幸运的是当你建立哈希表时

356
00:31:37,250 --> 00:31:39,810
你通常并不关注哈希表的具体大小

357
00:31:40,020 --> 00:31:43,640
如果你在某个值的附近取值 可能没问题

358
00:31:43,810 --> 00:31:46,290
因为这不会影响到运行效率

359
00:31:46,440 --> 00:31:49,000
所以没必要选择一个具体的值

360
00:31:49,250 --> 00:32:02,500
不过要注意，千万不要选择太小的m来做除数

361
00:32:09,740 --> 00:32:12,840
让我解释一下为什么

362
00:32:12,980 --> 00:32:14,970
这种做法对这种除法哈希法不好

363
00:32:25,500 --> 00:32:27,740
我应该把这个小除数定义成d

364
00:32:33,230 --> 00:32:39,810
举个例子 如果d=2

365
00:32:39,900 --> 00:32:41,760
也就是说m是一个偶数

366
00:32:44,250 --> 00:32:47,160
如果恰好我们所说的那种情况发生了

367
00:32:47,300 --> 00:32:52,520
所有的键都是偶数的

368
00:32:55,770 --> 00:32:59,740
对哈希表的运作会产生什么影响？

369
00:33:01,530 --> 00:33:05,460
我有偶数个槽

370
00:33:05,600 --> 00:33:09,300
而所有用户选择的键

371
00:33:09,400 --> 00:33:11,760
也恰好都是偶数

372
00:33:11,980 --> 00:33:15,830
对哈希表的使用会发生什么事呢？

373
00:33:22,680 --> 00:33:24,200
[教授]在最坏情况下

374
00:33:24,290 --> 00:33:25,310
[教授]无论我选择什么哈希函数

375
00:33:25,400 --> 00:33:27,610
[教授]所有键都映射指向同一个槽

376
00:33:27,870 --> 00:33:29,550
[教授]但这里 假设

377
00:33:29,670 --> 00:33:33,130
[教授]一般情况下这个哈希函数的分布效果还不错

378
00:33:33,940 --> 00:33:38,400
但对于这个特殊的性质 它又会导致怎样的结果？

379
00:33:38,480 --> 00:33:42,620
不管我选择的是哪一组键

380
00:33:42,970 --> 00:33:44,340
只要它满足这一个性质

381
00:33:44,430 --> 00:33:46,200
那哈希表将变成什么样？

382
00:33:53,900 --> 00:33:58,090
偶数对偶数取余

383
00:33:59,540 --> 00:34:02,000
哈希函数h(k)的值会是什么？

384
00:34:08,560 --> 00:34:14,270
是偶数 对吧？如果我用偶数对偶数取余，得数就会是偶数

385
00:34:14,500 --> 00:34:16,660
那这对我使用哈希表又有什么影响呢？

386
00:34:19,520 --> 00:34:23,150
对了 你永远不可能哈希映射到一个奇数位的槽

387
00:34:24,320 --> 00:34:25,880
你浪费了一半的槽

388
00:34:26,580 --> 00:34:28,780
这并不关系到键的分布状况

389
00:34:29,510 --> 00:34:32,290
只要它们都是偶数的

390
00:34:32,940 --> 00:34:36,660
那就意味着奇数位的槽没用了

391
00:34:41,980 --> 00:34:46,430
另外一个极端的例子

392
00:34:46,760 --> 00:34:50,070
假设 m = 2^r

393
00:34:50,310 --> 00:34:55,750
也就是说 它所有的因子等于我们的小除数d

394
00:34:56,850 --> 00:35:01,510
在这种情况下 如果让k对m取余

395
00:35:02,810 --> 00:35:08,060
它的哈希过程中就不会考虑到k所有的位（二进制）

396
00:35:21,700 --> 00:35:33,400
就譬如我定义了这个二进制数...r=6

397
00:35:33,800 --> 00:35:36,480
那么m=2^6

398
00:35:36,710 --> 00:35:39,360
我用这串二进制数值

399
00:35:39,520 --> 00:35:46,200
对2^6取余的哈希值是多少？

400
00:35:47,500 --> 00:35:50,590
如果对2的幂取余 会发生什么情况？

401
00:35:59,580 --> 00:36:08,180
我对这个k的二进制数计算它的哈希值

402
00:36:12,720 --> 00:36:15,190
也就是拿它对2^6取余

403
00:36:17,130 --> 00:36:19,220
如果拿它除以2取余 结果是多少？

404
00:36:23,090 --> 00:36:27,860
这个数对2取余等于多少？ 对，是0

405
00:36:27,990 --> 00:36:31,330
对4取余呢？ 是10（二进制）

406
00:36:31,470 --> 00:36:33,430
除以2^6取余呢？

407
00:36:35,360 --> 00:36:40,570
对，就是最后这6位数 这就是h(k)

408
00:36:44,160 --> 00:36:46,620
当你对2的幂取余时

409
00:36:46,720 --> 00:36:48,710
你其实就是在取它（二进制）后几位的数字

410
00:36:49,610 --> 00:36:54,580
对2^r取余的结果 就等于它最低的r位数字

411
00:36:55,650 --> 00:36:58,310
这样的话 哈希函数就与键值的其他几位数无关了

412
00:36:59,660 --> 00:37:01,620
这是很糟糕的状况

413
00:37:01,710 --> 00:37:05,730
因为通常来说 二进制数据都具有一个常见的规则性

414
00:37:05,840 --> 00:37:10,520
要么所有的低位数字相同、高位不同

415
00:37:10,640 --> 00:37:14,000
要么反过来 所有的高位的数字相同、低位不同

416
00:37:14,200 --> 00:37:16,520
所以这种状况就并不是很好

417
00:37:16,890 --> 00:37:22,760
所以好的方法是取质数来作为m的值

418
00:37:25,640 --> 00:37:36,910
不要太接近2的幂或10的幂这些数

419
00:37:37,240 --> 00:37:39,160
因为2和10是全世界最常见的底数

420
00:37:39,310 --> 00:37:44,020
也是最有规则性的底数

421
00:37:46,090 --> 00:37:51,020
质数有时候也不是很好确定

422
00:37:51,650 --> 00:37:54,960
但总体上 质数并不难找

423
00:37:55,050 --> 00:37:57,340
有很多关于质数的好定理

424
00:37:57,540 --> 00:38:00,380
如果你只是平常地编写代码

425
00:38:00,480 --> 00:38:04,220
你知道要选怎么选哈希表大小  你就可以选用书本里的质数

426
00:38:04,350 --> 00:38:07,420
或者上网查阅、写个小程序之类的

427
00:38:07,510 --> 00:38:09,320
只要选出一个质数就好

428
00:38:09,430 --> 00:38:11,570
不要用太接近以2或10为底的数

429
00:38:11,650 --> 00:38:12,780
它就很可能有效地运行了

430
00:38:14,300 --> 00:38:15,970
可能还运行得相当不错

431
00:38:16,280 --> 00:38:18,430
上述是一个非常流行的方法 “除法哈希法”

432
00:38:18,520 --> 00:38:22,690
下一个我们要学习的算法

433
00:38:22,750 --> 00:38:24,710
会更加的出色

434
00:38:25,360 --> 00:38:27,600
人们使用“除法哈希法”是因为

435
00:38:27,740 --> 00:38:31,660
它能方便地嵌入代码里

436
00:38:33,040 --> 00:38:34,820
但它不是最好的算法

437
00:38:34,910 --> 00:38:36,660
原因之一是

438
00:38:36,740 --> 00:38:41,180
相对于乘法和加法而言

439
00:38:41,260 --> 00:38:46,420
在很多计算机上运算时 除法往往有更多的循环运算

440
00:38:47,230 --> 00:38:51,770
而实际上 我们通常用几步乘法就能解决问题

441
00:38:53,280 --> 00:38:56,960
所以 我们下面要介绍算法会更好用一些

442
00:38:57,170 --> 00:39:02,880
但其实我们今天所提到的哈希算法

443
00:39:02,960 --> 00:39:06,530
在某种意义上 都不能说是好的哈希函数

444
00:39:09,630 --> 00:39:11,740
对于“乘法哈希法”

445
00:39:11,890 --> 00:39:15,300
它的优点是 基本上只需要用到乘法运算

446
00:39:16,110 --> 00:39:20,660
同样地 我们也要先定些假设条件

447
00:39:20,750 --> 00:39:25,120
槽的数量m 是以2为底的幂数 这对后面运算有利

448
00:39:25,820 --> 00:39:37,220
同时我们还要假定计算机的一个字的长度是w位

449
00:39:38,390 --> 00:39:43,630
比如 比较合适的计算机的字长有32位的

450
00:39:43,720 --> 00:39:46,150
或者64位的

451
00:39:46,840 --> 00:39:48,620
这都是比较好算的

452
00:39:49,020 --> 00:39:52,490
这个哈希函数是这样的...

453
00:39:52,800 --> 00:40:05,800
h（k）=（A·k mod 2^w）rsh（w-r）

454
00:40:07,110 --> 00:40:12,110
关键的地方是这里的A

455
00:40:12,200 --> 00:40:18,520
A是一个奇数

456
00:40:18,760 --> 00:40:23,760
一个大于2^(w-r)  小于2^w的一个奇数

457
00:40:26,260 --> 00:40:30,410
它是一个等长于计算机字长的奇数

458
00:40:31,500 --> 00:40:36,270
无论你的键值是什么 把它与A相乘

459
00:40:36,370 --> 00:40:42,750
乘以这个有趣的整数 然后对2^w取余

460
00:40:42,950 --> 00:40:46,270
最后得出的结果 再向右移一定的位数

461
00:40:46,360 --> 00:40:48,970
偏移w-r的位数

462
00:40:49,200 --> 00:40:57,630
“rsh”指二进制位运算的右偏移

463
00:41:01,570 --> 00:41:04,210
让们分析一下这函数在做什么

464
00:41:04,310 --> 00:41:08,420
但我先教你们一些如何选择A的值

465
00:41:08,480 --> 00:41:11,220
或不要选哪些值作为A的值

466
00:41:11,430 --> 00:41:19,850
首先A的取值不要太接近以2为底的数

467
00:41:24,900 --> 00:41:27,820
这是一个快速的算法

468
00:41:31,740 --> 00:41:43,660
因为相乘后再对2^w取余 比除法要快

469
00:41:45,940 --> 00:41:48,790
还有一点是 右移运算也很快

470
00:41:49,100 --> 00:41:51,830
尤其是我们已经知道了偏移量是多少

471
00:41:53,060 --> 00:41:56,790
在你运算这个哈希函数前

472
00:41:56,930 --> 00:41:59,100
你已经提前知道了w和r的值

473
00:41:59,300 --> 00:42:02,860
所以编译器也有些提高运算速度的方法

474
00:42:04,210 --> 00:42:07,960
那我们举个例子 来理解这个哈希函数的运作

475
00:42:13,950 --> 00:42:19,480
在这个例子里 我们有8个槽

476
00:42:19,580 --> 00:42:21,990
8=2^3

477
00:42:22,250 --> 00:42:26,040
我们取一个特殊的字长为7位

478
00:42:26,180 --> 00:42:28,900
有人见过世界上哪台计算机的字长是7位的吗？

479
00:42:30,360 --> 00:42:32,720
这里就有一台

480
00:42:33,020 --> 00:42:38,560
A是一个用于哈希函数的定值

481
00:42:38,770 --> 00:42:46,070
假定 A=1011001

482
00:42:46,430 --> 00:42:54,430
我选取一个k值来乘以A

483
00:42:54,730 --> 00:43:01,140
我设定k值为1101011

484
00:43:02,180 --> 00:43:03,500
用A乘以k

485
00:43:03,780 --> 00:43:07,170
这两个值恰好都占一个字长

486
00:43:07,390 --> 00:43:12,570
你可以将它们看成计算机里的两个字

487
00:43:12,720 --> 00:43:14,170
在这里 都是7位

488
00:43:14,310 --> 00:43:16,740
不过通常的计算机里 这些应该是32位的数

489
00:43:16,850 --> 00:43:22,340
所以这应该是两个32位数的乘法运算

490
00:43:22,560 --> 00:43:29,350
这里乘法运算会得出一个2w位的答案

491
00:43:29,470 --> 00:43:35,500
当你用两个w位的数相乘时 你会得到一个2w位的答案

492
00:43:35,700 --> 00:43:50,750
这个例子里 乘积是这个

493
00:43:52,780 --> 00:43:59,660
这些是乘积部分

494
00:43:59,980 --> 00:44:03,050
然后再拿它对2^w取余

495
00:44:03,180 --> 00:44:06,960
对2^w取余也是意味着

496
00:44:07,060 --> 00:44:10,710
忽略掉这乘积的高位

497
00:44:10,870 --> 00:44:13,130
这几位数都忽略掉

498
00:44:20,270 --> 00:44:24,930
要记住 当一个数对以2为底的幂取余时

499
00:44:25,070 --> 00:44:27,300
得到的是该数低位的值

500
00:44:27,450 --> 00:44:30,340
所以取余的结果是这几个低位的值

501
00:44:31,960 --> 00:44:36,040
再然后是右偏移运算 同样也是很方便

502
00:44:36,140 --> 00:44:40,100
因为大部分的计算机里 当我用两个32位数相乘时

503
00:44:40,220 --> 00:44:45,380
计算机会有一个指令会直接得出32个低位的值

504
00:44:45,490 --> 00:44:48,010
所以使用这种指令

505
00:44:48,130 --> 00:44:52,110
通常会比先算64位结果要快很多

506
00:44:53,040 --> 00:44:56,480
所以 它用起来非常方便的

507
00:44:56,590 --> 00:45:00,840
因为我想要的只是...

508
00:45:00,950 --> 00:45:05,590
这个字长的前3位的值

509
00:45:05,740 --> 00:45:08,500
这个就是h(k)

510
00:45:10,450 --> 00:45:15,880
所以我们用右移运算移走其他的位

511
00:45:16,000 --> 00:45:19,570
将右边低位移走 在高位填充0

512
00:45:19,710 --> 00:45:22,070
最后得到h(k)的值

513
00:45:25,330 --> 00:45:28,020
怎么理解这个运算过程

514
00:45:31,730 --> 00:45:37,210
为什么这是一个很精彩的算法 它到底做了什么

515
00:45:37,370 --> 00:45:44,430
你可以这样想

516
00:45:44,550 --> 00:45:50,440
把A看作一个二进制的分数

517
00:45:50,660 --> 00:45:55,600
想像小数点在这里 哦不 是二进制小数点

518
00:45:55,960 --> 00:45:58,340
小数点在这里

519
00:45:58,590 --> 00:46:02,080
当A乘以某个数时

520
00:46:02,390 --> 00:46:05,400
小数点就会出现在这里

521
00:46:08,280 --> 00:46:10,520
你只需要大概地想像一下

522
00:46:10,630 --> 00:46:13,390
没必要把这些放入计算机里

523
00:46:13,480 --> 00:46:15,350
因为这只是帮助我们理解而已

524
00:46:15,460 --> 00:46:18,770
我可以想像 这边是小数部分 那个是整数部分

525
00:46:18,930 --> 00:46:22,480
我们真正需要的是这个乘积的小数部分

526
00:46:22,720 --> 00:46:25,450
要把A看成一个数的小数部分

527
00:46:25,720 --> 00:46:28,220
我们可以“车轮法”来理解这个哈希函数

528
00:46:33,510 --> 00:46:39,220
我们画一个车轮

529
00:46:40,980 --> 00:46:43,480
将它等分成八部分

530
00:46:45,630 --> 00:46:48,740
这个点代表0

531
00:46:48,970 --> 00:46:52,760
然后我走了一圈 这个点变成1

532
00:46:53,030 --> 00:46:57,030
我再走一圈 这个点是2 依此类推

533
00:46:57,300 --> 00:47:00,860
如果我绕着这个单位车轮转

534
00:47:01,140 --> 00:47:06,570
所有的整数都和这个零点连成一线

535
00:47:06,760 --> 00:47:10,150
然后我们可以用分数把车轮划分成几块

536
00:47:10,290 --> 00:47:13,430
这原本是零点 这里是八分之一

537
00:47:13,570 --> 00:47:19,360
因为我们把车轮等分成八份 2、3、4...7

538
00:47:20,530 --> 00:47:27,260
如果我用1乘以A

539
00:47:27,420 --> 00:47:31,000
用上述例子的A 乘以1

540
00:47:31,120 --> 00:47:33,290
基本上是这样绕的

541
00:47:33,480 --> 00:47:40,380
大概到这里 我想是5.5

542
00:47:40,470 --> 00:47:44,930
因为1乘以A大约等于5.5

543
00:47:47,170 --> 00:47:56,100
差不多是5.5/8

544
00:47:57,420 --> 00:47:59,180
大概到这里 这是A

545
00:47:59,410 --> 00:48:04,760
如果我算2A 那继续绕

546
00:48:04,820 --> 00:48:07,490
大概会到这里

547
00:48:07,790 --> 00:48:12,610
稍微超过3 大概在这里

548
00:48:12,830 --> 00:48:19,670
这是2A 然后是3A

549
00:48:19,820 --> 00:48:23,440
大概是绕到这里

550
00:48:25,710 --> 00:48:33,250
每次我加多一个A

551
00:48:33,410 --> 00:48:36,930
它会加多一段A的弧长

552
00:48:37,250 --> 00:48:41,900
我想说的是 如果A是奇数

553
00:48:42,150 --> 00:48:45,520
不是近似以2为底的幂值

554
00:48:45,690 --> 00:48:50,730
那哈希的过程 就可以看成是

555
00:48:50,790 --> 00:48:53,000
将键扔进不同的槽

556
00:48:53,100 --> 00:48:55,780
类似绕车轮 如果k值特别大

557
00:48:56,040 --> 00:48:59,480
那k乘以A 将相当于绕k个圈

558
00:48:59,570 --> 00:49:00,610
在哪里停下呢？

559
00:49:00,750 --> 00:49:03,270
这就像是在转动一个幸运轮盘

560
00:49:03,410 --> 00:49:07,810
会在某个地方停下  这些是基本的概念

561
00:49:08,000 --> 00:49:13,280
它最终将在某个地方停下

562
00:49:13,660 --> 00:49:16,500
你就想知道 它会在哪个位置停下呢？

563
00:49:16,650 --> 00:49:19,910
它就这样转啊转 最后停在某个地方

564
00:49:20,090 --> 00:49:25,310
这也是为什么 这是个不错的哈希函数

565
00:49:25,520 --> 00:49:27,780
不过这只是探索性的哈希方法

566
00:49:28,030 --> 00:49:29,430
因为对于任意哈希函数而言

567
00:49:29,560 --> 00:49:33,100
你总能找到一些键 使得哈希出来的结果很糟糕

568
00:49:34,190 --> 00:49:36,080
问题是 你在实际应用中选择哪个

569
00:49:38,250 --> 00:49:54,570
我想说的第二个话题

570
00:49:54,790 --> 00:49:59,210
我们讨论过用链接法 来解决碰撞问题

571
00:49:59,430 --> 00:50:07,400
其实还有别外一个解决碰撞的方法 也是很有用的

572
00:50:07,550 --> 00:50:15,830
这个用来解决碰撞的方法 称为“开放寻址法”

573
00:50:25,410 --> 00:50:33,140
在这个方法里 我们没有链表

574
00:50:34,660 --> 00:50:37,820
如果我们用链接法

575
00:50:37,950 --> 00:50:42,480
为了做到这一点 在每个记录里

576
00:50:42,700 --> 00:50:44,930
就需要一个额外的关联地址

577
00:50:45,100 --> 00:50:49,110
但对于某些应用来说 就没必要为此付出巨大的开支

578
00:50:49,330 --> 00:50:52,270
我们也不想对记录做有任何的改动

579
00:50:54,250 --> 00:51:03,740
在这种情况下 开放寻址法就是解决碰撞的很有效的方法

580
00:51:05,200 --> 00:51:11,740
用开放寻址法的时候 如果我哈希到一个槽

581
00:51:11,970 --> 00:51:16,680
但这个槽已经存放了记录 没关系

582
00:51:16,880 --> 00:51:20,800
我就用另外一个哈希函数再哈希一次

583
00:51:21,110 --> 00:51:23,910
我用第二个哈希函数

584
00:51:24,030 --> 00:51:27,080
再哈希到下一个槽 如果那个也满了

585
00:51:27,970 --> 00:51:30,100
那再哈希一次

586
00:51:30,290 --> 00:51:32,630
形成一个探查的序列

587
00:51:32,800 --> 00:51:34,790
然后变成一种算术排列

588
00:51:34,920 --> 00:51:37,320
使得我不用探查那些我已经查找过的槽

589
00:51:37,480 --> 00:51:40,210
直到找到一个可以放置的地方为止

590
00:51:40,460 --> 00:51:44,070
如果用一个好的探查序列

591
00:51:44,170 --> 00:51:46,590
我就能快速地找到一个放置的地方

592
00:51:48,050 --> 00:51:52,860
对于查找键值而言 我们就按同样的探查序列来查找

593
00:51:54,460 --> 00:52:08,100
开放寻址的思想就是  系统地探查哈希表

594
00:52:11,750 --> 00:52:20,840
直到找到一个空的槽为止

595
00:52:21,530 --> 00:52:24,440
我们可以把它扩展开来看

596
00:52:24,570 --> 00:52:28,280
如果哈希函数的序列是...

597
00:52:28,380 --> 00:52:35,710
实际上 一个哈希函数有两个参数 键和探查顺序

598
00:52:36,060 --> 00:52:40,460
换句话说 这是第一个哈希函数

599
00:52:40,600 --> 00:52:44,350
第二个函数...等等 它有两个参数

600
00:52:44,480 --> 00:52:49,700
哈希函数h会全域里的键

601
00:52:54,710 --> 00:52:58,370
通过一步步的探查映射到槽里

602
00:53:02,040 --> 00:53:11,170
U代表键的全域 这些是探查号

603
00:53:13,620 --> 00:53:15,980
这段表示槽

604
00:53:20,250 --> 00:53:31,740
正如我之前提到的 探查序列应该是一个算术排列

605
00:53:32,130 --> 00:53:37,620
换句话说 它必须是数字0到m-1的

606
00:53:37,710 --> 00:53:41,360
某种完全随机的排列

607
00:53:41,590 --> 00:53:44,070
对 把它们打乱重排

608
00:53:44,300 --> 00:53:51,140
另外 对于开放寻址表来说...

609
00:53:51,270 --> 00:53:52,960
你不必担心n链接的问题

610
00:53:53,050 --> 00:53:54,740
因为哈希表最终会被填满

611
00:54:00,310 --> 00:54:05,370
所以哈希表里元素的数量

612
00:54:05,530 --> 00:54:08,480
必须小于表的大小

613
00:54:08,640 --> 00:54:13,420
小于槽的数量 这样才不会溢出

614
00:54:13,670 --> 00:54:16,260
但如果哈希表已经满了 无论怎么探查

615
00:54:16,310 --> 00:54:18,240
你都不可能找到一个地方来存放数据

616
00:54:18,500 --> 00:54:23,770
所以 在这种规划类型中

617
00:54:23,870 --> 00:54:30,350
删除变得非常困难的 但不是不可能

618
00:54:30,450 --> 00:54:32,380
有专门的删除方案

619
00:54:32,530 --> 00:54:35,090
但删除操作执行起来比较困难 因为有这样的风险..

620
00:54:35,140 --> 00:54:40,190
当你从表中移除某个键后

621
00:54:40,230 --> 00:54:43,980
有人按探查序列来查找另一个键  他本应先发现这里不是他要的键

622
00:54:44,080 --> 00:54:47,210
继而再向下查找 然而现在却发现这个槽是空的

623
00:54:47,260 --> 00:54:51,270
那么他会认会 想查找的键很有可能不在这个表里

624
00:54:52,520 --> 00:54:54,610
对 你会碰到的问题

625
00:54:54,790 --> 00:54:56,790
那么你可以将之删除 但在槽里留下标记

626
00:54:56,880 --> 00:55:00,370
人们有各种各样的方案来做删除操作

627
00:55:00,550 --> 00:55:03,910
但都比较困难 链接法直接从链表里删除键就好了

628
00:55:04,060 --> 00:55:05,800
相比之下 这种删除操作很混乱

629
00:55:08,090 --> 00:55:10,050
我们举一个例子

630
00:55:22,520 --> 00:55:24,580
——来保证大家都跟得上

631
00:55:32,130 --> 00:55:42,180
插入一个键k=496 这是哈希表

632
00:55:50,480 --> 00:56:04,650
里面有一些数值 586、133、204、481等等

633
00:56:04,920 --> 00:56:07,180
哈希表是这样的 其它的地方是空的

634
00:56:09,770 --> 00:56:19,310
第零号探查，我们探查 h(496,0)

635
00:56:20,410 --> 00:56:24,550
假设我们哈希映射到这个槽 这里已经有数值204

636
00:56:25,590 --> 00:56:29,700
好，我们发现这个槽已经有记录了

637
00:56:29,990 --> 00:56:39,860
那就必须再探查一次 探查h(496,1)

638
00:56:40,130 --> 00:56:45,270
可能映射到这里 我发现——

639
00:56:45,500 --> 00:56:46,860
这个槽也被占用了

640
00:56:48,580 --> 00:56:55,490
现在我探查h(496,2)

641
00:56:55,700 --> 00:57:00,770
可能映射到这里 一个空槽

642
00:57:00,910 --> 00:57:04,130
如果是进行查找操作 那么返回nil

643
00:57:04,230 --> 00:57:07,730
如果是进行插入操作 则把键放入这个槽

644
00:57:09,370 --> 00:57:13,340
如果要查找一个已经放在这里的值

645
00:57:13,440 --> 00:57:17,010
在探查过程中 我就完全按照同样序列来查找

646
00:57:17,110 --> 00:57:19,280
发现这些位置都被占用了 最终——

647
00:57:19,380 --> 00:57:21,280
查到这里 找到了这个值

648
00:57:24,220 --> 00:57:27,480
人们还会使用多种探索性技巧

649
00:57:27,610 --> 00:57:30,190
像追踪最长探查序列

650
00:57:30,250 --> 00:57:34,230
因为查找操作的探查次数 不可能多于...

651
00:57:34,380 --> 00:57:36,850
所有插入操作中所用的最大的探查次数

652
00:57:37,230 --> 00:57:39,650
如果用了5次探查

653
00:57:39,770 --> 00:57:45,010
5是做插入操作时 用到的最大的探查次数

654
00:57:45,120 --> 00:57:47,530
那一个查找序列最多不会超过5个

655
00:57:47,800 --> 00:57:51,840
因此有时哈希表会附加 额外的数据

656
00:57:51,970 --> 00:57:55,940
这样它能及时结束 而不用保持探查序列

657
00:57:56,000 --> 00:58:00,560
结果却什么都找不到

658
00:58:01,680 --> 00:58:09,330
搜索也是用同样的探查序列

659
00:58:12,330 --> 00:58:18,540
如果成功 则返回相应记录

660
00:58:21,530 --> 00:58:28,050
如果不成功 则返回nil

661
00:58:32,520 --> 00:58:36,690
相当直观

662
00:58:38,880 --> 00:58:43,650
那么 就像刚刚哈希函数那样

663
00:58:43,710 --> 00:58:51,000
如何构造探查序列，如何有效进行探查

664
00:58:51,230 --> 00:58:53,310
也是有各种各样的方法

665
00:59:03,710 --> 00:59:09,570
其中最简单的 叫做“线性探查”

666
00:59:10,970 --> 00:59:15,170
线性探查的意思是

667
00:59:15,410 --> 00:59:28,330
让h(k,i）等于（h'(k,0）+ i) mod m

668
00:59:31,190 --> 00:59:36,960
不好意思 这里没有撇号

669
00:59:37,050 --> 00:59:43,160
我们的想法是 在第i次探查时...

670
00:59:44,040 --> 00:59:47,890
在第0号探查时 你找的是h(k,0)

671
00:59:48,590 --> 00:59:51,240
第1号探查 只要查找h(k,0)的下一个槽

672
00:59:51,770 --> 00:59:54,000
第2号探查 继续查找再下一个槽

673
00:59:54,160 --> 00:59:57,270
这样 相对于跳跃性地探查 你只需要简单地一个个探查

674
00:59:57,370 --> 01:00:00,060
探查到一个位置 然后接下去一个一个查找

675
01:00:01,780 --> 01:00:05,880
持续往下扫描 最后对m取余

676
01:00:06,030 --> 01:00:07,920
这样的话 如果查到表底 又会转回顶部

677
01:00:08,160 --> 01:00:11,100
这个真的很容易运作

678
01:00:11,210 --> 01:00:14,540
因为你并不需要 每次都重新算一次哈希函数

679
01:00:14,650 --> 01:00:17,530
你所要做的 是每次探查都加多一个1

680
01:00:17,640 --> 01:00:20,460
因为跟之前的函数的差别只是1

681
01:00:21,600 --> 01:00:23,410
你只要往下探查

682
01:00:23,520 --> 01:00:26,910
但也存在一个问题 叫做“群集现象”

683
01:00:27,010 --> 01:00:30,740
如果一串连续区域同时被占用了 那接下来所有的操作

684
01:00:30,840 --> 01:00:34,430
都必须不停探查 直至这串区域的底部

685
01:00:34,670 --> 01:00:37,930
这样看来这个方案并不是太好

686
01:00:38,030 --> 01:00:41,290
尽管不算很差 如果你只是做一些“豆腐渣”程序的话

687
01:00:43,250 --> 01:00:45,490
它会遇到“一次群集”的问题

688
01:00:45,700 --> 01:00:49,150
就是哈希表的某个区间会被占满

689
01:00:49,270 --> 01:00:52,140
任何映射到这段区间的键

690
01:00:52,230 --> 01:00:55,580
都必须探查遍历 这段里所有的槽

691
01:00:55,770 --> 01:01:02,520
连续被占有的槽 也会越来越长

692
01:01:06,590 --> 01:01:10,750
也有一种情况叫“二次群集”

693
01:01:10,850 --> 01:01:13,070
主要区别是

694
01:01:13,130 --> 01:01:17,820
每次加的是i而不是1

695
01:01:19,100 --> 01:01:24,310
而也许最有效率、最受欢迎的设计方案

696
01:01:24,420 --> 01:01:27,690
叫“二次哈希”

697
01:01:28,030 --> 01:01:30,370
你可以做一下统计分析

698
01:01:30,510 --> 01:01:33,670
人们通过统计分析 证明这是一个不错的方案

699
01:01:35,620 --> 01:01:43,610
让h(k，i）...写到下面去 这样才有足够地方写

700
01:01:43,860 --> 01:01:57,130
h(k，i)=(h_1(k)+i*h_2(k)）mod m

701
01:01:57,600 --> 01:02:02,560
你有两个关于m的哈希函数

702
01:02:04,830 --> 01:02:11,880
两个哈希函数分别是h_1(k)和h_2(k)

703
01:02:12,090 --> 01:02:14,740
计算这两个哈希函数

704
01:02:14,910 --> 01:02:19,590
开始你只用h_1(k)来做0号探查

705
01:02:19,690 --> 01:02:24,160
因为这里i会等于0

706
01:02:24,550 --> 01:02:31,890
然后对于1号探查 加上h_2(k)

707
01:02:32,000 --> 01:02:35,900
对于2号探查 加上原来的哈希函数值

708
01:02:36,130 --> 01:02:42,740
这样每次成功的探查 都只需要再加上h_2(k)

709
01:02:43,080 --> 01:02:46,460
这很简单 预先运算前两个哈希函数

710
01:02:46,600 --> 01:02:49,430
或者保险起见 第二个函数可以推迟计算

711
01:02:49,570 --> 01:02:51,610
但最基本上 是把两个函数值都计算好

712
01:02:51,710 --> 01:02:53,580
然后不断地叠加第二个函数值

713
01:02:53,690 --> 01:02:55,830
从第一个哈希到的位置开始

714
01:02:55,910 --> 01:02:58,340
不断加上第二个哈希值 同时对m取余

715
01:02:58,470 --> 01:03:01,700
来决定你的探查序列

716
01:03:01,820 --> 01:03:03,410
这是一个优秀的方法

717
01:03:07,650 --> 01:03:17,630
它能完成不错的工作 通常把m取为以2为底的幂值

718
01:03:17,860 --> 01:03:20,650
这样来使用

719
01:03:20,760 --> 01:03:24,890
比如 通常人们会结合乘法哈希法一起使用

720
01:03:25,020 --> 01:03:26,520
这里m是以2为底的值

721
01:03:26,640 --> 01:03:30,860
h_2(k)选择奇数的值

722
01:03:33,130 --> 01:03:36,640
在这里不使用偶数

723
01:03:36,730 --> 01:03:40,520
因为那样对于某些特殊键 会直接跳过某些槽

724
01:03:41,750 --> 01:03:43,970
再说一次 你可能会遇到这样的问题 所有的数值都是偶数

725
01:03:44,070 --> 01:03:46,620
或者所有的数值都是奇数

726
01:03:47,040 --> 01:03:50,350
如果让h_2(k)是奇数 让m是2为底的幂数

727
01:03:50,490 --> 01:03:53,620
你能保证所有槽都被分配到

728
01:03:57,160 --> 01:03:59,900
分析一下这个框架

729
01:04:00,180 --> 01:04:02,770
看起来是一个很有意思的框架

730
01:04:07,200 --> 01:04:09,290
里面有一些美好的数学元素

731
01:04:12,090 --> 01:04:17,630
再一次说到最坏情况... 哈希不是完美的

732
01:04:17,720 --> 01:04:20,590
分析一下平均情况

733
01:04:33,330 --> 01:04:39,970
为了这个分析 我们要假设的东西比“链接法”还要多一点

734
01:04:40,210 --> 01:04:43,920
这里的假设叫“均匀哈希”

735
01:04:50,990 --> 01:04:59,780
所有键都均等地

736
01:05:03,750 --> 01:05:15,970
有 m! 种探查序列

737
01:05:19,550 --> 01:05:31,960
而且每个键都是相互独立的

738
01:05:42,050 --> 01:05:45,260
我们将要证明的理论是

739
01:05:50,020 --> 01:05:56,510
预期的探查次数

740
01:05:56,730 --> 01:06:06,540
最多不超过1/(1-α) 如果α小于1

741
01:06:07,650 --> 01:06:15,140
这也意味着 哈希表里键的数量小于槽的数量

742
01:06:19,850 --> 01:06:20,940
好 我们要证明的就是

743
01:06:21,020 --> 01:06:23,370
探查次数等于1/(1-α)

744
01:06:32,100 --> 01:06:35,820
α是装载因子

745
01:06:37,110 --> 01:06:40,900
当然 对于开放寻址法 我们要求装载因子小于1

746
01:06:41,920 --> 01:06:43,730
因为如果我们的键数大于槽数

747
01:06:43,840 --> 01:06:46,850
开放寻址法就不起作用了

748
01:06:46,940 --> 01:06:50,980
因为你必须要为每个键都在哈希表找一个槽

749
01:06:55,660 --> 01:07:04,080
那先来看一个失败搜索的案例

750
01:07:06,000 --> 01:07:10,500
首先 第一次探查必不可少

751
01:07:20,910 --> 01:07:33,010
如果有n/m 不好意思 如果n个项存放在m个槽里

752
01:07:34,060 --> 01:07:36,920
探查过程碰撞到

753
01:07:37,050 --> 01:07:39,650
一个已经被占用的槽的概率是多少？

754
01:07:43,250 --> 01:07:45,500
发生碰撞的概率是多少？

755
01:07:45,890 --> 01:07:50,620
对 就是n/m

756
01:07:50,840 --> 01:07:59,100
所以 发生碰撞的概率是n/m

757
01:08:00,180 --> 01:08:04,330
因为哈希表有n个项在里面

758
01:08:04,430 --> 01:08:06,710
随机哈希其中一个

759
01:08:08,520 --> 01:08:11,890
撞上某一个的概率是多少？n/m

760
01:08:13,370 --> 01:08:16,120
然后 第二次探查也是必须的

761
01:08:23,170 --> 01:08:27,130
进行第二次探查

762
01:08:27,450 --> 01:08:31,660
第二次探查发生碰撞的概率是多少？

763
01:08:34,150 --> 01:08:37,180
这里就要用到“均匀哈希”的假设了

764
01:08:37,310 --> 01:08:38,880
因为每个键都均等地

765
01:08:38,980 --> 01:08:43,010
有 m! 种探查序列

766
01:08:43,550 --> 01:08:46,880
那么 第二次探查发生碰撞的概率...

767
01:08:48,480 --> 01:08:50,950
会是多少？

768
01:09:07,470 --> 01:09:15,260
[教授]这是一种排列 是吧？（？）

769
01:09:18,340 --> 01:09:24,150
差不多 但具体是多少呢？

770
01:09:24,570 --> 01:09:26,980
那是问题所在

771
01:09:27,250 --> 01:09:30,420
你不会撞上同一个槽

772
01:09:31,660 --> 01:09:33,470
因为这是一个排列

773
01:09:35,100 --> 01:09:41,430
完全正确 (n-1)/(m-1)

774
01:09:41,810 --> 01:09:43,670
因为现在

775
01:09:43,860 --> 01:09:47,660
我已经把第一次发生碰撞的槽 给排除掉了

776
01:09:47,820 --> 01:09:51,790
那现在 我们已经和一个键碰撞过了

777
01:09:51,950 --> 01:09:55,330
那其他的n-1个键

778
01:09:55,470 --> 01:09:57,810
就随机地分布在

779
01:09:58,000 --> 01:10:03,670
剩下的m-1个槽里

780
01:10:04,820 --> 01:10:06,040
大家都理解了？

781
01:10:06,460 --> 01:10:09,080
按照这样的概率 发生了碰撞

782
01:10:10,010 --> 01:10:15,620
那意味着我们需要第三次探查

783
01:10:16,550 --> 01:10:21,620
那照这样下去 下一次的碰撞概率是多少？

784
01:10:25,380 --> 01:10:28,200
对  它变成(n-2)/(m-2)

785
01:10:29,450 --> 01:10:37,650
我们注意到(n-i)/(m-i)

786
01:10:38,020 --> 01:10:52,260
小于n/m 也就是小于α

787
01:10:53,010 --> 01:10:59,330
至于为什么 (n-i)/(m-i) < n/m

788
01:10:59,430 --> 01:11:03,730
你可以这样理解

789
01:11:03,820 --> 01:11:08,730
如果n < m，虽然同样是减去i

790
01:11:09,830 --> 01:11:14,700
但是n减少的比例 却比m减少的比例要多

791
01:11:15,970 --> 01:11:18,870
因此 (n-i)/(m-i)

792
01:11:18,970 --> 01:11:20,520
就会比n/m小

793
01:11:22,230 --> 01:11:24,230
你也可以尝试下做一下代数运算

794
01:11:24,890 --> 01:11:26,480
我认为当你思考问题或

795
01:11:26,570 --> 01:11:32,350
进行数量运算时 代数分析总是有帮助的

796
01:11:34,650 --> 01:11:36,360
它会定性同时也定量地让你理解所发生的事

797
01:11:38,320 --> 01:11:47,320
那预期探查数就是...

798
01:11:50,650 --> 01:11:55,490
会等于...

799
01:11:55,610 --> 01:11:56,910
因为我们需要点空间 所以

800
01:11:57,000 --> 01:12:00,710
必须是1 因为要有第一次探查

801
01:12:00,850 --> 01:12:04,350
加上概率n/m

802
01:12:04,650 --> 01:12:12,270
还需要一次探查 加上概率(n-1)/(m-1)

803
01:12:13,420 --> 01:12:16,000
继续另外一个探查...

804
01:12:24,710 --> 01:12:30,320
直到1+1/(m-n)

805
01:12:39,050 --> 01:12:43,040
每一步都有连锁的影响

806
01:12:43,350 --> 01:12:45,350
课本里有使用指标随机变量

807
01:12:45,350 --> 01:12:47,150
来做的更严谨的证明

808
01:12:47,390 --> 01:12:50,090
我这里给出的是简单的版本

809
01:12:54,200 --> 01:12:57,610
这是第一次探查

810
01:12:57,990 --> 01:13:00,440
我有n/m的概率 要进行第二次探查

811
01:13:00,690 --> 01:13:02,190
而这一次探查的结果是

812
01:13:02,320 --> 01:13:05,940
有(n-1)/(m-1)的概率 必须进行下一步探查

813
01:13:07,150 --> 01:13:10,810
然后 我又有(n-2)/(m-2)的概率发生碰撞

814
01:13:10,890 --> 01:13:12,610
必须再进行下一个探查 以此类推

815
01:13:13,520 --> 01:13:15,570
这就是我最后要探查的次数

816
01:13:17,270 --> 01:13:21,420
这条式子小于或等于

817
01:13:21,800 --> 01:13:29,700
1+α(1+α(1+α(...1+α)))...

818
01:13:34,620 --> 01:13:38,860
这要用到刚才所述的内容

819
01:13:39,250 --> 01:13:47,920
这些小于或等于1+α...我把它们乘出来

820
01:13:48,020 --> 01:13:55,200
α+1+α^2+α^3+...

821
01:13:59,250 --> 01:14:02,370
这式子能无限写下去 做为上面式子的上限

822
01:14:04,470 --> 01:14:07,440
大家都看到这些数学式了吗？

823
01:14:07,580 --> 01:14:14,330
然后全部加起来 从0到正无穷

824
01:14:14,590 --> 01:14:21,060
最终等于1/(1-α)

825
01:14:21,330 --> 01:14:26,910
用你熟悉的几何数列上限

826
01:14:32,010 --> 01:14:38,520
同样的 课本里也有成功搜索的分析

827
01:14:39,100 --> 01:14:41,140
同样的 成功搜索的分析也需要一点技巧性

828
01:14:41,370 --> 01:14:43,970
因为当要搜索的东西 已经存在于哈希表里

829
01:14:44,080 --> 01:14:51,050
你就要考虑在哈希表里...

830
01:14:51,280 --> 01:14:54,110
它的分布是怎样

831
01:14:54,340 --> 01:14:58,090
但结果依然是1/(1-α)

832
01:14:59,150 --> 01:15:01,000
好 我们看看这式子意味着什么

833
01:15:08,800 --> 01:15:12,440
如果α< 1 而且是一个常数量

834
01:15:14,000 --> 01:15:17,340
意味着需要O(1)步探查

835
01:15:22,190 --> 01:15:26,590
如果α是一个常数量 需要O(1)步探查

836
01:15:29,690 --> 01:15:33,880
但最好还是理解常数量的到底是个怎么样的状况

837
01:15:34,280 --> 01:15:42,730
举个例子 如果哈希表一半是满的 α是0.5

838
01:15:43,960 --> 01:15:51,190
从上述分析来看 预期探查数是多少?

839
01:15:53,540 --> 01:15:58,870
2次 因为1/(1-0.5)等于2

840
01:16:05,290 --> 01:16:13,830
如果哈希表填充了90%的槽 平均需要多少次探查？

841
01:16:15,670 --> 01:16:23,470
10次 所以你可以看到 随着哈希表的密度增大

842
01:16:23,680 --> 01:16:29,290
探查的时间花费会急剧地增加

843
01:16:29,680 --> 01:16:33,410
所以 一般不要让哈希表 太过稠密

844
01:16:33,640 --> 01:16:38,680
没必要要求99.9%的利用率

845
01:16:38,850 --> 01:16:41,560
虽然我有一个哈希表 利用率百分之百

846
01:16:41,890 --> 01:16:48,590
是啊 但它很慢 真的很慢很慢

847
01:16:49,950 --> 01:16:53,780
因为随着α逼近1

848
01:16:53,980 --> 01:17:02,070
运行时间会趋近m或者n

849
01:17:04,190 --> 01:17:07,380
好的 那下一节课 我们将讨论

850
01:17:07,520 --> 01:17:09,850
什么是算法里最...

851
01:17:09,950 --> 01:17:15,200
有意思的想法

852
01:17:15,300 --> 01:17:18,320
我们将讨论 如何解决以下问题：

853
01:17:18,980 --> 01:17:22,290
无论你选择何种哈希函数 总有一个不适宜的键集

854
01:17:23,500 --> 01:17:26,140
下一次我们将介绍几种非常精彩的...

855
01:17:26,240 --> 01:17:29,120
用来应对这种问题的方法

856
01:17:29,480 --> 01:17:32,950
到时会用到很多数学技巧 应该是很有意思的一节课

