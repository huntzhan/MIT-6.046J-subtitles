1
00:00:06,330 --> 00:00:12,610
我们今天来讲动态规划

2
00:00:19,800 --> 00:00:28,500
本质上来说  这里的“编程”

3
00:00:28,500 --> 00:00:32,540
并不是指实际的计算机编程

4
00:00:32,540 --> 00:00:34,640
其实  编程这个名词的本义是

5
00:00:34,640 --> 00:00:39,120
按照一定的步骤来解决问题

6
00:00:39,120 --> 00:00:41,270
你们可能已经听说过线性规划

7
00:00:41,270 --> 00:00:43,530
和动态规划

8
00:00:43,530 --> 00:00:47,240
无论哪个  尽管我们现在在编程中

9
00:00:47,240 --> 00:00:49,970
使用这些算法

10
00:00:49,970 --> 00:00:52,100
但在实际计算机编程时

11
00:00:52,100 --> 00:00:54,930
你要做的是写出一行一行的

12
00:00:54,930 --> 00:00:59,490
能够按步骤执行的代码

13
00:00:59,490 --> 00:01:02,970
这样电脑才会明白如何执行这项工作

14
00:01:02,970 --> 00:01:05,550
这里说的“编程”是以前的表达方式了

15
00:01:05,550 --> 00:01:07,520
当然  按照惯例我们说编程的时候

16
00:01:07,520 --> 00:01:09,940
指的都是电脑程序的编程

17
00:01:09,940 --> 00:01:11,500
哦  严格来说倒也不一定

18
00:01:11,500 --> 00:01:14,510
文献上说的编程还是讲它的本义

19
00:01:14,510 --> 00:01:26,750
动态规划就是一种设计的技巧

20
00:01:26,750 --> 00:01:31,600
就像我们以前讲过的分而治之法

21
00:01:31,600 --> 00:01:35,420
也就是说它是解决一类问题的方法

22
00:01:35,420 --> 00:01:40,450
而不是某种固定的算法

23
00:01:40,450 --> 00:01:47,690
我们通过一个具体的例子来学习这种方法

24
00:01:47,690 --> 00:01:58,390
就是传说中的最长公共子序列问题

25
00:01:58,390 --> 00:02:02,680
缩写是LCS【译注：后面会用LCS来代替最长公共子序列】

26
00:02:02,680 --> 00:02:05,600
这个问题在很多地方都会出现

27
00:02:05,600 --> 00:02:08,950
在计算生物学里尤为重要

28
00:02:08,950 --> 00:02:11,220
比如你想在一些DNA长链里

29
00:02:11,220 --> 00:02:14,650
找到两条链里相同的部分

30
00:02:14,650 --> 00:02:22,520
比如其中一段序列是基因组序列

31
00:02:22,520 --> 00:02:25,100
它们是用什么东西

32
00:02:25,100 --> 00:02:28,900
来表示演化过程的比较的？

33
00:02:28,900 --> 00:02:33,520
演化树  对  更准确一点的说法？

34
00:02:33,520 --> 00:02:37,200
系统发生树  很给力嘛  对  就是系统发生树

35
00:02:37,200 --> 00:02:40,680
很好  下面说一下这个问题

36
00:02:40,680 --> 00:02:49,420
给定两个序列  x是从1到m

37
00:02:49,420 --> 00:02:55,430
y从1到n

38
00:02:55,440 --> 00:03:08,570
然后找出它们的LCS

39
00:03:08,580 --> 00:03:19,850
这里要提一下  尽管在一般情况下

40
00:03:19,850 --> 00:03:23,840
我们称之为最长公共子序列

41
00:03:23,840 --> 00:03:28,680
但通常 最长公共子序列并不唯一

42
00:03:28,690 --> 00:03:30,490
可能有很多子序列

43
00:03:30,500 --> 00:03:33,140
都是最长公共子序列

44
00:03:33,150 --> 00:03:35,900
不过通常情况下

45
00:03:35,900 --> 00:03:37,900
大家都说的不太严谨

46
00:03:37,900 --> 00:03:42,230
我习惯说“之一”  除非最长公共子序列的确只有一个

47
00:03:42,230 --> 00:03:44,240
不过我也有可能说走嘴

48
00:03:44,240 --> 00:03:48,330
因为大家平时都这么说

49
00:03:48,340 --> 00:03:52,160
忽略了它可能不唯一的情况

50
00:03:52,160 --> 00:03:53,890
现在来看例子吧

51
00:03:53,890 --> 00:04:10,280
令x是这个序列  y是这个序列

52
00:04:10,280 --> 00:04:14,870
它们的LCS是什么？

53
00:04:14,870 --> 00:04:16,750
它们的LCS是什么？

54
00:04:16,750 --> 00:04:33,330
看看你们能不能直接用肉眼看出来

55
00:04:33,330 --> 00:04:34,520
AB  长度只有2吗？

56
00:04:34,530 --> 00:04:39,910
谁找到更长的了吗？大声点说出来

57
00:04:39,910 --> 00:04:59,010
BDB, BDB. BDAB, BDAB, BDAB, 还有别的吗？

58
00:04:59,020 --> 00:05:04,870
那么BDAB就是那个最长的

59
00:05:04,890 --> 00:05:15,530
有没有哪个是和它同一长度的？

60
00:05:15,540 --> 00:05:21,040
有没有和它不相上下的？

61
00:05:21,050 --> 00:05:33,450
BCAB BCAB 还有一个？

62
00:05:33,460 --> 00:05:38,560
BCBA,很好, 这些都是长度为4的

63
00:05:38,570 --> 00:05:40,760
没有长度是5的公共子序列

64
00:05:40,770 --> 00:05:43,920
好  那我们现在就用算法来证明

65
00:05:43,920 --> 00:05:46,460
我们上面目测的都是正确的

66
00:05:46,470 --> 00:05:49,970
确保真的没有长度为5的公共子序列

67
00:05:49,980 --> 00:05:53,820
对于这个几个子序列  我们可以这样说

68
00:05:53,830 --> 00:05:57,450
任意一个都是x和y的LCS

69
00:05:57,450 --> 00:06:05,040
这里我们更喜欢用函数符号来表示

70
00:06:05,050 --> 00:06:13,130
不过本质上其实是一种关系而非函数

71
00:06:13,200 --> 00:06:15,790
于是我们就把这个叫做LCS

72
00:06:15,800 --> 00:06:17,160
指的是那些LCS里其中的一个

73
00:06:17,160 --> 00:06:22,750
指的是那些LCS里其中的一个

74
00:06:22,760 --> 00:06:24,980
当然  这个表示也不是很标准的

75
00:06:24,990 --> 00:06:28,950
不过只要我们自己心里清楚  就没什么大问题

76
00:06:28,960 --> 00:06:34,760
当然别乱用符号 不过随意一点也很好嘛！

77
00:06:34,770 --> 00:06:37,310
简单点表示更利于表达

78
00:06:37,320 --> 00:06:42,430
当然前提是你清楚它的本质是什么

79
00:06:42,440 --> 00:06:48,920
那么我们继续  这个问题可以用

80
00:06:48,940 --> 00:06:55,670
穷举法来解决

81
00:06:55,680 --> 00:07:01,470
就是要检查每一个——也许你们

82
00:07:01,480 --> 00:07:10,690
刚才就是这样想的——x里从1到m的每个子序列

83
00:07:10,700 --> 00:07:29,320
然后看看y里面是不是也有一样的子序列

84
00:07:29,330 --> 00:07:34,660
就是算出这里面所有的子序列

85
00:07:34,670 --> 00:07:39,660
然后检查下面有没有

86
00:07:39,670 --> 00:07:50,550
分析一下

87
00:07:50,560 --> 00:07:59,300
对于检查这个操作  如果已知一个x的子序列

88
00:07:59,310 --> 00:08:03,140
你需要花费多少时间来确定

89
00:08:03,150 --> 00:08:06,420
是不是y的子序列

90
00:08:06,430 --> 00:08:11,770
比如我给定你BCAB这样的序列

91
00:08:11,780 --> 00:08:15,000
我需要多长时间来判断

92
00:08:15,010 --> 00:08:20,350
它是否是y的子序列？

93
00:08:20,360 --> 00:08:31,230
就是y的长度  O(n)  你是怎么知道的？

94
00:08:31,240 --> 00:08:33,220
是的  就是扫描一遍

95
00:08:33,230 --> 00:08:37,080
如果发现第一个相同的字符

96
00:08:37,090 --> 00:08:39,650
那就按x和y的下标开始递归

97
00:08:39,670 --> 00:08:46,600
判断x和y里对应的元素是否相同

98
00:08:46,610 --> 00:08:53,360
总而言之  就是顺着捋一遍

99
00:08:53,370 --> 00:08:54,330
看看有没有相同的

100
00:08:54,330 --> 00:08:56,500
遍历这个字符串  看看有没有相同的

101
00:08:56,510 --> 00:08:59,720
第二个问题是

102
00:08:59,730 --> 00:09:05,570
x有多少个子序列？

103
00:09:05,580 --> 00:09:08,780
2^n？

104
00:09:08,790 --> 00:09:16,310
x是从1到m  也就是说x的子序列有2^m个

105
00:09:16,320 --> 00:09:18,110
嗯  2^m

106
00:09:18,120 --> 00:09:24,280
x的子序列有2^m个

107
00:09:24,290 --> 00:09:27,620
有一种方法来计算

108
00:09:27,630 --> 00:09:29,950
某个序列的子序列有多少个

109
00:09:29,960 --> 00:09:34,700
考虑一个长度为m的“位向量”

110
00:09:34,710 --> 00:09:36,190
每个位上只可能是0或者1

111
00:09:36,200 --> 00:09:39,710
如果有一个元素被标记为1

112
00:09:39,730 --> 00:09:44,210
那就表示这个元素被我放进了子序列里

113
00:09:44,220 --> 00:09:53,920
这样我就可以得到一个映射  每个x的子序列

114
00:09:53,940 --> 00:09:57,630
都对应了一个相应的位向量

115
00:09:57,640 --> 00:10:00,030
当然  有的子序列的字符可能是相同的

116
00:10:00,040 --> 00:10:04,010
不过在最坏情况下  所有的字符都是不一样的

117
00:10:04,020 --> 00:10:09,440
那样每个子序列都是不同的

118
00:10:09,450 --> 00:10:25,470
所以每个长为m的位向量 都对应了一个子序列

119
00:10:25,490 --> 00:10:28,010
总体的思想就是这样

120
00:10:28,020 --> 00:10:34,870
于是这个方法在最坏条件下的运行时间

121
00:10:34,880 --> 00:10:41,220
就是O(n·2^m)  也就是说

122
00:10:41,230 --> 00:10:49,270
由于m在指数位上  运行时间也就是指数阶的

123
00:10:49,280 --> 00:10:51,120
我们可以用一个术语

124
00:10:51,130 --> 00:10:55,240
描述指数阶时间

125
00:10:55,250 --> 00:11:02,200
龟速  好吧  嗯  挺好

126
00:11:02,210 --> 00:11:09,970
对  就叫龟速  这是很糟糕的情况

127
00:11:09,970 --> 00:11:12,860
这样做需要花费相当长的时间

128
00:11:12,860 --> 00:11:16,740
才能算出最长公共子序列的长度

129
00:11:16,740 --> 00:11:20,140
因为子序列实在是太多了

130
00:11:20,140 --> 00:11:24,040
那么我们现在需要设计

131
00:11:24,040 --> 00:11:28,710
一种更给力的算法来解决这个问题

132
00:11:28,710 --> 00:11:32,720
可以分为几个步骤

133
00:11:32,720 --> 00:11:40,370
第一步是进行简化

134
00:11:40,370 --> 00:11:47,650
我们来分别看看

135
00:11:47,650 --> 00:11:57,900
x和y的LCS有多长

136
00:11:57,910 --> 00:12:05,900
我们要做的就是扩展这个算法

137
00:12:05,910 --> 00:12:13,690
使之能够找到最长公共子序列

138
00:12:13,700 --> 00:12:15,880
我们从序列的长度入手

139
00:12:15,900 --> 00:12:17,910
那么先试着简化计算

140
00:12:17,920 --> 00:12:19,340
LCS长度这个问题

141
00:12:19,350 --> 00:12:23,220
令人愉快的是  这个长度是唯一的

142
00:12:23,230 --> 00:12:26,160
所谓的最大长度

143
00:12:26,180 --> 00:12:28,440
有且仅有一个

144
00:12:28,450 --> 00:12:30,900
于是我们现在要做的就是

145
00:12:30,910 --> 00:12:33,210
如何计算LCS的长度

146
00:12:33,220 --> 00:12:36,430
然后我们再回过头来看看

147
00:12:36,430 --> 00:12:40,920
哪个公共子区间达到了这个长度

148
00:12:40,920 --> 00:12:44,450
这样做就简化了很多

149
00:12:44,450 --> 00:12:46,690
因为我们无需在意其它的可能性

150
00:12:46,690 --> 00:12:48,900
我们要做的就是记录

151
00:12:48,900 --> 00:12:51,130
一个最大长度的数值

152
00:12:51,130 --> 00:12:54,440
这样就把它简化成了一个数值问题

153
00:12:54,440 --> 00:12:58,000
我们会用到这样的符号

154
00:12:58,000 --> 00:12:59,870
这个符号很常见  不过在这里——

155
00:12:59,870 --> 00:13:07,100
如果我对一个序列加了绝对值符号

156
00:13:07,100 --> 00:13:13,880
它表示的是这个序列的长度  S

157
00:13:13,880 --> 00:13:21,050
嗯  这是第一点  接下来我们要做的

158
00:13:21,050 --> 00:13:23,610
我们要做的——

159
00:13:23,610 --> 00:13:26,380
对付这样的问题需要你的优化意识

160
00:13:26,380 --> 00:13:30,180
从某种意义上来说

161
00:13:30,180 --> 00:13:40,180
要设计一个优秀的动态规划算法

162
00:13:40,220 --> 00:13:45,210
意识才是最重要的

163
00:13:45,240 --> 00:13:52,280
这样我们就不用考虑x和y的所有子序列了

164
00:13:52,320 --> 00:14:04,390
而只是它们的前缀

165
00:14:04,420 --> 00:14:07,070
我们要做的只是考量它们的前缀

166
00:14:07,070 --> 00:14:12,240
以及如何用这些前缀来描述

167
00:14:12,240 --> 00:14:18,560
它们自己的LCS长度

168
00:14:18,590 --> 00:14:26,580
特别的  我们定义c[i,j]

169
00:14:26,610 --> 00:14:30,700
来记录x和y的LCS长度

170
00:14:30,740 --> 00:14:36,390
x的前缀是从1到i的

171
00:14:36,460 --> 00:14:41,790
y的前缀则是从1到j

172
00:14:41,790 --> 00:14:44,820
之后我们要做的就是

173
00:14:44,860 --> 00:14:52,570
算出这些个c[i,j]

174
00:14:52,600 --> 00:15:01,700
如果这个完成了之后  那接下来如何

175
00:15:01,730 --> 00:15:13,670
算出x和y的最长公共子序列？

176
00:15:13,700 --> 00:15:16,130
LCS问题要怎么解？

177
00:15:16,170 --> 00:15:22,280
在我已经解出了c[i,j]的前提下

178
00:15:22,310 --> 00:15:25,590
如何计算x和y的LCS长度的？

179
00:15:25,620 --> 00:15:31,240
嗯  c[m,n]

180
00:15:31,270 --> 00:15:36,650
这就是结果对吧？所以  c[m,n]

181
00:15:36,680 --> 00:15:43,090
就等于x和y的的LCS

182
00:15:43,120 --> 00:15:52,850
因为下标从1到m再从1到n  就都走过一遍了

183
00:15:52,880 --> 00:15:57,130
那么  我们要做的已经明确了

184
00:15:57,160 --> 00:16:03,930
就是找到c[m,n]的归纳式  更一般地说

185
00:16:03,960 --> 00:16:06,700
用其它的c[i,j]来表示c[i,j]

186
00:16:06,730 --> 00:16:16,120
来一起看看这是怎么算的

187
00:16:16,150 --> 00:17:03,460
于是按照这个公式  c[i,j]就等于——

188
00:17:03,490 --> 00:17:07,400
意思就是如果x的第i个字符

189
00:17:07,430 --> 00:17:11,760
和y的第j个字符相等

190
00:17:11,790 --> 00:17:14,650
那么c[i,j]就等于

191
00:17:14,650 --> 00:17:18,570
c[i-1,j-1]+1

192
00:17:18,580 --> 00:17:20,070
如果它们不相等

193
00:17:20,100 --> 00:17:23,210
那c[i,j]就等于c[i,j-1]和c[i-1,j]中

194
00:17:23,210 --> 00:17:33,580
比较大的那一个

195
00:17:33,620 --> 00:17:35,420
我们将要证明它

196
00:17:35,450 --> 00:17:39,480
这个公式告诉我们  对于给定的c[i,j]

197
00:17:39,560 --> 00:17:49,320
它的值是由两个严格小于它的值决定的

198
00:17:49,360 --> 00:17:55,560
这里面肯定有一个是比较小的

199
00:17:55,560 --> 00:17:56,500
这样我们就知道

200
00:17:56,530 --> 00:18:06,500
如何理解c[i,j]的计算过程

201
00:18:06,500 --> 00:18:12,070
我们就来证明这个

202
00:18:12,070 --> 00:18:19,570
从x[i]=y[j]的情况开始

203
00:18:19,600 --> 00:18:23,280
我们来画个图

204
00:18:23,320 --> 00:18:48,530
这个是x

205
00:18:48,560 --> 00:19:14,550
这个是y

206
00:19:14,580 --> 00:19:17,780
这个是序列x  就是这个

207
00:19:17,810 --> 00:19:22,310
长长的条形框  下面的是序列y

208
00:19:22,310 --> 00:19:39,280
当x[i]和y[j]相等的时候

209
00:19:39,280 --> 00:19:46,230
来看一下这是什么意思

210
00:19:46,260 --> 00:19:57,840
令最长公共子序列z[1..k]

211
00:19:57,880 --> 00:20:10,710
等于LCS(x[1..i], y[1..j])

212
00:20:10,740 --> 00:20:21,170
当c[i,j]=k的时候. 这样的话

213
00:20:21,200 --> 00:20:29,050
x[1..i], y[1..j]的最长公共子序列

214
00:20:29,090 --> 00:20:31,670
就等于这个k值

215
00:20:31,710 --> 00:20:36,070
然后我们假设有一个序列达到了这个长度

216
00:20:36,100 --> 00:20:44,160
我们称其为z

217
00:20:44,190 --> 00:21:02,470
那谁来说说z[k]是什么东西？

218
00:21:02,500 --> 00:21:12,380
这里的z[k]是指什么？

219
00:21:12,420 --> 00:21:16,120
是的  其实就等于x[i]  同时也等于y[j]

220
00:21:16,150 --> 00:21:19,620
为什么是这样的？

221
00:21:19,650 --> 00:21:39,430
为什么不等于别的值？

222
00:21:39,460 --> 00:21:42,600
很好  看来你们找到要领了

223
00:21:42,630 --> 00:21:47,440
其实就是说  如果z这个序列

224
00:21:47,480 --> 00:21:51,860
不包含最后面的这个元素

225
00:21:51,870 --> 00:21:55,880
也就是假设LCS里没有这两个字符

226
00:21:55,890 --> 00:21:58,050
而在这两个序列里的前面的这些字符都是相等的

227
00:21:58,080 --> 00:22:02,720
只是不包含后面这两个字符

228
00:22:02,720 --> 00:22:07,990
那么我就可以向这个LCS中添加这个字符

229
00:22:07,990 --> 00:22:11,610
使其长度增加  长度变成k+1

230
00:22:11,650 --> 00:22:15,540
因为最后这两个也是相等的

231
00:22:15,540 --> 00:22:32,630
也就是说如果这个LCS还没到x[i]

232
00:22:32,660 --> 00:22:39,630
那么在上面加个x[i]就可以让它更长了

233
00:22:39,660 --> 00:22:47,930
加个x[i]不费吹灰之力嘛

234
00:22:47,960 --> 00:22:53,020
那么接下来

235
00:22:53,020 --> 00:23:02,020
对于z[1..k-1]这个序列

236
00:23:02,020 --> 00:23:05,160
显然它就是

237
00:23:05,180 --> 00:23:13,050
x[1..i-1]和y[1..j-1]的

238
00:23:13,090 --> 00:23:25,270
最长公共子序列

239
00:23:25,310 --> 00:23:28,940
因为我们已经知道了这是一个最长公共子序列

240
00:23:28,940 --> 00:23:31,350
z[1..k]是x[1..i]和y[1..j]

241
00:23:31,350 --> 00:23:35,390
最长公共子序列

242
00:23:35,390 --> 00:23:37,580
我们已经知道了最后的那个字符是什么

243
00:23:37,580 --> 00:23:41,030
它就是x[i]  也等于y[j]

244
00:23:41,030 --> 00:23:44,530
因此  除了最后的那个字符

245
00:23:44,530 --> 00:23:49,280
其它的z一定是

246
00:23:49,280 --> 00:23:56,000
x[1..i-1]和y[1..j-1]的一个公共序列

247
00:23:56,000 --> 00:23:59,410
都跟上了吧？它一定是一个公共序列

248
00:23:59,410 --> 00:24:09,550
你们还能想到些什么？

249
00:24:09,550 --> 00:24:15,210
你们感觉z[1..k-1]还有点什么猫腻？

250
00:24:15,210 --> 00:24:19,940
它是这两个的公共序列  对吧？

251
00:24:19,940 --> 00:24:24,490
很好  它还是最长公共子序列

252
00:24:24,490 --> 00:24:33,950
我要说的就是这个命题  z[1..k-1]

253
00:24:33,950 --> 00:24:42,250
其实就是x[1..i-1]和y[1..j-1]的

254
00:24:42,250 --> 00:24:54,450
最长公共子序列

255
00:24:54,450 --> 00:24:57,360
下面我们来证明这个命题。

256
00:24:57,360 --> 00:25:02,260
要证明这个得绕点弯

257
00:25:02,260 --> 00:25:17,010
假设w是一个更长的公共子序列

258
00:25:17,160 --> 00:25:29,560
这也就是说w的长度要比k-1大

259
00:25:29,590 --> 00:25:33,830
如果存在一个公共子序列的长度

260
00:25:33,860 --> 00:25:35,930
比z[1..k-1]长

261
00:25:35,930 --> 00:25:37,000
那么这个子序列的长度

262
00:25:37,020 --> 00:25:40,140
就要大于k-1

263
00:25:40,170 --> 00:25:44,240
接下来我们要用到一个很经典的方法

264
00:25:44,270 --> 00:25:47,920
你们将不止一次地遇见它  不仅仅是这周

265
00:25:47,950 --> 00:25:49,570
对于这周的内容它至关重要

266
00:25:49,600 --> 00:25:53,000
而且后面的课还会提到它

267
00:25:53,030 --> 00:26:00,040
总之  它的名字是“剪贴”法

268
00:26:00,070 --> 00:26:05,070
这个方法就是把w拿出来

269
00:26:05,100 --> 00:26:12,440
把那个最后面的字符z[k]连结在后面

270
00:26:12,440 --> 00:26:25,410
把它们接在一起  连结

271
00:26:25,410 --> 00:26:27,700
连结就是接上的术语表示

272
00:26:29,170 --> 00:26:31,840
我可以取一个

273
00:26:31,870 --> 00:26:34,900
更长的公共子序列

274
00:26:34,930 --> 00:26:42,480
然后把z[k]和它进行连结

275
00:26:42,510 --> 00:26:50,000
这个连结后的序列一定是

276
00:26:50,020 --> 00:27:09,690
x[1..i]和y[1..j]的一个公共子序列

277
00:27:09,690 --> 00:27:20,960
它的长度一定大于k  因为——

278
00:27:20,960 --> 00:27:23,870
它的长度是多少？

279
00:27:23,870 --> 00:27:27,390
w的长度就已经比k-1大了

280
00:27:27,420 --> 00:27:29,240
在这之上我又加了一个字符

281
00:27:29,270 --> 00:27:34,980
这里我们进行了合并  合并后的序列长度就大于k了

282
00:27:35,010 --> 00:27:47,980
于是导出了矛盾  假设不成立  原命题得证

283
00:27:48,010 --> 00:27:51,560
简单来说就是  我假设

284
00:27:51,590 --> 00:27:54,790
有一个比更长的公共子序列  也就是说

285
00:27:54,820 --> 00:28:01,120
如果两个拿掉了末字符的前缀

286
00:28:01,150 --> 00:28:03,900
它们的一个公共子序列

287
00:28:03,930 --> 00:28:06,550
已经比k-1大了

288
00:28:06,580 --> 00:28:09,820
这样就会使总体的LCS变大

289
00:28:09,840 --> 00:28:12,080
而这当然是不可能的

290
00:28:12,080 --> 00:28:20,490
所以这个拼成的序列一定是一个LCS  对吧

291
00:28:20,520 --> 00:28:28,520
有问题没？因为你们需要学会

292
00:28:28,550 --> 00:28:34,600
这种苦逼的证明方式

293
00:28:34,630 --> 00:28:43,080
所以如果有任何问题  直接告诉我就好

294
00:28:43,110 --> 00:28:49,420
我们现在已经得到了

295
00:28:49,440 --> 00:28:56,560
z[1..k]是去掉末字符的两个前缀的

296
00:28:56,590 --> 00:28:59,420
最长公共子序列

297
00:28:59,450 --> 00:29:04,560
这样的话  我们可以算出

298
00:29:04,590 --> 00:29:14,130
c[i-1,j-1]等于多少？

299
00:29:14,160 --> 00:29:28,230
c[i-1,j-1]是多少？

300
00:29:28,260 --> 00:29:29,800
k-1.很好

301
00:29:29,830 --> 00:29:31,900
我们来继续吧

302
00:29:31,930 --> 00:29:43,800
这说明c[i,j]就等于

303
00:29:43,990 --> 00:29:55,750
c[i-1,j-1]+1

304
00:29:55,780 --> 00:29:58,180
刚才讲的这些

305
00:29:58,210 --> 00:29:59,500
都比较直观

306
00:29:59,530 --> 00:30:02,660
其它的一些些LCS问题

307
00:30:02,690 --> 00:30:05,110
可能并没有这么一目了然

308
00:30:05,140 --> 00:30:11,970
我们要讲的是——其它情形我就不赘述了

309
00:30:12,000 --> 00:30:20,490
证明过程都差不多

310
00:30:20,520 --> 00:30:22,910
其实我们刚才讲的就是

311
00:30:22,940 --> 00:30:26,750
动态规划的两个特征之一

312
00:30:26,780 --> 00:30:27,580
特征的意思

313
00:30:27,610 --> 00:30:32,610
就是当你遇到这种结构的问题时

314
00:30:32,640 --> 00:30:34,970
十有八九是可以用动态规划

315
00:30:35,000 --> 00:30:38,960
来解决的

316
00:30:38,990 --> 00:30:55,640
下面说的就是动态规划的特征

317
00:30:55,670 --> 00:30:59,600
下面来讲第一条

318
00:30:59,630 --> 00:31:13,050
这也是最优子结构的性质

319
00:31:13,080 --> 00:31:23,840
意思是问题的一个最优解——

320
00:31:23,870 --> 00:31:25,880
问题是指实际的问题实例

321
00:31:25,910 --> 00:31:29,610
不过一直称为“问题实例”又太文绉绉

322
00:31:29,640 --> 00:31:32,160
计算机领域中所说的问题

323
00:31:32,200 --> 00:31:38,800
实际上是有无数种不同的实例

324
00:31:38,830 --> 00:31:42,890
比如排序就是一个问题

325
00:31:42,920 --> 00:31:46,130
一个排序的实例就是一个特别的输入

326
00:31:46,160 --> 00:31:48,540
所以我们要处理的都是问题实例

327
00:31:48,570 --> 00:31:52,470
不过口头上我就叫它“问题”了

328
00:31:52,500 --> 00:31:56,700
那么  如果一个问题的最优解

329
00:31:56,730 --> 00:32:11,120
包含了子问题的最优解

330
00:32:11,150 --> 00:32:15,170
这里应该框起来

331
00:32:15,200 --> 00:32:19,250
因为实在很重要

332
00:32:19,280 --> 00:32:21,870
所以  比如说

333
00:32:21,900 --> 00:32:30,970
z是x和y的LCS

334
00:32:31,000 --> 00:32:48,860
那么任何z的前缀都是某个x的前缀

335
00:32:48,890 --> 00:33:07,720
和某个y的前缀的LCS  对吧

336
00:33:07,750 --> 00:33:09,130
嗯  就是这个意思

337
00:33:09,160 --> 00:33:12,250
当我拿到这个问题  我发现了

338
00:33:12,280 --> 00:33:17,780
里面存在最优子结构

339
00:33:17,810 --> 00:33:22,450
在这种结构下你总是能够——

340
00:33:22,490 --> 00:33:24,190
在上面应用

341
00:33:24,220 --> 00:33:27,750
剪贴法来做出证明

342
00:33:27,780 --> 00:33:33,150
证明如果子问题的解不是最优的

343
00:33:33,180 --> 00:33:39,260
那么用剪贴法你总能找到

344
00:33:39,290 --> 00:33:49,800
一个全局最优解

345
00:33:49,830 --> 00:33:56,950
根据这个定理  我们可以来

346
00:33:56,980 --> 00:34:21,900
计算LCS问题了

347
00:34:21,930 --> 00:34:37,000
这里是代码——稍等

348
00:34:37,030 --> 00:34:40,150
那就先忽略这里的初始值

349
00:35:42,400 --> 00:35:53,200
返回值就是LCS的长度

350
00:35:53,230 --> 00:35:59,090
本质上就是应用前面的那个定理

351
00:35:59,120 --> 00:36:04,380
它有可能就是LCS  如果x[i]和y[j]

352
00:36:04,410 --> 00:36:07,160
是相等的

353
00:36:07,190 --> 00:36:09,700
这时它就等于它的一个前缀+1

354
00:36:09,730 --> 00:36:13,840
这个前缀是去掉末尾字符之后的LCS

355
00:36:13,870 --> 00:36:17,630
+1是因为去掉的那个字符就是相等的

356
00:36:17,660 --> 00:36:20,960
如果x[i]和y[j]不等  那么在x末尾去掉一个字符

357
00:36:20,990 --> 00:36:23,960
它就等于这个玩意的LCS

358
00:36:23,990 --> 00:36:26,410
或者是y末尾去掉一个字符

359
00:36:26,440 --> 00:36:29,000
这两个取最大值

360
00:36:29,030 --> 00:36:36,850
得到的那个就是LCS

361
00:36:36,880 --> 00:36:51,060
这个程序的最坏情况是什么？

362
00:36:51,090 --> 00:36:52,970
最坏情况下会发生什么？

363
00:36:53,000 --> 00:37:06,480
这两种情况中的哪种更令我不爽？

364
00:37:06,510 --> 00:37:11,560
第二种情况  为什么呢？

365
00:37:11,590 --> 00:37:14,640
说得对  这里要进行两次LCS子问题的计算

366
00:37:14,670 --> 00:37:15,310
而这种情况下你只会计算一次

367
00:37:15,340 --> 00:37:19,760
还不止这样  上面那种情况两个下标都减少1

368
00:37:19,780 --> 00:37:23,530
而下面这种情况

369
00:37:23,560 --> 00:37:25,410
每次只有一个下标会减少

370
00:37:25,440 --> 00:37:27,150
然后还得把这两个都算一次

371
00:37:27,180 --> 00:37:29,440
这个过程是一个树

372
00:37:29,470 --> 00:37:32,280
所以最糟的情况就是

373
00:37:32,310 --> 00:37:42,440
对于所有的i,j  x[i]不等于x[j]【译注：此处应为x[i]不等于y[j]】

374
00:37:42,470 --> 00:37:48,500
我们来画一个这个程序的递归树

375
00:37:48,530 --> 00:38:00,310
来理解一下它是如何工作的

376
00:38:00,340 --> 00:38:03,700
我给定m=7

377
00:38:03,730 --> 00:38:07,850
n=6

378
00:38:07,880 --> 00:38:10,450
我们从上面开始

379
00:38:10,480 --> 00:38:14,430
下标是7,6

380
00:38:14,460 --> 00:38:18,180
在最坏情况下  我们要执行的是这些

381
00:38:18,210 --> 00:38:23,470
所以这边是6,6  那边是7,5

382
00:38:23,500 --> 00:38:31,290
这是第一层递归

383
00:38:31,350 --> 00:38:33,510
然后这边继续分成两支

384
00:38:33,540 --> 00:38:37,650
这边是5,6

385
00:38:37,680 --> 00:38:40,710
下标i 减一得到的

386
00:38:40,740 --> 00:38:42,700
这边继续分下去

387
00:38:42,730 --> 00:38:47,570
得到4,6和5,5

388
00:38:47,600 --> 00:38:50,790
这边也会延伸下去

389
00:38:50,810 --> 00:39:01,260
得到6,5 5,5 6,4

390
00:39:01,290 --> 00:39:07,960
再算这边  第一个下标减一

391
00:39:07,990 --> 00:39:15,230
6,5 它下面是5,5 6,4

392
00:39:15,260 --> 00:39:18,000
一直下去  再到这边

393
00:39:18,030 --> 00:39:24,610
得到7,4  然后是6,4

394
00:39:24,640 --> 00:39:28,650
7,3  下面继续分

395
00:39:28,670 --> 00:39:31,950
好的  我们把这棵树画出来了

396
00:39:31,980 --> 00:39:39,930
这个树的高度是多少？

397
00:39:39,960 --> 00:39:42,800
不是指这个情况下的具体数值

398
00:39:42,820 --> 00:39:46,630
而是用m和n来表示

399
00:39:46,660 --> 00:39:49,790
树的高度是多少？

400
00:39:49,820 --> 00:39:54,620
是m和n的最大值？你说得也对

401
00:39:54,620 --> 00:40:06,920
它和最大值是同阶的  不过不是最大值

402
00:40:06,950 --> 00:40:08,630
这最大值应该是

403
00:40:08,660 --> 00:40:16,370
照你说的应该是7

404
00:40:16,400 --> 00:40:18,520
不过这里差不多可以目测

405
00:40:18,550 --> 00:40:23,560
从这条路径下来

406
00:40:23,590 --> 00:40:28,160
只经过了三层  减少了——m加n

407
00:40:28,180 --> 00:40:30,580
很好  不错  m加n

408
00:40:30,600 --> 00:40:34,330
这个高度是m加n

409
00:40:34,360 --> 00:40:39,080
它是二分的

410
00:40:39,120 --> 00:40:48,330
所以它的高度说明运算量

411
00:40:48,360 --> 00:40:55,170
是m+n的指数阶

412
00:40:55,200 --> 00:40:59,380
和穷举法相比  这个算法要更好吗

413
00:40:59,400 --> 00:41:00,540
其实不然

414
00:41:00,570 --> 00:41:05,960
我们对它的评价就是——龟速

415
00:41:05,990 --> 00:41:09,530
我们都爱速度

416
00:41:09,560 --> 00:41:13,780
我们都渴望奔驰的感觉

417
00:41:13,780 --> 00:41:16,780
不过我想你们肯定已经察觉到

418
00:41:16,810 --> 00:41:21,710
这个树有些很奇妙的特性

419
00:41:21,760 --> 00:41:28,010
是的  有很多运算是重复的

420
00:41:28,040 --> 00:41:29,760
是的  重复的运算有很多

421
00:41:29,790 --> 00:41:33,010
尤其是这里  这里的整个子树

422
00:41:33,040 --> 00:41:38,760
还有这边的子树  它们是完全一样的

423
00:41:38,790 --> 00:41:40,620
它们都是一样的子树

424
00:41:40,620 --> 00:41:49,600
也就是你要解决的相同子问题

425
00:41:49,620 --> 00:41:51,600
这里也可以看到

426
00:41:51,630 --> 00:41:55,140
这个地方的这个子树就等于

427
00:41:55,160 --> 00:41:57,500
这边这个子树

428
00:41:57,530 --> 00:42:04,860
所以说重复的运算有很多

429
00:42:04,890 --> 00:42:09,050
要注意  如果你想快速完成工作

430
00:42:09,080 --> 00:42:13,410
那就不要做重复的工作

431
00:42:13,440 --> 00:42:16,820
好的  不要一直做重复的事情

432
00:42:16,850 --> 00:42:18,940
所以当你发现你在做重复的事

433
00:42:18,970 --> 00:42:23,500
去找找能不再重复它的方法

434
00:42:23,530 --> 00:42:47,940
于是  接下来动态规划的第二个特征就闪亮登场了

435
00:42:47,970 --> 00:43:03,260
这个特征叫做重叠子问题

436
00:43:03,300 --> 00:43:16,720
一个递归的过程包含

437
00:43:16,740 --> 00:43:32,410
很多  抱歉  是少数

438
00:43:32,440 --> 00:43:48,610
独立的子问题被反复计算了多次

439
00:43:48,640 --> 00:43:54,650
我又要把这个地方框起来了  因为的确很重要

440
00:43:54,680 --> 00:43:56,890
我不怎么喜欢框

441
00:43:56,920 --> 00:43:59,100
也许我应该多用框

442
00:43:59,130 --> 00:44:01,780
毫无疑问这里应该用框

443
00:44:01,810 --> 00:44:08,180
比如说  这有一个递归

444
00:44:08,210 --> 00:44:12,150
这是个指数阶的树

445
00:44:12,170 --> 00:44:18,000
高度是2^(m+n)

446
00:44:18,030 --> 00:44:21,830
应该是总的问题数

447
00:44:21,850 --> 00:44:23,540
我是想说的是这个意思

448
00:44:23,570 --> 00:44:32,280
那么有多少独立的子问题？ m乘n  对吧？

449
00:44:32,310 --> 00:44:44,580
那么LCS问题的子问题空间

450
00:44:44,610 --> 00:44:58,120
包含了m乘n个独立的子问题

451
00:44:58,150 --> 00:45:04,750
这个数字显得微不足道

452
00:45:04,790 --> 00:45:08,940
相比较于2^(m+n)或者2^n

453
00:45:08,970 --> 00:45:10,360
或者2^m神马的

454
00:45:10,390 --> 00:45:14,520
总之这个数很小

455
00:45:14,550 --> 00:45:19,000
因为在每个子问题中

456
00:45:19,030 --> 00:45:22,160
这个数是由i和j来表示的

457
00:45:22,190 --> 00:45:24,880
i是从1到m

458
00:45:24,910 --> 00:45:29,630
j从1到n

459
00:45:29,660 --> 00:45:32,190
实际的数字没有看起来那么多

460
00:45:32,210 --> 00:45:34,690
只是它们俩的乘积

461
00:45:34,720 --> 00:45:37,620
这是一个改进版的算法

462
00:45:37,650 --> 00:45:41,080
是个解决问题的好办法

463
00:45:41,110 --> 00:45:54,360
这个算法叫做备忘法

464
00:45:54,390 --> 00:46:04,940
注意  这是备忘法而不是记忆法

465
00:46:04,970 --> 00:46:08,270
你要做的就是在计算子问题的时候

466
00:46:08,300 --> 00:46:11,090
用备忘的方式记录一下

467
00:46:11,120 --> 00:46:14,180
做备忘的意思就是我已经算完了

468
00:46:14,210 --> 00:46:17,360
如果你需要这个值的时候 就不用重新算一次

469
00:46:17,400 --> 00:46:18,850
你可以微微一笑

470
00:46:18,880 --> 00:46:22,510
然后说：我已经做过了  结果在这呢

471
00:46:22,540 --> 00:46:25,850
好的  这是它的代码

472
00:46:25,880 --> 00:46:36,380
和那个代码很像

473
00:46:36,410 --> 00:46:39,440
其实就是把c[i,j]存成一个表

474
00:46:39,460 --> 00:46:44,650
我们要做的就是判断

475
00:46:44,650 --> 00:46:48,590
如果c[i,j]是空的

476
00:46:48,610 --> 00:46:52,400
也就是说它还没被算过  于是我们把它算出来

477
00:46:52,420 --> 00:46:53,530
然后呢  怎么算出来的？

478
00:46:53,560 --> 00:47:32,820
就是我们做过的

479
00:47:32,850 --> 00:47:36,390
所有的这部分

480
00:47:36,420 --> 00:47:40,480
就是我们做过的那些

481
00:47:40,510 --> 00:47:46,240
完全相同

482
00:47:46,260 --> 00:47:58,030
然后  我们就返回c[i,j]

483
00:47:58,050 --> 00:48:02,050
这时我们不用管重复计算的事了

484
00:48:02,070 --> 00:48:05,040
如果是空的  那么我们就进行计算

485
00:48:05,070 --> 00:48:09,600
否则  返回它就行了

486
00:48:09,620 --> 00:48:11,820
没算过  就去算

487
00:48:11,990 --> 00:48:16,790
算过了  就返回

488
00:48:16,820 --> 00:48:20,510
相当明了的代码

489
00:48:20,540 --> 00:48:31,830
好的

490
00:48:31,860 --> 00:48:36,110
有意思的问题是 我们要花多长时间

491
00:48:36,110 --> 00:48:56,260
来执行它

492
00:48:56,290 --> 00:49:02,820
需要开动一下脑筋

493
00:49:02,850 --> 00:49:11,840
嗯？是的  花费是O(mn)

494
00:49:11,870 --> 00:49:23,340
这是为什么？

495
00:49:23,340 --> 00:49:25,360
是的  我得调用c[i,j]

496
00:49:25,390 --> 00:49:27,840
我可能会调用c[i,j]好多次

497
00:49:27,870 --> 00:49:28,810
这样做的话

498
00:49:28,840 --> 00:49:37,170
我还是在递归地调用它

499
00:49:37,190 --> 00:49:43,250
所以你不得不这样  每个递归调用

500
00:49:43,280 --> 00:49:45,920
都按最坏情况算的话

501
00:49:45,940 --> 00:49:54,160
就是找这两个的最大值

502
00:49:54,190 --> 00:49:55,120
这就包括了

503
00:49:55,150 --> 00:49:58,290
一次递归调用  一次查找

504
00:49:58,320 --> 00:50:08,050
计算这个要花费相当大的代价

505
00:50:08,080 --> 00:50:10,350
你说得对  直觉很对

506
00:50:10,380 --> 00:50:12,620
我们来看看如何得到更精确的证明

507
00:50:12,650 --> 00:50:18,610
为什么这个花费O(mn)

508
00:50:18,630 --> 00:50:19,920
这是在做什么？

509
00:50:19,920 --> 00:50:21,840
并不是说每次的调用

510
00:50:21,870 --> 00:50:23,160
花费的时间

511
00:50:23,190 --> 00:50:24,890
都是一个常数

512
00:50:24,920 --> 00:50:26,350
有时候计算量很繁重

513
00:50:26,380 --> 00:50:35,360
有时我人品爆发  直接就能返回它了

514
00:50:35,390 --> 00:50:37,730
所以你的直觉是很准确的

515
00:50:37,750 --> 00:50:39,700
相当准确  我们需要的只是一些

516
00:50:39,770 --> 00:50:47,100
更清晰有力的论述 来让大家信服

517
00:50:47,130 --> 00:51:01,460
还想试试？对了  最多是三次  没错

518
00:51:01,460 --> 00:51:04,010
这么想的确说得通

519
00:51:04,050 --> 00:51:05,630
你也可以这么想  它是一种

520
00:51:05,660 --> 00:51:08,660
按你的说法是平摊的方式

521
00:51:08,680 --> 00:51:14,070
记账方法  来看这个问题

522
00:51:14,100 --> 00:51:15,920
平摊代价是多少？

523
00:51:15,950 --> 00:51:18,350
比如说这几个调用

524
00:51:18,380 --> 00:51:21,660
当它们中的某一个

525
00:51:21,700 --> 00:51:25,150
我想让每一次的调用 都花费同样运算量

526
00:51:25,170 --> 00:51:28,020
这样我要找这里的结果时

527
00:51:28,050 --> 00:51:29,770
只要调用就好了

528
00:51:29,800 --> 00:51:33,950
某种意义上来说  这几条语句是调用的花费

529
00:51:33,980 --> 00:51:35,610
我向它们收取调用和返回的费用

530
00:51:35,640 --> 00:51:41,070
我向它们收取调用和返回的费用

531
00:51:41,100 --> 00:51:46,550
这几行还有这一行是调用花费

532
00:51:46,580 --> 00:51:54,310
然后中间这几行是c[i,j]的花费

533
00:51:54,340 --> 00:51:58,350
要注意的是 基本上每一次的调用

534
00:51:58,380 --> 00:52:03,610
其花费都是常数量的

535
00:52:03,640 --> 00:52:07,220
所以计算一个c[i,j]  平摊起来

536
00:52:07,250 --> 00:52:11,100
我也只需要常数量的运算

537
00:52:11,130 --> 00:52:15,680
我对一个c[i,j]的花费就这么多

538
00:52:15,710 --> 00:52:18,230
你可以把它看成

539
00:52:18,230 --> 00:52:22,340
用记账方法来进行平摊分析

540
00:52:22,370 --> 00:52:27,570
每个计算单元 我都收够一定的费用

541
00:52:27,600 --> 00:52:30,340
来支付这一步的操作 再加上

542
00:52:30,360 --> 00:52:35,590
支付查看下一层元素和返回的操作

543
00:52:35,620 --> 00:52:37,650
即使它真的要继续往下运算

544
00:52:37,680 --> 00:52:39,350
那也无所谓  因为这些花费

545
00:52:39,380 --> 00:52:43,000
会由另外的ij来负责

546
00:52:43,030 --> 00:52:46,940
所以  每个计算单元都只花费常数量的时间

547
00:52:46,970 --> 00:52:57,180
在O(mn)中  每次都花费常数量的计算

548
00:52:57,210 --> 00:52:58,960
你可以用

549
00:52:58,980 --> 00:53:01,270
平摊分析来证明它

550
00:53:01,300 --> 00:53:03,830
它的空间花费是多少？

551
00:53:03,860 --> 00:53:05,560
我们一般不关注空间

552
00:53:05,590 --> 00:53:08,030
但这里我们得开始看看空间的问题了

553
00:53:08,070 --> 00:53:09,900
对于一些算法来说

554
00:53:09,900 --> 00:53:11,580
空间是很重要的

555
00:53:11,600 --> 00:53:20,570
我需要多少空间？储存空间？

556
00:53:20,600 --> 00:53:26,950
是的  也是m乘n  就是储存c[i,j]的表

557
00:53:26,980 --> 00:53:29,130
剩下的用来储存x和y的

558
00:53:29,150 --> 00:53:31,680
只有m+n那么多

559
00:53:31,710 --> 00:53:33,670
可以忽略不计了

560
00:53:33,700 --> 00:53:37,440
我需要的空间大概就是m乘n那么多

561
00:53:37,470 --> 00:53:40,900
所以备忘法的算法

562
00:53:40,920 --> 00:53:45,000
在编程中是很有用的策略

563
00:53:45,030 --> 00:53:47,260
当你有相同传入的参数

564
00:53:47,280 --> 00:53:48,830
你就会得到相同的结果

565
00:53:48,860 --> 00:53:51,210
当然它也有不管用的时候

566
00:53:51,240 --> 00:53:53,640
那就是当你的运算

567
00:53:53,670 --> 00:53:57,790
有很多传入参数

568
00:53:57,820 --> 00:53:59,760
都是不一样的时候

569
00:53:59,790 --> 00:54:02,720
不过对于这种

570
00:54:02,750 --> 00:54:06,040
函数式的编程

571
00:54:06,070 --> 00:54:09,720
如果你已经计算过一组参数的结果  那直接查找就好了

572
00:54:09,750 --> 00:54:14,150
总之这东西好处多多

573
00:54:14,180 --> 00:54:16,830
然而  它也花费了相当多的空间

574
00:54:16,860 --> 00:54:20,290
而且在空间上也不是很整齐的

575
00:54:20,320 --> 00:54:21,970
所以有另一种策略来解决重复运算

576
00:54:22,000 --> 00:54:27,110
就是用自底向上的方法

577
00:54:27,140 --> 00:54:35,930
这才是传说中的的真·动态规划

578
00:54:35,960 --> 00:54:50,060
主要思想就是自底向上地计算表格

579
00:54:50,090 --> 00:54:53,100
把这边擦掉

580
00:54:53,130 --> 00:55:00,680
就用这边的这块吧

581
00:55:00,710 --> 00:55:32,310
啊  我还是用后面这块吧

582
00:55:32,340 --> 00:55:33,220
我们要做的是

583
00:55:33,250 --> 00:55:36,810
我们要做的就是观察c[i,j]表格

584
00:55:36,840 --> 00:55:38,760
然后意识到其实可以按照一定顺序

585
00:55:38,780 --> 00:55:40,960
来填这个表

586
00:55:40,990 --> 00:55:45,000
前面讲的是自顶向下的备忘法

587
00:55:45,030 --> 00:55:46,850
不过实际上还有一种方式

588
00:55:46,880 --> 00:55:49,730
我们可以自底向上地来做

589
00:55:49,760 --> 00:55:53,830
我们来看一下

590
00:55:53,870 --> 00:56:02,600
这是我们的表格

591
00:56:02,630 --> 00:56:05,670
这是x

592
00:56:05,700 --> 00:56:20,900
这是y

593
00:56:20,920 --> 00:56:27,410
我需要先对这些空项进行初始化

594
00:56:27,440 --> 00:56:36,580
我没有覆盖掉c[i,j]的初始值

595
00:56:36,610 --> 00:56:41,350
c[0]的含义就是一个没有任何元素的前缀

596
00:56:41,380 --> 00:56:45,610
这个前缀里面什么都没有  它的长度也就是0

597
00:56:45,640 --> 00:56:52,500
画出这些只是要划定一个边界

598
00:56:52,530 --> 00:56:55,030
现在  我要做的就是套公式了

599
00:56:55,060 --> 00:56:58,620
公式已经被我擦得灰飞烟灭了  好吧

600
00:56:58,650 --> 00:57:02,320
为了计算LCS

601
00:57:02,350 --> 00:57:04,940
计算LCS的长度

602
00:57:04,970 --> 00:57:12,030
从y里的这个字符开始

603
00:57:12,030 --> 00:57:14,170
还有x里的这个字符

604
00:57:14,200 --> 00:57:16,810
比如说这里  它们不相等

605
00:57:16,840 --> 00:57:20,360
于是它等于这两个的最大值

606
00:57:20,390 --> 00:57:24,460
这里它们相等了

607
00:57:24,480 --> 00:57:30,160
它就等于1加上左上方这个数

608
00:57:30,190 --> 00:57:31,890
我来画条连线

609
00:57:31,930 --> 00:57:32,840
每次我找到了一个相等的字符

610
00:57:32,870 --> 00:57:33,850
我就这么画条连线

611
00:57:33,880 --> 00:57:35,780
意思是我第一次遇到了

612
00:57:35,810 --> 00:57:40,490
它们相等的情况

613
00:57:40,520 --> 00:57:43,300
然后我要做的就是应用那个递归公式

614
00:57:43,330 --> 00:57:45,350
就是我们证明过的定理里的那个

615
00:57:45,380 --> 00:57:48,370
这里它们不相等

616
00:57:48,400 --> 00:57:51,150
所以是两个的最大值

617
00:57:51,170 --> 00:57:52,670
这里相等了

618
00:57:52,700 --> 00:57:59,140
所以是1加上这货  这里不相等

619
00:57:59,160 --> 00:58:03,030
就是那两个的最大值

620
00:58:03,060 --> 00:58:07,210
这里不相等  取最大值

621
00:58:07,240 --> 00:58:10,330
这里是1加前面的

622
00:58:10,360 --> 00:58:16,930
大家都明白第一行是怎么填出来的了吧？

623
00:58:16,950 --> 00:58:18,870
很好  这样你们就可以派上用场了

624
00:58:18,900 --> 00:58:24,440
它等于多少？

625
00:58:24,440 --> 00:58:30,250
说出来就行  0  很好

626
00:58:30,270 --> 00:58:39,310
1  因为是取最大值  1,2  没错

627
00:58:39,340 --> 00:58:45,040
这个呢  然后这个

628
00:58:45,070 --> 00:58:56,830
2,2  好的  这里  0

629
00:58:56,860 --> 00:59:01,000
1  因为是取最大值

630
00:59:01,030 --> 00:59:15,290
2,2,2  很好

631
00:59:15,320 --> 00:59:32,920
1,1,2,2,2,3

632
00:59:32,950 --> 00:59:49,300
3,1,2,3

633
00:59:49,330 --> 00:59:59,740
继续 3,4

634
00:59:59,770 --> 01:00:11,890
1,3

635
01:00:11,910 --> 01:00:21,930
3,4  很好  4

636
01:00:21,960 --> 01:00:29,110
好的  于是我们的答案就是：4

637
01:00:29,140 --> 01:00:33,310
显而易见  这是很快的代码

638
01:00:33,340 --> 01:00:37,670
因为这用到了现代机器的一个性质

639
01:00:37,700 --> 01:00:43,420
如果对内存的操作是有规律性的  那它们通常很给力

640
01:00:43,450 --> 01:00:48,160
如果你按这个顺序使用内存

641
01:00:48,190 --> 01:00:51,500
这个二维数组就是按这种顺序存下来

642
01:00:51,530 --> 01:00:54,830
否则的话就是按这种顺序

643
01:00:54,860 --> 01:00:56,420
按这种顺序存储的

644
01:00:56,450 --> 01:01:04,790
这个算法跑起来就是飞一样的感觉

645
01:01:04,820 --> 01:01:13,680
那么  我们花了多少时间来干这个？

646
01:01:13,710 --> 01:01:26,160
是的O(mn)  Θ(mn)  是吧？

647
01:01:26,190 --> 01:01:30,020
我们稍后就讲空间的问题

648
01:01:30,050 --> 01:01:31,550
所以hold住你的问题  那是个好问题

649
01:01:31,580 --> 01:01:34,060
很好的问题

650
01:01:34,090 --> 01:01:42,200
很好  那么我们是怎么算出——记得吗

651
01:01:42,230 --> 01:01:43,610
我们有简化的方法

652
01:01:43,640 --> 01:01:47,630
我们只需计算出长度

653
01:01:47,660 --> 01:01:52,360
然后我就可以找出

654
01:01:52,390 --> 01:01:55,180
一个那么长的序列来

655
01:01:55,210 --> 01:01:56,720
我要做的是

656
01:01:56,740 --> 01:02:04,020
通过回溯法重建LCS

657
01:02:04,050 --> 01:02:11,130
通过回溯法重建LCS

658
01:02:11,160 --> 01:02:14,670
所以我从这里出发

659
01:02:14,700 --> 01:02:19,070
这里我做了一次选择

660
01:02:19,100 --> 01:02:20,950
因为这里没有连线

661
01:02:20,980 --> 01:02:23,040
它取决于这两个值其中的一个

662
01:02:23,070 --> 01:02:27,550
所以来向这边走

663
01:02:27,570 --> 01:02:31,460
现在这里出现了一条斜线

664
01:02:31,490 --> 01:02:42,020
所以我们要做的就是标记

665
01:02:42,050 --> 01:02:46,920
出现在这些位置上的字符

666
01:02:46,950 --> 01:02:48,790
这里是3

667
01:02:48,830 --> 01:02:51,830
然后继续走  这是3

668
01:02:51,850 --> 01:02:53,590
这里又发现了一条斜线

669
01:02:53,620 --> 01:03:00,220
意思是这个字符被选上了

670
01:03:00,240 --> 01:03:08,030
往上走到这  然后到这

671
01:03:08,060 --> 01:03:10,310
然后再往斜上走

672
01:03:10,340 --> 01:03:14,620
也就是说这个字符也被选上了

673
01:03:14,650 --> 01:03:21,300
然后这边  这边

674
01:03:21,330 --> 01:03:27,120
然后继续向上  这两个字符被选上了

675
01:03:27,140 --> 01:03:30,920
于是这就是我的LCS

676
01:03:30,950 --> 01:03:32,770
当然这只是一种路径

677
01:03:32,800 --> 01:03:35,580
我也可以不走寻常路

678
01:03:35,610 --> 01:03:41,660
得到一个截然不同的LCS

679
01:03:41,690 --> 01:03:45,200
这种简化其实就是在说  看吧

680
01:03:45,230 --> 01:03:48,770
我只是往回走了几步就能找出LCS

681
01:03:48,800 --> 01:03:51,640
这是相当不错的  因为这意味着

682
01:03:51,670 --> 01:03:56,910
在计算的过程中

683
01:03:56,940 --> 01:03:59,070
用这些反向指针

684
01:03:59,100 --> 01:04:03,540
来重建LCS其实是很容易的

685
01:04:03,570 --> 01:04:05,640
如果我想从前向后建立LCS

686
01:04:05,670 --> 01:04:08,520
那将会困难重重

687
01:04:08,560 --> 01:04:12,590
那么接着我刚才说的  空间问题

688
01:04:12,620 --> 01:04:16,270
是O(mn)因为我们还是要用到这个表格

689
01:04:16,290 --> 01:04:30,800
其实用O(min(m,n))的空间就能解决问题

690
01:04:30,830 --> 01:04:32,220
为了回答你的问题

691
01:04:32,250 --> 01:04:39,720
怎么做O(min(m,n))的空间？

692
01:04:39,750 --> 01:04:42,300
按对角线不会得到min(m,n)

693
01:04:42,330 --> 01:04:49,070
那会得到m,n的和

694
01:04:49,100 --> 01:04:51,530
按对角线走

695
01:04:51,560 --> 01:04:54,700
也许我没理解你的话

696
01:04:54,730 --> 01:04:58,630
好的  按你说的  我按什么顺序处理这个地方？

697
01:04:58,660 --> 01:04:59,440
好的  我开始了

698
01:04:59,470 --> 01:05:03,400
我从这里开始  下一个是哪个？

699
01:05:03,430 --> 01:05:06,990
这个？

700
01:05:07,020 --> 01:05:09,980
这里  再到这里.....像这样？

701
01:05:10,010 --> 01:05:12,860
这的确是很好的顺序

702
01:05:12,890 --> 01:05:19,170
你的意思是

703
01:05:19,200 --> 01:05:24,530
每次都保存对角线上的元素

704
01:05:24,560 --> 01:05:26,030
也就是说对角线的长度

705
01:05:26,060 --> 01:05:29,220
就是min(m,n)？

706
01:05:29,250 --> 01:05:30,480
嗯  的确是这样

707
01:05:30,530 --> 01:05:32,490
你还可以用一种方法

708
01:05:32,530 --> 01:05:34,490
这种方法更直观

709
01:05:34,530 --> 01:05:35,930
你只要比较m和n

710
01:05:35,960 --> 01:05:38,040
看看那个更小  那么首先

711
01:05:38,070 --> 01:05:42,750
我们就从这个算法入手

712
01:05:42,780 --> 01:05:45,770
如果我按行来做

713
01:05:45,800 --> 01:05:51,020
我不需要前一行的数据

714
01:05:51,050 --> 01:05:53,880
每次只需要一行就够了

715
01:05:53,910 --> 01:05:57,370
我可以只用一行计算

716
01:05:57,400 --> 01:06:00,470
因为一旦我算除了后面的行

717
01:06:00,500 --> 01:06:03,540
第一行就无关紧要了

718
01:06:03,570 --> 01:06:06,540
其实我都不需要这整个行

719
01:06:06,580 --> 01:06:10,210
我需要的只有现在我用的这一行

720
01:06:10,240 --> 01:06:14,150
和上一行的一两个元素

721
01:06:14,180 --> 01:06:16,700
还有上一行的末尾

722
01:06:16,730 --> 01:06:21,480
所以我用到了这一行的前缀  还有上一行两个元素

723
01:06:21,510 --> 01:06:23,150
还有上一行的末尾

724
01:06:23,180 --> 01:06:26,200
实际上  你需要的只有一行

725
01:06:26,230 --> 01:06:28,940
加上O(1)这么多的元素

726
01:06:28,970 --> 01:06:32,310
我可以选择是横向还是纵向

727
01:06:32,340 --> 01:06:36,870
哪样省空间我就选哪样

728
01:06:36,900 --> 01:06:37,880
可能你的那个

729
01:06:37,920 --> 01:06:39,470
对角线法也能行

730
01:06:39,510 --> 01:06:43,680
我得想一想

731
01:06:43,720 --> 01:06:45,120
喔  问得好

732
01:06:45,120 --> 01:06:48,910
现在可以做到的是计算LCS长度

733
01:06:48,910 --> 01:06:52,910
并且只需要一行加上O(1)的空间

734
01:06:52,940 --> 01:07:03,420
那么我们的作业就是  这是个高难度的作业

735
01:07:03,450 --> 01:07:13,590
就是用很小的空间

736
01:07:13,620 --> 01:07:19,940
就重建出LCS

737
01:07:19,970 --> 01:07:22,240
就用我们刚才很天真的算法

738
01:07:22,270 --> 01:07:24,950
其实如何进行回溯有些复杂

739
01:07:24,980 --> 01:07:28,000
因为你丢失了很多信息

740
01:07:28,020 --> 01:07:32,910
所以说这是一个相当开动脑筋的问题

741
01:07:32,940 --> 01:07:39,170
它遵循分而治之的方法

742
01:07:39,200 --> 01:07:46,380
而不是一些简单的制表之类的东西

743
01:07:46,410 --> 01:07:49,140
用来练手很不错  比如

744
01:07:49,180 --> 01:07:52,650
让它出现在下一次课后作业里

745
01:07:52,680 --> 01:07:58,850
都是很精巧很锻炼思维的问题

746
01:07:58,880 --> 01:08:03,980
做做很有好处

747
01:08:04,010 --> 01:08:09,290
这就是备忘法

748
01:08:09,330 --> 01:08:11,960
那个叫动态规划

749
01:08:11,990 --> 01:08:14,500
备忘法和动态规划是两个东西

750
01:08:14,530 --> 01:08:19,210
即使它们之间有关系

751
01:08:19,230 --> 01:08:22,280
我们还将看到很多其它的问题

752
01:08:22,310 --> 01:08:27,640
都遵从动态规划的方式

753
01:08:27,660 --> 01:08:32,350
这是很牛的方法  在你们的作业里

754
01:08:32,380 --> 01:08:33,780
我再提一次作业的事

755
01:08:33,810 --> 01:08:35,500
作业里面  你们会看到一个问题

756
01:08:35,530 --> 01:08:38,390
叫做编辑距离问题

757
01:08:38,420 --> 01:08:40,440
编辑距离问题是给定你两个字符串

758
01:08:40,470 --> 01:08:42,610
然后你可以脑补一下

759
01:08:42,650 --> 01:08:44,860
你用一个上面只有一串字母的键盘打字

760
01:08:44,890 --> 01:08:47,940
你所能做的就是插入  删除

761
01:08:47,970 --> 01:08:50,640
替换  还得移动光标

762
01:08:50,670 --> 01:08:53,260
你要把这个字符串变形成另一个

763
01:08:53,290 --> 01:08:56,050
每次这种操作都有代价

764
01:08:56,080 --> 01:08:59,820
你的任务就是

765
01:08:59,820 --> 01:09:01,950
将这种变形的计算量减到最小

766
01:09:01,950 --> 01:09:02,840
这个问题

767
01:09:02,840 --> 01:09:06,480
在生物学上也是很常见的

768
01:09:06,510 --> 01:09:09,910
而且  还有各种编辑器也会用到它

769
01:09:09,940 --> 01:09:12,740
像影片编辑器  文本编辑器

770
01:09:12,770 --> 01:09:17,470
都要用这样的算法来使

771
01:09:17,500 --> 01:09:20,020
发送到系统的I/O数据最小化

772
01:09:20,050 --> 01:09:25,860
发送到系统的I/O数据最小化

773
01:09:25,890 --> 01:09:29,210
提醒你们一下  你们最好

774
01:09:29,240 --> 01:09:33,100
今天就开始做作业一

775
01:09:33,130 --> 01:09:38,750
因为我分配任务的时候

776
01:09:38,780 --> 01:09:41,730
并不是按步骤一点点来的

777
01:09:41,760 --> 01:09:44,520
我只担心有些同学可能

778
01:09:44,550 --> 01:09:47,750
不能及时得到作业所需要的输入输出神马的

779
01:09:47,780 --> 01:09:48,910
不能及时得到作业所需要的输入输出神马的

780
01:09:48,940 --> 01:09:54,080
在网站上有一些示例问题

781
01:09:54,110 --> 01:09:57,790
你可以用任何你想用的语言写

782
01:09:57,820 --> 01:10:01,480
包括 Matlab

783
01:10:01,510 --> 01:10:05,900
Python  只要是你喜欢的

784
01:10:05,930 --> 01:10:10,030
答案会用Java和Python写出

785
01:10:10,060 --> 01:10:16,290
用c语言写出来的应该是最快的

786
01:10:16,320 --> 01:10:20,090
你也可以用汇编来写

787
01:10:20,110 --> 01:10:22,070
你们还是太年轻了 大叔我当年用的就是汇编

788
01:10:22,100 --> 01:10:28,850
在我那激情燃烧的岁月

789
01:10:28,880 --> 01:10:34,290
我建议你们马上就开始做这个

790
01:10:34,320 --> 01:10:37,640
我提一句  另一件事就是这个习题集里

791
01:10:37,670 --> 01:10:43,330
这些题是必做题

792
01:10:43,360 --> 01:10:45,340
都是必做的题

793
01:10:45,370 --> 01:10:47,510
不过你也知道你可以跳着做

794
01:10:47,540 --> 01:10:49,840
适当的跳几道题不会有大问题

795
01:10:49,870 --> 01:10:53,200
不过这一个  你要是跳了  那就给跪吧 成绩立马降一级

796
01:10:53,230 --> 01:10:57,800
都给我乖乖做好

797
01:17:59,790 --> 01:18:03,770
然后 对每个插入都收取两倍的代价

