1
00:00:05,660 --> 00:00:07,690
大家好 各位

2
00:00:07,720 --> 00:00:09,930
很高兴你们都早早来了  看起来不错嘛

3
00:00:09,960 --> 00:00:14,090
我在数什么时候这个课上助教的人数会比学生多

4
00:00:14,120 --> 00:00:21,000
好吧他们会来的 来来来 开始上课

5
00:00:23,550 --> 00:00:30,700
今天讲的是星战第二部分  帝国反击战

6
00:00:30,750 --> 00:00:32,710
所以 在上一次 我们的对手

7
00:00:32,740 --> 00:00:37,110
图先生  带着问题找到了我们

8
00:00:37,140 --> 00:00:40,320
我们有一个源 我们有一个有向图

9
00:00:40,350 --> 00:00:41,920
我们有每条边的权重

10
00:00:41,950 --> 00:00:43,910
而且它们都是非负数

11
00:00:43,940 --> 00:00:45,740
这就是我们喜闻乐见的

12
00:00:45,770 --> 00:00:48,210
我们通过构建一个Dijkstra算法

13
00:00:48,250 --> 00:00:50,490
从而击败了这个帝国

14
00:00:50,520 --> 00:00:55,490
然后非常效率地找到了单源最短路径

15
00:00:55,530 --> 00:00:57,720
从s到每个其余顶点地最短路径

16
00:00:57,740 --> 00:01:02,740
但是今天  死星有了一个新的把戏

17
00:01:02,790 --> 00:01:05,880
我们有潜在的负权值

18
00:01:05,910 --> 00:01:07,550
不管怎样我们还是要解决

19
00:01:07,590 --> 00:01:09,100
具体来说就是负权环的问题

20
00:01:09,120 --> 00:01:11,860
当我们发现出现了一个负权环

21
00:01:11,900 --> 00:01:13,560
我们只能让它一圈一圈一圈地运行

22
00:01:13,590 --> 00:01:15,700
然后时间就这么走啊走啊走啊

23
00:01:15,730 --> 00:01:17,930
这种循环可以无穷无尽地进行下去

24
00:01:17,990 --> 00:01:21,600
所以这里并不存在最短路径

25
00:01:21,630 --> 00:01:23,850
因为无论你选择那条路径  你都能得到一条更短的

26
00:01:23,890 --> 00:01:26,600
所以今天我们来讨论一下这个问题

27
00:01:26,620 --> 00:01:28,560
我们将要说到

28
00:01:28,590 --> 00:01:31,750
一个实际上比Dijkstra的还简单的新算法

29
00:01:31,780 --> 00:01:35,670
虽然没有它快 我们把它叫做Bellman－Ford算法

30
00:01:39,860 --> 00:01:42,350
这个算法将允许负权数存在

31
00:01:42,370 --> 00:01:45,580
并且在某种程度上接受负权环

32
00:01:45,620 --> 00:01:53,730
虽然接受程度可能没有你们想象地那么高

33
00:01:53,760 --> 00:01:58,290
当然 我们得给结论留些空间

34
00:01:58,320 --> 00:02:01,810
好了 所以 Bellman-Ford算法——

35
00:02:01,830 --> 00:02:04,780
是由两个人发明的——估计你们也猜到了

36
00:02:04,800 --> 00:02:08,750
它可以计算出最短路径权重

37
00:02:08,770 --> 00:02:11,290
因此 它对权值没有限制

38
00:02:11,320 --> 00:02:12,400
权值是任意的  并且

39
00:02:12,440 --> 00:02:17,490
它计算的是最短途径权重

40
00:02:17,520 --> 00:02:20,940
所以 请记得这个记号  δ(s,v)

41
00:02:20,960 --> 00:02:24,840
表示从s到v的最短途径权值

42
00:02:24,870 --> 00:02:28,550
s被称作源顶点

43
00:02:34,800 --> 00:02:39,010
然后我们要计算出

44
00:02:39,030 --> 00:02:42,300
所有这些顶点的权数  用小写v

45
00:02:44,820 --> 00:02:47,790
结论是 计算从s到任意一点的路径

46
00:02:47,820 --> 00:02:52,360
并不比计算s到某个顶点难

47
00:02:52,400 --> 00:02:54,190
所以 我们把到所有点的路径全都算一遍

48
00:02:54,220 --> 00:02:56,350
不过在这里还是有个问题

49
00:02:56,380 --> 00:02:58,460
它允许负权数

50
00:02:58,490 --> 00:03:02,000
这有利有弊

51
00:03:02,020 --> 00:03:06,060
Bellman－ford可能会说   矮油

52
00:03:06,090 --> 00:03:08,050
负权环出现了

53
00:03:08,070 --> 00:03:10,890
它会告诉我们负权环在刷存在感

54
00:03:16,930 --> 00:03:19,420
那么  负权环是存在的

55
00:03:19,440 --> 00:03:26,860
因此这里有些δ是负无穷的

56
00:03:26,880 --> 00:03:30,360
这就很诡异了

57
00:03:30,390 --> 00:03:31,870
所以 Bellman-Ford算法——

58
00:03:31,900 --> 00:03:34,060
就是我们一会儿要说的 它其实是给

59
00:03:34,080 --> 00:03:35,460
没有负权环的问题而构造的

60
00:03:35,500 --> 00:03:36,710
因为这样更直观一点

61
00:03:36,750 --> 00:03:39,820
其实可以说它是允许负权环存在的  但它只是会检测出来

62
00:03:39,860 --> 00:03:41,630
在这种情况下它不会给你δ的值

63
00:03:41,670 --> 00:03:43,170
当然你可以修改算法

64
00:03:43,200 --> 00:03:44,460
来帮你算出δ值

65
00:03:44,480 --> 00:03:47,100
我们这里先不讲

66
00:03:47,100 --> 00:03:54,060
不过嘛 学完这个算法 留给你们的作业就是

67
00:03:54,090 --> 00:03:58,080
计算出所有的δ

68
00:04:09,390 --> 00:04:11,470
这做起来并不困难

69
00:04:11,500 --> 00:04:14,120
但我们在这里没有时间做了

70
00:04:16,880 --> 00:04:26,310
那么  现在我们来讲这个算法   它很直观

71
00:04:26,340 --> 00:04:28,500
正如我所说的  它比Dijkstra的算法还要简单

72
00:04:32,110 --> 00:04:35,390
它是一个松弛算法

73
00:04:35,420 --> 00:04:37,950
它的主体思想就是

74
00:04:37,980 --> 00:04:40,800
像Dijkstra所做的那样对边进行松弛

75
00:04:40,830 --> 00:04:42,980
我们能够用到许多的来自Dijkstra的推论

76
00:04:43,000 --> 00:04:45,890
与此同时  证明所用的时间将会缩短3倍

77
00:04:45,930 --> 00:04:49,440
因为起初的2/3部分我们已经从Dijkstra得到了

78
00:04:49,470 --> 00:04:52,240
一不小心多讲了一点

79
00:04:52,260 --> 00:04:54,680
那么  这第一个部分是初始化

80
00:04:54,710 --> 00:04:58,870
然后 d[v]代表了

81
00:04:58,890 --> 00:05:01,210
从s到v的估计距离

82
00:05:01,230 --> 00:05:03,530
然后 在算法的运行过程中

83
00:05:03,560 --> 00:05:05,770
我们不断更新这些估值

84
00:05:05,800 --> 00:05:09,580
初始化的时候  d(s)=0

85
00:05:09,610 --> 00:05:12,990
不过现在这可不一定是正确答案

86
00:05:13,020 --> 00:05:14,740
剩下的都是无穷大

87
00:05:14,770 --> 00:05:16,450
当然无穷大也是一个实际的值

88
00:05:16,480 --> 00:05:19,440
这些最大值都有一个具体的值

89
00:05:19,470 --> 00:05:20,790
这就相当给力了

90
00:05:20,810 --> 00:05:24,630
这是和前面一样的初始化

91
00:05:33,820 --> 00:05:37,480
现在我们有一个主循环

92
00:05:37,510 --> 00:05:38,960
循环了v-1次

93
00:05:38,980 --> 00:05:40,830
我们实际上不会用到变量i

94
00:05:40,860 --> 00:05:44,790
它只是一个计数器

95
00:05:59,600 --> 00:06:03,020
然后我们考察每一条边  并对它进行松弛操作

96
00:06:03,050 --> 00:06:09,650
这是一个很简单的想法  如果你刚开始学松弛操作的话

97
00:06:09,680 --> 00:06:11,660
你应该先试试这么做

98
00:06:11,690 --> 00:06:16,260
问题在于你何时停止

99
00:06:19,620 --> 00:06:28,420
这有点类似于  我有一个朋友

100
00:06:28,460 --> 00:06:29,750
在他6岁的时候他会说

101
00:06:29,770 --> 00:06:31,010
矮油  我知道香蕉这个单词怎么拼了

102
00:06:31,040 --> 00:06:32,380
我只是不知道什么时候结束

103
00:06:32,430 --> 00:06:35,180
好吧  这和松弛操作是一样的

104
00:06:38,060 --> 00:06:40,790
这是我们的松弛操作  就像之前一样

105
00:06:40,820 --> 00:06:43,050
我们看着这个边

106
00:06:43,090 --> 00:06:45,410
观察它是否违反了三角不等式

107
00:06:45,430 --> 00:06:48,480
根据我们现在的测算  我们知道

108
00:06:48,510 --> 00:06:49,970
s到v的距离至多是

109
00:06:50,000 --> 00:06:52,400
s到u的距离再加上从u到v的那条边的权重

110
00:06:52,430 --> 00:06:54,470
如果不是  我们将它们设为相等

111
00:06:54,500 --> 00:06:58,920
我们已经证明了这一直是一个正确的操作

112
00:06:58,960 --> 00:07:01,650
我的意思是  它不会违背——

113
00:07:01,670 --> 00:07:03,220
这些d[v]的距离绝对不会变的太小

114
00:07:03,250 --> 00:07:04,730
如果我们做了一连串的松弛操作

115
00:07:04,770 --> 00:07:06,450
所以 基本思路是你算每一条边

116
00:07:06,470 --> 00:07:08,650
都去松弛它  顺序什么的无所谓

117
00:07:08,690 --> 00:07:11,220
只是松弛每一条边就行了  每次一条

118
00:07:11,220 --> 00:07:13,590
然后松弛v-1次

119
00:07:13,630 --> 00:07:15,390
这应该是足够的

120
00:07:15,420 --> 00:07:20,410
不过仅限于没有负权环的时候

121
00:07:20,440 --> 00:07:25,090
那么  如果这里出现了负权环

122
00:07:25,120 --> 00:07:26,220
我们需要把它检测出来

123
00:07:26,260 --> 00:07:32,420
我们将用一个相当直接的方法来做

124
00:07:32,440 --> 00:07:37,100
我们做的是完全一样的事

125
00:07:37,130 --> 00:07:38,790
下面这些是在循环外的

126
00:07:38,820 --> 00:07:46,030
在图中对于每条边有同样的四个循环

127
00:07:46,060 --> 00:07:50,360
我们将要松弛它  然后如果你们能够松弛它

128
00:07:50,400 --> 00:07:53,830
那就证明存在一个负权环

129
00:07:59,610 --> 00:08:01,960
所以这就是我们所要求证的

130
00:08:27,010 --> 00:08:28,590
好吧  这就是这个算法

131
00:08:28,620 --> 00:08:31,890
在结尾我们应该有d[v]

132
00:08:31,940 --> 00:08:35,480
接下来是“else”的情况

133
00:08:35,510 --> 00:08:39,940
对于每一个顶点v来说 d[v]=δ(s,v)

134
00:08:39,960 --> 00:08:42,370
依据这条规则  如果我们没有找到负权环

135
00:08:42,400 --> 00:08:44,650
我们就可以得到最短路径权值

136
00:08:44,670 --> 00:08:46,360
这就是这个观点

137
00:08:46,360 --> 00:08:49,650
第一点是 在这里

138
00:08:49,680 --> 00:08:51,540
运行时间是非常容易分析的

139
00:08:51,560 --> 00:08:53,050
所以从运行时间入手

140
00:08:53,080 --> 00:08:55,130
我们能够将它和Dijkstra算法比较

141
00:08:55,160 --> 00:08:56,190
在这里

142
00:08:56,220 --> 00:08:59,540
什么是算法的执行时间？

143
00:09:06,680 --> 00:09:09,470
V乘以E   一点没错

144
00:09:14,970 --> 00:09:18,150
好了  我来假定  这个很自然的

145
00:09:18,180 --> 00:09:21,680
V和E都是正值  然后它就是V乘以E

146
00:09:21,700 --> 00:09:25,120
所以  这有一点的慢  不过可以接受

147
00:09:25,150 --> 00:09:29,890
和Dijkstra的算法比起来  这些是

148
00:09:29,910 --> 00:09:32,700
本质上是 (E + V)·log(V)

149
00:09:32,740 --> 00:09:35,320
忽略这些log的话是线性时间

150
00:09:35,340 --> 00:09:38,050
在这里我们有一些是至少是二次的V

151
00:09:38,080 --> 00:09:39,820
假设你的图是连通图的话

152
00:09:39,850 --> 00:09:41,590
所以 它会比较慢

153
00:09:41,610 --> 00:09:43,690
但是它会解决这些负权值

154
00:09:43,710 --> 00:09:45,250
Dijkstra算法完全都不能解决负权值

155
00:09:45,280 --> 00:09:48,990
那么我们举个例子

156
00:09:49,020 --> 00:09:53,190
让你们更加清楚为什么希望这个算法可以行得通

157
00:09:58,340 --> 00:10:00,010
然后我们当然将要证明这些是它行的通

158
00:10:00,030 --> 00:10:03,180
但是这些证明很简单

159
00:10:12,500 --> 00:10:18,040
所以我要画一个有负权值的图

160
00:10:18,070 --> 00:10:19,240
但是没有负权环

161
00:10:19,270 --> 00:10:21,690
这样我可以得到了一个有趣的结果

162
00:10:52,650 --> 00:10:57,050
很好  我们还要做一件事

163
00:10:57,090 --> 00:11:00,080
来解释这个算法的输出结果

164
00:11:00,110 --> 00:11:02,080
它取决于你访问边的顺序

165
00:11:02,110 --> 00:11:04,930
所以我给这些边一个随机顺序

166
00:11:04,960 --> 00:11:07,520
其实你们随便说一个顺序就行

167
00:11:07,550 --> 00:11:09,440
不过为了和笔记保持一致

168
00:11:09,470 --> 00:11:11,850
我按这个顺序排列它

169
00:11:11,880 --> 00:11:13,100
比如说我标注上4

170
00:11:13,140 --> 00:11:15,220
表明这是我访问的第四条边

171
00:11:15,240 --> 00:11:17,010
其实这并不重要

172
00:11:17,050 --> 00:11:21,390
但它却会影响到

173
00:11:21,420 --> 00:11:23,710
特定的图的运算过程

174
00:11:38,840 --> 00:11:42,030
标完了么

175
00:11:42,060 --> 00:11:46,260
1 2 3 4 5 6 7 8

176
00:11:46,280 --> 00:11:49,010
好了  我的起始点是A

177
00:11:49,040 --> 00:11:54,940
然后  就是这样  我想要执行这个算法

178
00:11:54,960 --> 00:11:57,660
我就要进行初始化

179
00:11:57,690 --> 00:12:01,250
那么  我设s的估值为0

180
00:12:01,280 --> 00:12:02,700
然后剩下的每一个都是无穷大

181
00:12:02,740 --> 00:12:09,810
然后给我一些关于时间的概念

182
00:12:09,830 --> 00:12:13,210
在这里我画...或者说是写

183
00:12:13,240 --> 00:12:18,850
当算法运行时所有这些d的值	

184
00:12:18,890 --> 00:12:21,090
因为我要划掉并且重写它们

185
00:12:21,110 --> 00:12:22,810
这个图会变得有点凌乱

186
00:12:22,840 --> 00:12:24,550
我们在做个跟踪表

187
00:12:24,590 --> 00:12:28,840
这些是初始0还有无穷大的值  对吧？

188
00:12:28,840 --> 00:12:32,600
[学生]：……

189
00:12:32,620 --> 00:12:35,670
[教授]:其实没关系的  那么  对于这个算法 你可以

190
00:12:35,690 --> 00:12:39,220
按不同顺序来访问这些边

191
00:12:39,250 --> 00:12:42,300
我们会证明的  但是现在我

192
00:12:42,330 --> 00:12:43,670
每一次都用相同的顺序

193
00:12:43,690 --> 00:12:46,280
问得好  实际上 在这里是没关系的

194
00:12:46,330 --> 00:12:50,890
好吧  所以这里是起始点

195
00:12:50,910 --> 00:12:52,330
现在我将要松弛每一条边

196
00:12:52,360 --> 00:12:53,930
所以  现在我们在这将有许多边

197
00:12:53,960 --> 00:12:55,080
没有任何计算

198
00:12:55,120 --> 00:12:57,730
我尝试去松弛N-1这条边  我想说

199
00:12:57,760 --> 00:13:00,680
我知道从S到B的的距离是无穷大

200
00:13:00,730 --> 00:13:05,160
那么无穷大加上2的话 我就能够从S到E

201
00:13:05,190 --> 00:13:07,950
好吧  无穷加上2并没有比无穷大很多

202
00:13:07,970 --> 00:13:11,380
好了  所以我什么都不做  不将这个更新为无穷

203
00:13:11,420 --> 00:13:13,390
我想说  无穷大加上2听上去甚至更可怕

204
00:13:13,410 --> 00:13:14,770
但是无穷大加上2还是无穷大

205
00:13:14,800 --> 00:13:16,990
好了  这是1号边

206
00:13:17,030 --> 00:13:18,990
所以  2号边不松弛

207
00:13:19,020 --> 00:13:20,930
3号也是一样的

208
00:13:20,950 --> 00:13:23,940
4号边也是同样  我们开始得到一些有趣的东西

209
00:13:23,970 --> 00:13:25,160
因为我在这儿有一个有限的值

210
00:13:25,180 --> 00:13:27,640
它说我从A到B

211
00:13:27,660 --> 00:13:33,550
只需要经过权值-1的边  所以这个看上去不错

212
00:13:33,580 --> 00:13:35,910
我在这里写下-1

213
00:13:35,940 --> 00:13:40,850
然后把B的值更新为-1

214
00:13:40,880 --> 00:13:44,470
剩下的保持一致  所以我只要坚持

215
00:13:44,500 --> 00:13:47,450
一遍一遍地做它  这是4号边

216
00:13:47,490 --> 00:13:49,890
5号 我们也可以做一个松弛

217
00:13:49,930 --> 00:13:52,000
4比无穷大更好

218
00:13:52,040 --> 00:13:55,140
所以  C是4

219
00:13:55,160 --> 00:14:00,230
然后我们到了6号边

220
00:14:00,250 --> 00:14:04,190
这是无穷大加上5 这比四差

221
00:14:04,220 --> 00:14:06,370
好了  所以这儿没有松弛了

222
00:14:06,400 --> 00:14:10,140
7号边很有趣

223
00:14:10,180 --> 00:14:11,910
因为我在这里有一个有限的值-1

224
00:14:11,950 --> 00:14:13,820
加上这条边的权值

225
00:14:13,850 --> 00:14:15,750
权值为3   总数为2

226
00:14:15,770 --> 00:14:17,500
实际上比4好

227
00:14:17,530 --> 00:14:20,360
所以  这里的路线ABC实际上

228
00:14:20,390 --> 00:14:24,710
比我之前找到的那个路线好

229
00:14:24,740 --> 00:14:26,650
所以  现在这是2

230
00:14:26,680 --> 00:14:30,690
这所有的都发生在一个主循环的迭代中

231
00:14:30,740 --> 00:14:34,730
实际上我们发现了两条通向C的好路径

232
00:14:34,750 --> 00:14:35,980
我们发现其中一个比另一个好

233
00:14:36,020 --> 00:14:37,990
好了  这是7号边

234
00:14:38,020 --> 00:14:41,070
8号边在遥远的这边 它打了回酱油

235
00:14:41,090 --> 00:14:45,990
好了  所以这是这个外层循环的第一个环路

236
00:14:46,020 --> 00:14:48,230
所以  i的第一个值 i=1

237
00:14:48,260 --> 00:14:52,340
好了  现在我们继续

238
00:14:52,360 --> 00:14:55,870
继续这样  所以  我们从1号边开始

239
00:14:55,910 --> 00:14:59,490
现在-1加上2是1

240
00:14:59,510 --> 00:15:02,910
比无穷大要好  我们要开始加速了

241
00:15:02,940 --> 00:15:06,080
这都是重复的工作

242
00:15:06,110 --> 00:15:07,980
实际上直到我们做完了它也没有那么长

243
00:15:08,010 --> 00:15:12,900
2号  这是一个无穷大  所以我们不做任何事情

244
00:15:12,930 --> 00:15:16,450
3号  -1加上2等于1

245
00:15:16,480 --> 00:15:18,010
比无穷大好

246
00:15:18,040 --> 00:15:26,760
这是顶点d  然后它是3号

247
00:15:26,790 --> 00:15:30,450
4号我们已经做完了  没有变化

248
00:15:30,480 --> 00:15:34,710
5号  这里我们又回到路径4

249
00:15:34,730 --> 00:15:36,730
但是它比2差  所以我们不管它

250
00:15:36,760 --> 00:15:41,730
6号  1加上5是6

251
00:15:41,750 --> 00:15:43,820
比2要大  所以不好

252
00:15:43,840 --> 00:15:49,960
像这样绕一圈  7号也一样

253
00:15:49,990 --> 00:15:53,730
8号很有趣

254
00:15:53,760 --> 00:15:57,370
所以  我们这里的权值是1

255
00:15:57,410 --> 00:15:58,780
这里的权值是-3

256
00:15:58,810 --> 00:16:02,110
所以  总数是-2  比1要好

257
00:16:02,140 --> 00:16:17,640
所以  这是d  然后  我相信它就是这样

258
00:16:17,660 --> 00:16:19,730
所以  这一轮一定结束了

259
00:16:22,170 --> 00:16:24,140
所以  i加上2

260
00:16:24,160 --> 00:16:25,640
因为我们只看了第八条边

261
00:16:25,680 --> 00:16:27,200
然后  我作弊看一下答案

262
00:16:27,230 --> 00:16:29,160
真的  这就是最后一件要做的事

263
00:16:29,180 --> 00:16:32,580
其实我们只需要检查从d向外的边

264
00:16:32,600 --> 00:16:35,600
因为这是唯一被改变了的顶点

265
00:16:35,630 --> 00:16:38,370
然后  这里没有更多可以松弛的了

266
00:16:38,400 --> 00:16:39,900
所以  这是在两圈内

267
00:16:39,930 --> 00:16:42,190
我们就得到了所有的最短路径

268
00:16:42,220 --> 00:16:44,870
这个算法实际上会

269
00:16:44,900 --> 00:16:47,830
循环四圈来保证正确性

270
00:16:47,850 --> 00:16:50,070
因为我们这里有5个顶点  循环次数比它少1

271
00:16:50,100 --> 00:16:52,720
所以  事实上  这个操作里

272
00:16:52,740 --> 00:16:55,890
这下面还有两个空着没做的循环

273
00:16:55,910 --> 00:16:58,750
但已经不会再改变了 坑爹呢这是

274
00:16:58,790 --> 00:17:03,940
好了 所以这就是Bellman-Ford算法了

275
00:17:03,960 --> 00:17:06,390
我的意思是 虽然它的确没有做错事

276
00:17:06,430 --> 00:17:08,850
但问题是  为什么它保证

277
00:17:08,880 --> 00:17:10,720
在v-1步内收敛（最短路径）

278
00:17:10,750 --> 00:17:11,780
除非存在着负权环？

279
00:17:11,810 --> 00:17:12,990
有问题么

280
00:17:13,030 --> 00:17:22,560
[学生]:……

281
00:17:22,590 --> 00:17:24,760
[教授]:对  这是一个优化法

282
00:17:24,780 --> 00:17:27,400
如果你发现了整个循环 什么都没有发生

283
00:17:27,440 --> 00:17:29,220
那么你可以把它记下来

284
00:17:29,240 --> 00:17:30,880
然后停下来 但在最差的情况下

285
00:17:30,920 --> 00:17:33,140
它不会有任何区别 但是在实际应用里

286
00:17:33,170 --> 00:17:34,630
你可能希望这样做 对不？

287
00:17:34,660 --> 00:17:42,000
好问题  那么经过一些简单的观察

288
00:17:42,030 --> 00:17:43,870
我的意思是 我们只做松弛操作

289
00:17:43,910 --> 00:17:45,900
所以 我们可以用到之前的分析

290
00:17:45,930 --> 00:17:47,060
特别是 d的数值

291
00:17:47,080 --> 00:17:49,170
只单调递减

292
00:17:49,190 --> 00:17:50,890
当我们在这里划去了一些数值

293
00:17:50,920 --> 00:17:52,960
我们总是将它变小 这是好的

294
00:17:52,980 --> 00:17:55,470
这算法的另一个优点是

295
00:17:55,520 --> 00:17:58,290
你甚至可以在分布式计算机系统下运行它

296
00:17:58,330 --> 00:18:01,400
如果这是一些真是的网络,一些电脑网络

297
00:18:01,430 --> 00:18:03,100
然后这些是机器

298
00:18:03,130 --> 00:18:04,510
它们之间用这些线连接

299
00:18:04,550 --> 00:18:07,440
我的意思是 这种操作纯粹的局部的

300
00:18:07,480 --> 00:18:08,670
松弛是局部的

301
00:18:08,730 --> 00:18:09,950
你们不需要任何的整体策略

302
00:18:09,980 --> 00:18:11,150
你们如果问

303
00:18:11,170 --> 00:18:14,230
我们可以在每一步做一个不同的顺序么？

304
00:18:14,270 --> 00:18:15,930
我说可以啊 你可以继续松弛边缘

305
00:18:15,950 --> 00:18:17,750
继续松弛边缘

306
00:18:17,810 --> 00:18:20,070
然后在你分布式网络中一直做这个

307
00:18:20,100 --> 00:18:22,230
最终 你将找到最短路径

308
00:18:22,260 --> 00:18:25,440
所以 这个算法保证在V循环内完成

309
00:18:25,470 --> 00:18:27,750
在分布式系统里  它可能更加不同步

310
00:18:27,780 --> 00:18:29,340
而且 分析起来会更难一些

311
00:18:29,370 --> 00:18:31,380
但是这么做行得通

312
00:18:31,400 --> 00:18:32,970
它保证是收敛

313
00:18:33,010 --> 00:18:34,930
所以 Bellman-ford算法

314
00:18:34,950 --> 00:18:38,850
经常用于求网络上的最短路径问题

315
00:18:41,630 --> 00:18:43,280
好了 所以最后让我们证明它会有效吧

316
00:18:43,300 --> 00:18:47,240
这应该用几块黑板就能讲完

317
00:18:56,720 --> 00:18:59,400
假设我们有一个图和一些边权值

318
00:18:59,420 --> 00:19:01,340
没有负权环

319
00:19:06,600 --> 00:19:09,060
然后这个观点是

320
00:19:09,080 --> 00:19:11,090
我们最终会得到正确答案

321
00:19:15,720 --> 00:19:20,440
所以 当Bellman-ford算法结束时

322
00:19:20,460 --> 00:19:34,410
所有顶点的d[v]都会等于δ值（最短路径值）

323
00:19:34,440 --> 00:19:40,970
证明将变得十分直接

324
00:19:45,090 --> 00:19:48,270
只要用到这些之前讲的引理    还记得吧？

325
00:19:48,370 --> 00:19:52,830
所以 我们只是分开的观察每一个顶点

326
00:19:55,420 --> 00:19:57,790
所以 我叫这个顶点V

327
00:19:57,820 --> 00:20:00,980
这个在算法结束之前都是成立的

328
00:20:01,000 --> 00:20:04,440
所以 记得我们需要证明的是在某一时间点

329
00:20:04,460 --> 00:20:06,330
d[v]=δ(s,v)

330
00:20:06,350 --> 00:20:08,590
因为我们知道它单调递减

331
00:20:08,620 --> 00:20:10,170
并且我们知道它不会

332
00:20:10,210 --> 00:20:11,450
变得比正确值还小

333
00:20:11,480 --> 00:20:12,880
因为松弛永远是安全的

334
00:20:12,900 --> 00:20:15,720
所以我们只需证明 在某一时间点它是成立的

335
00:20:15,740 --> 00:20:17,090
那么它到最后都一直会是成立的

336
00:20:17,150 --> 00:20:34,400
所以  通过d值的单调性

337
00:20:34,420 --> 00:20:36,790
和已经证明了的第一条正确性

338
00:20:40,320 --> 00:20:42,930
就是d[v]

339
00:20:42,960 --> 00:20:46,600
总是大于等于δ

340
00:20:49,410 --> 00:21:01,310
我们只需要证明在某一时间点 等式成立

341
00:21:14,860 --> 00:21:17,730
这就是我们的目的

342
00:21:20,100 --> 00:21:23,660
那么 我们将要做的只是观察V

343
00:21:23,680 --> 00:21:25,600
和到V的最短路径

344
00:21:25,640 --> 00:21:28,540
然后我们观察 这条路径上的算法做了什么

345
00:21:28,560 --> 00:21:32,200
所以 我来给这条路径起个名字 我们叫它p

346
00:21:32,220 --> 00:21:36,180
它从顶点v_0开始然后转向v_1 v_2

347
00:21:36,220 --> 00:21:39,400
然后 在v_k停止

348
00:21:39,430 --> 00:21:42,720
这不仅仅是最短途径而已

349
00:21:42,760 --> 00:21:44,610
它是从s开始的

350
00:21:44,640 --> 00:21:47,810
所以 v_0是s 并且在v终止

351
00:21:47,840 --> 00:21:50,890
所以我要给s和v起几个名字

352
00:21:50,920 --> 00:21:53,200
这样讨论起来才能保持一致

353
00:21:53,220 --> 00:22:06,050
所以 这是从s到v的最短路径

354
00:22:09,520 --> 00:22:11,770
现在 我同样想要它

355
00:22:11,800 --> 00:22:13,390
不只是从s到v的任何的最短路径

356
00:22:13,420 --> 00:22:15,690
而且在所有s到v里的最短路径之间

357
00:22:15,710 --> 00:22:20,600
经过最少的边的那一条最短路径

358
00:22:30,330 --> 00:22:31,560
好了 最短在这里意味着

359
00:22:31,600 --> 00:22:33,460
用路径的总权值表示

360
00:22:33,480 --> 00:22:35,260
先要满足权重最小

361
00:22:35,300 --> 00:22:37,990
而且它经过的边的数目里也是最少的

362
00:22:41,250 --> 00:22:43,830
然后 它这么做的原因是 这样能够推导出

363
00:22:43,860 --> 00:22:46,240
p是一个简单路径

364
00:22:46,280 --> 00:22:49,550
意味着它没有任何重复的顶点

365
00:22:49,590 --> 00:22:55,070
现在 有谁可以告诉我为什么我需要假定

366
00:22:55,100 --> 00:22:56,920
边的数量是能尽可能少的

367
00:22:56,950 --> 00:23:01,040
来保证p是最简的？ 我们说

368
00:23:01,070 --> 00:23:03,130
不是所有的最短路径都必须是简单的  对么

369
00:23:03,130 --> 00:23:06,030
[学生]：……

370
00:23:06,060 --> 00:23:08,730
[教授]:是的 我可能有一个零权环  确实是

371
00:23:08,750 --> 00:23:11,670
所以 我的意思是 我们事实上都希望在这个定理里

372
00:23:11,690 --> 00:23:13,530
我们假设这里没有负权环

373
00:23:13,550 --> 00:23:15,590
但是这里可能仍旧有零权环

374
00:23:15,620 --> 00:23:18,050
作为一个零权环,你可以将它放进任何一个最短路径之间

375
00:23:18,090 --> 00:23:20,180
使路径变得任意地长

376
00:23:20,220 --> 00:23:21,420
一遍遍地重复经过这些点

377
00:23:21,460 --> 00:23:22,860
这样很蛋疼啊

378
00:23:22,880 --> 00:23:25,280
我想要的p是简单路径

379
00:23:25,310 --> 00:23:30,000
其实有个捷径可以保证

380
00:23:30,020 --> 00:23:31,830
每当我遇到一个零权环  我就把它扔掉

381
00:23:31,860 --> 00:23:34,660
然后这是它的数学语言表达

382
00:23:34,690 --> 00:23:40,490
好了 现在关于这个最短路径我们知道些什么？

383
00:23:40,510 --> 00:23:45,110
我们知道  最短路径的子路径是最短路径

384
00:23:45,180 --> 00:23:47,040
这是一个最优子结构

385
00:23:47,110 --> 00:23:51,210
所以 我们知道了从s到v_i的最短路径

386
00:23:51,230 --> 00:23:56,100
有点归纳法的感觉   这个是最短路径

387
00:23:56,120 --> 00:23:58,560
我的意思是  它是那条路径的权值

388
00:23:58,600 --> 00:24:00,480
特别是从s到v_(i-1)的最短途径

389
00:24:00,500 --> 00:24:02,960
加上最后一条边的权值

390
00:24:02,980 --> 00:24:05,050
v_(i-1)到v_i

391
00:24:05,080 --> 00:24:10,990
所以 这是我们上次通过最优子结构所证明的

392
00:24:17,640 --> 00:24:23,430
好了 想这已经足够热身了

393
00:24:23,460 --> 00:24:28,970
我现在要用i来做归纳法

394
00:24:29,000 --> 00:24:31,950
从v_0开始进行   然后一直到v_k

395
00:24:31,970 --> 00:24:33,320
所以 第一个问题是

396
00:24:33,350 --> 00:24:41,540
d[v_0]是什么  也就是s？

397
00:24:41,580 --> 00:24:44,740
源点的d值是多少？

398
00:24:44,770 --> 00:24:47,330
好吧 当然在这个算法的开始

399
00:24:47,360 --> 00:24:48,470
它是零

400
00:24:48,490 --> 00:24:51,360
所以 让我们说起初等于零

401
00:24:53,760 --> 00:24:55,890
因为这是我们对它赋值的

402
00:24:55,910 --> 00:24:57,110
然后它只从这里下降

403
00:24:57,140 --> 00:24:58,620
所以 它无疑的 不超过零

404
00:24:58,640 --> 00:25:02,930
这真正的问题是 什么是δ(s,v_0)

405
00:25:02,960 --> 00:25:05,290
什么是从s到s的最短路径

406
00:25:11,790 --> 00:25:13,570
它必须为零

407
00:25:13,600 --> 00:25:15,420
否则你们会有个负权环   对

408
00:25:15,460 --> 00:25:17,860
我最喜欢的答案 零

409
00:25:17,900 --> 00:25:22,490
那么  如果我们有另一条从s到s的路径

410
00:25:22,520 --> 00:25:23,630
我的意思是 那是一个回路

411
00:25:23,660 --> 00:25:27,980
所以它应该是零  所以  这里实际上

412
00:25:28,000 --> 00:25:30,660
在算法开始相等  这个灰常不错

413
00:25:30,680 --> 00:25:32,190
这意味着它会一直都是这样

414
00:25:32,210 --> 00:25:34,410
因为我们刚刚这里讨论过  它一直变小

415
00:25:34,430 --> 00:25:35,440
永远不会变得过小

416
00:25:35,460 --> 00:25:39,260
所以d[v_0]的值设对了

417
00:25:39,290 --> 00:25:42,010
对归纳法的基础情况来说很好

418
00:25:42,040 --> 00:25:44,530
当然 我们真正关心的是v_k

419
00:25:44,560 --> 00:25:55,460
就是v  那么让我们用归纳法求一下v_i

420
00:25:55,480 --> 00:26:00,200
之后我们会得到一个结果v_k

421
00:26:09,270 --> 00:26:13,580
那么  让我们用归纳法来做

422
00:26:13,610 --> 00:26:27,750
这更有趣   我们说

423
00:26:27,780 --> 00:26:31,350
d[Vi] =δ(s, v_i)

424
00:26:31,380 --> 00:26:38,450
在循环了i次这个算法以后

425
00:26:38,480 --> 00:26:43,230
所以实际上这个涉及到了i

426
00:26:43,260 --> 00:26:46,980
在这个算法里  它们是循环次数

427
00:26:50,750 --> 00:26:54,710
一个循环执行了所有的边

428
00:26:54,740 --> 00:26:56,010
对所有边进行松弛

429
00:26:56,040 --> 00:26:58,900
所以i等于零无疑是正确的

430
00:26:58,940 --> 00:27:00,740
我们刚证明过了  在零圈过后

431
00:27:00,770 --> 00:27:02,290
在算法开始的阶段

432
00:27:02,320 --> 00:27:05,020
d[v_0] = δ(s,v_0)

433
00:27:07,120 --> 00:27:12,910
好了  那么现在  这并不是我真的想要的  不过就这样吧

434
00:27:12,940 --> 00:27:17,170
现在我们将要证明d[v_(i+1)]的情况

435
00:27:19,140 --> 00:27:21,200
我建议你们做一些假设

436
00:27:21,230 --> 00:27:24,880
其实... 为什么不按照我说的来改掉它

437
00:27:24,900 --> 00:27:28,150
通常把归纳法想成递归会比较好

438
00:27:28,180 --> 00:27:32,250
假设这个成立  我们说

439
00:27:32,290 --> 00:27:35,560
你们关心的  j比i小的时候

440
00:27:35,600 --> 00:27:37,530
然后你们d[v_i]成立

441
00:27:37,570 --> 00:27:40,900
这样想通常要简单得多

442
00:27:40,930 --> 00:27:42,110
特别是  你可以用

443
00:27:42,150 --> 00:27:45,270
完整归纳法证明所有j比i小时的情况

444
00:27:45,290 --> 00:27:47,600
这里我们只需要小于的情况

445
00:27:47,630 --> 00:27:51,740
我们在这里有一些在i和i-1之间的联系

446
00:27:51,770 --> 00:27:53,240
用δ表示

447
00:27:53,280 --> 00:27:57,260
我们要讨论一下d值

448
00:27:57,280 --> 00:28:05,860
好  我们来想想 接下来这里会发生什么

449
00:28:05,890 --> 00:28:13,000
我们知道  这样说  在i-1圈后

450
00:28:13,030 --> 00:28:18,680
我们有了这个归纳假设

451
00:28:18,710 --> 00:28:23,920
d[v_(i-1)]=δ(s,v_(i-1))

452
00:28:23,940 --> 00:28:27,720
然后我们要推断i圈之后

453
00:28:27,750 --> 00:28:29,520
那么我们有多了一轮来做这个

454
00:28:29,560 --> 00:28:34,340
我们想要推断d[v_i]有正确的解

455
00:28:34,380 --> 00:28:41,900
δ(S,Vi)    它们是不是很眼熟？

456
00:28:41,920 --> 00:28:45,550
我们要在这一轮里松弛每一条边

457
00:28:45,580 --> 00:28:50,620
特别是  在某些点

458
00:28:50,650 --> 00:28:54,740
我们必须松弛从v_(i-1)到v_i的边

459
00:28:54,760 --> 00:28:56,910
我们知道边组成了这条路径

460
00:28:56,940 --> 00:28:58,260
这是关于路径的定义

461
00:28:58,290 --> 00:29:06,460
在第i轮的时候  我们松弛了每一条边

462
00:29:06,490 --> 00:29:12,220
所以 我们也会松弛到（v_(i-1),v_i)

463
00:29:15,200 --> 00:29:27,950
那么接下来发生了什么  这是一个记忆测试

464
00:29:40,510 --> 00:29:42,680
速度点   死星正在逼近

465
00:29:44,930 --> 00:29:48,470
所以  如果我们给v_(i-1)取得了一个正确的值

466
00:29:48,500 --> 00:29:50,200
我们松弛了一条从这里向外的边

467
00:29:50,240 --> 00:29:54,370
而这条边是从s到v_i的最短路径中的一段

468
00:29:54,400 --> 00:30:04,180
那么我们知道了什么？ d[v_i]变成了正确的值

469
00:30:04,210 --> 00:30:05,490
δ(S, Vi)

470
00:30:05,510 --> 00:30:08,590
上次我们叫它正确性引理

471
00:30:08,610 --> 00:30:11,350
讲Dijkstra算法时我们证明过

472
00:30:11,390 --> 00:30:13,960
但是它实际上只是个松弛操作

473
00:30:13,980 --> 00:30:21,370
很容易证明

474
00:30:29,150 --> 00:30:31,190
它是从这来的

475
00:30:31,210 --> 00:30:34,670
我们知道最短路径权值是这个

476
00:30:34,700 --> 00:30:37,380
所以  理所当然的 d[v_i]至少是这么大

477
00:30:37,410 --> 00:30:41,410
我们假设它还要大一点  否则就已经做完了

478
00:30:41,430 --> 00:30:44,160
我们设了v_(i-1)的值是这个

479
00:30:44,180 --> 00:30:46,590
所以 无疑这就是

480
00:30:46,620 --> 00:30:48,600
在松弛操作里被检验的条件

481
00:30:48,630 --> 00:30:52,720
然后  假设d[v_i]的值将会

482
00:30:52,750 --> 00:30:54,400
比这个大 这么假定的话

483
00:30:54,420 --> 00:30:56,310
然后我们设它等于这个

484
00:30:56,330 --> 00:30:57,970
准确来说就是d(s,v_i)

485
00:30:58,000 --> 00:30:59,890
所以 当我们松弛那条边

486
00:30:59,910 --> 00:31:02,470
我们给了它一个正确的数值

487
00:31:02,500 --> 00:31:05,150
那么证明就完成了  对吧

488
00:31:05,180 --> 00:31:08,340
这很简单  关键是

489
00:31:08,370 --> 00:31:10,700
看下你的最短路径  在这里

490
00:31:12,690 --> 00:31:15,510
然后如果我们假设这里没有负权环

491
00:31:15,540 --> 00:31:17,410
在最初有正确的值

492
00:31:17,430 --> 00:31:21,830
d[s]将会变成零  在第一轮过后

493
00:31:21,850 --> 00:31:23,030
你肯定会松弛这条边

494
00:31:23,070 --> 00:31:25,660
然后你得到了那个顶点的正确数值

495
00:31:25,690 --> 00:31:28,650
在第二轮之后  你肯定松弛这条边

496
00:31:28,690 --> 00:31:30,160
在这里你得到了这个顶点的

497
00:31:30,180 --> 00:31:31,540
正确d值  等等等等

498
00:31:31,560 --> 00:31:34,530
所以  无论你选择了哪一条最短路径

499
00:31:34,550 --> 00:31:35,890
你可以运用这个分析

500
00:31:35,910 --> 00:31:39,330
然后你知道 如果这条路径的长度

501
00:31:39,360 --> 00:31:42,910
在这里我们假设它是k条边

502
00:31:42,940 --> 00:31:49,950
然后在k轮之后  你就完成了

503
00:31:49,980 --> 00:31:53,070
好吧其实还没证完

504
00:31:53,100 --> 00:31:56,410
不好意思  所以这意味着在k轮之后

505
00:32:02,120 --> 00:32:07,260
v_k就有一个正确的值  就是v

506
00:32:12,160 --> 00:32:15,220
所以唯一的问题就是k可以变成多大

507
00:32:15,240 --> 00:32:18,850
最好是正确答案  最大的情况

508
00:32:18,880 --> 00:32:23,540
是v-1  通过算法证明

509
00:32:23,560 --> 00:32:25,280
你只需要做v-1步

510
00:32:25,310 --> 00:32:27,290
确实  边的数量

511
00:32:27,320 --> 00:32:30,410
在简单路径的图里

512
00:32:30,440 --> 00:32:33,150
顶多是顶点的数量减一

513
00:32:35,270 --> 00:32:40,130
k最多是v-1  因为p是简单路径

514
00:32:47,350 --> 00:32:49,800
所以这就是为什么我们要假设

515
00:32:49,830 --> 00:32:51,150
它不止是任何的最短路径

516
00:32:51,180 --> 00:32:53,720
它必须是一个简单路径  不用重复任何的顶点

517
00:32:53,740 --> 00:32:56,450
所以在这条路径里最多有V个顶点

518
00:32:56,480 --> 00:32:58,410
所以在这个路径里最多有v-1条边

519
00:32:58,440 --> 00:33:02,770
好了  这就是Bellman-ford算法

520
00:33:02,800 --> 00:33:06,220
在正确性上检验上十分简单

521
00:33:06,240 --> 00:33:07,400
当然我们用了很多

522
00:33:07,430 --> 00:33:09,050
上次证明过的定理

523
00:33:09,080 --> 00:33:20,100
来使它变得简单  好  这套理论的结果

524
00:33:20,130 --> 00:33:27,890
或这个证明的结果是   如果Bellman-ford算法不能收敛

525
00:33:30,760 --> 00:33:33,130
就是这个算法正在检验的

526
00:33:33,160 --> 00:33:36,220
就是检验这个松弛是否

527
00:33:36,260 --> 00:33:40,300
在d-1步之后还要继续算

528
00:33:40,320 --> 00:33:41,420
对  在这个算法末尾

529
00:33:41,450 --> 00:33:43,320
还有一轮  就是第V轮

530
00:33:43,360 --> 00:33:44,840
我们来看看是否有任何改变

531
00:33:44,870 --> 00:33:46,880
我们假设  这个算法

532
00:33:46,920 --> 00:33:51,910
在v-1轮操作后不收敛

533
00:33:56,910 --> 00:34:02,150
那么这里肯定有一个负权环

534
00:34:11,790 --> 00:34:14,090
这个只是一个我们刚刚证明的命题的逆否命题

535
00:34:14,120 --> 00:34:15,900
我们证明了  如果假设

536
00:34:15,940 --> 00:34:17,520
这里没有负权环

537
00:34:17,550 --> 00:34:19,630
那么d[s]为零

538
00:34:19,670 --> 00:34:21,510
然后所有这些论证都在说

539
00:34:21,540 --> 00:34:23,380
在v-1圈之后会收敛

540
00:34:23,420 --> 00:34:24,630
那就没什么好做的了

541
00:34:24,660 --> 00:34:25,980
一旦你达到了最短路径权值

542
00:34:26,010 --> 00:34:27,050
因为你是单调递减的

543
00:34:27,070 --> 00:34:28,130
你又不能突破最小值

544
00:34:28,160 --> 00:34:29,440
你又不能捅破地板

545
00:34:29,460 --> 00:34:32,200
所以  如果你无论什么原因收敛失败了

546
00:34:32,230 --> 00:34:33,350
在v-1轮后

547
00:34:33,380 --> 00:34:35,560
你肯定是违反了假设

548
00:34:35,600 --> 00:34:36,890
我们所作出的唯一的假设

549
00:34:36,930 --> 00:34:38,410
是这里没有负权环

550
00:34:38,440 --> 00:34:41,870
所以这告诉我们 Bellman-ford算法实际上是对的

551
00:34:41,890 --> 00:34:44,360
当它说这里有负权环

552
00:34:44,390 --> 00:34:46,550
那就真的是有

553
00:34:46,580 --> 00:34:54,350
这是对的  好吧  你可以调整Bellman-ford算法

554
00:34:54,380 --> 00:34:56,970
在那种情况下稍稍运行久一些

555
00:34:56,990 --> 00:34:58,690
然后把所有的负无穷点找出来

556
00:34:58,720 --> 00:35:00,120
这个  在某种意义上

557
00:35:00,150 --> 00:35:02,370
是在你习题集里要做的

558
00:35:02,400 --> 00:35:05,330
所以这里就不讲了

559
00:35:05,350 --> 00:35:08,210
但是这绝对是一个很好的练习

560
00:35:08,240 --> 00:35:10,230
来想出方法找到负无穷

561
00:35:10,260 --> 00:35:11,680
哪些是迷失在了

562
00:35:11,710 --> 00:35:14,000
负权环里的顶点？

563
00:35:14,030 --> 00:35:15,630
那些负无穷的顶点就是了

564
00:35:15,660 --> 00:35:20,160
好   你可能会说我讲得太快了

565
00:35:20,190 --> 00:35:22,070
实际上还没完

566
00:35:22,090 --> 00:35:24,870
这集还没完

567
00:35:24,900 --> 00:35:27,610
我们要用到Bellman-ford算法

568
00:35:27,640 --> 00:35:31,290
来解决甚至更大更复杂的最短路径问题

569
00:35:31,320 --> 00:35:34,030
然后在今天的讲座的剩下部分

570
00:35:34,050 --> 00:35:38,100
我们还将看到它应用于更加普遍的问题

571
00:35:38,140 --> 00:35:39,660
在某种程度上  我们叫它线性规划

572
00:35:39,690 --> 00:35:42,310
在接下来的讲座里

573
00:35:42,340 --> 00:35:44,560
我们将用它来做一些神奇的东西

574
00:35:44,580 --> 00:35:50,680
用于全对最短路径  我们从这开始讲

575
00:35:50,700 --> 00:35:57,380
我们的目标是——虽然今天不是很看得出来

576
00:35:57,400 --> 00:35:58,830
是能够计算出

577
00:35:58,860 --> 00:36:01,630
每对顶点之间的最短路径

578
00:36:01,650 --> 00:36:03,230
我们现在只需

579
00:36:03,270 --> 00:36:06,640
运行Bellman-ford算法v次

580
00:36:06,670 --> 00:36:09,470
但是我们当然要比这个做得更好

581
00:36:12,450 --> 00:36:15,740
接下来是整个三部曲的高潮

582
00:36:17,440 --> 00:36:20,200
今天我们刚刚发现了卢克的爸爸是谁

583
00:36:28,490 --> 00:36:32,730
那么 我们发现这个

584
00:36:32,750 --> 00:36:35,780
最短途径的的父亲是线性规划

585
00:36:35,820 --> 00:36:39,890
实际上  它既是父亲又是母亲

586
00:36:39,920 --> 00:36:42,870
因为程序没有性别 = =

587
00:36:46,730 --> 00:36:56,620
好吧  我父亲喜欢说

588
00:36:56,650 --> 00:36:59,840
我们都去学了即兴演讲

589
00:36:59,870 --> 00:37:03,560
所以我们有即兴创作的学位

590
00:37:03,580 --> 00:37:07,160
然后他说  你知道  我们去即兴演讲课

591
00:37:07,180 --> 00:37:10,650
是为了让我们的段子更幽默

592
00:37:10,690 --> 00:37:12,810
但问题是

593
00:37:12,830 --> 00:37:14,030
实际上它并没有让我们更幽默

594
00:37:14,060 --> 00:37:15,490
它只是让我们滥用冷笑话而已

595
00:37:15,520 --> 00:37:18,840
所以说 你们都被我冷到了

596
00:37:18,860 --> 00:37:21,750
其实任何这和卢克父亲半毛钱关系都没有

597
00:37:21,780 --> 00:37:25,410
总之我们继续  好吧  线性规划

598
00:37:25,430 --> 00:37:28,720
是非常典型的问题  一个强大的工具

599
00:37:28,740 --> 00:37:29,980
有没有任何人在此之前知道线性规划

600
00:37:30,010 --> 00:37:35,040
好吧  有一个  然后  我确定你这辈子

601
00:37:35,070 --> 00:37:36,480
某个时候会碰到

602
00:37:36,510 --> 00:37:39,980
做一些像是最优化的计算

603
00:37:40,010 --> 00:37:41,840
这就是某种线性规划

604
00:37:41,870 --> 00:37:43,730
是一个非常有用的工具

605
00:37:43,760 --> 00:37:47,700
现在给你一个矩阵和两个向量

606
00:37:47,770 --> 00:37:49,390
还不够令人兴奋

607
00:37:49,460 --> 00:37:54,670
你所想要做的就是找到一个向量

608
00:37:54,740 --> 00:37:59,630
这是一个相当没劲的解释

609
00:37:59,650 --> 00:38:02,060
我们会看到是什么马上让它变得有趣

610
00:38:14,950 --> 00:38:18,650
所以  你想要把一些目标函数最大化

611
00:38:18,720 --> 00:38:24,490
你有一些约束条件  它们都是用线性式表示的

612
00:38:24,540 --> 00:38:27,990
所以  目标函数是含x的线性函数

613
00:38:28,020 --> 00:38:31,190
然后你的约束条件是一连串的线性式

614
00:38:31,210 --> 00:38:33,470
不等式的约束  这是一个让它变得有趣的东西

615
00:38:33,490 --> 00:38:36,090
这不仅仅是解线性方程组

616
00:38:36,120 --> 00:38:38,640
这不仅仅是算线性代数神马的

617
00:38:38,680 --> 00:38:42,690
或者  当然它也可能没有这样的x

618
00:38:50,920 --> 00:38:54,610
好了  是不是觉得跟Bellman-ford

619
00:38:54,650 --> 00:38:56,250
有些千丝万缕的联系

620
00:38:56,280 --> 00:38:59,410
我们会看到它们之间的一些联系

621
00:38:59,440 --> 00:39:00,620
要么你想要发现些什么

622
00:39:00,640 --> 00:39:01,810
或者说明它不存在

623
00:39:01,840 --> 00:39:04,510
好了  这仍旧是一个很模糊的联系

624
00:39:04,530 --> 00:39:06,000
但我同样想要最大化一些东西

625
00:39:06,020 --> 00:39:07,560
或者最小化最短路径

626
00:39:07,580 --> 00:39:11,860
之类的东东  我们有这些约束

627
00:39:11,880 --> 00:39:17,480
可能对你来说很直观

628
00:39:17,510 --> 00:39:19,660
差不多吧  我更偏向于几何的图

629
00:39:19,690 --> 00:39:24,170
然后我试着画个几何图出来

630
00:39:24,200 --> 00:39:27,160
我从来没有试过在黑板上做这个

631
00:39:27,190 --> 00:39:29,340
应该很好玩

632
00:39:32,750 --> 00:39:35,050
我想我将要坑爹地失败了

633
00:39:42,250 --> 00:39:45,800
它看起来神似个十二面体

634
00:39:45,840 --> 00:39:47,670
嘛 差不多吧 好吧不像

635
00:39:47,700 --> 00:39:49,640
底下不平  好吧

636
00:39:49,680 --> 00:39:53,480
所以 如果你有一连串的线性约束

637
00:39:53,530 --> 00:39:55,720
这个应该是三维的  我现在标出来

638
00:39:55,740 --> 00:39:57,020
它在三维中  很好

639
00:39:57,040 --> 00:39:59,820
所以 你有这些线性约束

640
00:39:59,880 --> 00:40:03,540
我们想到用它们来定义n维里的超平面

641
00:40:03,580 --> 00:40:08,430
好了  这里你们有了一个空间

642
00:40:08,450 --> 00:40:09,660
这是三维空间

643
00:40:09,700 --> 00:40:13,050
所以  n等于3  然后  这些超平面

644
00:40:13,080 --> 00:40:15,670
如果从超平面的一面看过去

645
00:40:15,700 --> 00:40:17,160
这是小于或等于

646
00:40:17,190 --> 00:40:18,690
如果你取交叉点

647
00:40:18,720 --> 00:40:20,690
你会得到一些凸多面体或者多面体

648
00:40:20,730 --> 00:40:24,020
在三维里你可能得到一个十二面体什么的

649
00:40:24,060 --> 00:40:29,210
然后你的目标  你有一些目标向量c

650
00:40:29,230 --> 00:40:30,960
我们说  方向向上

651
00:40:30,990 --> 00:40:34,400
假设这是向量c

652
00:40:34,440 --> 00:40:37,390
你的目标是找到这个多面体的最高点

653
00:40:37,420 --> 00:40:40,950
所以在这里  可能是这个  好了  这个是目标

654
00:40:40,990 --> 00:40:42,130
这是最优点x

655
00:40:42,160 --> 00:40:44,870
这是从几何的角度来说

656
00:40:44,900 --> 00:40:46,900
如果你用代数来看

657
00:40:46,940 --> 00:40:55,520
你想要使c的转置乘x最大化

658
00:40:58,550 --> 00:41:01,260
所以  这个是m  这个是n

659
00:41:01,300 --> 00:41:03,110
检验维度是对的

660
00:41:03,140 --> 00:41:05,210
所以 这就是说你想要最大化点乘积

661
00:41:05,240 --> 00:41:08,260
你想要增大

662
00:41:08,290 --> 00:41:09,750
x在c方向上的长度

663
00:41:09,790 --> 00:41:16,030
然后  你想要使它最大化  在某些限制条件下

664
00:41:16,060 --> 00:41:17,760
看上去可能有点像这个

665
00:41:17,800 --> 00:41:21,840
所以   这是A   这个是m排n列

666
00:41:21,870 --> 00:41:25,370
你想要把它乘以……

667
00:41:25,400 --> 00:41:27,330
某些有n排的的东西

668
00:41:27,360 --> 00:41:33,540
这就是x  把x写下来  n排1列

669
00:41:33,580 --> 00:41:35,650
然后 它应该小于

670
00:41:35,670 --> 00:41:39,560
或等于一些高度是这个的  这个是B

671
00:41:39,580 --> 00:41:47,570
在符号右边  好的  这就是从代数角度看

672
00:41:47,600 --> 00:41:50,370
检验下所有维度都弄对了

673
00:41:50,400 --> 00:41:53,870
不过你可以这样一行一行下来

674
00:41:53,900 --> 00:41:57,230
和这一列相乘  然后得出来的是这里这个数

675
00:41:57,260 --> 00:41:59,770
仅仅是作为所有x这边的一个线性约束

676
00:41:59,800 --> 00:42:05,310
接下来你想要最大化这个具体的线性函数

677
00:42:05,340 --> 00:42:07,960
从x_1到x_n  来满足这些约束

678
00:42:07,990 --> 00:42:12,290
十分简单  但是很牛逼

679
00:42:12,330 --> 00:42:17,130
你可以把各种各样的问题

680
00:42:17,170 --> 00:42:20,960
用线性规划的方法解决 例如最短路径问题

681
00:42:27,340 --> 00:42:30,000
所以  这是一个经典的工具  在这堂课里

682
00:42:30,040 --> 00:42:32,000
我们将不涉及任何的算法

683
00:42:32,050 --> 00:42:33,170
来解决线性规划

684
00:42:33,220 --> 00:42:34,480
这有一点狡猾

685
00:42:34,530 --> 00:42:37,540
我只提一下它们的存在

686
00:42:37,590 --> 00:42:40,300
有许多高效的算法

687
00:42:40,340 --> 00:42:42,970
和很多的代码来做这个

688
00:42:43,010 --> 00:42:47,200
这是一个非常实用的方案

689
00:42:56,100 --> 00:42:59,760
所以  许多的算法来解决线性规划问题

690
00:42:59,790 --> 00:43:02,720
线性规划通常被称作LP

691
00:43:05,000 --> 00:43:07,700
我会举些例子

692
00:43:07,720 --> 00:43:11,020
有个叫单一算法  这个是最早的之一

693
00:43:11,050 --> 00:43:16,770
我想它是第一个  椭球算法

694
00:43:16,820 --> 00:43:19,440
还有个内点法

695
00:43:24,800 --> 00:43:26,260
还有随机抽样

696
00:43:27,170 --> 00:43:29,530
这里每个我就讲一点点

697
00:43:31,560 --> 00:43:33,860
因为我们不会去深度地讨论任何一个

698
00:43:33,890 --> 00:43:36,680
我所指的单一算法

699
00:43:36,720 --> 00:43:38,950
某种程度上可以说是世界上出现的最早的算法之一

700
00:43:38,970 --> 00:43:41,730
也无疑是最普遍的算法之一  一直沿用至今

701
00:43:41,760 --> 00:43:43,480
几乎所有的线性规划代码

702
00:43:43,510 --> 00:43:44,630
都在用单一算法

703
00:43:44,670 --> 00:43:47,620
它碰巧在最坏情况里运行次数呈指数增长

704
00:43:47,650 --> 00:43:50,470
所以理论上 它其实是很烂的

705
00:43:50,500 --> 00:43:52,330
但是在实际运用中  它的效果很好

706
00:43:52,360 --> 00:43:53,990
然后最近有一些研究

707
00:43:54,030 --> 00:43:55,280
是来尝试着理解这个的

708
00:43:55,310 --> 00:43:59,740
它还是在最坏情况下运行次数呈指数增长

709
00:43:59,770 --> 00:44:11,930
但是  它很实用  实际上这里有一个有争议的问题

710
00:44:11,960 --> 00:44:15,860
就是是否存在单一算法的变种

711
00:44:15,890 --> 00:44:18,850
能在多项式时间内运行  这里我就不讲了

712
00:44:18,880 --> 00:44:20,270
这是一个主要的争议问题

713
00:44:20,300 --> 00:44:21,660
在这个线性规划的领域里

714
00:44:21,690 --> 00:44:24,130
这个椭球算法是第一个

715
00:44:24,160 --> 00:44:26,550
用来解决多项式时间的线性规划的算法

716
00:44:26,590 --> 00:44:29,730
所以  在很长一段时间里 人们不知道  在那段时间

717
00:44:29,760 --> 00:44:31,790
人们开始意识到多项式时间是个好东西

718
00:44:31,830 --> 00:44:34,040
这大概是在60年代后期

719
00:44:34,080 --> 00:44:35,990
多项式时间是个好东西

720
00:44:36,020 --> 00:44:40,710
椭球算法是第一个这么做的

721
00:44:40,740 --> 00:44:42,650
这是一个非常普遍的算法  并且非常的有效

722
00:44:42,670 --> 00:44:45,340
理论上来说  但完全不实用  不过它很酷炫

723
00:44:45,370 --> 00:44:47,750
它让你做一些事情  像是你可以在多项式时间内

724
00:44:47,780 --> 00:44:51,110
解决一个有指数多个约束的线性规划

725
00:44:51,140 --> 00:44:52,880
你可以得到各种各样的疯狂的东西

726
00:44:52,900 --> 00:44:56,520
所以 我只会说它是多项式时间

727
00:44:56,540 --> 00:44:59,930
我真的说不出什么好话了

728
00:44:59,950 --> 00:45:02,430
但我们不说它  它很不实用

729
00:45:02,470 --> 00:45:06,880
内点法类似是一种混合

730
00:45:06,920 --> 00:45:08,960
它们在多项式时间里运行  这个可以保证

731
00:45:09,000 --> 00:45:12,160
然后  它们也同样很实用

732
00:45:12,180 --> 00:45:14,440
这些天有些这样的争论

733
00:45:14,470 --> 00:45:16,190
关于单一算法和内点法哪个更好

734
00:45:16,230 --> 00:45:18,030
不知道今天是怎样

735
00:45:18,060 --> 00:45:19,720
但是在几年前它们是并驾齐驱的

736
00:45:19,740 --> 00:45:23,480
而且随即抽样是一个全新的方式

737
00:45:23,510 --> 00:45:27,280
这是几年前两个MIT教授

738
00:45:27,300 --> 00:45:31,090
Dimitris Bertsimas 和 Santosh Vempala搞的

739
00:45:31,110 --> 00:45:35,560
一个搞电子工程的 我猜另一个是教应用数学的

740
00:45:35,600 --> 00:45:37,390
所以 只是为了告诉你们

741
00:45:37,420 --> 00:45:38,860
这个领域相当活跃

742
00:45:38,890 --> 00:45:40,920
人们仍旧在寻找新的方法来解决线性规划

743
00:45:40,950 --> 00:45:43,390
这完全是随机的  并且十分简单

744
00:45:43,440 --> 00:45:45,380
十分普通  它还没有被运用

745
00:45:45,420 --> 00:45:46,760
所以 我们还不知道它是否实用

746
00:45:46,780 --> 00:45:50,440
但是  它有潜力  好的就这么多了

747
00:45:52,820 --> 00:45:54,550
我们继续看

748
00:45:54,580 --> 00:45:56,210
一个稍微简单一点的线性规划

749
00:45:59,230 --> 00:46:01,320
我们要去做的第一个限制

750
00:46:01,350 --> 00:46:02,710
实际上并不是一个限制

751
00:46:02,730 --> 00:46:06,630
但是虽然如此  我们还是会考虑它

752
00:46:10,060 --> 00:46:12,870
它比较容易弄懂  所以在这里

753
00:46:12,900 --> 00:46:16,830
我们有一些多面体 我们想要把一些目标最大化

754
00:46:16,860 --> 00:46:19,570
在可行性问题上 我只想知道

755
00:46:19,600 --> 00:46:20,730
多面体是不是空的

756
00:46:20,760 --> 00:46:22,820
你能找到在多面体里的任何一个点吗？

757
00:46:22,840 --> 00:46:25,080
你能找到任何一系列的x值

758
00:46:25,110 --> 00:46:26,580
来满足那些约束吗？

759
00:46:28,290 --> 00:46:34,070
好了 所以这里没有目标函数c

760
00:46:34,090 --> 00:46:40,650
只要找到x  使得Ax小于等于B就好

761
00:46:40,680 --> 00:46:44,000
好了 结论是你可以证明一个非常普遍的理论

762
00:46:44,030 --> 00:46:45,690
如果你可以解决线性可行性

763
00:46:45,720 --> 00:46:47,860
那你也能够解决线性规划

764
00:46:47,890 --> 00:46:52,340
我们不会在这里证明这点  但是实际上它并不比

765
00:46:52,370 --> 00:46:54,800
原来的问题简单  即使它感觉起来更简单

766
00:46:54,820 --> 00:46:55,900
而且考虑起来也很容易

767
00:46:55,920 --> 00:47:00,370
我只是说实际上它不比线性规划简单

768
00:47:09,450 --> 00:47:12,320
好了  我们下一个要做的限制

769
00:47:12,340 --> 00:47:13,460
是个真正的限制条件

770
00:47:13,500 --> 00:47:15,650
它使这个问题简化了很多

771
00:47:27,400 --> 00:47:30,660
而且是用在不同的约束条件下

772
00:47:39,960 --> 00:47:42,670
如果这些现在看上去有那么点的抽象

773
00:47:42,710 --> 00:47:44,690
我们现在来点预备知识

774
00:47:44,720 --> 00:47:48,680
一个有不同约束的系统

775
00:47:48,730 --> 00:47:51,060
是一个线性的可行性问题

776
00:47:51,090 --> 00:47:53,950
所以 这是一个没有目标的线性规划

777
00:47:57,770 --> 00:48:01,100
并且带有一个限制

778
00:48:01,130 --> 00:48:17,340
矩阵每行  呃  在矩阵A里

779
00:48:17,380 --> 00:48:26,510
有一个1   还有一个 -1

780
00:48:29,030 --> 00:48:31,490
剩下的在那行里的每一个都是零

781
00:48:34,180 --> 00:48:38,160
好了  换句话说  每一个约束

782
00:48:38,200 --> 00:48:41,820
有它很简单的形式

783
00:48:41,860 --> 00:48:47,960
它涉及了两个变量和一些数

784
00:48:48,000 --> 00:48:52,980
所以 我们有了一些像x_j - x_i

785
00:48:53,020 --> 00:48:55,550
小于等于W_ij

786
00:48:55,580 --> 00:48:59,370
所以 这仅仅是个数字 它们是两个变量

787
00:48:59,400 --> 00:49:02,560
这里有个一个减号 这里没有其他值

788
00:49:02,600 --> 00:49:06,080
没有系数 没有其他的x_k出现

789
00:49:06,110 --> 00:49:09,240
只有它们两个 然后你有了一连串的

790
00:49:09,270 --> 00:49:11,900
这种形式的约束条件  矩阵里每一行一个

791
00:49:11,930 --> 00:49:16,880
我还没想过它的几何意义

792
00:49:16,920 --> 00:49:20,030
我想这意味着超平面都很简单

793
00:49:20,060 --> 00:49:22,940
不好意思我也不知道了

794
00:49:22,960 --> 00:49:24,510
在多维里想象这个有点难

795
00:49:24,540 --> 00:49:29,250
但是 它开始和我们之前见过的东西联系起来

796
00:49:29,280 --> 00:49:32,410
也就是说和旁边这块黑板  很快了

797
00:49:32,430 --> 00:49:37,400
好  现在我很快地举些例子

798
00:49:37,430 --> 00:49:40,580
大致说明一下

799
00:49:53,720 --> 00:49:56,860
这儿是个非常简单的 不同约束组成的式组

800
00:50:09,480 --> 00:50:12,250
和一个解  为什么不呢

801
00:50:16,340 --> 00:50:20,330
解决它并不是特别繁琐

802
00:50:20,350 --> 00:50:22,170
但这里有解

803
00:50:22,190 --> 00:50:24,080
唯一要去检查的是

804
00:50:24,110 --> 00:50:25,660
每一个这里的约束都被满足了

805
00:50:25,690 --> 00:50:27,680
x_1-x_2是3

806
00:50:27,700 --> 00:50:29,520
小于等于三 等等

807
00:50:29,550 --> 00:50:31,000
这里可能有一个负值

808
00:50:31,020 --> 00:50:33,720
也可能有一个正值  都可以

809
00:50:39,620 --> 00:50:45,850
我现在想把这个

810
00:50:45,880 --> 00:50:49,870
有不同约束的式组变成一张图

811
00:50:49,900 --> 00:50:52,030
因为我们知道很多关于图的东西

812
00:50:52,070 --> 00:50:55,260
所以 我们把这个叫做约束图

813
00:51:01,420 --> 00:51:04,340
然后 它将代表这些约束

814
00:51:04,360 --> 00:51:06,860
我要怎么做？ 我把每一个约束

815
00:51:06,900 --> 00:51:08,930
总之看上去是这样

816
00:51:08,960 --> 00:51:14,350
然后我把它看成一条边

817
00:51:24,170 --> 00:51:26,870
好了 所以如果我写它是x_j - x_i

818
00:51:26,890 --> 00:51:29,240
小于等于W_ji

819
00:51:29,270 --> 00:51:31,290
w一看就知道是指权值

820
00:51:31,320 --> 00:51:33,360
准确来说这就是我们叫它w的原因

821
00:51:33,400 --> 00:51:37,420
我要让它成为从v_i到v_j的一条边

822
00:51:37,450 --> 00:51:39,500
顺序有点不一样

823
00:51:39,530 --> 00:51:41,940
那条边的权值是W_ij

824
00:51:41,970 --> 00:51:45,350
所以 只要这么做 做出n个顶点

825
00:51:45,380 --> 00:51:50,970
那么就得出顶点数等于n

826
00:51:51,000 --> 00:51:54,160
边的数量等于约束的数量

827
00:51:54,200 --> 00:51:56,210
就是m  也是矩阵的高度

828
00:51:56,230 --> 00:51:58,980
然后只要换算一下  举个例子

829
00:51:59,020 --> 00:52:04,090
这儿我们有三个变量 所以 我们有三个顶点

830
00:52:04,110 --> 00:52:11,000
v_1 v_2 v_3  我们有x_1 - x_2

831
00:52:11,030 --> 00:52:14,930
所以我们有一条从v_2到v_1的边  权值是3

832
00:52:14,960 --> 00:52:17,240
我们有x_2 - x_3

833
00:52:17,280 --> 00:52:21,880
所以 我们有一条从V3到V2的边  权值是-2

834
00:52:21,920 --> 00:52:24,250
然后我们于X1-X3

835
00:52:24,270 --> 00:52:27,610
所以 我们有一条边从v_3到v_1权值是2

836
00:52:27,650 --> 00:52:29,830
我希望我的方向是正确的

837
00:52:29,870 --> 00:52:33,820
好的  这就是这个图

838
00:52:33,840 --> 00:52:40,090
现在和最短路径看不出明显的联系 是么

839
00:52:40,120 --> 00:52:41,870
但是 事实上

840
00:52:41,910 --> 00:52:46,740
这个约束条件已经很接近最短路径了

841
00:52:46,770 --> 00:52:48,960
所以 让我来重写一遍  你可以说

842
00:52:48,990 --> 00:52:55,490
x_j小于等于x_i + W_ij

843
00:52:55,510 --> 00:52:57,930
或者 你可以这么想

844
00:52:57,970 --> 00:53:04,290
d[j]小于等于d[i] + w_ij

845
00:53:04,330 --> 00:53:08,410
这是一个泡泡里面是概念

846
00:53:08,440 --> 00:53:11,550
是不是看上去好眼熟？

847
00:53:11,580 --> 00:53:14,640
像极了三角不等式和松弛操作

848
00:53:14,680 --> 00:53:16,030
所以 这里有一个很紧密的联系

849
00:53:16,080 --> 00:53:18,290
在这两个我们现在要证明的问题之间

850
00:53:41,200 --> 00:53:43,930
所以 我们会有两个定理

851
00:53:43,960 --> 00:53:49,630
而且 它很像Bellman-ford在负权环中的正确性验证

852
00:53:49,650 --> 00:53:51,780
他们都讨论负权环的情况

853
00:53:51,810 --> 00:53:55,880
开始 它证明了

854
00:53:55,910 --> 00:53:57,310
我们有这个约束图

855
00:53:57,340 --> 00:53:58,440
它可能有负权值

856
00:53:58,470 --> 00:53:59,780
也可能有正权值

857
00:53:59,810 --> 00:54:01,590
我们发现关键的是

858
00:54:01,610 --> 00:54:02,630
如果你有一个负权环

859
00:54:02,660 --> 00:54:06,130
所以第一件要去证明的是

860
00:54:06,150 --> 00:54:08,070
假如你有一个负权环

861
00:54:10,940 --> 00:54:12,820
那就糟糕了

862
00:54:12,850 --> 00:54:14,580
什么糟糕的事情？

863
00:54:14,620 --> 00:54:16,160
嗯哼  我们尝试着

864
00:54:16,200 --> 00:54:17,610
满足这个约束式组

865
00:54:17,640 --> 00:54:19,550
所以  最坏的事是这里可能无解

866
00:54:19,570 --> 00:54:21,330
这些参数可能是不可行的

867
00:54:21,370 --> 00:54:23,170
就是这样

868
00:54:23,200 --> 00:54:27,670
这个理论实际上是“当且仅当”

869
00:54:27,710 --> 00:54:29,670
但是首先我们想证明“当”

870
00:54:29,690 --> 00:54:33,820
如果你只有一个负权环  你就gg吧

871
00:54:33,850 --> 00:54:38,420
有些参数有可能不满足条件

872
00:54:38,440 --> 00:54:42,150
只是比较直接地来解释它

873
00:54:42,170 --> 00:54:45,400
在线性规划里  它们叫做不可行的

874
00:54:45,420 --> 00:54:48,090
但是说“不满足”更容易理解

875
00:54:48,120 --> 00:54:51,090
没有办法找到一个x_i

876
00:54:51,130 --> 00:54:53,590
来同时满足所有的限制条件

877
00:54:53,630 --> 00:54:56,980
所以我们来看一下

878
00:54:57,010 --> 00:54:59,730
考虑一个负权环

879
00:54:59,760 --> 00:55:03,460
它从某个顶点开始  经过了一些顶点

880
00:55:03,490 --> 00:55:04,760
在某些点又回来了

881
00:55:04,790 --> 00:55:07,180
我不在乎是否它重复了顶点

882
00:55:07,200 --> 00:55:10,860
只要这个循环  从v_1到v_1

883
00:55:10,890 --> 00:55:14,680
是一个负权环  严格负的权值

884
00:55:23,870 --> 00:55:25,950
好了  接下来我要做的是

885
00:55:25,980 --> 00:55:27,640
仅仅写下所有的系数

886
00:55:27,680 --> 00:55:30,300
这里的每一条边对应一个约束

887
00:55:30,330 --> 00:55:32,930
一定是这个约束集里某一个

888
00:55:32,960 --> 00:55:34,220
因为我们有那个图

889
00:55:34,250 --> 00:55:37,900
这些是所有的边  让我们看一下它们给了我们什么

890
00:55:37,920 --> 00:55:40,520
那么 我们有一条从v_1到v_2的边

891
00:55:40,540 --> 00:55:44,280
对应x_2 - x_1

892
00:55:44,300 --> 00:55:46,770
最多是什么  是W_12

893
00:55:46,810 --> 00:55:50,430
然后我们有了x_3 - x_2

894
00:55:52,660 --> 00:55:55,850
这是权值W_23   等等等等

895
00:55:55,880 --> 00:56:01,860
最终我们得到了一些像x_k - x_(k-1)

896
00:56:01,890 --> 00:56:10,600
这是这条边 W_(k-1)k

897
00:56:10,640 --> 00:56:15,620
最后我们有了这条边  绕过来

898
00:56:15,650 --> 00:56:28,740
这是x_1 - x_k W_k1  如果符号对的话

899
00:56:28,770 --> 00:56:31,150
好的  所以这里有一连串的约束

900
00:56:31,190 --> 00:56:32,540
那要怎么处理？

901
00:56:38,060 --> 00:56:42,170
关于这些约束 有谁发现什么有趣的东西了没？

902
00:56:42,210 --> 00:56:51,070
我是说 在式子的左边？不好意思？

903
00:56:51,100 --> 00:56:57,100
听上去像是正确答案  什么？

904
00:56:57,130 --> 00:56:59,740
缩进法 对 很好

905
00:56:59,770 --> 00:57:02,140
全部都抵消了  如果我把这些加上去

906
00:57:02,180 --> 00:57:03,940
这里有一个x_2和一个 -x_2

907
00:57:03,960 --> 00:57:06,030
这里有一个-x_1和一个x_1

908
00:57:06,060 --> 00:57:07,860
这里有个-x_k和一个x_k

909
00:57:07,880 --> 00:57:10,710
所有都抵消了  如果左手边加起来

910
00:57:10,740 --> 00:57:13,150
那么  如果右边加起来会发生什么？

911
00:57:13,170 --> 00:57:15,670
到这里我得到零  我最喜欢的答案

912
00:57:15,700 --> 00:57:21,420
到这  我们得到了负权环里

913
00:57:21,460 --> 00:57:23,140
所有边的权值

914
00:57:23,170 --> 00:57:26,730
就是循环的权值  是负的

915
00:57:26,760 --> 00:57:31,470
所以  零严格地小于零  矛盾

916
00:57:31,500 --> 00:57:34,230
矛盾  等一下

917
00:57:34,260 --> 00:57:36,000
我们并没有假设任何东西是错的

918
00:57:36,030 --> 00:57:37,860
所以 这并不是一个真正的矛盾

919
00:57:37,900 --> 00:57:39,220
在数学角度上

920
00:57:39,240 --> 00:57:40,590
我们并没有和世界矛盾

921
00:57:40,620 --> 00:57:43,460
我们只是说这些约束是矛盾的

922
00:57:43,490 --> 00:57:47,120
换句话说 如果你取任何一个x_i的值

923
00:57:47,150 --> 00:57:48,920
没有办法说这些都可以成立

924
00:57:48,950 --> 00:57:50,890
因为你会得到矛盾答案

925
00:57:50,920 --> 00:57:53,680
所以 对于这些约束来讲是不可能

926
00:57:53,710 --> 00:58:00,510
由一些实数x_i满足   这些一定是不能满足的

927
00:58:00,540 --> 00:58:05,070
我们说这里找不到一个皆大欢喜的解

928
00:58:05,100 --> 00:58:13,460
更准确地说  x_1直到x_m  都没有权值

929
00:58:13,490 --> 00:58:15,180
能够满足这些约束

930
00:58:15,210 --> 00:58:18,570
因为它们左手边加起来是零

931
00:58:18,600 --> 00:58:19,900
右边加起来又是负的

932
00:58:19,930 --> 00:58:23,450
好的  这是一个简单的证明

933
00:58:23,470 --> 00:58:25,620
反向证明会难一点点

934
00:58:31,670 --> 00:58:35,320
好  不错  我们有了个这个联系  所以我们要这样想

935
00:58:35,350 --> 00:58:37,420
假设你想要解这些不等式组

936
00:58:37,440 --> 00:58:39,160
我们将看到一个这样的应用

937
00:58:39,180 --> 00:58:44,570
我谷歌了下差分约束系统

938
00:58:44,610 --> 00:58:45,670
有相当一部分这方面的研究

939
00:58:45,690 --> 00:58:47,230
关于差分约束系统的

940
00:58:47,270 --> 00:58:50,310
他们都用了最短路径来解决

941
00:58:50,340 --> 00:58:53,470
所以 如果我们能证明最短路径——

942
00:58:53,500 --> 00:58:55,810
这我们知道如何计算的——和差分约束系统的联系

943
00:58:55,840 --> 00:58:57,170
我们将发现一些有趣的东西

944
00:58:57,200 --> 00:58:58,740
下一节课将会看到

945
00:58:58,780 --> 00:59:00,620
甚至更多的关于差分约束系统的运用

946
00:59:00,650 --> 00:59:03,690
你会发现它们真的很有用

947
00:59:03,720 --> 00:59:06,340
对于全对最短路径问题来说

948
00:59:08,480 --> 00:59:11,060
好了 不过现在让我们仅仅证明

949
00:59:11,080 --> 00:59:12,890
这个等价关系  然后结束这节课

950
00:59:16,200 --> 00:59:18,410
所以这个反向证明是  如果

951
00:59:18,440 --> 00:59:25,010
在这个参数图里有负权环

952
00:59:30,360 --> 00:59:35,460
那么这个系统就应该是可以满足的  我们说

953
00:59:35,490 --> 00:59:37,480
这些负权环是唯一的障碍

954
00:59:37,510 --> 00:59:46,320
在求解这些不等式组的时候

955
00:59:52,100 --> 00:59:57,220
我在这里有一种感觉

956
00:59:57,250 --> 01:00:00,090
我得讲讲约束图  很好

957
01:00:10,750 --> 01:00:24,950
满足的 很好 那么  我们将看到一个技巧

958
01:00:24,980 --> 01:00:28,100
当我们考虑最短路径问题的时候很有用

959
01:00:28,130 --> 01:00:30,710
这有一点点难想到

960
01:00:30,740 --> 01:00:32,470
尤其是当你之前没有见过它的时候

961
01:00:32,490 --> 01:00:35,210
在做练习和考试的时候很有用

962
01:00:35,240 --> 01:00:38,280
所以  把这个记住

963
01:00:38,320 --> 01:00:42,560
我的意思是  我证明它不仅是为了得到一个定理

964
01:00:42,600 --> 01:00:45,980
更是要得到修改约束图的思想

965
01:00:46,010 --> 01:00:48,180
我把这叫做约束图G

966
01:00:48,200 --> 01:00:51,110
修改图是一个非常有用的想法

967
01:00:51,150 --> 01:01:01,860
所以 我们就加一个新的顶点S

968
01:01:01,890 --> 01:01:07,460
或者源点  用这个源

969
01:01:07,500 --> 01:01:14,500
看  我们还要加上一连串从s出发的边

970
01:01:14,530 --> 01:01:16,010
因为作为一个初始点

971
01:01:16,040 --> 01:01:17,860
它最好连上一些东西

972
01:01:17,890 --> 01:01:20,950
所以我们将加一个零权值的边

973
01:01:20,980 --> 01:01:24,950
或者从s到任何地方的零权值的边

974
01:01:31,330 --> 01:01:34,310
那么对于每个在参数图里的其他顶点

975
01:01:34,350 --> 01:01:37,000
那些顶点被叫做v_i  v_1到v_n

976
01:01:37,030 --> 01:01:40,190
这就是约束图

977
01:01:40,220 --> 01:01:43,220
我抄一遍  这样可以改写一下

978
01:01:45,730 --> 01:01:47,810
备份总是明智的选择

979
01:01:47,830 --> 01:01:49,550
尤其是在你做些更改前  不是么

980
01:01:51,680 --> 01:01:55,760
所以现在 我想要加上一个新的顶点s 在这里

981
01:01:55,790 --> 01:01:58,450
我的新的源 我只是利用了我的参数图

982
01:01:58,480 --> 01:02:01,530
无论它是什么样的  加进零权重的边

983
01:02:01,550 --> 01:02:09,030
到所有其它的点上   灰常简单

984
01:02:09,080 --> 01:02:14,400
现在  我做了什么？  你做了神马哇？

985
01:02:14,430 --> 01:02:17,970
我现在有了一个候选源

986
01:02:18,020 --> 01:02:19,530
它可以到达所有的顶点

987
01:02:19,560 --> 01:02:21,910
所以 从s的最短途径

988
01:02:21,950 --> 01:02:24,830
理想情况下 从s出发的路径是存在的

989
01:02:24,860 --> 01:02:27,910
我只要不超过零的权值 就可以从s到任何地方

990
01:02:27,940 --> 01:02:35,560
好了 可能小一些 它可以变小些么？  你看

991
01:02:35,590 --> 01:02:38,300
像 v_2 我可以通过0-2来得到

992
01:02:38,330 --> 01:02:39,680
所以 这比零小

993
01:02:39,720 --> 01:02:41,020
所以这里我要小心一点

994
01:02:41,050 --> 01:02:42,640
假设这里出现了负权环会怎样

995
01:02:42,670 --> 01:02:44,950
雅蠛蝶啊  这样的话就不会有最短途径了

996
01:02:44,970 --> 01:02:47,200
幸运的是  我们假设

997
01:02:47,240 --> 01:02:49,070
在原图里没有负权环

998
01:02:49,100 --> 01:02:50,610
如果你思考一下它

999
01:02:50,640 --> 01:02:52,970
如果在原图里没有负权环

1000
01:02:53,000 --> 01:02:56,550
我们加了一条从s到任何地方的边

1001
01:02:56,580 --> 01:02:59,240
我们没有做任何新的负权环

1002
01:02:59,280 --> 01:03:00,640
因为你可以从s开始

1003
01:03:00,670 --> 01:03:02,170
从s去某些地方的花费为0

1004
01:03:02,190 --> 01:03:03,580
这不影响任何权值

1005
01:03:03,620 --> 01:03:06,170
然后 你们被强制留在旧图里

1006
01:03:06,200 --> 01:03:08,630
所以 这不可能有任何新的负权环

1007
01:03:08,680 --> 01:03:13,520
所以 被修改的图没有负权环

1008
01:03:13,540 --> 01:03:18,140
这不错 因为它也有从s出发的路径

1009
01:03:18,170 --> 01:03:20,310
因此它也有从s出发的最短路径

1010
01:03:20,330 --> 01:03:30,100
修改了的图没有负权值

1011
01:03:34,300 --> 01:03:39,810
因为它之前并没有 然后 它有从s出发的路径

1012
01:03:42,420 --> 01:03:45,240
这里有一条从s到每个顶点的路径

1013
01:03:45,270 --> 01:03:47,200
可能之前没有

1014
01:03:47,220 --> 01:03:50,000
在之前 我不能从v_2到v_3  比如说

1015
01:03:50,040 --> 01:03:52,570
好吧 现在仍然是这样

1016
01:03:52,600 --> 01:03:54,620
但是从s出发我可以到任何地方

1017
01:03:54,650 --> 01:03:58,660
所以 这意味着这个图 这个修改后的图

1018
01:03:58,690 --> 01:04:01,740
有最短路径 从s出发 最短路径存在

1019
01:04:05,830 --> 01:04:08,770
换句话说 如果我取了所有的最短路径权值

1020
01:04:08,800 --> 01:04:11,330
像我从s起运行Bellman-ford算法 然后

1021
01:04:11,360 --> 01:04:15,970
我能得到一连串有限的数字 d[v]

1022
01:04:15,990 --> 01:04:19,540
对于每一个值 每一个顶点

1023
01:04:23,910 --> 01:04:26,130
这看上去是个好主意 让我们来试试

1024
01:04:26,160 --> 01:04:29,820
所以 最短路径存在

1025
01:04:29,860 --> 01:04:35,020
让我们就标记x_i是

1026
01:04:35,040 --> 01:04:37,790
从s到v_i的最短路径权值

1027
01:04:37,820 --> 01:04:43,970
为什么不呢？  对于实际数字来说这样很好

1028
01:04:44,000 --> 01:04:46,370
从s到v_i的最短路径

1029
01:04:46,410 --> 01:04:48,890
这是有限的因为它比无穷大小

1030
01:04:48,920 --> 01:04:51,260
而且它比无穷小大

1031
01:04:51,290 --> 01:04:53,620
所以 一些有限的数字

1032
01:04:53,650 --> 01:04:54,910
这就是需要用到的东西

1033
01:04:54,950 --> 01:04:56,640
来满足这些约束条件

1034
01:04:56,670 --> 01:05:00,030
这个观点是说这是个可以满足的工作

1035
01:05:00,060 --> 01:05:03,390
为什么？三角不等式

1036
01:05:03,420 --> 01:05:07,410
在这里某些地方我们写了三角不等式

1037
01:05:07,440 --> 01:05:09,340
这看上去很像三角不等式

1038
01:05:09,370 --> 01:05:10,900
事实上  我觉得这个快证完了

1039
01:05:10,930 --> 01:05:12,720
我们看看

1040
01:05:12,750 --> 01:05:16,720
我们想要的是确保成立的是

1041
01:05:16,750 --> 01:05:20,460
x_j - x_i小于等于W_ij

1042
01:05:20,490 --> 01:05:25,580
无论何时ij是一条边  或者我们说(v_i,v_j)

1043
01:05:25,610 --> 01:05:27,540
对于每一个这样的参数

1044
01:05:27,560 --> 01:05:31,200
所以 对于在边集里的(v_i,v_j)

1045
01:05:31,220 --> 01:05:35,210
好  这个什么时候成立？

1046
01:05:35,240 --> 01:05:40,240
好吧 让我们先把它展开  所以x_i是这个δ

1047
01:05:40,270 --> 01:05:43,680
而且x_j是另外的什么δ  所以我们有

1048
01:05:43,710 --> 01:05:51,840
δ(s,v_j)-δ(s,v_i)  然后在右手边

1049
01:05:51,870 --> 01:05:54,740
Wij 这是从i到j的边权

1050
01:05:54,780 --> 01:05:58,650
所以 这是v_i到v_j的权值

1051
01:05:58,680 --> 01:06:01,970
这里重新写一下

1052
01:06:02,010 --> 01:06:08,330
δ(s,v_j) 小于等于

1053
01:06:08,350 --> 01:06:13,890
δ(s,v_i)+W(v_i,v_j)

1054
01:06:13,930 --> 01:06:17,540
这差不多就是个三角不等式

1055
01:06:17,570 --> 01:06:20,410
从s到v_j的最短路径最多是

1056
01:06:20,440 --> 01:06:21,480
是从s到v_j的最短路径

1057
01:06:21,510 --> 01:06:24,030
加上一条具体的从v_i到v_j的路径

1058
01:06:24,070 --> 01:06:26,200
换句话说 从v_i到v_j的那条单边

1059
01:06:26,230 --> 01:06:29,340
这个只能比最短路径长

1060
01:06:29,370 --> 01:06:30,880
所以 这令右手边数值变得更大

1061
01:06:30,910 --> 01:06:32,840
这让这个不等式更加成立

1062
01:06:32,870 --> 01:06:35,890
就是说它以前成立  现在也还是成立

1063
01:06:35,910 --> 01:06:38,060
这就证明了 这个是成立的

1064
01:06:38,100 --> 01:06:41,190
这些全都是平行的描述

1065
01:06:41,220 --> 01:06:44,160
这些我们通过三角不等式证明这个是成立的

1066
01:06:44,200 --> 01:06:46,570
因此  这些条件都被满足

1067
01:06:46,600 --> 01:06:54,400
灰常神奇  我现在热情高涨啊

1068
01:06:54,440 --> 01:06:57,740
所以  我们已经证明了

1069
01:06:57,770 --> 01:07:00,010
负权环出现刚好是当

1070
01:07:00,060 --> 01:07:03,460
这些不等式组不能被满足时

1071
01:07:03,490 --> 01:07:05,880
所以  如果我们想要满足它们

1072
01:07:05,910 --> 01:07:07,480
如果我们想要找到x的解

1073
01:07:07,520 --> 01:07:09,070
我们用Bellman-ford算法

1074
01:07:09,100 --> 01:07:11,430
要么它说  哦  不能给我负权环

1075
01:07:11,460 --> 01:07:13,900
然后你们被泼了一头冷水  然后 就没有然后了

1076
01:07:13,930 --> 01:07:15,700
但这是你们能得到的最好的答案了

1077
01:07:15,730 --> 01:07:18,120
否则  它会说

1078
01:07:18,140 --> 01:07:19,700
这里没有负权环

1079
01:07:19,740 --> 01:07:21,090
这是你们的最短路径权值

1080
01:07:21,120 --> 01:07:22,470
你们只要把它们代进去  然后 见证奇迹吧

1081
01:07:22,500 --> 01:07:25,620
你得到了满足这些约束条件的x_i

1082
01:07:25,660 --> 01:07:28,170
很好 现在 它不只是图

1083
01:07:28,210 --> 01:07:29,850
我的意思是  我们从代数形式的约束开始

1084
01:07:29,880 --> 01:07:33,370
我们通过这种变换将它变成了图

1085
01:07:33,410 --> 01:07:35,380
然后我们给图添加了一个源顶点s

1086
01:07:35,400 --> 01:07:39,220
所以  我的意思是  我们要建立一个图来解决我们的问题

1087
01:07:39,240 --> 01:07:41,910
非常强大的想法  现在我们只用代进数值

1088
01:07:41,910 --> 01:07:44,340
运行Bellman-ford算法 结果就出来了

1089
01:07:44,340 --> 01:07:47,090
酷  这是化简的想法

1090
01:07:47,130 --> 01:07:49,910
你可以把未知的问题

1091
01:07:49,940 --> 01:07:51,540
化简为已知的问题来解决掉

1092
01:07:51,570 --> 01:07:53,740
你知道如何解决最短路径

1093
01:07:53,790 --> 01:07:55,670
如果是没有负权环的话  或者

1094
01:07:55,700 --> 01:07:58,350
用Bellman-ford算法发现这里有一个的负权环

1095
01:07:58,370 --> 01:08:01,390
所以 现在我们知道如何来解不等式组了

1096
01:08:01,410 --> 01:08:05,350
这说明  你甚至可以做更多

1097
01:08:05,380 --> 01:08:11,230
Bellman-ford算法比

1098
01:08:11,270 --> 01:08:13,140
只是解决这些约束能做的更多

1099
01:08:13,170 --> 01:08:16,950
但是首先让我写下来

1100
01:08:16,980 --> 01:08:19,000
我之前强调的部分

1101
01:08:19,030 --> 01:08:24,810
这个推论你可以用Bellman-ford算法推导

1102
01:08:24,850 --> 01:08:30,790
我的意思是 你做了这个图 然后你运用Bellman-ford算法

1103
01:08:30,830 --> 01:08:36,650
然后它会解出你的差分约束不等式组

1104
01:08:36,700 --> 01:08:39,950
所以 让我在这里给些数字

1105
01:08:40,010 --> 01:08:42,690
你有了m个不同的约束

1106
01:08:42,730 --> 01:08:46,050
然后你有了n个变量

1107
01:08:52,000 --> 01:08:57,300
然后它会在m*n时间内解出来

1108
01:08:57,340 --> 01:09:00,520
实际上 这些数字有些许增大

1109
01:09:00,560 --> 01:09:04,350
因为我们加上了n条边

1110
01:09:04,390 --> 01:09:05,860
然后我们加上了一个顶点

1111
01:09:05,890 --> 01:09:08,530
但是假设所有的这些数字都是不可忽略的

1112
01:09:08,570 --> 01:09:11,030
m最小是n  那就是O(mn)时间

1113
01:09:14,100 --> 01:09:16,020
好了 尝试着避免这类情况

1114
01:09:16,040 --> 01:09:18,560
它们中的一些接近零

1115
01:09:18,600 --> 01:09:22,980
好  所以一些其他的情况

1116
01:09:23,010 --> 01:09:24,270
就如我刚刚所说的

1117
01:09:24,300 --> 01:09:27,440
我们将要留下这些作为练习

1118
01:09:27,490 --> 01:09:29,660
因为它们没有那么重要

1119
01:09:29,680 --> 01:09:31,320
我们需要的主要的是这个

1120
01:09:31,360 --> 01:09:33,580
但是 一些其他神奇的东西是

1121
01:09:33,620 --> 01:09:39,480
Bellman-ford算法事实上优化了一些目标函数

1122
01:09:39,500 --> 01:09:42,190
所以 我们在说它只是一个可行性问题

1123
01:09:42,210 --> 01:09:44,010
我们只是想知道

1124
01:09:44,040 --> 01:09:45,670
这些约束是否可以被满足

1125
01:09:45,700 --> 01:09:51,250
事实上 你可以加上一个具体的目标函数

1126
01:09:54,880 --> 01:09:57,440
所以 你不能给他一个随机的目标函数

1127
01:09:57,470 --> 01:10:04,000
但是这里有一个有趣的  x_1+x_2+……+x_n

1128
01:10:04,040 --> 01:10:12,600
好吧 但不只是那样 我们有一些约束

1129
01:10:21,640 --> 01:10:25,660
这是线性规划  我想要最大化

1130
01:10:25,700 --> 01:10:29,020
所有x_i的和   并满足所有x_i都是非正数的条件下

1131
01:10:29,050 --> 01:10:32,530
以及这个差分约束不等式组  这个前面有了

1132
01:10:32,570 --> 01:10:34,620
这很好  我们注意到在某个点s

1133
01:10:34,650 --> 01:10:37,250
你可以只用不超过0的代价到达任何地方

1134
01:10:37,270 --> 01:10:39,340
那么 我们知道在这道题里

1135
01:10:39,380 --> 01:10:41,260
所有的x_i是负的

1136
01:10:41,290 --> 01:10:43,130
这没有必要

1137
01:10:43,150 --> 01:10:44,840
但是当你运行Bellman-ford算法 你会发现的确是这样

1138
01:10:44,860 --> 01:10:47,150
所以如果你用Bellman-ford解一个问题

1139
01:10:47,180 --> 01:10:49,460
这不比其他任何事特殊

1140
01:10:49,490 --> 01:10:52,370
你也是会得到非正的x_i

1141
01:10:52,410 --> 01:10:53,880
所以  由于约束的限制

1142
01:10:53,910 --> 01:10:55,500
它实际上让它们在

1143
01:10:55,520 --> 01:10:59,640
L1范数内尽可能地趋近0

1144
01:10:59,680 --> 01:11:01,050
对于这些值的总和

1145
01:11:01,070 --> 01:11:02,680
它使这个和尽可能地靠近了零

1146
01:11:02,710 --> 01:11:04,260
它尝试着让这个值的绝对值里尽可能的小

1147
01:11:08,300 --> 01:11:10,740
好了 它还可以做得更多

1148
01:11:10,770 --> 01:11:15,670
它做饭 它打扫 它找到了最短路径

1149
01:11:15,690 --> 01:11:29,000
它同时使广度最小化   也就是x_i中的最大值

1150
01:11:29,030 --> 01:11:33,960
减去x_i中的最小值

1151
01:11:34,000 --> 01:11:37,160
所以 我的意思是 如果画一条实数轴

1152
01:11:37,190 --> 01:11:39,010
然后这里是x_i们  随便它们在哪里

1153
01:11:39,040 --> 01:11:41,880
它最小化了这段距离

1154
01:11:41,920 --> 01:11:44,170
而零在这里的某个地方

1155
01:11:44,200 --> 01:11:48,670
所以 它尝试让x_i尽可能的紧密

1156
01:11:48,700 --> 01:11:51,460
这实际上是L无限范数

1157
01:11:51,490 --> 01:11:53,200
如果你知道些关于范数的东西

1158
01:11:53,230 --> 01:11:55,370
在你的线性代数课上

1159
01:11:55,410 --> 01:11:56,860
好吧 这是L1范数

1160
01:11:56,890 --> 01:12:00,540
我认为它最小化了每一个线性规划范数

1161
01:12:00,570 --> 01:12:03,510
很好 所以 让我们用它来干点什么吧

1162
01:12:12,150 --> 01:12:14,010
让我们来解个题

1163
01:12:14,040 --> 01:12:17,380
然后我们今天的课就结束了

1164
01:12:17,410 --> 01:12:21,210
下一节课我们会看到真正神奇的东西

1165
01:12:21,230 --> 01:12:23,660
关于这些东西的神奇应用

1166
01:12:23,690 --> 01:12:27,450
现在 我们将看一个很帅气

1167
01:12:27,480 --> 01:12:29,120
又很简明的应用

1168
01:12:31,900 --> 01:12:33,380
也就是VLSI 

1169
01:12:33,410 --> 01:12:36,270
我们讨论过一点 VLSI回路的问题

1170
01:12:36,290 --> 01:12:37,710
分治法问题

1171
01:12:37,740 --> 01:12:39,880
你们有一连串的集成电路片 你想要调整它们

1172
01:12:39,910 --> 01:12:42,900
让某些值最小化 所以  这里有一个

1173
01:12:42,940 --> 01:12:44,990
从VLSI设计中引申出来的具体问题

1174
01:12:45,020 --> 01:12:46,570
这里是其中一个

1175
01:12:50,510 --> 01:12:56,220
你有一堆的集成电路的零件

1176
01:13:00,350 --> 01:13:04,120
你想要以某种方法在你的回路里调整它们

1177
01:13:07,090 --> 01:13:10,470
不让其中任意两个过于靠近

1178
01:13:10,500 --> 01:13:12,260
你至少要有一点距离

1179
01:13:12,290 --> 01:13:14,510
像至少它们不能叠在一起

1180
01:13:14,540 --> 01:13:16,200
也许你要多点空间

1181
01:13:16,230 --> 01:13:18,060
来在中间布线等等

1182
01:13:18,090 --> 01:13:23,340
所以  不把任意两个放置过近

1183
01:13:29,890 --> 01:13:35,150
好了 所以只是给你们一个想法  所以我有一些目标

1184
01:13:35,180 --> 01:13:36,350
对于这个过程

1185
01:13:36,380 --> 01:13:37,940
也不用说得太细

1186
01:13:37,970 --> 01:13:42,140
你有一些零件

1187
01:13:42,180 --> 01:13:45,230
这是材料  集成电路片  等等一些玩意

1188
01:13:45,270 --> 01:13:47,840
不管它们是什么形状

1189
01:13:47,870 --> 01:13:50,090
我只是想能够移动它们

1190
01:13:50,120 --> 01:13:52,460
来让任意点间的间距

1191
01:13:52,500 --> 01:13:53,970
就比如说这个间距

1192
01:13:54,020 --> 01:13:57,710
这个间距应该最少是一些δ

1193
01:13:57,740 --> 01:13:59,650
或者我不想用δ

1194
01:13:59,680 --> 01:14:02,990
让我们用ε  很好 即小数字

1195
01:14:03,020 --> 01:14:06,800
所以  我仅需要分离一下各部分

1196
01:14:06,830 --> 01:14:09,290
对于这个问题十分简单

1197
01:14:09,310 --> 01:14:11,830
就是说那些部分

1198
01:14:11,860 --> 01:14:13,370
是只被允许水平地滑动

1199
01:14:13,410 --> 01:14:14,860
所以 这是一个一维问题

1200
01:14:14,890 --> 01:14:16,100
这些物体是在二维平面里的

1201
01:14:16,130 --> 01:14:19,460
或者无论如何  但是我只能够在x坐标里移动它们

1202
01:14:19,490 --> 01:14:21,280
所以  如果要建模

1203
01:14:21,300 --> 01:14:27,250
我将要看每一部分的左边缘  然后说

1204
01:14:27,280 --> 01:14:30,130
这两个左边缘之间

1205
01:14:30,160 --> 01:14:33,160
至少是有一点距离

1206
01:14:33,190 --> 01:14:35,820
所以我这样想

1207
01:14:35,850 --> 01:14:38,490
无论如何这个距离是加上了一些ε  但是你知道

1208
01:14:38,530 --> 01:14:40,590
如果你要计算一些诡异的二维图形

1209
01:14:40,610 --> 01:14:42,430
这有一点太近了

1210
01:14:42,470 --> 01:14:43,820
因为这些属于一条直线

1211
01:14:43,860 --> 01:14:46,030
但是 这里有一些系数 对于任何的两片

1212
01:14:46,070 --> 01:14:47,700
我能够计算出它们能靠多近

1213
01:14:47,730 --> 01:14:51,270
它们应该不能再近了  那么我把这个标为x_1

1214
01:14:51,300 --> 01:14:54,340
这个标为x_2  那么  我们有了一些约束

1215
01:14:54,360 --> 01:14:59,930
像x_2 - x_1最少是d+ε

1216
01:14:59,960 --> 01:15:02,550
或者无论你算出的权重是什么

1217
01:15:02,580 --> 01:15:08,630
所以对于每一对零件 我可以做相同的事

1218
01:15:08,660 --> 01:15:12,460
计算一些关于它们距离多远的约束

1219
01:15:12,490 --> 01:15:14,730
现在我想要给这些x标上坐标

1220
01:15:14,770 --> 01:15:16,760
现在 我假设它们只是变量

1221
01:15:16,790 --> 01:15:19,340
我想要水平地滑动这些零件为了

1222
01:15:19,380 --> 01:15:21,690
尽可能的使他们紧密

1223
01:15:21,720 --> 01:15:23,510
以便把它们装进尽可能小的电路片里

1224
01:15:23,530 --> 01:15:26,160
因为大电路板要花费更多的钱

1225
01:15:26,200 --> 01:15:28,610
和时间 和任何东西 能量神马的

1226
01:15:28,640 --> 01:15:29,820
你总是想要你的集成电路很小

1227
01:15:29,870 --> 01:15:33,540
那么Bellman-ford算法实现了这个

1228
01:15:33,560 --> 01:15:45,380
所以Bellman-ford解出了这些约束

1229
01:15:51,590 --> 01:15:53,280
因为它只是一堆不等式组

1230
01:15:53,310 --> 01:15:54,730
我们知道它们是可以解决的

1231
01:15:54,760 --> 01:15:57,290
因为你可以把这些零件用任意距离分开

1232
01:15:57,320 --> 01:16:02,180
而且 它最小化了这些宽度

1233
01:16:02,210 --> 01:16:04,860
最小化了我所需集成电路的大小

1234
01:16:04,900 --> 01:16:07,790
最大的x_i值减去最小的x_i值

1235
01:16:11,090 --> 01:16:15,950
那么  这就是集成的最大化

1236
01:16:15,980 --> 01:16:18,500
或者体积的最小化集成电路

1237
01:16:20,310 --> 01:16:22,980
好了 这是一维问题

1238
01:16:23,010 --> 01:16:24,460
所以它可能看上去是刻意为之

1239
01:16:24,490 --> 01:16:28,150
但是二维问题实在很难去解决

1240
01:16:28,180 --> 01:16:29,830
就是这个了  事实上

1241
01:16:29,860 --> 01:16:34,030
这是在不错的多项式时间内解决的最好做法了

1242
01:16:34,070 --> 01:16:36,100
这里有一些其他运用  比如你在把一些事件剪辑进

1243
01:16:36,130 --> 01:16:38,090
呃  像是多媒体中

1244
01:16:38,120 --> 01:16:41,260
而且你想要保证这音频

1245
01:16:41,290 --> 01:16:42,920
至少在视频的两秒后播放

1246
01:16:42,950 --> 01:16:45,500
然后也有要同时播放的东西

1247
01:16:45,540 --> 01:16:47,520
而且它们必须彼此之间有一定的间隔

1248
01:16:47,540 --> 01:16:49,790
所以 有许多关于使用Bellman-ford的研究

1249
01:16:49,820 --> 01:16:51,290
来解决不同的约束

1250
01:16:51,310 --> 01:16:52,910
来建立多媒体文件

1251
01:16:52,940 --> 01:16:56,820
好了  就是这样

1252
01:16:56,860 --> 01:16:58,060
下一节课我们会看到

1253
01:16:58,090 --> 01:16:59,910
关于Bellman-ford算法更多的运用

1254
01:16:59,950 --> 01:17:04,090
来解决全对的最短路径  有问题么

1255
01:17:04,110 --> 01:17:13,020
非常好

