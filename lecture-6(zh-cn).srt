1
00:00:06,680 --> 00:00:09,560
今天我们不再讨论排序

2
00:00:09,560 --> 00:00:12,560
这是个令人兴奋的进步

3
00:00:12,560 --> 00:00:16,560
我们要讨论另外一个问题

4
00:00:16,560 --> 00:00:21,560
一个和排序有关但是又不同的问题

5
00:00:33,560 --> 00:00:34,720
我们要讨论另外一个问题

6
00:00:34,840 --> 00:00:37,010
也用线性时间解决

7
00:00:37,170 --> 00:00:38,670
上节课我们讨论到

8
00:00:38,670 --> 00:00:40,740
我们可以用线性时间排序

9
00:00:40,850 --> 00:00:43,100
只是我们需要一些额外的假设

10
00:00:43,330 --> 00:00:44,430
今天我们要看这样一个问题

11
00:00:44,600 --> 00:00:46,730
这个问题只需要线性时间

12
00:00:46,850 --> 00:00:49,260
即使刚看上去它需要排序

13
00:00:49,800 --> 00:00:51,790
这是一个简单一些的问题

14
00:00:53,960 --> 00:00:56,720
问题是这样的  我给你一些数

15
00:00:59,320 --> 00:01:01,490
我们称它们为元素

16
00:01:04,100 --> 00:01:06,270
假设这些元素在一个数组中

17
00:01:07,390 --> 00:01:10,680
没有一个特别的顺序  即无序

18
00:01:11,480 --> 00:01:18,150
我想找到第k小的数

19
00:01:24,410 --> 00:01:28,020
这个数被称为排名第k的元素

20
00:01:35,560 --> 00:01:38,930
换句话说  我有一组无序的数

21
00:01:39,200 --> 00:01:40,810
假如我能够把这些数排序

22
00:01:40,940 --> 00:01:43,280
我就能知道第k号元素是什么

23
00:01:43,520 --> 00:01:44,700
但是现在不允许排序

24
00:01:44,820 --> 00:01:49,900
解决这个问题的一种原始的方案

25
00:01:51,260 --> 00:01:55,440
是排序并返回第k号元素

26
00:01:55,560 --> 00:01:58,240
这是这个问题的一种解

27
00:01:58,590 --> 00:02:00,290
我们希望有更好的方案

28
00:02:01,110 --> 00:02:04,000
将数组A排序

29
00:02:04,930 --> 00:02:08,560
返回A[k]

30
00:02:09,260 --> 00:02:10,690
是一种我们可以做的方案

31
00:02:11,000 --> 00:02:13,280
如果我们用堆排序或者归并排序

32
00:02:13,480 --> 00:02:15,070
会使用nlogn的时间

33
00:02:16,350 --> 00:02:18,220
我们希望有比nlogn更好的解

34
00:02:19,070 --> 00:02:20,740
最好是线性时间

35
00:02:24,930 --> 00:02:29,970
这个问题是很自然的

36
00:02:30,510 --> 00:02:32,780
这个问题有许多应用

37
00:02:33,480 --> 00:02:35,800
具体是什么取决于你对k的选择

38
00:02:36,010 --> 00:02:38,420
k是1到n之间的任意数

39
00:02:38,530 --> 00:02:43,130
如果我们选k等于1

40
00:02:43,240 --> 00:02:44,740
这个元素有个名字  是什么名字呢

41
00:02:46,140 --> 00:02:47,530
最小值  很简单

42
00:02:50,320 --> 00:02:52,600
有人说下在线性的时间里

43
00:02:52,710 --> 00:02:57,950
我们怎么找到最小的元素  没错

44
00:02:58,090 --> 00:02:59,330
遍历整个数组

45
00:02:59,640 --> 00:03:02,010
记录下你见过的最小的数

46
00:03:02,320 --> 00:03:04,510
求最大值也一样  k=n

47
00:03:06,100 --> 00:03:08,700
求这些值相当没意思

48
00:03:09,940 --> 00:03:11,700
但是这个问题的一个更有趣的版本

49
00:03:11,810 --> 00:03:16,040
是找出中位数

50
00:03:16,930 --> 00:03:22,950
(n+1)/2的向上或者向下取整

51
00:03:24,200 --> 00:03:27,370
这两个元素都叫做中位数

52
00:03:33,300 --> 00:03:35,650
线性时间内找出无序数列的中位数

53
00:03:35,770 --> 00:03:37,660
有点意思

54
00:03:37,860 --> 00:03:40,460
这就是这次课的主要目标

55
00:03:40,620 --> 00:03:41,940
找到中位数

56
00:03:42,050 --> 00:03:43,490
实际上我们任意可以找到

57
00:03:43,600 --> 00:03:47,050
第k小的元素

58
00:03:47,170 --> 00:03:50,020
但有代表性的  我们希望找到中位数

59
00:03:50,280 --> 00:03:53,180
在周五的习题课上  你会知道这为什么很有用

60
00:03:53,380 --> 00:03:55,820
有很多使用分治策略的情况下

61
00:03:56,010 --> 00:03:59,190
你都可以用中位数  而且不需要排序

62
00:04:00,040 --> 00:04:04,350
因此你可以线性解决很多问题

63
00:04:05,690 --> 00:04:09,900
今天我们要谈顺序统计问题的的两个算法

64
00:04:10,010 --> 00:04:11,390
这两个算法都是线性时间

65
00:04:11,740 --> 00:04:13,230
第一个算法是随机的

66
00:04:13,430 --> 00:04:15,180
所以只是期望时间是线性时间

67
00:04:15,560 --> 00:04:18,080
第二个算法考虑最坏情况

68
00:04:18,900 --> 00:04:21,500
以第一个算法为基础

69
00:04:22,660 --> 00:04:29,420
我们先讲一个随机的分治算法

70
00:04:44,560 --> 00:04:47,560
这个算法叫随机选择

71
00:05:00,560 --> 00:05:04,530
参数与你们平时见的不太一样

72
00:05:06,180 --> 00:05:08,460
这个顺序问题里面  已有数组A

73
00:05:08,810 --> 00:05:10,670
这里我改变记号

74
00:05:10,830 --> 00:05:12,570
我要找第i小的元素

75
00:05:12,730 --> 00:05:15,830
所以i是我要找的序号

76
00:05:18,820 --> 00:05:20,930
我还要再改变下问题

77
00:05:21,050 --> 00:05:24,270
我不从整个数组里面找第i个数

78
00:05:24,420 --> 00:05:27,360
而是从其中一段中来找

79
00:05:28,080 --> 00:05:29,570
在A里从p到q找

80
00:05:30,440 --> 00:05:32,270
我们要用那个函数做递归

81
00:05:32,690 --> 00:05:34,110
用递归算法

82
00:05:34,190 --> 00:05:36,110
因为我们要用分治策略

83
00:05:37,510 --> 00:05:38,940
下面是算法

84
00:05:49,520 --> 00:05:52,080
基本情形  这很简单

85
00:05:54,640 --> 00:05:57,810
我们要使用一部分快速排序

86
00:05:59,290 --> 00:06:00,490
随机快速排序

87
00:06:07,900 --> 00:06:11,860
前两节课我们没有真正定义这个子程序

88
00:06:12,020 --> 00:06:14,370
但你应该知道这个函数做什么了

89
00:06:14,910 --> 00:06:16,790
如果你读了课本的话

90
00:06:17,530 --> 00:06:23,310
在数组A从p到q之间

91
00:06:23,460 --> 00:06:25,400
在p和q之间随机找个数

92
00:06:25,680 --> 00:06:28,410
和第一个元素交换  再调用划分函数

93
00:06:28,570 --> 00:06:31,670
划分函数用第一个元素将数组划分成两部分

94
00:06:31,830 --> 00:06:34,520
一部分都小于等于第一个划分元素

95
00:06:34,640 --> 00:06:36,350
另一部分大于等于划分元素

96
00:06:36,520 --> 00:06:40,320
在p和q之间随机选择一个划分

97
00:06:40,630 --> 00:06:45,130
将数组分成可能不相等的两部分

98
00:06:51,760 --> 00:06:55,570
然后返回划分元素的序号

99
00:06:56,950 --> 00:06:58,810
是p和q之间的某个数

100
00:07:00,090 --> 00:07:05,860
我们设k为r-p+1

101
00:07:07,140 --> 00:07:15,540
这么做是因为k是划分元素的序号

102
00:07:17,170 --> 00:07:21,280
它在A[p...q]之中

103
00:07:25,160 --> 00:07:26,990
我画个图

104
00:07:30,320 --> 00:07:33,750
数组A从p开始到q结束

105
00:07:33,870 --> 00:07:36,160
还有其他元素  不过这一步递归我们只考虑

106
00:07:36,290 --> 00:07:39,870
p和q之间的元素

107
00:07:40,020 --> 00:07:42,120
我们随机取一个元素  比如这个

108
00:07:42,510 --> 00:07:47,320
我们把元素从这里划分  假设是r

109
00:07:48,950 --> 00:07:52,060
使得前面的小于或等于A[r]

110
00:07:52,950 --> 00:07:56,290
后面的这些元素都大于等于A[r]

111
00:07:57,220 --> 00:07:59,620
A[r]是划分元素

112
00:08:02,330 --> 00:08:05,740
在调用之后  数组就像这样

113
00:08:05,940 --> 00:08:10,060
r这里是划分元素的位置

114
00:08:10,290 --> 00:08:14,520
小于等于A[r]元素的数目

115
00:08:14,950 --> 00:08:20,570
包括r本身  是r-p+1

116
00:08:20,770 --> 00:08:22,870
这里有r-p个元素

117
00:08:23,260 --> 00:08:26,250
加上这里的一个

118
00:08:26,910 --> 00:08:27,850
如果从1开始计数

119
00:08:27,850 --> 00:08:29,430
如果这是1号  这是2号

120
00:08:29,580 --> 00:08:32,530
那么这个元素会是第k号

121
00:08:34,090 --> 00:08:37,110
可以从划分的结构上得到这些结果

122
00:08:40,870 --> 00:08:44,540
现在我们开始递归  有三种情况

123
00:08:51,790 --> 00:08:54,190
取决于i和k的关系

124
00:08:54,390 --> 00:08:56,600
i是我们要找的序号

125
00:08:56,910 --> 00:09:00,010
k是我们划分元素在划分后的位置

126
00:09:00,130 --> 00:09:01,570
k的位置是巧合

127
00:09:01,840 --> 00:09:03,290
但如果幸运的话i=k

128
00:09:03,290 --> 00:09:04,870
那么就是我们要找的元素

129
00:09:11,420 --> 00:09:13,130
我们只需返回划分元素

130
00:09:14,140 --> 00:09:16,820
更有可能的是  我们寻找的元素

131
00:09:16,930 --> 00:09:20,430
在划分元素的左边或者右边

132
00:09:20,540 --> 00:09:22,910
如果在左边的话  我们递归左边这块

133
00:09:23,110 --> 00:09:25,960
在右边的话  我们递归右边的这块

134
00:09:26,120 --> 00:09:28,020
这点我们很清楚了

135
00:09:44,270 --> 00:09:45,900
现在写在右边的元素

136
00:10:07,030 --> 00:10:10,790
我们要么递归p到r-1的这块

137
00:10:11,080 --> 00:10:13,820
这是这种情况

138
00:10:13,930 --> 00:10:15,950
我们要找的序号在A[r]左边

139
00:10:16,610 --> 00:10:18,370
或者我们递归右边的这块

140
00:10:18,490 --> 00:10:20,570
从r-1到q

141
00:10:22,550 --> 00:10:24,190
当我们在左边这块递归时

142
00:10:24,340 --> 00:10:25,780
我们需找的序号不发生变化

143
00:10:25,890 --> 00:10:27,930
但当我们在右边这块递归时

144
00:10:28,040 --> 00:10:29,350
我们需要做些偏移

145
00:10:29,360 --> 00:10:32,710
因为我们要除去这里的k个元素

146
00:10:32,910 --> 00:10:37,110
这里的长度是k

147
00:10:42,170 --> 00:10:45,420
我们去掉左边的k个元素

148
00:10:46,050 --> 00:10:47,990
在剩下的数组中

149
00:10:48,140 --> 00:10:50,700
我们寻找第i-k小的元素

150
00:10:51,830 --> 00:10:55,550
这就是递归式  我们只做一个递归

151
00:10:56,910 --> 00:10:58,640
随机划分不是递归

152
00:10:58,750 --> 00:11:00,130
这只需要线性时间

153
00:11:01,030 --> 00:11:03,000
我们总共做的工作量应该是

154
00:11:03,280 --> 00:11:06,260
线性的时间加上一次递归

155
00:11:09,300 --> 00:11:10,560
下面我们要看下

156
00:11:11,300 --> 00:11:14,690
预期的运行时间是多少

157
00:11:15,230 --> 00:11:16,860
不过我们首先做个例子

158
00:11:24,660 --> 00:11:27,010
好让你们弄清楚这个算法

159
00:11:27,550 --> 00:11:33,770
假设在数组中找第7小的元素

160
00:11:48,510 --> 00:11:51,230
举个例子

161
00:11:51,500 --> 00:11:54,020
假设我们把第一个元素做为划分元素

162
00:11:55,550 --> 00:11:57,700
这是为了简单起见

163
00:11:57,700 --> 00:11:59,630
如果要随机找个元素我得抛几次硬币

164
00:11:59,710 --> 00:12:01,880
所以我们就选第一个元素

165
00:12:02,310 --> 00:12:04,480
如果我以6作为划分元素

166
00:12:04,800 --> 00:12:08,290
这就是我们两周前讨论的例子

167
00:12:08,990 --> 00:12:10,300
我就不讨论了

168
00:12:10,770 --> 00:12:13,640
我们得到和两周前一样的数组

169
00:12:16,720 --> 00:12:24,160
就是2 5 3 6 8 13 10和11

170
00:12:25,790 --> 00:12:28,380
运行划分算法

171
00:12:28,500 --> 00:12:31,060
元素就会如此排列

172
00:12:31,380 --> 00:12:35,450
这里是r  这里是p

173
00:12:35,610 --> 00:12:38,870
p为1  q是结尾

174
00:12:41,860 --> 00:12:46,060
我要找的是第7小的数

175
00:12:46,250 --> 00:12:48,270
进行划分后

176
00:12:48,460 --> 00:12:50,520
数字6落在了第4的位置

177
00:12:50,790 --> 00:12:53,150
因为左边的小于6

178
00:12:53,230 --> 00:12:55,830
并且右边的大于6

179
00:12:56,140 --> 00:13:00,510
排序后  数字6还是会在第4这个位置

180
00:13:01,100 --> 00:13:02,340
所以r是4

181
00:13:05,130 --> 00:13:09,160
有问题吗  12变成11了

182
00:13:09,320 --> 00:13:10,990
这是11  不管你信不信

183
00:13:13,010 --> 00:13:15,610
写清楚点  不好意思

184
00:13:16,420 --> 00:13:18,250
有时我写的1有点像2

185
00:13:18,480 --> 00:13:24,420
这点不好  不过很好改正

186
00:13:28,490 --> 00:13:29,890
考试的时候可别这样

187
00:13:31,790 --> 00:13:33,810
我那个1其实是2  不行

188
00:13:36,170 --> 00:13:37,470
虽然我们没排序

189
00:13:37,590 --> 00:13:40,670
只是用线性的时间按6划分

190
00:13:40,780 --> 00:13:43,650
我们也知道  如果排序6还是在这里

191
00:13:43,880 --> 00:13:45,240
其他的原始在哪不知道

192
00:13:45,360 --> 00:13:48,150
它们不是顺序的  但是根据划分的性质

193
00:13:48,310 --> 00:13:50,540
6是在正确的位置

194
00:13:50,770 --> 00:13:55,310
6是第4小的  我们要找的是第7小

195
00:13:55,580 --> 00:13:57,460
根据这是第4小的

196
00:13:57,780 --> 00:14:00,060
结果在这边

197
00:14:00,600 --> 00:14:06,800
答案是10  我猜  不  是11

198
00:14:09,610 --> 00:14:11,020
总共有8个元素

199
00:14:11,140 --> 00:14:12,420
所以是第二大

200
00:14:12,580 --> 00:14:14,750
最大值是13  我在作弊

201
00:14:14,900 --> 00:14:16,910
答案是11

202
00:14:18,040 --> 00:14:20,410
我们知道答案在右半边

203
00:14:20,830 --> 00:14:23,860
因为要找第7小  而7大于4

204
00:14:24,190 --> 00:14:25,960
在这部分中是第几小

205
00:14:26,160 --> 00:14:28,800
去掉前面的4个数字

206
00:14:29,270 --> 00:14:34,030
因为p是1  所以k是4

207
00:14:35,000 --> 00:14:36,320
6是第4小的数

208
00:14:36,610 --> 00:14:38,970
去掉前4个数  结果是

209
00:14:39,350 --> 00:14:47,110
7减4等于3

210
00:14:48,280 --> 00:14:51,240
确实是  第3小的数是11

211
00:14:51,400 --> 00:14:53,700
递归的查找  这就是答案

212
00:14:55,990 --> 00:14:58,870
现在算法很清晰了吧

213
00:15:00,570 --> 00:15:02,270
困难的地方是分析它

214
00:15:02,740 --> 00:15:06,940
这里的分析和随机化快速排序类似

215
00:15:07,130 --> 00:15:09,070
尽管没那么复杂

216
00:15:09,460 --> 00:15:10,980
所以能讲快点

217
00:15:11,250 --> 00:15:12,650
但是这也是对随机化快速排序分析

218
00:15:12,800 --> 00:15:15,140
的一次复习  有点复杂

219
00:15:15,920 --> 00:15:18,370
多练两次也有好处

220
00:15:19,690 --> 00:15:22,630
在分析此算法的期望运行时间前

221
00:15:22,790 --> 00:15:29,230
我们照例进行一些概述

222
00:15:30,090 --> 00:15:32,490
就像往常  在开始前

223
00:15:32,630 --> 00:15:36,970
我们通过直觉来自我感觉良好

224
00:15:38,520 --> 00:15:40,540
或者糟糕  马上你就看到了

225
00:15:41,950 --> 00:15:45,320
思考一下两个极端的例子

226
00:15:46,480 --> 00:15:48,420
好的情况和最坏情况

227
00:15:49,580 --> 00:15:52,760
我提前说一点  今天所有的分析的前提是

228
00:15:53,740 --> 00:15:55,680
假设元素不相等

229
00:16:03,060 --> 00:16:05,750
如果有相等元素  就很乱

230
00:16:06,340 --> 00:16:08,670
甚至得修改一下算法

231
00:16:08,780 --> 00:16:10,690
因为如果所有元素都相等

232
00:16:10,690 --> 00:16:12,430
选择一个随机元素

233
00:16:12,550 --> 00:16:14,060
划分效果就很差

234
00:16:14,720 --> 00:16:16,050
我们假设全部都不相等

235
00:16:16,220 --> 00:16:18,360
这才是真正有意思的情况

236
00:16:23,260 --> 00:16:24,580
一个很幸运的情况

237
00:16:26,140 --> 00:16:28,860
最好情况就是在正中划分

238
00:16:29,130 --> 00:16:32,360
划分在左边的元素的数量等于

239
00:16:32,640 --> 00:16:35,160
在右边的元素数

240
00:16:35,510 --> 00:16:41,060
但是1/10到1/9的划分也几乎一样好

241
00:16:41,260 --> 00:16:45,060
任何的常数比例的划分  这样说

242
00:16:45,310 --> 00:16:47,490
都和1/2的划分一样好

243
00:16:48,800 --> 00:16:52,460
得到的递归式是

244
00:16:55,800 --> 00:17:00,650
最坏的情况  这得看情况

245
00:17:00,960 --> 00:17:04,290
假设1/10在左边  9/10在右边

246
00:17:04,410 --> 00:17:06,390
每次划分

247
00:17:07,050 --> 00:17:08,840
情况都不同

248
00:17:08,910 --> 00:17:12,680
如果找的数很小  则在1/10中

249
00:17:12,950 --> 00:17:15,280
如果大  则在9/10中

250
00:17:15,440 --> 00:17:17,280
大多数时候  它会在9/10中

251
00:17:17,470 --> 00:17:21,510
在幸运的情况中作最坏情况分析

252
00:17:22,010 --> 00:17:23,600
我们更乐意得到上界

253
00:17:24,260 --> 00:17:27,440
T(n)最大是T(9/10n)+Θ(n)

254
00:17:28,460 --> 00:17:30,740
显然在更大的这部分  情况更坏

255
00:17:32,260 --> 00:17:34,200
怎么求解这个递归式

256
00:17:36,680 --> 00:17:38,620
解递归式是很早以前的事了

257
00:17:38,770 --> 00:17:41,030
应该用哪种方法

258
00:17:42,270 --> 00:17:44,630
主方法  这是哪一种情况

259
00:17:48,320 --> 00:17:49,490
第三种  正确

260
00:17:50,840 --> 00:17:53,090
你还记得呀  就是第三种

261
00:17:56,830 --> 00:18:00,880
n^(logba)  b是10/9

262
00:18:01,070 --> 00:18:03,550
这并不重要  因为a是1

263
00:18:03,900 --> 00:18:08,350
任意底数的log1都是0  n⁰等于1

264
00:18:09,740 --> 00:18:12,380
n多项式地大于1

265
00:18:14,300 --> 00:18:21,340
结果就是Θ(n)  很好

266
00:18:22,000 --> 00:18:23,740
就是我们想要的  线性时间复杂度

267
00:18:23,900 --> 00:18:25,800
如果够幸运的话  效果很好

268
00:18:26,280 --> 00:18:28,030
不幸的是  这只是直觉

269
00:18:28,220 --> 00:18:30,160
我们并不是每次都是幸运的

270
00:18:31,410 --> 00:18:33,370
我们可以做和随机化快速排序相同

271
00:18:33,480 --> 00:18:34,390
的那些分析

272
00:18:34,500 --> 00:18:36,440
如果交替幸运和不幸运

273
00:18:37,020 --> 00:18:40,400
结果还是好的  再说说不幸运的情况

274
00:18:42,110 --> 00:18:43,700
看看能有多糟

275
00:18:44,050 --> 00:18:46,410
这是真正的最坏情况分析

276
00:18:51,260 --> 00:18:58,850
我们得到了一个0和n-1的划分

277
00:19:00,130 --> 00:19:02,730
因为无论如何我们都去掉了划分元素

278
00:19:02,880 --> 00:19:05,910
没有比划分元素更小的了

279
00:19:06,790 --> 00:19:07,790
左边没有任何元素

280
00:19:07,980 --> 00:19:10,250
右边有n-1个元素

281
00:19:11,420 --> 00:19:18,310
现在的递归式是T(n)=T(n-1)+Θ(n)

282
00:19:19,520 --> 00:19:24,150
结果是多少  n²

283
00:19:24,380 --> 00:19:26,150
对  这个你们应该知道

284
00:19:28,170 --> 00:19:30,790
因为是等差级数  所以是n²

285
00:19:35,830 --> 00:19:36,880
这相当糟糕

286
00:19:37,070 --> 00:19:38,980
比起先排序再选择第i小的元素

287
00:19:39,140 --> 00:19:40,850
还差的很远

288
00:19:42,720 --> 00:19:45,050
最坏情况  这个算法效率巨差

289
00:19:45,630 --> 00:19:48,000
但是大多数时候  它都很好

290
00:19:48,270 --> 00:19:51,020
除非你背到家了

291
00:19:51,180 --> 00:19:55,500
每次掷硬币都输  不然不会如此

292
00:19:55,960 --> 00:19:57,860
你一般会得到一个幸运的情况

293
00:19:58,020 --> 00:19:59,220
至少我们马上就要证明它

294
00:20:01,200 --> 00:20:03,900
我们要证明期望运行时间是线性的

295
00:20:04,290 --> 00:20:06,170
出现二次方复杂度的情况极少

296
00:20:06,520 --> 00:20:09,550
等会儿会将最坏情况也变成线性复杂度

297
00:20:10,520 --> 00:20:13,510
这才真正解决了问题

298
00:20:28,560 --> 00:20:32,560
现在来分析

299
00:20:41,830 --> 00:20:44,310
你们之前见过一个类似的分析

300
00:20:45,070 --> 00:20:46,460
说说该怎么办

301
00:20:48,050 --> 00:20:49,840
为了分析期望运行时间

302
00:20:54,180 --> 00:20:55,160
这是一个分治算法

303
00:20:55,320 --> 00:20:58,250
所以我们希望写出关于运行时间

304
00:20:59,060 --> 00:21:00,380
的递归式

305
00:21:07,400 --> 00:21:10,860
我不要答案  告诉我分析这个算法

306
00:21:11,020 --> 00:21:13,270
期望时间的第一步是什么

307
00:21:15,110 --> 00:21:15,890
能再说一遍吗

308
00:21:16,550 --> 00:21:18,300
看看有哪些不同的情况  完全正确

309
00:21:18,610 --> 00:21:21,770
我们有多种的

310
00:21:21,890 --> 00:21:24,330
划分可能

311
00:21:24,530 --> 00:21:27,800
可能分为0和n-1  也可能对半分

312
00:21:29,340 --> 00:21:32,580
一共有n种划分可能

313
00:21:32,850 --> 00:21:34,950
如何才能分析这么多的情况

314
00:21:40,070 --> 00:21:41,930
指示器随机变量  正确

315
00:21:42,160 --> 00:21:43,440
就是要这样做

316
00:21:44,220 --> 00:21:45,900
指示器随机变量说明

317
00:21:45,970 --> 00:21:48,850
我们处理的不只是函数T(n)

318
00:21:48,960 --> 00:21:50,750
而且是一个随机变量

319
00:21:51,370 --> 00:21:53,270
这点很妙

320
00:21:53,580 --> 00:21:56,230
T(n)依赖随机选择

321
00:21:56,390 --> 00:21:57,940
所以它是一个随机变量

322
00:22:03,500 --> 00:22:05,470
接着我们要使用指示器随机变量

323
00:22:05,550 --> 00:22:07,920
为的是写出T(n)的递归式

324
00:22:24,370 --> 00:22:30,620
T(n)是算法在规模为n下的运行时间

325
00:22:38,510 --> 00:22:43,900
我还要明确的写出

326
00:22:44,910 --> 00:22:47,080
关于随机数的假设

327
00:22:53,750 --> 00:22:56,930
那就是它们的选择是相互独立的

328
00:22:58,830 --> 00:23:00,930
每次调用随机划分时

329
00:23:01,090 --> 00:23:04,070
得到的结果完全独立于

330
00:23:04,230 --> 00:23:06,710
其它时候的调用

331
00:23:06,870 --> 00:23:09,590
要分析是正确的  这点很重要

332
00:23:10,170 --> 00:23:13,600
接下来就能看到为什么

333
00:23:13,870 --> 00:23:17,130
现在  为了写出T(n)的等式

334
00:23:17,790 --> 00:23:21,670
需要定义指示器随机变量

335
00:23:34,670 --> 00:23:36,250
我们称它为Xk

336
00:23:36,520 --> 00:23:42,260
k等于0到n-1

337
00:23:48,880 --> 00:23:51,590
指示器随机变量非1即0

338
00:23:53,300 --> 00:23:56,510
它是1  当划分是

339
00:23:57,100 --> 00:24:00,280
分割后左边的数组长度为k

340
00:24:01,670 --> 00:24:10,020
也就是说数组被分割成k和n-k-1两段

341
00:24:14,160 --> 00:24:15,440
否则  Xk的值为0

342
00:24:18,670 --> 00:24:24,890
所以给定下标从0到n-1的n个值

343
00:24:25,010 --> 00:24:27,340
不管随机选择怎么实现

344
00:24:27,590 --> 00:24:29,220
每种分割对应的Xk值要么为1

345
00:24:29,490 --> 00:24:30,700
要么为0

346
00:24:31,120 --> 00:24:36,090
现在我们根据不同情况

347
00:24:36,400 --> 00:24:37,760
分别分析算法的运行时间

348
00:24:47,560 --> 00:24:50,810
也就是统一分析算法各个步骤

349
00:24:51,390 --> 00:24:52,780
得到所有可能的情况

350
00:24:53,440 --> 00:24:55,030
然后我们就能知道期望时间要怎么算

351
00:24:58,670 --> 00:25:05,610
如果穷举所有随机分割的情况

352
00:25:08,320 --> 00:25:12,620
T(n)的上界是这样得到的

353
00:25:27,380 --> 00:25:29,700
如果数组被分割成0和n-1两组

354
00:25:29,700 --> 00:25:31,740
最坏情况是递归处理n-1这组

355
00:25:31,970 --> 00:25:34,250
那么问题就变成在n-1的数组上递归

356
00:25:35,180 --> 00:25:38,100
而长度为0的数组可以直接得到结果

357
00:25:41,630 --> 00:25:44,230
如果数组被分割为1和n-2两组

358
00:25:44,660 --> 00:25:46,300
期望时间就是左右两个时间中较大的那个

359
00:25:46,460 --> 00:25:49,160
那就肯定能据此找到一个上界

360
00:25:54,290 --> 00:25:55,330
以此类推

361
00:26:01,020 --> 00:26:04,390
最终数组分割为n-1和0的两组

362
00:26:12,540 --> 00:26:15,330
现在我们就得到了不同分割对应的情况

363
00:26:15,410 --> 00:26:17,250
但是我们有指示器随机变量Xk

364
00:26:17,370 --> 00:26:19,040
来标记每种情况什么时候会发生

365
00:26:19,390 --> 00:26:22,370
我们只需要把每种情况下计算得到的值

366
00:26:22,640 --> 00:26:24,080
乘以指示器随机变量Xk

367
00:26:24,230 --> 00:26:25,940
不对应当前分割的情况时Xk值为0

368
00:26:26,110 --> 00:26:29,860
而对应当前分割的情况时Xk为1

369
00:26:30,010 --> 00:26:33,040
如果把所有加起来也是一样的

370
00:26:35,350 --> 00:26:42,290
这就等于对k求和

371
00:26:42,830 --> 00:26:45,140
用指示器随机变量

372
00:26:45,490 --> 00:26:49,420
乘以相应时间代价  T括号内k和n-k-1

373
00:26:49,850 --> 00:26:52,600
两种情况下较大的那个值

374
00:26:57,090 --> 00:26:58,320
再加Θ(n)

375
00:27:01,980 --> 00:27:05,010
某种程度上这是对代表运行时间的

376
00:27:05,170 --> 00:27:07,760
随机变量T(n)的递归

377
00:27:07,890 --> 00:27:12,430
现在结果就取决于当前是哪种分割情况

378
00:27:12,970 --> 00:27:16,200
我们知道每种情况发生的概率是相同的

379
00:27:16,980 --> 00:27:20,330
因为分割基准元素是随机选择的

380
00:27:21,380 --> 00:27:23,490
递归的存在使得要得到期望

381
00:27:24,540 --> 00:27:26,280
还要进一步分析

382
00:27:27,330 --> 00:27:30,160
随机变量的取值可以很大比如为n²

383
00:27:30,490 --> 00:27:32,000
幸运时则是线性的

384
00:27:33,200 --> 00:27:37,510
必须充分考虑以得到我们想要的结果

385
00:27:52,970 --> 00:27:57,000
让我们来看看随机变量T(n)的期望值

386
00:27:57,820 --> 00:28:00,610
也就是刚才的求和计算式的期望值

387
00:28:01,460 --> 00:28:05,070
把它抄写过来这样就可以在这块板上写

388
00:28:27,970 --> 00:28:30,760
我要计算这个求和式的期望值

389
00:28:31,380 --> 00:28:33,830
有哪些与期望相关的的属性可以用呢

390
00:28:35,040 --> 00:28:36,300
线性很好

391
00:28:37,270 --> 00:28:39,090
我们可以把求和计算提到外面来

392
00:29:06,880 --> 00:29:08,970
现在就变成求一组期望的总和

393
00:29:09,320 --> 00:29:11,220
让我们分别来看一下每一项期望怎么求

394
00:29:11,530 --> 00:29:15,520
每一项期望都和对应的两个随机变量有关

395
00:29:16,300 --> 00:29:17,840
也就是这个指示器随机变量

396
00:29:18,170 --> 00:29:21,470
还有这个更加复杂的函数

397
00:29:21,660 --> 00:29:23,290
也就是代表运行时间的

398
00:29:23,600 --> 00:29:25,030
这个更复杂的随机变量

399
00:29:25,570 --> 00:29:28,950
它们的值依赖于递归过程的每次随机选择

400
00:29:30,920 --> 00:29:32,240
现在我要怎么做呢

401
00:29:38,250 --> 00:29:40,930
我要计算两个随机变量之积的期望

402
00:29:43,760 --> 00:29:45,420
准确地说  它们相互独立

403
00:29:45,730 --> 00:29:48,340
这两个随机变量相互独立的话

404
00:29:48,620 --> 00:29:50,350
那么它们之积的期望

405
00:29:50,500 --> 00:29:52,100
就等于它们期望之积

406
00:29:52,680 --> 00:29:55,160
现在我们需要验证它们相互独立

407
00:29:58,040 --> 00:30:00,640
我希望如此  否则就没有什么能做的了

408
00:30:01,530 --> 00:30:02,850
为什么它俩相互独立呢

409
00:30:05,020 --> 00:30:08,160
什么  因为我们声明如此

410
00:30:08,310 --> 00:30:11,070
因为这里声明的算法前提

411
00:30:11,300 --> 00:30:14,170
我们声明选择的随机数字都是相互独立的

412
00:30:15,450 --> 00:30:17,310
这里需一点补充说明

413
00:30:17,700 --> 00:30:19,790
所有这些Xk的值

414
00:30:19,950 --> 00:30:21,810
从X0到Xn-1

415
00:30:21,930 --> 00:30:24,830
求和计算式的所有这些Xk值都取决于

416
00:30:24,950 --> 00:30:29,990
首次划分时产生的随机数

417
00:30:31,580 --> 00:30:34,290
而这些Xk值之间是相关的

418
00:30:34,490 --> 00:30:36,580
因为当其中一个值为1时其余都必须为0

419
00:30:36,740 --> 00:30:39,140
所以这些Xk值之间是相关的

420
00:30:39,530 --> 00:30:41,860
但考虑这边的这个式子中

421
00:30:41,970 --> 00:30:45,920
T(max(k,n-k-1))是唯一随机的部分

422
00:30:46,140 --> 00:30:47,270
那是递归调用求解的

423
00:30:47,620 --> 00:30:50,280
每次递归产生一个随机数

424
00:30:50,850 --> 00:30:54,440
按照声明每次产生的随机数

425
00:30:54,440 --> 00:30:57,780
都会独立于首次调用时产生的随机数

426
00:30:57,980 --> 00:31:01,470
调用时随机数取值范围在0到n-1之间

427
00:31:05,520 --> 00:31:06,730
这就是该随机变量与这些

428
00:31:06,840 --> 00:31:08,480
相互独立的原因

429
00:31:08,590 --> 00:31:10,780
快速排序也是这样  但是我知道会有人

430
00:31:10,900 --> 00:31:15,010
对前面的内容有些疑惑  所以我重申一次

431
00:31:18,160 --> 00:31:21,370
所以我们得到两个期望值的乘积

432
00:31:21,880 --> 00:31:34,130
E[Xk]乘以E[T(max(k,n-k-1))]

433
00:31:34,360 --> 00:31:37,160
Θ(n)本来可以放在外面的

434
00:31:37,160 --> 00:31:39,180
现在我们还是把它留在里面

435
00:31:40,110 --> 00:31:42,560
Θ(n)的期望不用求

436
00:31:42,790 --> 00:31:45,660
Θ(n)的期望为Θ(n)

437
00:31:47,940 --> 00:31:53,410
Xk的期望是多少  1/n

438
00:31:55,110 --> 00:31:58,140
因为每一个值都是以相同的概率出现

439
00:31:58,210 --> 00:32:00,850
有n个这样的值所以期望为1/n

440
00:32:02,210 --> 00:32:03,510
值为1或0

441
00:32:03,970 --> 00:32:06,220
那么我们就可以将其分开计算

442
00:32:06,340 --> 00:32:10,990
我们有1/n乘以函数T的期望

443
00:32:11,690 --> 00:32:14,640
再加上1/n乘以Θ(n)

444
00:32:14,750 --> 00:32:18,260
后面会是常数  但又累加n次

445
00:32:18,410 --> 00:32:21,560
我们将其展开

446
00:32:34,610 --> 00:32:38,180
要从k=0加到k=n-1

447
00:32:38,840 --> 00:32:41,010
我想这个1/n可以提到外面来

448
00:32:43,740 --> 00:32:53,120
那么就变成求T(max(k,n-k-1))的期望

449
00:32:55,020 --> 00:32:56,500
这里有很多麻烦的括号

450
00:32:57,010 --> 00:33:01,970
还要加一个从k=0到k=n-1的求和

451
00:33:02,090 --> 00:33:03,840
让我来把这个求和式写出来

452
00:33:07,480 --> 00:33:11,160
1/n在前面Θ(n)在里面

453
00:33:12,440 --> 00:33:14,530
这个求和式结果为n²

454
00:33:15,580 --> 00:33:19,670
然后还要除以n所以这整个就等于Θ(n)

455
00:33:20,640 --> 00:33:21,920
看起来没什么复杂的

456
00:33:22,070 --> 00:33:24,440
这部分只是说明了Θ(n)的期望就是Θ(n)

457
00:33:24,930 --> 00:33:26,550
Θ(n)的平均值就是Θ(n)

458
00:33:27,990 --> 00:33:29,660
有意思的是这个部分

459
00:33:31,220 --> 00:33:33,130
现在我们怎么来处理这个求和式呢

460
00:33:35,340 --> 00:33:38,480
这里不同于随机快速排序

461
00:33:39,680 --> 00:33:40,920
因为我们要处理函数max

462
00:33:41,720 --> 00:33:46,720
随机快速排序要求T(k)加T(n-k-1)的和

463
00:33:47,110 --> 00:33:48,950
因为那时要使函数在两组数据上同时递归

464
00:33:49,160 --> 00:33:50,710
这里我们只要处理较长的这组数据

465
00:33:53,660 --> 00:34:00,600
而这里的max确实是一个难处理的部分

466
00:34:03,120 --> 00:34:07,190
怎么去掉max呢  想想有什么办法

467
00:34:17,290 --> 00:34:19,850
不错  我只要对一半依次求和然后乘2

468
00:34:20,050 --> 00:34:23,000
也就是说这里的每个项都出现了两次

469
00:34:23,570 --> 00:34:28,700
k=0时和k=n-1时这里的项都是T(n-1)

470
00:34:28,890 --> 00:34:32,460
k=1和k=n-2时  同理2和n-3也一样

471
00:34:34,360 --> 00:34:37,670
事实上我只要计算这个求和式里一半的项

472
00:34:38,170 --> 00:34:39,350
那样看起来更清楚一点

473
00:34:39,500 --> 00:34:41,090
让我检查下这个指数对不对

474
00:34:43,460 --> 00:34:49,200
n/2向下取整  加到n-1比较可靠

475
00:34:51,640 --> 00:34:54,810
后面则只要算E(T(k))

476
00:34:54,810 --> 00:34:56,500
抱歉  我忘了要乘以2了

477
00:34:56,690 --> 00:34:58,860
所以我要把这个1改成2

478
00:35:00,960 --> 00:35:03,680
保留Θ(n)

479
00:35:04,300 --> 00:35:06,400
这只是因为每一项都出现了两次

480
00:35:06,710 --> 00:35:07,810
提出公因数

481
00:35:08,140 --> 00:35:12,630
如果n是奇数  实际上重复计算了一个值

482
00:35:13,020 --> 00:35:14,300
但显然这将不小于原值

483
00:35:15,890 --> 00:35:19,070
所以上界是可靠的  并且这个上界已满足要求

484
00:35:19,380 --> 00:35:21,240
因为我们只希望时间代价是线性的

485
00:35:21,440 --> 00:35:24,230
而这个算法的运行时间至少是线性的

486
00:35:24,400 --> 00:35:26,150
所以我们只需要一个线性的上界

487
00:35:27,560 --> 00:35:33,270
这就是递归  E(T(n))最大为2/n乘以

488
00:35:33,650 --> 00:35:37,390
k从0到n对应的E(T(k))中一半项的和

489
00:35:37,390 --> 00:35:39,180
再加Θ(n)

490
00:35:39,330 --> 00:35:40,750
这是一个有点麻烦的递归

491
00:35:41,020 --> 00:35:42,380
但是我们还是要解决它

492
00:35:42,650 --> 00:35:46,020
实际上这会比随机快速排序递归简单一点

493
00:35:46,130 --> 00:35:48,190
我们要解出这个式子

494
00:35:48,350 --> 00:35:51,740
我们应该用什么方法呢  对不起

495
00:35:53,020 --> 00:35:55,310
主定理吗  这个想法不错

496
00:35:55,500 --> 00:35:58,950
只是这里每次递归调用都对应不同的k值

497
00:35:59,710 --> 00:36:00,720
主定理适用的情况是

498
00:36:00,830 --> 00:36:04,130
每次调用都是相同的参数相同的k值

499
00:36:04,750 --> 00:36:07,160
唉呀  要是这里能用主定理就好了

500
00:36:08,090 --> 00:36:10,800
还有什么别的方法吗  代换法

501
00:36:10,960 --> 00:36:14,150
当遇到很难  解有疑问的情况用代换法

502
00:36:14,380 --> 00:36:16,480
好的方面是我们知道我们想要做什么

503
00:36:16,790 --> 00:36:20,120
至少从直觉上  这个现在已经擦掉了

504
00:36:20,470 --> 00:36:22,640
我们确实能猜到结果应该是线性时间

505
00:36:22,920 --> 00:36:25,280
所以我们就知道我们要证明什么

506
00:36:26,370 --> 00:36:33,190
我们确实能直接用代换法证明这个结论

507
00:36:40,500 --> 00:36:43,600
我要证明的是存在一个大于0的常数c

508
00:36:44,030 --> 00:36:46,250
根据这个递归过程常数c会使得E(T(n))

509
00:36:46,410 --> 00:36:51,260
小于等于c*n  下面是证明过程

510
00:36:59,400 --> 00:37:01,650
前面已经提到可以用代换法来证明

511
00:37:11,740 --> 00:37:14,690
用归纳法我们首先假设

512
00:37:14,840 --> 00:37:17,440
对于所有小于n的值都成立

513
00:37:20,230 --> 00:37:23,650
假设小于n时成立  然后证明n的情况

514
00:37:27,640 --> 00:37:29,790
E[T(n)]等于

515
00:37:30,640 --> 00:37:34,710
展开这个递归式使用刚才得出的结论

516
00:37:34,870 --> 00:37:37,530
不大于这个式子  我们把它抄过来

517
00:37:52,030 --> 00:37:53,870
这里每次递归调用

518
00:37:54,060 --> 00:37:56,890
一些严格比n小的k值

519
00:37:57,780 --> 00:38:01,890
抱歉  我抄错了  是2/n向下取整  不是0

520
00:38:04,100 --> 00:38:08,000
按照归纳假设依次代入

521
00:38:08,120 --> 00:38:12,310
根据归纳假设  它≤ck

522
00:38:15,020 --> 00:38:18,160
于是得到这个不等式

523
00:38:35,560 --> 00:38:37,800
c可以提到求和号外

524
00:38:37,920 --> 00:38:39,200
因为它是常数

525
00:38:41,200 --> 00:38:43,990
这个写得有点冗长

526
00:38:45,270 --> 00:38:48,410
因为我要算这个求和

527
00:38:55,110 --> 00:38:58,560
这是个经典的求和

528
00:38:59,340 --> 00:39:02,940
如果你们还记得一点求和技巧的话

529
00:39:03,440 --> 00:39:05,380
就能解出结果来

530
00:39:06,540 --> 00:39:08,870
如果从0加到n-1

531
00:39:09,100 --> 00:39:10,690
这是个等差数列

532
00:39:10,860 --> 00:39:13,790
但这里只取原数列的一半求和

533
00:39:14,180 --> 00:39:15,470
你们应该能算出来

534
00:39:15,590 --> 00:39:20,490
至少是阶数  它是多少呢

535
00:39:22,430 --> 00:39:24,330
二次方  对的  肯定是二次方

536
00:39:24,450 --> 00:39:27,530
但这里我们需要一个更精确的上界

537
00:39:27,690 --> 00:39:29,280
待会我们就会知道该系数的重要性

538
00:39:30,090 --> 00:39:32,130
这个求和式将不大于

539
00:39:32,400 --> 00:39:39,260
3/8*n²  这很关键

540
00:39:39,690 --> 00:39:42,830
3/8比1/2小

541
00:39:43,000 --> 00:39:44,440
因此可以消掉这个2

542
00:39:45,720 --> 00:39:48,040
后续的证明将作为习题

543
00:39:48,940 --> 00:39:50,440
证明其实很简单

544
00:39:50,710 --> 00:39:53,000
用归纳法证明就行了

545
00:39:53,500 --> 00:39:55,770
求得该系数则需要多一些工夫

546
00:39:55,930 --> 00:39:57,670
但也没多很多

547
00:39:57,910 --> 00:39:59,460
你们可以自己用归纳法证明

548
00:40:01,400 --> 00:40:04,670
我化简一下

549
00:40:06,340 --> 00:40:11,810
有点复杂  最终要得到c*n

550
00:40:12,390 --> 00:40:16,850
写成c*n减去其余部分的形式

551
00:40:17,790 --> 00:40:21,140
这里有些复杂的分数

552
00:40:21,260 --> 00:40:25,150
2乘3得6除以8

553
00:40:25,730 --> 00:40:29,160
就是3/4,  对吧

554
00:40:29,410 --> 00:40:34,550
这里是1  需要减去1/4得到3/4

555
00:40:34,900 --> 00:40:38,970
这里我觉得应该是1/4*c*n

556
00:40:40,950 --> 00:40:42,590
最后还有个1阶余项

557
00:40:42,790 --> 00:40:47,720
负负得正

558
00:40:49,850 --> 00:40:51,750
刚才重写了一遍  看起来就比较明白了

559
00:40:52,830 --> 00:40:54,420
我们得到了我们想要的结果

560
00:40:54,660 --> 00:40:59,300
我们希望这个非负

561
00:40:59,370 --> 00:41:01,470
然后就得到小于等于c*n

562
00:41:01,700 --> 00:41:04,630
这显然正确  如果这个非负的话

563
00:41:05,390 --> 00:41:06,440
看起来不错

564
00:41:06,550 --> 00:41:08,960
因为我们可以取任意大的c

565
00:41:09,160 --> 00:41:12,020
无论里面的系数多大都只是个定值

566
00:41:12,140 --> 00:41:15,960
因此总存在c使递归式成立

567
00:41:16,850 --> 00:41:19,490
当c比4乘该系数大时

568
00:41:19,610 --> 00:41:22,940
那这部分非负

569
00:41:23,290 --> 00:41:33,070
所以不等式在c足够大时成立

570
00:41:33,300 --> 00:41:34,550
同样在基本情形也成立

571
00:41:34,900 --> 00:41:37,050
证明中只用简略地提一句

572
00:41:37,710 --> 00:41:41,620
当c充分大时条件成立

573
00:41:41,780 --> 00:41:44,880
在基本情形里T(n)为某一常数自然也成立

574
00:41:45,740 --> 00:41:47,540
这里约为1

575
00:41:47,970 --> 00:41:49,640
因为那样我们就不用递归调用了

576
00:41:51,930 --> 00:41:52,780
所以我们得到

577
00:41:53,250 --> 00:41:55,610
随机选择算法

578
00:41:58,710 --> 00:42:03,150
运行时间的复杂度期望是Θ(n)

579
00:42:10,990 --> 00:42:12,480
但比较糟糕的是最坏情况

580
00:42:12,600 --> 00:42:15,680
最坏情况下的复杂度是Θ(n²)

581
00:42:21,280 --> 00:42:23,760
还有什么问题吗

582
00:42:24,150 --> 00:42:28,000
这已证明完毕最终得出了

583
00:42:28,110 --> 00:42:30,560
期望的时间复杂度是Θ(n)

584
00:42:30,560 --> 00:42:32,560
而最坏情况的复杂度是Θ(n²)

585
00:42:32,560 --> 00:42:36,660
全弄清楚了吗  好的

586
00:42:38,100 --> 00:42:39,030
你们要好好研究这些证明

587
00:42:39,180 --> 00:42:41,160
它们阐明了随机快排和随机选择

588
00:42:41,320 --> 00:42:43,140
两算法之间的内在联系

589
00:42:44,380 --> 00:42:45,560
要牢记在心

590
00:42:48,200 --> 00:42:50,780
这个强大的算法在实际工作中很有用

591
00:42:50,970 --> 00:42:53,080
大部分情况下分割点都会在中间部分

592
00:42:53,390 --> 00:42:57,070
1/4至3/4之间  这很好

593
00:42:57,770 --> 00:43:01,450
而出现最坏情况n²的可能性相当小

594
00:43:02,150 --> 00:43:05,680
可能只有1/nⁿ的概率

595
00:43:05,790 --> 00:43:07,500
或其他非常非常小的值

596
00:43:07,970 --> 00:43:11,750
但我是理论家

597
00:43:12,020 --> 00:43:15,250
如果最坏情况的复杂度是Θ(n)就更好了

598
00:43:15,640 --> 00:43:18,200
那会是最好的结果

599
00:43:18,310 --> 00:43:19,840
理想中的最优结果

600
00:43:19,960 --> 00:43:20,970
复杂度不可能小于Θ(n)

601
00:43:21,100 --> 00:43:22,420
因为你必须把所有数都看一遍

602
00:43:23,230 --> 00:43:26,370
所以  如何剔除这个最坏情况

603
00:43:26,720 --> 00:43:28,080
并以某种方式避免随机性

604
00:43:28,310 --> 00:43:31,260
保证最坏情况复杂度也是Θ(n)

605
00:43:31,410 --> 00:43:38,090
这可以做到  但这是非同一般的算法

606
00:43:38,240 --> 00:43:40,490
在我们所见过的算法中

607
00:43:40,610 --> 00:43:41,970
最复杂的算法之一

608
00:43:46,240 --> 00:43:48,600
这并不是最复杂的算法

609
00:43:49,100 --> 00:43:52,050
但在我们见过的算法中  它是

610
00:43:53,910 --> 00:44:01,980
线性的最坏情况时间复杂度

611
00:44:07,130 --> 00:44:12,130
这算法由几个牛人创造

612
00:44:14,850 --> 00:44:18,330
Blum  Floyd

613
00:44:19,790 --> 00:44:25,140
Pratt  Rivest和Tarjan

614
00:44:30,800 --> 00:44:33,440
我只见过Blum和Rivest和Tarjan

615
00:44:33,840 --> 00:44:35,070
哦还见过Pratt

616
00:44:35,270 --> 00:44:36,970
我倒是跟所有作者都蛮接近的

617
00:44:37,980 --> 00:44:39,300
这是个老算法

618
00:44:39,410 --> 00:44:41,620
但在当时是个重大突破

619
00:44:41,810 --> 00:44:43,560
而且现在依然是令人叹服的算法

620
00:44:45,810 --> 00:44:48,210
Rivest是MIT的一个教授

621
00:44:48,420 --> 00:44:49,930
就是RSA公钥体系中的那个R

622
00:44:51,910 --> 00:44:55,440
我当年的博士综合测验的时候

623
00:44:55,750 --> 00:44:57,760
封皮是个搞笑的问题

624
00:44:58,070 --> 00:44:59,700
问在这些作者

625
00:44:59,700 --> 00:45:04,230
发明出线性的最坏情况算法的这些人中

626
00:45:04,230 --> 00:45:06,790
谁最富有

627
00:45:08,730 --> 00:45:11,790
很遗憾这个不是考试算分的一部分

628
00:45:12,070 --> 00:45:12,980
但这是个好问题

629
00:45:13,100 --> 00:45:17,410
由于录像的原因我不能告诉你们答案

630
00:45:17,410 --> 00:45:18,030
但想一下这问题

631
00:45:18,260 --> 00:45:21,360
这并不显然  好几个人都很富

632
00:45:21,560 --> 00:45:23,380
问题是  谁最富

633
00:45:28,130 --> 00:45:30,840
总之  在富起来之前他们创造了这个算法

634
00:45:31,150 --> 00:45:32,310
他们想出很多算法

635
00:45:32,430 --> 00:45:34,990
即使富起来以后  信不信由你

636
00:45:37,860 --> 00:45:42,360
我们需要一个好的主元  保证好的主元

637
00:45:42,550 --> 00:45:44,610
随机主元看起来是个好方法

638
00:45:44,780 --> 00:45:47,030
最简单的方法正是随机选一个

639
00:45:47,300 --> 00:45:48,850
很大概率上讲都会很好

640
00:45:49,630 --> 00:45:53,540
但我们想选出一个确实很好的主元

641
00:45:54,110 --> 00:45:58,560
新想法是递归地生成主元

642
00:46:00,560 --> 00:46:04,440
除了递归我们还能做什么

643
00:46:05,650 --> 00:46:07,240
你们从递归中可以理解

644
00:46:07,360 --> 00:46:10,430
如果递归地求解半个问题

645
00:46:11,010 --> 00:46:13,400
我们需要多做一个线性复杂度的工作

646
00:46:13,400 --> 00:46:14,730
就像归并排序中的递归

647
00:46:14,840 --> 00:46:16,910
T(n)=2[T(n/2)+Θ(n)]

648
00:46:17,300 --> 00:46:18,930
你们应该做梦都能背出来

649
00:46:20,980 --> 00:46:22,060
复杂度是nlogn

650
00:46:22,720 --> 00:46:25,620
我们不能递归地分成两半

651
00:46:25,760 --> 00:46:26,650
必须做的更好

652
00:46:26,850 --> 00:46:30,720
所以这个递归的复杂度必须严格小于n

653
00:46:32,310 --> 00:46:35,180
这算法的神奇之处正是在此

654
00:46:36,500 --> 00:46:39,760
所以是选择而不是随机选择

655
00:46:40,960 --> 00:46:43,150
这和初始状态有关

656
00:46:43,240 --> 00:46:46,150
但我们只要第i大的元素

657
00:46:46,460 --> 00:46:49,060
以及需要查找的数组的大小

658
00:46:50,370 --> 00:46:52,260
我写下这个算法

659
00:46:52,460 --> 00:46:57,070
比随机选择稍稍不正式一些

660
00:46:57,380 --> 00:46:58,930
这个是算法的一点点儿高级抽象

661
00:47:20,370 --> 00:47:28,970
我在这边画一下这个算法

662
00:47:30,040 --> 00:47:31,740
第一步有些奇怪

663
00:47:31,930 --> 00:47:35,190
这里也是一个算法思想的关键之处

664
00:47:35,370 --> 00:47:36,370
这些数据

665
00:47:36,570 --> 00:47:37,620
之间没有什么特殊顺序

666
00:47:37,730 --> 00:47:39,990
我并不把它们排成一排

667
00:47:40,840 --> 00:47:45,760
而是排成5×n/5网格

668
00:47:47,700 --> 00:47:50,060
这需要一些时间来画

669
00:47:50,970 --> 00:47:54,850
你们也需要这么多时间  我就画一下吧

670
00:47:58,510 --> 00:47:59,820
宽度无关紧要

671
00:47:59,980 --> 00:48:03,100
应该是n/5

672
00:48:03,260 --> 00:48:05,200
你们相应地画五排

673
00:48:06,340 --> 00:48:09,010
宽度是n/5  高度必须是5

674
00:48:10,250 --> 00:48:11,800
我认为我画对了  数一下

675
00:48:12,230 --> 00:48:13,220
确实是五

676
00:48:14,700 --> 00:48:15,840
就应该是五

677
00:48:16,040 --> 00:48:18,250
有些数不能被5整除

678
00:48:18,370 --> 00:48:21,470
所以最后一列不一样

679
00:48:22,080 --> 00:48:25,880
这个部分宽度为n/5向下取整

680
00:48:26,230 --> 00:48:28,400
然后最多剩下4个

681
00:48:28,640 --> 00:48:30,220
忽略这些  它们无关紧要

682
00:48:30,380 --> 00:48:34,610
只会添加一个常数  这就是我的数组

683
00:48:34,840 --> 00:48:37,510
只是画得比较搞怪一些

684
00:48:37,940 --> 00:48:39,920
每一竖列都是一组

685
00:48:40,360 --> 00:48:42,610
我可以圈出每一列  像讲义里做的那样

686
00:48:42,730 --> 00:48:45,940
但是如果画圈  这个图将非常混乱

687
00:48:46,060 --> 00:48:49,450
图会被画得满满的  我只是警告下

688
00:48:49,740 --> 00:48:51,490
到最后将几乎无法辨认

689
00:48:51,600 --> 00:48:54,670
不过...  就是这样

690
00:48:56,610 --> 00:49:00,450
如果你觉得无聊  你可以这样画几次

691
00:49:00,610 --> 00:49:03,050
你也可以看看会画成什么样

692
00:49:06,150 --> 00:49:08,440
因此这就是组  每一竖组五个元素

693
00:49:09,450 --> 00:49:10,460
下一步

694
00:49:17,120 --> 00:49:18,510
第二步是递归

695
00:49:19,690 --> 00:49:24,540
这里会有点不一样  甚至很不一样

696
00:49:28,090 --> 00:49:32,240
抱歉  我应该在这两步之间空上一行

697
00:49:32,720 --> 00:49:34,780
因此我会把第二步移到下面去

698
00:49:34,780 --> 00:49:36,550
然后把这个加在第一步后面

699
00:49:38,530 --> 00:49:42,170
在第一步中  我们还要找每一组的中值

700
00:49:52,330 --> 00:49:54,850
想象在这个图中

701
00:49:55,040 --> 00:49:58,380
每一组中的五个元素重新排列

702
00:49:58,770 --> 00:50:00,470
这样中间的那个元素就是中值

703
00:50:00,570 --> 00:50:03,550
这些元素被称为每组的中值

704
00:50:04,130 --> 00:50:06,660
每一组五个元素  中值就刚好在正中间

705
00:50:06,770 --> 00:50:08,250
一组中有两个元素小于中值

706
00:50:08,400 --> 00:50:09,840
两个元素大于中值

707
00:50:10,070 --> 00:50:11,890
同时  假设元素都不相等

708
00:50:13,060 --> 00:50:14,690
就是这样  计算它们

709
00:50:15,190 --> 00:50:16,870
这要花多长时间

710
00:50:21,210 --> 00:50:23,190
n/5个组  每一组5个元素

711
00:50:23,340 --> 00:50:24,740
计算每一组的中值

712
00:50:31,560 --> 00:50:35,940
什么  对  2*n/5

713
00:50:36,050 --> 00:50:37,990
就是Θ(n)  这就是我想听到的

714
00:50:38,650 --> 00:50:41,030
我的意思是  你考虑了比较  这样很好

715
00:50:41,720 --> 00:50:43,850
这必然是Θ(n)

716
00:50:45,640 --> 00:50:46,840
关键是  在每一组中

717
00:50:47,460 --> 00:50:49,070
我只需要做固定次数的比较

718
00:50:49,230 --> 00:50:50,400
因为每一组中元素数目是一定的

719
00:50:50,560 --> 00:50:51,060
这个无所谓

720
00:50:51,260 --> 00:50:53,590
你可以进行随机选择算法

721
00:50:53,780 --> 00:50:54,710
无论你怎么做

722
00:50:54,830 --> 00:50:57,120
它仅仅只需要一定次数的比较

723
00:50:57,410 --> 00:50:59,580
只要你不重复比较就行

724
00:51:00,780 --> 00:51:02,620
所以这个很简单

725
00:51:04,500 --> 00:51:07,800
你可以对这五个数进行排序  看第三个数的值

726
00:51:07,990 --> 00:51:12,220
这个没什么影响  因为只有五个数

727
00:51:13,810 --> 00:51:14,680
这是一个很好的办法

728
00:51:14,830 --> 00:51:16,460
现在已经有一些元素

729
00:51:16,460 --> 00:51:19,700
简单的在每一组的中间

730
00:51:20,820 --> 00:51:22,280
而且只用到线性工作

731
00:51:23,130 --> 00:51:24,760
到目前为止还干得不错

732
00:51:27,760 --> 00:51:30,300
现在开始第二步  就是我之前开始写的那步

733
00:51:32,400 --> 00:51:33,650
我们进行递归

734
00:51:56,910 --> 00:52:00,980
下个步骤是...  这层我们有n/5个中值

735
00:52:01,630 --> 00:52:04,150
我将要计算出这些中值的中值

736
00:52:05,080 --> 00:52:07,220
想象一下我重新排列了这些数

737
00:52:07,330 --> 00:52:08,730
不幸的是这有偶数个数

738
00:52:08,850 --> 00:52:13,270
这有6个数但我要进行重组

739
00:52:13,420 --> 00:52:15,450
因此这个我画了两个框的数

740
00:52:15,690 --> 00:52:17,370
是这些元素的中值

741
00:52:17,570 --> 00:52:19,970
因此有2个元素完全小于这个值

742
00:52:20,170 --> 00:52:22,320
有三个数绝对大于这个值

743
00:52:22,590 --> 00:52:25,440
它不会直接告诉我们任何情况

744
00:52:25,440 --> 00:52:29,110
这看起来没直接告诉我们什么其他信息

745
00:52:29,400 --> 00:52:30,370
我们稍后会回来

746
00:52:30,560 --> 00:52:32,770
实际上  它确实告诉我们了一些元素信息

747
00:52:33,120 --> 00:52:35,210
不过现在  这个元素只是这些数的中值

748
00:52:35,490 --> 00:52:38,590
而这每个数也只是这五个元素的中值

749
00:52:38,940 --> 00:52:39,950
这是我们所知道的

750
00:52:40,910 --> 00:52:43,120
如果我们用递归去运算

751
00:52:43,120 --> 00:52:45,700
这个需要花T(n/5)的时间

752
00:52:47,910 --> 00:52:48,780
到目前为止非常的好

753
00:52:48,910 --> 00:52:53,270
可以用线性的递归法去解决这个n/5大小的问题

754
00:52:53,430 --> 00:52:55,560
我们知道这个是线性时间

755
00:52:57,830 --> 00:53:00,230
不过这还有更多的步骤  我们显然还没有做完

756
00:53:08,490 --> 00:53:11,050
下一步是...  x是我们的划分元素

757
00:53:11,200 --> 00:53:12,610
我们在那儿划分

758
00:53:12,610 --> 00:53:15,430
剩下的算法就像是随机划分

759
00:53:16,240 --> 00:53:19,730
因此我们要把k定义为x的排序号

760
00:53:20,820 --> 00:53:24,270
这个可以推导出是n-1+r或者别的什么形式

761
00:53:24,380 --> 00:53:27,020
不过我不准备写怎么去做的

762
00:53:27,140 --> 00:53:28,500
因为我们现在处在更高的层次上

763
00:53:28,960 --> 00:53:31,070
但是确实是可算的

764
00:53:31,070 --> 00:53:33,970
现在我们有三种情况分支

765
00:53:34,280 --> 00:53:37,350
如果结果恰巧等于k那么很开心

766
00:53:37,460 --> 00:53:39,600
因为这个主元正是我们想要的

767
00:53:41,420 --> 00:53:47,040
但是  i更有可能大于或者小于k

768
00:53:48,820 --> 00:53:50,960
选择合适递归调用

769
00:53:51,810 --> 00:54:00,000
我们用递归的选取第i小的元素

770
00:54:04,740 --> 00:54:09,530
在数组的小值部分

771
00:54:09,650 --> 00:54:12,420
也就是划分元素的左侧部分

772
00:54:12,430 --> 00:54:17,230
如果i>k我们用递归的方法在数组的大值区

773
00:54:18,080 --> 00:54:22,270
选择第i-k小的值

774
00:54:26,990 --> 00:54:27,630
这里我写得比较简略

775
00:54:27,630 --> 00:54:28,900
因为这些都是我们之前已经接触过的

776
00:54:28,980 --> 00:54:34,600
所有这些都和前面几步的随机选择一样

777
00:54:43,390 --> 00:54:44,520
这就是整个算法

778
00:54:45,530 --> 00:54:47,120
关键的问题是这个为什么可行

779
00:54:47,310 --> 00:54:48,440
为什么是线性时间的

780
00:54:51,070 --> 00:54:52,930
第一个问题是这里的递归是什么

781
00:54:53,130 --> 00:54:54,470
我们现在还不能把它写出来

782
00:54:54,980 --> 00:54:56,330
因为我们不知道

783
00:54:56,720 --> 00:54:58,390
这里面的子问题有多大

784
00:54:58,660 --> 00:55:00,650
我们要递归上半部分或者下半部分

785
00:55:00,770 --> 00:55:01,540
就像之前一样

786
00:55:01,850 --> 00:55:05,070
如果很不幸  我们得到像是0:n-1

787
00:55:05,310 --> 00:55:07,130
这将会变成n²时间算法

788
00:55:07,280 --> 00:55:09,140
矛盾就在于这个划分元素要

789
00:55:09,380 --> 00:55:11,930
非常的好  足够的好

790
00:55:13,620 --> 00:55:17,270
这个算法的运行时间是T(一个数乘以n)

791
00:55:18,660 --> 00:55:20,600
我们现在还不知道这个数是什么

792
00:55:22,540 --> 00:55:24,010
这个值能达到多大

793
00:55:25,530 --> 00:55:28,290
我可以问问你们

794
00:55:28,490 --> 00:55:31,050
但是这里已经有点复杂了  所以我会直接告诉你们

795
00:55:31,580 --> 00:55:34,870
我们已经有了一个递归  需要的时间是T(n/5)

796
00:55:35,180 --> 00:55:37,350
这里最好有一个任意的常数

797
00:55:37,510 --> 00:55:39,870
这样这里就是n乘以一个常数

798
00:55:40,130 --> 00:55:43,690
如果这个常数可以完全的小于4/5将会更好

799
00:55:44,270 --> 00:55:45,710
如果这个数等于4/5

800
00:55:46,230 --> 00:55:47,880
你还没有很好的分割这个问题

801
00:55:48,080 --> 00:55:49,550
你将会得到一个nlogn的运行时间

802
00:55:50,090 --> 00:55:52,770
如果这个数严格小于4/5

803
00:55:53,390 --> 00:55:56,900
那么你至少以常数因子让问题减小

804
00:55:57,000 --> 00:55:59,310
在这种情况下如果你把所有的子问题加在一起

805
00:55:59,430 --> 00:56:01,870
n/5以及一个数乘以n

806
00:56:02,150 --> 00:56:05,440
你将会得到一个严格小于1*n的常数

807
00:56:05,650 --> 00:56:07,830
这样保证了这个算法是几何的

808
00:56:08,020 --> 00:56:09,730
如果它是几何的  你将会得到线性时间算法

809
00:56:09,840 --> 00:56:12,290
这是一种直觉  但这种直觉是对的

810
00:56:14,380 --> 00:56:17,130
记住无论何时  你的目标都是一个线性时间算法

811
00:56:18,110 --> 00:56:19,430
如果你用的是分治法

812
00:56:19,580 --> 00:56:22,110
你将会得到所有子问题的大小

813
00:56:22,220 --> 00:56:25,480
是一个小于1*n的常数

814
00:56:27,460 --> 00:56:28,400
这样就可以运行了

815
00:56:28,760 --> 00:56:33,700
因此我们需要算出这个常数的值

816
00:56:36,250 --> 00:56:37,690
同时我们将用到这张图

817
00:56:41,610 --> 00:56:44,400
很难得这张图到现在还很整洁

818
00:56:44,790 --> 00:56:46,550
现在我们要把它变得混乱了

819
00:56:48,610 --> 00:56:52,770
我要做的是在两个点之间画一个箭头

820
00:56:52,770 --> 00:56:54,850
或者说是元素  节点

821
00:56:54,970 --> 00:56:55,950
随便你想怎么称呼它

822
00:56:56,680 --> 00:56:57,840
那就把它们叫做a和b

823
00:56:58,140 --> 00:57:01,590
我想给这个箭头确定方向  使得它指向较大的值

824
00:57:01,740 --> 00:57:03,250
那么这就意味着a小于b

825
00:57:03,990 --> 00:57:07,090
这只是对于这个图的记法

826
00:57:09,470 --> 00:57:13,730
这个元素...  我将写出我所知道的一切

827
00:57:14,080 --> 00:57:16,290
这个元素是这五个元素的中值

828
00:57:16,530 --> 00:57:17,920
我将标箭头表明

829
00:57:18,080 --> 00:57:20,060
这些元素大于中值

830
00:57:20,170 --> 00:57:21,820
而这些元素小于中间值

831
00:57:22,010 --> 00:57:25,560
因此箭头是这样画的

832
00:57:27,660 --> 00:57:30,170
要是有一些彩色粉笔就好了

833
00:57:31,110 --> 00:57:34,670
也就是说这个值在这五个元素的中间

834
00:57:34,860 --> 00:57:38,310
每一列都是这样

835
00:57:54,280 --> 00:57:56,590
这个图开始显得有点混乱了

836
00:57:57,280 --> 00:57:58,290
我还没有画完

837
00:58:01,060 --> 00:58:04,780
我们也知道这个元素是这些中值中的中值

838
00:58:05,130 --> 00:58:07,340
对于所有框出的元素来说这个值在正中间

839
00:58:08,280 --> 00:58:10,920
我将标箭头标明这些值小于中值

840
00:58:11,120 --> 00:58:12,780
而这些值大于中值

841
00:58:13,540 --> 00:58:14,960
不过算法并不能做这些

842
00:58:15,070 --> 00:58:17,550
它不需要知道这一切是怎么完成的

843
00:58:17,670 --> 00:58:20,500
也许它可以  但这些只是为了分析

844
00:58:21,400 --> 00:58:24,620
我们知道它大于这个元素  同时也大于这个元素

845
00:58:25,900 --> 00:58:27,490
我们没有办法直接得到其他的元素

846
00:58:27,610 --> 00:58:29,360
我们只知道这个元素比那两个都大

847
00:58:29,710 --> 00:58:32,320
而这个元素又小于这三个

848
00:58:34,220 --> 00:58:36,590
现在这个图乱的不行了

849
00:58:38,830 --> 00:58:42,510
对于小于关系比较有利的是这有一个传递关系

850
00:58:42,660 --> 00:58:46,970
如果这张图上有一个有向路径

851
00:58:47,200 --> 00:58:50,390
可以知道这个元素一定小于那个元素

852
00:58:51,870 --> 00:58:54,390
因为这个小于这个  这个又小于那个

853
00:58:55,900 --> 00:58:58,730
虽然我只知道每一列中的大小关系

854
00:58:58,880 --> 00:59:01,710
和中间这一行的大小关系  但是实际上

855
00:59:01,950 --> 00:59:04,290
我可以推知这个元素  用x来表示的话

856
00:59:07,190 --> 00:59:10,980
这个元素比所有这些元素都大

857
00:59:11,910 --> 00:59:13,650
因为它比这个元素和这个元素都大

858
00:59:13,850 --> 00:59:18,300
而根据箭头方向  这两个元素又比这些大

859
00:59:19,160 --> 00:59:24,240
同时我还知道  这一块区域的元素都是...

860
00:59:24,350 --> 00:59:25,750
我不得不把这张图变得更加混乱了

861
00:59:25,870 --> 00:59:27,860
你们不必这样做

862
00:59:28,130 --> 00:59:30,070
这个长方形内的所有元素

863
00:59:31,610 --> 00:59:33,000
都大于或者等于这个元素

864
00:59:33,390 --> 00:59:35,370
而这个长方形内的所有元素

865
00:59:35,720 --> 00:59:37,310
都小于或者等于元素x

866
00:59:39,280 --> 00:59:40,890
那么已知大小关系的元素有多少个呢

867
00:59:41,310 --> 00:59:43,150
这里大概包括了一半的组

868
00:59:43,360 --> 00:59:48,240
而这里是一列的3/5

869
00:59:49,060 --> 00:59:52,620
由此可知  至少有

870
00:59:55,260 --> 00:59:57,880
总共有n/5个组

871
00:59:59,090 --> 01:00:04,970
取其中的一半

872
01:00:06,450 --> 01:00:08,330
从图上我们可以大概看出来

873
01:00:08,640 --> 01:00:11,710
对这个值向下取整

874
01:00:13,290 --> 01:00:16,470
每一个组涉及三个元素

875
01:00:17,150 --> 01:00:21,990
所有至少有n/5向下取整再除以2向下取整再乘以3个元素

876
01:00:23,160 --> 01:00:28,390
小于等于元素x

877
01:00:28,520 --> 01:00:31,470
大于等于元素x的元素个数也是这样

878
01:00:32,710 --> 01:00:35,150
现在再来简化一下

879
01:00:38,830 --> 01:00:41,970
我还会给出一些证明过程

880
01:00:42,130 --> 01:00:45,190
我们画了图  但只是为了证明这是正确的

881
01:00:47,090 --> 01:00:52,510
我们有至少这么多个组内中间值

882
01:00:57,750 --> 01:00:59,570
它们小于或者等于元素x

883
01:01:00,030 --> 01:01:01,660
这是我们在证明时要用到的条件

884
01:01:01,820 --> 01:01:04,910
这些组内中间值中有一半都小于或等于x

885
01:01:05,020 --> 01:01:07,100
因为元素x是组内中间值的中间值

886
01:01:07,200 --> 01:01:08,970
这很容易理解

887
01:01:09,240 --> 01:01:12,300
这几乎是个等式  但我们做了向下取整

888
01:01:12,410 --> 01:01:13,810
所以是大于等于符号

889
01:01:14,430 --> 01:01:16,860
对于每个组内中间值来说  我们知道

890
01:01:17,170 --> 01:01:19,960
有三个元素小于或等于这个组内中间值

891
01:01:20,080 --> 01:01:22,510
因此根据传递关系它们也小于等于元素x

892
01:01:22,770 --> 01:01:24,520
所以这个数还要再乘以3

893
01:01:26,710 --> 01:01:30,350
这实际上就是n/10的向下取整

894
01:01:31,440 --> 01:01:33,320
前面我故意把这个式子写得比较复杂

895
01:01:33,430 --> 01:01:35,410
只是为了说明这个式子是怎么来的

896
01:01:36,870 --> 01:01:42,640
现在我们知道这里至少是3*n/10

897
01:01:42,790 --> 01:01:48,730
也就是大概有3/10的元素在不等式的一边

898
01:01:48,940 --> 01:01:51,730
实际上不等式两边至少各有3/10的元素

899
01:01:52,000 --> 01:01:56,460
因此不等号的两边最多有7/10的元素

900
01:01:57,780 --> 01:01:59,330
所以这里的数字应该是7/10

901
01:01:59,640 --> 01:02:02,720
如果幸运的话  7/10+1/5肯定比1小

902
01:02:03,150 --> 01:02:07,140
我相信它成立  但是处理10进制还有些问题

903
01:02:07,230 --> 01:02:09,020
我只能处理2进制的情况

904
01:02:11,070 --> 01:02:13,940
所以我们还要再作一些简化

905
01:02:14,060 --> 01:02:19,550
这个简化过程比想象的要容易一些

906
01:02:19,770 --> 01:02:23,100
主要是把这个烦人的取整符号去掉

907
01:02:23,530 --> 01:02:27,330
实际上这里没有什么引理可用

908
01:02:28,600 --> 01:02:31,120
如果n足够大  那么

909
01:02:31,550 --> 01:02:36,630
n/10的取整再乘以3一定比n/4大

910
01:02:37,010 --> 01:02:38,450
n/4比较容易处理

911
01:02:40,400 --> 01:02:43,040
这表明每一个组至少是n/4个元素

912
01:02:43,190 --> 01:02:45,090
因此每一个组最多是3n/4个元素

913
01:02:45,360 --> 01:02:48,650
因为另一边是n/4元素  这里就是3/4

914
01:02:49,200 --> 01:02:52,310
显然1/5小于1/4

915
01:02:53,040 --> 01:02:55,680
加起来的话显然是小于1的

916
01:02:55,950 --> 01:02:57,150
这样就可以算了

917
01:02:57,930 --> 01:03:00,170
运行时间怎么样呢  好的

918
01:03:03,360 --> 01:03:05,440
分析到这里  剩下的部分就很简单了

919
01:03:06,960 --> 01:03:09,480
这个算法到底怎么样

920
01:03:10,060 --> 01:03:13,120
你会意识到这是一种非常好的

921
01:03:13,250 --> 01:03:16,470
用来选择划分基准的方法  恰好能够

922
01:03:16,870 --> 01:03:19,380
使两部分递归加起来是线性时间

923
01:03:19,530 --> 01:03:22,940
这也是为什么这么多著名人物参与其中

924
01:03:28,350 --> 01:03:31,010
在这门课上尤其是测试中  你们一般

925
01:03:31,130 --> 01:03:33,300
不会碰到这么妙的一个算法

926
01:03:33,630 --> 01:03:37,280
因为你只能用这个算法来找中间值

927
01:03:37,440 --> 01:03:40,120
中间值确实是非常好的划分基准

928
01:03:41,800 --> 01:03:44,750
现在你知道了这个算法而我们不是在1973年

929
01:03:45,620 --> 01:03:47,990
你不需要知道具体是怎么回事

930
01:03:48,260 --> 01:03:49,570
我是说你应该知道这个算法是怎么算的

931
01:03:49,680 --> 01:03:52,010
但你不需要在另一个算法中写这个过程

932
01:03:52,130 --> 01:03:54,010
你只需要调用这个算法

933
01:03:54,130 --> 01:03:55,560
就能在线性时间内得到中间值

934
01:03:55,930 --> 01:03:58,020
然后就能把一组数划分成左边和右边

935
01:03:58,140 --> 01:04:00,310
而左边和右边的元素个数恰好相等

936
01:04:00,590 --> 01:04:01,260
太棒了

937
01:04:01,450 --> 01:04:03,520
这是一个非常有用的子程序

938
01:04:03,830 --> 01:04:06,800
这个算法很常用  周五的练习就会用到

939
01:04:09,760 --> 01:04:12,180
我分析过运行时间了吗

940
01:04:12,330 --> 01:04:15,990
第一步是线性时间  第二步是T(n/5)

941
01:04:16,340 --> 01:04:19,150
第三步我还没写  是线性时间

942
01:04:21,360 --> 01:04:23,440
最后一步是递归调用

943
01:04:23,750 --> 01:04:26,650
现在我们已经知道这是3/4

944
01:04:32,230 --> 01:04:38,300
可以得到这个式子  T(n)的上限是

945
01:04:38,840 --> 01:04:43,280
T(n/5)+T(3n/4)

946
01:04:44,940 --> 01:04:47,400
你也可以用7/10代替3/4

947
01:04:47,900 --> 01:04:54,200
答案是一样的  但是多一个取整

948
01:04:54,820 --> 01:04:59,000
所以我们不那么做  我认为这是线性的

949
01:04:59,350 --> 01:05:05,010
怎么来证明呢  代换法

950
01:05:10,200 --> 01:05:12,550
假设T(n)的上限是c*n

951
01:05:12,660 --> 01:05:14,450
那就足够了

952
01:05:14,450 --> 01:05:16,230
用代换法证明

953
01:05:17,800 --> 01:05:20,120
我们还是假设较小的数都满足这个式子

954
01:05:22,990 --> 01:05:24,180
要证明对于当前n  这个式子也成立

955
01:05:24,650 --> 01:05:27,410
我们有T(n)的上限是这个式子

956
01:05:27,990 --> 01:05:28,960
T(n/5)

957
01:05:29,160 --> 01:05:31,210
归纳法可以证明  因为n/5小于n

958
01:05:31,560 --> 01:05:33,150
我们可以得到这里是

959
01:05:33,790 --> 01:05:37,470
写成c/5*n

960
01:05:41,230 --> 01:05:42,040
好的

961
01:05:42,930 --> 01:05:48,050
然后这里是3/4*cn

962
01:05:49,060 --> 01:05:51,710
接下来是一个线性项

963
01:05:54,890 --> 01:05:56,670
现在  不幸的是

964
01:05:56,780 --> 01:05:58,800
我不得不处理非二进制情况

965
01:05:59,020 --> 01:06:00,560
我要作弊地看一下我的笔记了

966
01:06:01,170 --> 01:06:10,430
这个式子就是19/20*cn+Θ(n)

967
01:06:11,130 --> 01:06:13,610
显然这里是严格小于1的

968
01:06:13,960 --> 01:06:16,950
因为这里严格小于1  我可以写成是

969
01:06:17,060 --> 01:06:21,570
1*cn再减去某个常数  这里就是1/20

970
01:06:21,690 --> 01:06:23,410
只要结果和上面相同就可以了

971
01:06:23,740 --> 01:06:25,410
1/20*cn

972
01:06:25,610 --> 01:06:29,390
然后是这个烦人的Θ(n)

973
01:06:29,660 --> 01:06:31,440
我想把它去掉因为我想让这里是负的

974
01:06:31,990 --> 01:06:35,280
但是只要c非常大  这里就是非负的

975
01:06:35,360 --> 01:06:37,920
取这里常数的20倍就可以了

976
01:06:39,270 --> 01:06:44,740
所以只要c足够大  上限就是cn

977
01:06:47,030 --> 01:06:50,780
顺便说一句  如果n小于等于50

978
01:06:51,440 --> 01:06:55,130
我们在上面用到过  那么T(n)是一个常数

979
01:06:55,320 --> 01:06:56,460
不管怎么样

980
01:06:56,730 --> 01:07:00,670
只要c足够大  T(n)的上限就是cn

981
01:07:01,250 --> 01:07:02,950
这就证明了之前的假设

982
01:07:03,580 --> 01:07:06,810
当然  这里的常数相当大

983
01:07:07,350 --> 01:07:09,640
它依赖于这些常数和运行时间

984
01:07:09,750 --> 01:07:11,000
而它们都由你的机器性能来决定

985
01:07:11,500 --> 01:07:13,980
但是实际上这个算法没有那么热门

986
01:07:14,600 --> 01:07:17,040
因为这些常数都相当大

987
01:07:17,160 --> 01:07:18,800
即使我们通过一些算法保证

988
01:07:18,920 --> 01:07:20,500
划分基准是中间值

989
01:07:20,740 --> 01:07:22,490
即使这些递归加起来小于1

990
01:07:22,600 --> 01:07:24,230
并且还是几何级数的

991
01:07:24,500 --> 01:07:26,750
说它是几何级数的是因为

992
01:07:26,910 --> 01:07:29,890
问题的规模每次至少降低了19/20

993
01:07:30,130 --> 01:07:32,510
实际上问题规模不会很快变得足够小

994
01:07:32,820 --> 01:07:35,170
除非你不会抛硬币  否则实际应用中

995
01:07:35,400 --> 01:07:37,130
你很可能不会想用这个算法

996
01:07:37,870 --> 01:07:40,190
随机算法非常非常快

997
01:07:40,500 --> 01:07:42,310
而理论上这确实是我们的梦想

998
01:07:42,430 --> 01:07:44,790
它是线性时间  是能期望的最优算法

999
01:07:44,980 --> 01:07:48,570
你需要线性时间  有保证的线性

1000
01:07:49,440 --> 01:07:52,300
在下课之前  我还要提到

1001
01:07:54,200 --> 01:07:55,480
一个课后练习

1002
01:08:01,410 --> 01:08:03,380
为什么我们要用五个元素为一组

1003
01:08:03,840 --> 01:08:05,560
为什么不是三个元素为一组

1004
01:08:09,640 --> 01:08:10,920
你们也许已经猜到了

1005
01:08:11,040 --> 01:08:12,710
因为三个元素为一组的话结果不成立

1006
01:08:12,820 --> 01:08:15,440
找出其中的原因是非常有用的

1007
01:08:15,820 --> 01:08:16,830
如果你能算出用三个元素为一组

1008
01:08:17,070 --> 01:08:18,900
代替五个元素为一组的情况下问题的解

1009
01:08:19,180 --> 01:08:20,180
你会发现你本应该理解却没有理解的

1010
01:08:20,260 --> 01:08:22,160
问题的本质

1011
01:08:22,390 --> 01:08:25,150
5是这个算法能成功的最小数字

1012
01:08:25,730 --> 01:08:30,210
7个元素为一组算法也能成立

1013
01:08:30,480 --> 01:08:31,800
但是理论上来说性能不会提高很多

1014
01:08:32,230 --> 01:08:33,550
有问题吗

1015
01:08:35,210 --> 01:08:37,540
好的  然后是星期五的习题课

1016
01:08:37,650 --> 01:08:39,790
实验室星期日开放  习题集下周一交

1017
01:08:39,940 --> 01:08:41,460
两周后测试

