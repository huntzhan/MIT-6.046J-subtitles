1
00:00:11,400 --> 00:00:17,430
这次我们要用到...

2
00:00:17,570 --> 00:00:20,600
一些上一节课所学到的技术

3
00:00:22,040 --> 00:00:25,780
也就是平摊分析课上内容

4
00:00:26,700 --> 00:00:30,050
今天要讲的内容非常酷炫

5
00:00:30,060 --> 00:00:37,410
是一种比较不同算法的方法

6
00:00:37,410 --> 00:00:41,220
用来比较所谓的在线算法

7
00:00:41,300 --> 00:00:47,770
在讲这个算法之前

8
00:00:47,810 --> 00:00:51,810
我们先用一个自组织表的问题来引入

9
00:00:57,650 --> 00:01:00,550
好的 先说说已知条件

10
00:01:00,650 --> 00:01:06,290
我们有一个表L 里面有n个元素

11
00:01:08,910 --> 00:01:14,340
我们定义了一个操作

12
00:01:19,680 --> 00:01:21,400
咕  差点写错字了

13
00:01:23,420 --> 00:01:31,150
访问x操作 也就是访问表里的元素x

14
00:01:31,410 --> 00:01:32,450
它可能是搜索

15
00:01:32,630 --> 00:01:34,220
也可能是其他的操作

16
00:01:34,510 --> 00:01:37,700
总之 它需要进入表里 接触到这个元素

17
00:01:37,790 --> 00:01:44,030
而这个操作的代价就等于

18
00:01:44,360 --> 00:01:49,470
x在表里的排位

19
00:01:49,570 --> 00:02:03,430
换句话说 就是从表头到x的距离

20
00:02:05,270 --> 00:02:07,340
而我们想要做的其他操作

21
00:02:07,910 --> 00:02:09,570
也同样是这个算法需要做的操作

22
00:02:09,730 --> 00:02:11,780
这个是用户会用到的操作

23
00:02:11,820 --> 00:02:14,980
用户对表进行一系列的访问

24
00:02:15,350 --> 00:02:18,190
把元素一个一个访问个遍

25
00:02:18,260 --> 00:02:22,820
按照他或她想要的顺序

26
00:02:23,310 --> 00:02:27,220
然后 L的顺序还可以重新调整

27
00:02:31,500 --> 00:02:38,710
只要置换相邻元素就可以了

28
00:02:45,500 --> 00:02:49,530
而置换操作的代价只要1

29
00:02:50,660 --> 00:02:51,980
那么 举个栗子

30
00:02:54,020 --> 00:03:02,180
假设我们的表是这样的

31
00:03:17,890 --> 00:03:22,910
喔呜 我是不是侧漏了些东西？

32
00:03:25,670 --> 00:03:27,730
算了 稍微漏点霸气而已

33
00:03:27,810 --> 00:03:31,250
我还是把它改成跟我小抄一样吧

34
00:03:31,530 --> 00:03:36,290
这样就能和视频吻合了

35
00:03:42,360 --> 00:03:43,760
好的 我们这有一个表

36
00:03:44,120 --> 00:03:48,700
例如我要访问元素14

37
00:03:48,860 --> 00:03:50,780
键值为14的元素

38
00:03:51,690 --> 00:03:57,120
好的 这步操作的代价是1 2 3 4

39
00:03:57,300 --> 00:04:02,630
那么 这次访问的代价是4

40
00:04:04,810 --> 00:04:08,450
接下来 我们要做一系列的访问操作

41
00:04:08,510 --> 00:04:10,730
用户要做这一系列操作

42
00:04:11,320 --> 00:04:14,950
显然 某些元素会访问得更加频繁

43
00:04:15,710 --> 00:04:19,880
我们想要把它放到表的前排

44
00:04:19,940 --> 00:04:22,190
这样你搜索时 就不用走得太远

45
00:04:22,240 --> 00:04:25,590
好的 这样的话 如果我们要置换元素

46
00:04:25,600 --> 00:04:29,820
比如说 如果我要置换3和50

47
00:04:33,410 --> 00:04:36,000
这步花费只需要1

48
00:04:36,760 --> 00:04:39,600
好的 我把这个换成50

49
00:04:39,960 --> 00:04:41,820
把这个换成3

50
00:04:42,680 --> 00:04:46,880
抱歉 一般来说 你们只需要交换指针就好了

51
00:04:48,300 --> 00:04:51,540
好的 这是我们定义的两个操作

52
00:04:53,070 --> 00:04:57,240
接下来 我们要用“在线”的形式来完成它

53
00:04:57,250 --> 00:05:00,980
那么 我们先给“在线”下定义

54
00:05:01,360 --> 00:05:06,660
一个操作序列S

55
00:05:06,760 --> 00:05:21,010
每次只发送一步的操作请求

56
00:05:22,750 --> 00:05:33,410
而在线算法则必须马上完成这步操作

57
00:05:42,590 --> 00:05:44,660
而不管接下来

58
00:05:44,710 --> 00:05:46,940
会出现什么操作

59
00:05:47,290 --> 00:05:49,640
那么 当你考虑序列中的第一项操作时

60
00:05:50,090 --> 00:05:52,200
你是不考虑后面的操作的

61
00:05:52,460 --> 00:05:54,760
无论是第二个 第三个 哪个都一样

62
00:05:54,940 --> 00:05:57,070
轮到第二项操作时

63
00:05:57,270 --> 00:05:59,280
你就只能执行这一项操作

64
00:05:59,290 --> 00:06:00,210
以此类推

65
00:06:00,390 --> 00:06:01,980
这就是在线算法

66
00:06:03,560 --> 00:06:06,380
反过来 离线算法

67
00:06:10,890 --> 00:06:19,760
它可以预先看过所有的操作

68
00:06:25,140 --> 00:06:26,380
好的 也就是说

69
00:06:26,590 --> 00:06:29,160
离线的算法需要预读整个序列

70
00:06:29,180 --> 00:06:30,830
然后再决定要怎么处理...

71
00:06:31,050 --> 00:06:33,320
操作1 操作2 等等

72
00:06:34,140 --> 00:06:37,280
所以 离线算法可以预读整个序列

73
00:06:37,310 --> 00:06:41,690
它可以提前知道17会被多次访问

74
00:06:42,820 --> 00:06:46,540
然后把它放到更靠近表头的地方

75
00:06:46,610 --> 00:06:50,130
这样离线算法的访问花费就会更少

76
00:06:50,210 --> 00:06:53,000
但在线算法却不能预知未来

77
00:06:53,930 --> 00:06:55,760
所以 这就有点像

78
00:06:55,990 --> 00:06:58,050
如果你熟悉俄罗斯方块的话

79
00:06:58,330 --> 00:06:59,750
对 俄罗斯方块

80
00:06:59,930 --> 00:07:02,740
那些方块是一个接一个的往下掉的

81
00:07:02,880 --> 00:07:04,010
你要旋转它

82
00:07:04,430 --> 00:07:07,320
然后左右移动它 把它放到合适的地方

83
00:07:08,130 --> 00:07:11,120
而在游戏中 你只能往前看一步

84
00:07:11,320 --> 00:07:13,380
你只能看到下一个要出现的方块是什么

85
00:07:13,560 --> 00:07:15,560
但通常下一个方块是在线计算的

86
00:07:15,780 --> 00:07:17,730
你没法看到再下一个方块什么的

87
00:07:17,950 --> 00:07:19,460
你必须一步作一个决定

88
00:07:19,860 --> 00:07:20,790
当你作出了一个决定

89
00:07:21,040 --> 00:07:22,580
再看到下一个方块 又突然发现

90
00:07:22,750 --> 00:07:24,170
啊 如果刚才作另一种决定的话

91
00:07:24,460 --> 00:07:25,740
结果要更好一点

92
00:07:26,230 --> 00:07:30,170
好吧 就是这一类问题

93
00:07:30,370 --> 00:07:31,900
离线俄罗斯方块什么样子的呢

94
00:07:32,130 --> 00:07:34,560
我能看到往后的整串方块

95
00:07:34,890 --> 00:07:36,900
然后 我再来决定这个方块放哪好

96
00:07:39,770 --> 00:07:45,240
好的 这其中 我们的目标是

97
00:07:45,280 --> 00:07:52,670
不管是在线离线 都是把代价最小化

98
00:07:53,390 --> 00:07:56,060
我们把它记为

99
00:07:59,670 --> 00:08:02,370
我的母星啊 我忘了给个名字

100
00:08:02,380 --> 00:08:05,430
这个是A算法

101
00:08:06,350 --> 00:08:10,160
总代价 C_A(S)

102
00:08:10,340 --> 00:08:14,920
好的 这是用A算法计算序列S的代价

103
00:08:15,160 --> 00:08:18,590
我们用这个记号来表示总代价

104
00:08:19,340 --> 00:08:23,220
那么 对这个问题的定义有没有问题？

105
00:08:24,250 --> 00:08:25,530
那么 我们遇到了在线计算的问题

106
00:08:25,680 --> 00:08:27,890
我们一次只能做一步计算

107
00:08:28,480 --> 00:08:32,710
好的 看看我们要做的是什么

108
00:08:33,720 --> 00:08:39,180
呃 我们分析它的最坏情况

109
00:08:50,180 --> 00:08:55,630
如果我们要分析它的最坏情况

110
00:08:55,770 --> 00:08:57,570
我们假想我们有个宿敌

111
00:08:57,690 --> 00:08:59,870
他会给我们安排整个俄罗斯方块的顺序

112
00:08:59,880 --> 00:09:03,020
对手还能看到我们所做的决定

113
00:09:03,170 --> 00:09:05,860
这样的话 宿敌会用什么对策？

114
00:09:08,020 --> 00:09:13,240
[学生]：...

115
00:09:13,410 --> 00:09:15,670
[教授]:破坏我们的计划 对 这是对手的想法

116
00:09:15,890 --> 00:09:18,280
那他或她准备怎么破？

117
00:09:18,340 --> 00:09:21,500
[学生]：...

118
00:09:21,660 --> 00:09:24,280
[教授]:这个问题怎么搞？

119
00:09:24,800 --> 00:09:25,780
他会怎么做？

120
00:09:26,260 --> 00:09:27,530
[学生]：...

121
00:09:27,540 --> 00:09:33,730
[教授]:对 无论我们怎么重排列表中的元素

122
00:09:34,250 --> 00:09:36,830
他都一步步看着 然后说

123
00:09:37,010 --> 00:09:38,240
最后是哪个元素？

124
00:09:38,460 --> 00:09:41,430
那才是他要我们访问的元素 是吧？

125
00:09:41,880 --> 00:09:44,150
那么 对手总是

126
00:09:48,600 --> 00:09:59,460
总是(要我们)访问序列L的末尾的元素

127
00:09:59,600 --> 00:10:02,580
不管它是啥 不管我们怎么重排列表

128
00:10:03,650 --> 00:10:07,750
好的 对于每一次 对手只(要我们)访问末尾

129
00:10:07,990 --> 00:10:11,450
那么总的代价 对于任意一种算法 都会有

130
00:10:12,030 --> 00:10:19,990
序列S的大小乘以n

131
00:10:20,740 --> 00:10:23,120
好的 因为 对于每个操作序列来说

132
00:10:23,340 --> 00:10:27,840
你都要走到底 所以代价是n

133
00:10:28,300 --> 00:10:30,780
对于序列中的每一步访问皆然

134
00:10:30,960 --> 00:10:34,930
好的 所以最坏情况不会很差

135
00:10:40,730 --> 00:10:44,770
还好吧

136
00:10:45,240 --> 00:10:47,830
研究这个问题的人...什么事？

137
00:10:47,850 --> 00:10:50,270
[学生]：...

138
00:10:50,330 --> 00:10:52,200
[教授]:这是在线算法的复杂度分析 是的

139
00:10:52,450 --> 00:10:54,900
离线算法 是的

140
00:10:55,010 --> 00:10:57,240
你可以这么叫它们 没问题

141
00:10:57,370 --> 00:11:01,060
我们尝试在离线的情况下去解决这个问题

142
00:11:01,250 --> 00:11:03,280
不好意思 是在线

143
00:11:04,060 --> 00:11:06,530
好的 就是说在线算法

144
00:11:06,710 --> 00:11:08,870
对手可能是令人发狂的难度

145
00:11:09,830 --> 00:11:12,850
总是要我们访问末尾元素 好吧？

146
00:11:13,060 --> 00:11:16,530
这个问题的由来是

147
00:11:16,640 --> 00:11:18,050
人们想 额

148
00:11:18,340 --> 00:11:22,860
如果最坏情况已经无法挽回了

149
00:11:24,290 --> 00:11:27,760
可能我得看看平均情况会如何

150
00:11:29,020 --> 00:11:30,320
那我们就来看看

151
00:11:31,350 --> 00:11:34,860
不同元素有不同概率分布的情况

152
00:11:35,720 --> 00:11:39,030
好的 分析平均情况

153
00:11:45,090 --> 00:11:52,630
假如说 元素x被访问到

154
00:11:56,470 --> 00:12:03,370
它的概率是P(x)

155
00:12:05,700 --> 00:12:07,390
好的 我们假设

156
00:12:07,560 --> 00:12:11,980
元素被访问的事件有一个先验分布

157
00:12:12,730 --> 00:12:20,960
对于一个访问序列 某种算法的期望代价

158
00:12:23,130 --> 00:12:28,950
如果说 我先设置一种元素的顺序

159
00:12:29,980 --> 00:12:33,540
之后就不再改变它

160
00:12:33,730 --> 00:12:36,760
然后看一下 会不会有某种固定的顺序

161
00:12:36,840 --> 00:12:39,210
特别适合某种分布？

162
00:12:39,440 --> 00:12:42,770
按照期望的定义

163
00:12:44,290 --> 00:12:47,800
就是访问x的概率乘上 在这里是代价

164
00:12:47,840 --> 00:12:54,370
也就是x的排位 排位与顺序相关

165
00:12:54,650 --> 00:12:56,630
顺序是我们设置的

166
00:12:59,910 --> 00:13:02,550
什么时候期望最小？

167
00:13:12,770 --> 00:13:15,450
所以这个就是期望的定义

168
00:13:15,590 --> 00:13:19,330
访问x的概率乘以代价

169
00:13:19,720 --> 00:13:21,280
然后对所有元素求总和

170
00:13:21,330 --> 00:13:23,760
这个代价就是元素在表里的位置

171
00:13:24,380 --> 00:13:26,230
所以 这个值

172
00:13:26,250 --> 00:13:28,560
这个总和 什么时候最小?

173
00:13:33,560 --> 00:13:36,820
[学生]：...

174
00:13:37,030 --> 00:13:39,810
[教授]:当最有可能用到的元素 有最低的排位时

175
00:13:40,120 --> 00:13:43,010
然后呢 其它的元素呢

176
00:13:45,930 --> 00:13:48,190
好的 那是什么意思？

177
00:13:48,240 --> 00:13:49,880
[学生]：...

178
00:13:50,040 --> 00:13:52,230
[教授]:嗯 把他们排好序 嗯

179
00:13:52,240 --> 00:13:56,090
按访问概率排成降序 对吧？

180
00:13:56,360 --> 00:14:00,280
所以 L这样排序的时候期望最小

181
00:14:02,180 --> 00:14:14,480
按访问概率P递减的顺序

182
00:14:18,010 --> 00:14:23,400
好吧 把最大概率的排在最前

183
00:14:23,610 --> 00:14:24,900
然后按概率递减

184
00:14:25,120 --> 00:14:28,440
因为 当我有概率地访问元素时

185
00:14:28,970 --> 00:14:30,410
我将会访问那些

186
00:14:30,740 --> 00:14:32,130
更可能访问到的元素

187
00:14:32,320 --> 00:14:34,220
其实这点也不难证明

188
00:14:34,460 --> 00:14:37,630
你只需想想 假设两个元素顺序反了

189
00:14:38,050 --> 00:14:39,300
你只要证明 通过交换

190
00:14:39,330 --> 00:14:45,560
你就能优化这个函数的性能

191
00:14:49,500 --> 00:14:51,220
好的 如果你并不知道（访问概率）

192
00:14:51,400 --> 00:14:54,080
那么我们也能得到如下的启发

193
00:14:57,710 --> 00:15:04,650
它只是记录每个元素...

194
00:15:08,700 --> 00:15:13,170
被访问的次数

195
00:15:18,680 --> 00:15:29,940
并按访问次数递减的顺序 维护这个表

196
00:15:35,920 --> 00:15:37,960
好的 当一个元素被访问到

197
00:15:39,470 --> 00:15:40,670
它的计数加一

198
00:15:42,430 --> 00:15:44,590
这样 他就会移动

199
00:15:44,730 --> 00:15:45,780
最多一个位置

200
00:15:45,910 --> 00:15:49,110
置换一次代价只是1

201
00:15:49,180 --> 00:15:50,490
它可能向前

202
00:15:51,320 --> 00:15:52,540
实际上 我觉得它可能移得更前

203
00:15:52,680 --> 00:15:54,430
当元素并列在一起的时候 对吧？

204
00:15:55,030 --> 00:15:56,870
是的 它可能花更多代价

205
00:15:57,070 --> 00:15:58,530
但思路就是 随着时间推移

206
00:15:59,010 --> 00:16:01,720
依照大数定理

207
00:16:01,910 --> 00:16:04,860
它将会和概率分布一致的

208
00:16:05,440 --> 00:16:07,480
你访问这一个的频数

209
00:16:07,520 --> 00:16:09,490
除以访问总数

210
00:16:09,640 --> 00:16:11,800
就得到了概率

211
00:16:11,810 --> 00:16:16,300
所以 你的表就会是按出现概率递减排列的

212
00:16:16,830 --> 00:16:20,100
好吧 假设这里有一种分布

213
00:16:20,560 --> 00:16:26,700
所有元素是按照分布来被选择

214
00:16:26,780 --> 00:16:28,760
或者被访问到

215
00:16:31,290 --> 00:16:36,280
这听起来并不像是

216
00:16:36,500 --> 00:16:38,140
你可以做得到的事

217
00:16:38,280 --> 00:16:39,590
这就是为什么我认为

218
00:16:39,810 --> 00:16:42,730
竞争分析这个概念有说服力

219
00:16:43,000 --> 00:16:46,040
就是因为它真的很强大 对吧？

220
00:16:47,030 --> 00:16:54,410
它是从人们的实践中获得的

221
00:16:58,380 --> 00:17:00,860
实际应用中 人们是在

222
00:17:01,380 --> 00:17:07,850
所谓的移前启发式中实现它的

223
00:17:11,160 --> 00:17:13,220
它基本思想是

224
00:17:13,360 --> 00:17:14,990
当你访问了一个元素后

225
00:17:16,230 --> 00:17:18,350
就把它移动到前面

226
00:17:19,730 --> 00:17:23,140
这仅仅是将访问该元素的代价加倍了

227
00:17:23,240 --> 00:17:25,440
因为我访问它时

228
00:17:25,620 --> 00:17:27,180
先要花它排位的代价找到它

229
00:17:27,330 --> 00:17:31,320
然后又要花它排位的代价来置换它

230
00:17:31,890 --> 00:17:33,470
把它置换到前面去

231
00:17:35,010 --> 00:17:38,060
但这也只是多花了一倍的代价 而现在

232
00:17:38,210 --> 00:17:41,620
如果访问到的是高频元素

233
00:17:41,890 --> 00:17:43,360
渐渐地你发现

234
00:17:43,640 --> 00:17:47,780
最可能被访问到的元素就都在表头

235
00:17:48,580 --> 00:17:54,130
所以 访问了x后

236
00:17:57,380 --> 00:18:09,580
把x置换到表头去

237
00:18:13,350 --> 00:18:22,510
这个代价刚好等于x的排名乘以2

238
00:18:22,830 --> 00:18:27,670
这个“2”要一分为二

239
00:18:27,820 --> 00:18:29,510
第一部分是访问

240
00:18:30,780 --> 00:18:33,510
第二部分是置换

241
00:18:38,110 --> 00:18:41,120
好的 这就是它们做的

242
00:18:41,270 --> 00:18:43,630
还有个好处就是

243
00:18:43,770 --> 00:18:46,900
假如发现它的访问模式是局部性的

244
00:18:47,150 --> 00:18:51,060
不是一个静态分布

245
00:18:51,640 --> 00:18:53,530
而是一旦我访问了某个数

246
00:18:53,640 --> 00:18:55,950
以后我就更有可能访问到它

247
00:18:56,420 --> 00:19:00,200
许多输入的模式都有这种情况

248
00:19:00,420 --> 00:19:03,270
这种机制则很适合处理局部性

249
00:19:03,520 --> 00:19:05,350
因为这样 元素就总会在表头附近

250
00:19:05,690 --> 00:19:08,410
当我访问过它一次 下次很快就找到了

251
00:19:08,550 --> 00:19:10,580
这叫做暂时局部性

252
00:19:10,830 --> 00:19:13,300
也就是在某段时间内的访问趋势

253
00:19:13,370 --> 00:19:15,730
在某段时间内 一些元素可能非常热门

254
00:19:15,810 --> 00:19:17,360
慢慢地 它又变冷门了

255
00:19:17,400 --> 00:19:20,150
这种算法对于元素的热门度

256
00:19:20,290 --> 00:19:24,460
有非常好的反应

257
00:19:24,810 --> 00:19:37,450
好的 对于S的局部性的反应相当好

258
00:19:44,510 --> 00:19:46,540
下面要介绍一个著名的分析技术

259
00:19:46,760 --> 00:19:49,720
它出自一篇非常著名的论文

260
00:19:50,330 --> 00:19:54,750
作者的名字就是B.T.大.神.

261
00:19:55,860 --> 00:19:58,620
他们采用了一种革新的方法

262
00:19:59,040 --> 00:20:00,910
来研究这种问题

263
00:20:01,450 --> 00:20:03,600
这种方法的影响到处可见

264
00:20:03,750 --> 00:20:11,610
从高速缓存分析 到高性能处理器分析

265
00:20:12,180 --> 00:20:14,450
再到硬盘分页管理分析

266
00:20:14,840 --> 00:20:19,410
还有一大批应用 都用到了这种基本技术

267
00:20:19,590 --> 00:20:21,840
这种技术就是竞争分析

268
00:20:28,400 --> 00:20:30,140
下面是定义

269
00:20:37,120 --> 00:20:45,430
我们称 在线算法A是α竞争的

270
00:20:51,380 --> 00:20:55,780
如果存在一个常数k

271
00:20:56,580 --> 00:21:05,030
满足对于任意操作序列S

272
00:21:07,320 --> 00:21:11,550
运用算法A的代价

273
00:21:13,580 --> 00:21:27,120
不超过α乘以opt的代价

274
00:21:27,380 --> 00:21:36,600
opt指的是最优的离线算法

275
00:21:37,290 --> 00:21:39,220
好的 最优的离线算法

276
00:21:39,330 --> 00:21:41,500
它一开始就预读了整个序列

277
00:21:42,140 --> 00:21:46,310
那么 它当然能对这个数列做最好的处理

278
00:21:47,410 --> 00:21:49,460
这就是它的代价

279
00:21:49,650 --> 00:21:54,420
有时候 它被称为上帝算法

280
00:21:55,990 --> 00:21:58,260
我们不是在课堂上讲耶稣

281
00:21:58,700 --> 00:21:59,930
也不是要冒犯在座的无神论者

282
00:22:00,040 --> 00:22:01,910
但人们有时就这样叫它

283
00:22:02,080 --> 00:22:04,760
上帝是无所不知的

284
00:22:04,800 --> 00:22:06,750
它绝对知道最优的策略

285
00:22:06,790 --> 00:22:09,670
能预知未来 了解一切运作 好吧？

286
00:22:09,790 --> 00:22:11,520
它能做到那样

287
00:22:11,520 --> 00:22:13,480
这就是最优算法

288
00:22:14,610 --> 00:22:16,610
我们要说的是

289
00:22:16,820 --> 00:22:21,520
代价是跟这个α有关

290
00:22:21,630 --> 00:22:23,460
它可能是一个函数式

291
00:22:23,580 --> 00:22:24,600
又可能是个常数

292
00:22:24,720 --> 00:22:29,050
然后 乘以最优算法

293
00:22:30,370 --> 00:22:33,520
再加上一个可能出现的常数

294
00:22:37,730 --> 00:22:39,980
举个例子 如果α等于2

295
00:22:40,800 --> 00:22:42,410
我们说这个是双竞争的

296
00:22:42,720 --> 00:22:44,580
意思是 你在最差情况下

297
00:22:44,620 --> 00:22:48,120
代价是最优算法的两倍

298
00:22:48,130 --> 00:22:51,430
但你的算法是在线的 比方说

299
00:22:52,360 --> 00:22:55,840
它真的是个非常强大的概念

300
00:22:55,990 --> 00:22:57,570
而且有趣的是

301
00:22:57,960 --> 00:23:00,810
我甚至还不知道这些是什么

302
00:23:01,430 --> 00:23:07,940
好吧 我觉得它最出色的一点

303
00:23:08,090 --> 00:23:12,350
就是不用对元素分布作出假设

304
00:23:12,450 --> 00:23:14,610
不对概率分布作出假设

305
00:23:15,370 --> 00:23:18,020
无论你给的是什么序列

306
00:23:18,590 --> 00:23:21,550
原则上 代价上限都受α因子控制着

307
00:23:21,610 --> 00:23:24,930
最优算法的α倍

308
00:23:24,930 --> 00:23:26,320
这点真的很出色

309
00:23:27,550 --> 00:23:30,850
接下来 我们要证明一个定理

310
00:23:34,980 --> 00:23:37,510
它已经被B.T.大.神.证明过了

311
00:23:37,800 --> 00:23:44,580
这个定理是 自组织表中的MTF算法

312
00:23:47,600 --> 00:23:50,150
是四竞争的

313
00:23:56,120 --> 00:24:04,880
好的 假设我们的宿敌说

314
00:24:05,060 --> 00:24:09,200
哼 人家就是要访问列表的最后一个元素

315
00:24:09,570 --> 00:24:10,760
就像一开始说的那样

316
00:24:12,090 --> 00:24:13,300
宿敌很傲娇

317
00:24:13,310 --> 00:24:14,560
我就是要访问那个元素

318
00:24:14,730 --> 00:24:16,790
我要使得MTF效果非常差

319
00:24:16,970 --> 00:24:18,950
因为你想把那个元素

320
00:24:19,130 --> 00:24:20,430
一直移到最前面

321
00:24:20,880 --> 00:24:23,210
那人家就再访问列表最后的那个元素

322
00:24:25,160 --> 00:24:26,400
这样一来

323
00:24:26,740 --> 00:24:31,440
这种访问的顺序对MTF来说非常糟糕

324
00:24:33,030 --> 00:24:34,030
它要花费大量的时间

325
00:24:34,170 --> 00:24:37,400
但上帝依然表示毫无压力

326
00:24:38,000 --> 00:24:39,820
而且α因子还不会大于4

327
00:24:40,470 --> 00:24:42,530
无论列表有多长

328
00:24:44,030 --> 00:24:45,140
真的很神啊

329
00:24:46,880 --> 00:24:49,570
虽然访问序列真的很恶劣

330
00:24:49,630 --> 00:24:51,820
但是 如果有方法

331
00:24:51,930 --> 00:24:54,790
能使这个序列表现出局部性

332
00:24:54,900 --> 00:24:57,840
或者任何能被加以利用的性质

333
00:24:57,940 --> 00:24:59,400
如果你预知整个序列

334
00:24:59,540 --> 00:25:01,840
MTF也可以受益

335
00:25:02,510 --> 00:25:04,310
总之它的代价总在4倍之内

336
00:25:06,400 --> 00:25:08,600
它真的是个很出色的定理

337
00:25:10,740 --> 00:25:16,040
它还是许多在线算法的分析的基础

338
00:25:16,190 --> 00:25:18,610
而现在 几乎所有的在线算法分析

339
00:25:18,820 --> 00:25:21,190
都用到竞争分析

340
00:25:22,040 --> 00:25:22,920
好吧 不是所有

341
00:25:23,020 --> 00:25:26,440
有时候你做的是概率分析 或者别的

342
00:25:26,580 --> 00:25:29,940
但最主流的还是竞争分析

343
00:25:30,050 --> 00:25:32,600
因为你用不着去做统计学上的假设

344
00:25:33,720 --> 00:25:36,930
你只需要证明无论如何 算法的效果都很好

345
00:25:37,040 --> 00:25:38,900
这简直让人热血沸腾 有木有？

346
00:25:38,900 --> 00:25:40,560
我整个人都斯巴达了！

347
00:25:45,320 --> 00:25:47,130
那我们来证明这个定理

348
00:25:47,580 --> 00:25:50,260
这堂课剩下的时间都用来证明这个

349
00:25:51,040 --> 00:25:53,780
从某些角度看 证明这个不难

350
00:25:53,920 --> 00:25:56,560
但它又不是那么的直观

351
00:25:56,670 --> 00:25:59,300
所以 你们要打醒十二分精神

352
00:26:03,130 --> 00:26:11,030
我们先记下一些符号

353
00:26:11,130 --> 00:26:23,910
设L_i为第i次访问后的MTF表

354
00:26:26,360 --> 00:26:36,660
然后设L_i*为第i次后的最优表

355
00:26:36,840 --> 00:26:38,340
所以 我一般会...

356
00:26:38,450 --> 00:26:40,390
加一个*号来表示最优表

357
00:26:41,610 --> 00:26:45,620
在讨论MTF时什么也不加

358
00:26:48,720 --> 00:26:49,990
这就是我们的表

359
00:26:50,180 --> 00:26:51,400
我们说 这个表是什么？

360
00:26:51,510 --> 00:26:56,580
我们构建表的过程 有一步操作

361
00:26:56,690 --> 00:27:00,660
它能把L_(i-1)转变为L_i

362
00:27:01,330 --> 00:27:03,030
这就是第i个操作做的事情

363
00:27:03,560 --> 00:27:06,420
把元素移到最前

364
00:27:06,560 --> 00:27:08,620
只要被访问到 就移到最前面去

365
00:27:08,730 --> 00:27:12,960
而最优算法只会做它认为最适合的操作

366
00:27:13,070 --> 00:27:14,540
内容我们不清楚

367
00:27:16,620 --> 00:27:30,410
那么我们设c_i为MTF表的第i个操作的代价

368
00:27:31,090 --> 00:27:38,560
代价等于x在L_(i-1)中的排位的两倍

369
00:27:39,830 --> 00:27:48,050
如果x被访问到 好的

370
00:27:48,160 --> 00:27:51,740
2乘以在L_(i-1)里的排位

371
00:27:51,950 --> 00:27:54,480
因为我们是在L_(i-1)表里访问它的

372
00:27:54,590 --> 00:27:56,750
然后把表转变为L_i

373
00:27:58,130 --> 00:28:01,020
同样地 我们令c_i

374
00:28:01,840 --> 00:28:11,500
为最优表的第i个操作的代价

375
00:28:12,430 --> 00:28:15,480
而这个就等于

376
00:28:15,580 --> 00:28:22,610
在表L_(i-1)*里访问x的代价

377
00:28:22,630 --> 00:28:27,260
也就是x在那一步的排位

378
00:28:27,370 --> 00:28:28,910
因为我们要访问它

379
00:28:29,380 --> 00:28:32,570
然后 若干次置换操作

380
00:28:32,870 --> 00:28:43,200
t_i是指 最优表做了t_i次置换

381
00:28:49,860 --> 00:28:53,600
好的 我们构建了一个模型

382
00:28:53,970 --> 00:28:56,360
我们有两种不同的列表

383
00:28:56,650 --> 00:28:58,400
两种表的代价也不同

384
00:29:00,870 --> 00:29:04,130
我们希望给它们做个比较

385
00:29:06,000 --> 00:29:10,990
MTF表与最优表 在任意一个时间点上作比较

386
00:29:11,980 --> 00:29:13,890
然后 你们认为要怎么做？

387
00:29:17,010 --> 00:29:18,400
我们该用什么方法

388
00:29:18,500 --> 00:29:20,250
来比较这两个表

389
00:29:20,690 --> 00:29:24,540
上节课说的一般方法？

390
00:29:27,240 --> 00:29:29,510
平摊分析 但怎么用？

391
00:29:30,860 --> 00:29:32,540
我们怎么样比较？

392
00:29:39,670 --> 00:29:42,700
我们上节课学了什么方法？

393
00:29:45,830 --> 00:29:47,190
势能函数 没错

394
00:29:48,450 --> 00:29:50,750
我们先去定义一个势能函数

395
00:29:52,120 --> 00:29:56,060
用来计算这两个表的距离

396
00:29:59,930 --> 00:30:01,570
好的 做法是

397
00:30:02,610 --> 00:30:05,440
我们先定义 然后再观察它

398
00:30:05,620 --> 00:30:21,950
我们定义一个势能函数Φ

399
00:30:22,880 --> 00:30:29,830
把MTF的表映射为实数

400
00:30:30,540 --> 00:30:33,130
定义如下

401
00:30:35,640 --> 00:30:44,880
Φ（L_i)等于2乘以集合的势

402
00:31:03,250 --> 00:31:09,690
好的 这是列表i里的优先操作

403
00:31:10,160 --> 00:31:13,000
我们可以定义两个元素间的关系

404
00:31:13,520 --> 00:31:20,320
如果在L_i中 x优先于y的话

405
00:31:20,960 --> 00:31:23,720
那从表头向下走 我会先遇到x

406
00:31:25,020 --> 00:31:26,810
这里我关心的是

407
00:31:27,450 --> 00:31:31,480
这两个表之间的不同点

408
00:31:31,660 --> 00:31:36,430
在MTF表里x优先于y

409
00:31:36,610 --> 00:31:39,790
在最优表里y优先于x

410
00:31:40,140 --> 00:31:43,480
它们有分歧 对吧

411
00:31:43,950 --> 00:31:46,400
我们也关心集合的势

412
00:31:46,510 --> 00:31:49,440
我们准备把它乘以二

413
00:31:51,110 --> 00:31:54,390
这个就等于两倍

414
00:31:54,860 --> 00:31:57,200
这个东西有个名字的

415
00:31:57,450 --> 00:31:59,170
我们在学排序的时候讲过了

416
00:31:59,450 --> 00:32:00,440
有人知道它的名字吗？

417
00:32:00,940 --> 00:32:01,950
很短的名字 非常短

418
00:32:02,010 --> 00:32:05,320
你们不一定都记得 但会有人记得的吧

419
00:32:05,510 --> 00:32:07,390
逆序对 很好

420
00:32:07,500 --> 00:32:09,910
逆序对的数目乘以二

421
00:32:13,530 --> 00:32:15,230
我们来举个荔枝

422
00:32:18,050 --> 00:32:24,160
我们假设L_i有5个元素

423
00:32:27,650 --> 00:32:34,120
我们用符号表示顺序

424
00:32:34,340 --> 00:32:35,940
让事情变得简单

425
00:32:55,380 --> 00:33:03,090
这种情况下 Φ(L_i)等于

426
00:33:03,740 --> 00:33:07,340
集合的势的两倍

427
00:33:07,570 --> 00:33:10,690
我们希望找出顺序不一致的地方

428
00:33:11,180 --> 00:33:15,390
所以这里 我有e和c在这里

429
00:33:15,710 --> 00:33:18,760
但是在那个序列是c和e

430
00:33:18,980 --> 00:33:20,260
所以这些是逆序的

431
00:33:20,440 --> 00:33:23,540
那我们数到第一个元素（e,c）

432
00:33:26,130 --> 00:33:29,980
然后是e和a  a和e

433
00:33:30,170 --> 00:33:32,310
这俩也是逆序的

434
00:33:36,530 --> 00:33:40,310
然后有ed de

435
00:33:46,600 --> 00:33:51,290
还有eb be 都是逆序

436
00:33:54,740 --> 00:33:58,410
现在我看到c a c a

437
00:33:58,430 --> 00:34:00,310
它们是顺序的

438
00:34:00,880 --> 00:34:06,360
cd cd cb cb 所以c没有逆序

439
00:34:06,620 --> 00:34:10,340
然后 ad ad 这些是顺序的

440
00:34:10,340 --> 00:34:13,140
a b a b 顺序的

441
00:34:13,460 --> 00:34:16,910
然后 db bd 所以有bd

442
00:34:17,420 --> 00:34:19,490
这是最后一个了

443
00:34:23,290 --> 00:34:25,200
这就是我的势函数

444
00:34:25,380 --> 00:34:28,900
所以就等于 10

445
00:34:29,790 --> 00:34:31,610
因为这个集合的势等于5

446
00:34:31,750 --> 00:34:33,300
我有五个逆序对

447
00:34:35,020 --> 00:34:37,070
好的 两个列表中

448
00:34:43,590 --> 00:34:48,100
那么我们看看这个势函数的一些特性

449
00:34:52,730 --> 00:34:55,700
第一个我们注意到Φ(L_i)

450
00:34:56,340 --> 00:34:58,760
对于任意i都大于等于0

451
00:35:00,040 --> 00:35:02,330
逆序数可能等于0

452
00:35:02,480 --> 00:35:03,780
但不可能小于0

453
00:35:04,660 --> 00:35:06,240
所以最小总是为0

454
00:35:06,820 --> 00:35:09,040
它的这一个特性

455
00:35:09,060 --> 00:35:11,810
会在势能函数中用到

456
00:35:12,170 --> 00:35:16,150
然后 另外的是 Φ(L_0)等于多少？

457
00:35:17,580 --> 00:35:18,860
等于0吗？

458
00:35:22,430 --> 00:35:24,470
这取决于表的初始状态

459
00:35:26,220 --> 00:35:29,280
好的 初始排列是什么？

460
00:35:29,430 --> 00:35:32,100
如果两个表初始排列相同的就为0

461
00:35:32,880 --> 00:35:34,340
它们没有逆序对

462
00:35:34,690 --> 00:35:36,000
但是 他们也可能从一开始就是不同的

463
00:35:36,070 --> 00:35:37,820
我们稍后会讨论一开始就不同的情况

464
00:35:37,980 --> 00:35:41,180
但是现在我们说Φ(L_0)等于0

465
00:35:41,640 --> 00:35:43,290
因为一开始的序列是相同的

466
00:35:43,400 --> 00:35:46,140
这样看起来才是公平的比较

467
00:36:02,170 --> 00:36:04,070
好的 现在我们有了这个势函数

468
00:36:04,310 --> 00:36:07,360
它计算的是 这两个表有多不同

469
00:36:08,620 --> 00:36:10,230
直观来看 我们的情况是

470
00:36:10,370 --> 00:36:12,700
两个表之间的不同点越多

471
00:36:13,440 --> 00:36:15,090
我们就越是能够

472
00:36:15,300 --> 00:36:17,790
储存更多的功 来为以后做准备

473
00:36:18,230 --> 00:36:20,140
基本思路就这样

474
00:36:20,450 --> 00:36:23,860
最优算法对列表的改变越多

475
00:36:24,210 --> 00:36:26,130
它就跟我们越不一样了

476
00:36:26,750 --> 00:36:31,580
某种程度上 我们就越是能在MTF里面

477
00:36:31,870 --> 00:36:33,720
利用列表之间的差异

478
00:36:33,830 --> 00:36:35,980
产生势能来为我们服务

479
00:36:36,080 --> 00:36:38,340
我们看看是怎么做到的

480
00:36:39,180 --> 00:36:42,430
我们先从另一角度观察

481
00:36:42,580 --> 00:36:57,420
交换一次位置 Φ会改变多少？

482
00:37:01,340 --> 00:37:04,020
一次交换Φ改变多少？

483
00:37:05,900 --> 00:37:07,820
其实就是在问

484
00:37:07,970 --> 00:37:09,000
如果做一步置换

485
00:37:09,180 --> 00:37:11,470
逆序对的数目会有什么改变？

486
00:37:14,420 --> 00:37:21,150
交换位置后会怎么样？

487
00:37:22,410 --> 00:37:23,970
Φ会发生什么？

488
00:37:25,750 --> 00:37:30,840
逆序对的数目会有什么改变？

489
00:37:31,650 --> 00:37:33,150
[学生]：...

490
00:37:34,050 --> 00:37:36,890
[教授]:如果我改变了 它就小于n-1

491
00:37:37,540 --> 00:37:39,440
当n足够大时 没错

492
00:37:41,370 --> 00:37:44,150
好的 如果我改变它们 你们想下这种情况

493
00:37:44,260 --> 00:37:46,470
假设我交换这里的两个元素

494
00:37:54,550 --> 00:37:58,110
这样会改变多少

495
00:38:00,430 --> 00:38:02,860
基本上是1或-1

496
00:38:04,340 --> 00:38:19,960
交换（相邻）元素会产生或消除一个逆序对

497
00:38:21,500 --> 00:38:22,550
如果你想想

498
00:38:22,620 --> 00:38:26,100
我交换的如果是c和a

499
00:38:26,580 --> 00:38:28,390
那c和a...

500
00:38:28,780 --> 00:38:31,610
跟表里其他元素的关系没有变化

501
00:38:33,860 --> 00:38:35,840
唯一可能发生的事情是

502
00:38:35,880 --> 00:38:39,250
置换前 它们的顺序相同

503
00:38:40,750 --> 00:38:42,900
置换后就变逆序了

504
00:38:42,950 --> 00:38:46,750
或者 它们原本是逆序的 被我交换位置后

505
00:38:46,990 --> 00:38:48,040
成了顺序的

506
00:38:49,090 --> 00:38:54,380
因此 这个操作对于势函数的改变

507
00:38:54,550 --> 00:38:56,630
等于正负二

508
00:38:57,250 --> 00:39:00,520
因为是逆序对的数量乘以2

509
00:39:06,200 --> 00:39:09,170
好的 有什么问题吗？

510
00:39:09,240 --> 00:39:12,800
所以 置换没有对势能造成多大的改变

511
00:39:13,370 --> 00:39:14,570
就只有1

512
00:39:14,760 --> 00:39:17,890
它不是加二就是减二

513
00:39:18,090 --> 00:39:20,330
就一个逆序对

514
00:39:26,010 --> 00:39:29,760
那现在 我们看一下这两个算法是怎么运作的

515
00:39:44,240 --> 00:40:01,330
好的 操作i访问两个列表的x会发生什么？

516
00:40:01,470 --> 00:40:03,310
会发生什么事？

517
00:40:03,980 --> 00:40:07,200
我们先要定义下面的集合

518
00:40:31,580 --> 00:40:33,100
为什么我总是这么做？

519
00:41:52,750 --> 00:41:54,770
好的 我们看到这里

520
00:41:55,070 --> 00:41:56,250
当我们访问x时

521
00:41:56,390 --> 00:41:58,850
我们观察这两个列表

522
00:41:59,730 --> 00:42:02,550
然后看到它们的关系是什么

523
00:42:02,660 --> 00:42:06,450
根据操作的先来后到

524
00:42:06,550 --> 00:42:08,270
我觉得有幅图片非常有用

525
00:42:08,550 --> 00:42:10,720
可以帮助我们理解

526
00:42:15,050 --> 00:42:17,130
好的 我们设

527
00:42:19,000 --> 00:42:20,700
这里是L_(i-1)

528
00:42:20,800 --> 00:42:24,270
我们的列表 画起来是这样的

529
00:42:24,510 --> 00:42:26,170
我们这里有个x

530
00:42:27,810 --> 00:42:31,190
还有就是L_(i-1)*的

531
00:42:32,010 --> 00:42:34,190
也就是最优表

532
00:42:37,780 --> 00:42:41,570
他或她 把x放在其他位置上

533
00:42:47,310 --> 00:42:51,510
好的 这个集合是什么？

534
00:42:52,240 --> 00:42:58,470
这个集合里 y在x的前面

535
00:43:00,240 --> 00:43:04,390
这是集合A∪B的情况

536
00:43:10,380 --> 00:43:13,830
好的 这两个里面y都在x前面

537
00:43:14,190 --> 00:43:17,630
而对于表L_(i-1)* A集合里 y在x前面

538
00:43:17,770 --> 00:43:22,750
但是... A集合里 y在x前面

539
00:43:22,890 --> 00:43:25,020
B集合里 y在x的后面

540
00:43:25,580 --> 00:43:29,230
下面也同样 这个集合是什么？

541
00:43:38,000 --> 00:43:40,350
A∪C 很好

542
00:43:42,000 --> 00:43:45,430
那这个呢？囧

543
00:43:46,680 --> 00:43:48,980
它就是C∪D

544
00:43:49,400 --> 00:43:51,280
因为我这里有A∪B 而这里是x

545
00:43:51,380 --> 00:43:52,840
所以应该是其他的集合

546
00:43:53,180 --> 00:43:55,440
好的 这里是B∪D

547
00:44:00,970 --> 00:44:09,720
所以 这里是我们要关注的四个集合

548
00:44:10,000 --> 00:44:12,510
我们实际最关心的是这两个

549
00:44:17,250 --> 00:44:21,640
我们这里还有个r

550
00:44:22,270 --> 00:44:24,350
记录x的位置 也就等于

551
00:44:24,460 --> 00:44:33,570
x在L_(i-1)的排位

552
00:44:34,930 --> 00:44:36,850
然后这里 这个是r

553
00:44:37,570 --> 00:44:44,010
它就等于x在L_(i-1)*的排位

554
00:44:44,640 --> 00:44:46,650
好 我们已经知道这些排位了

555
00:44:47,360 --> 00:44:49,190
我们要研究的是

556
00:44:49,540 --> 00:44:54,340
实际上 用集合来表示这个位置

557
00:44:56,500 --> 00:44:58,530
好的 那这是什么位置？

558
00:44:58,830 --> 00:45:06,980
好 排位 我们有r等于 A的大小

559
00:45:07,300 --> 00:45:09,930
加上B的大小再加一

560
00:45:12,640 --> 00:45:19,120
而r*等于A的大小

561
00:45:19,630 --> 00:45:22,620
加上C的大小再加上一

562
00:45:29,440 --> 00:45:32,120
那么 我们看下这里发生了什么

563
00:45:33,050 --> 00:45:38,210
当这两个算法都在运作时

564
00:45:39,100 --> 00:45:42,660
当它访问到x时

565
00:45:43,560 --> 00:45:45,820
我们把x移动到列表的开头

566
00:45:50,640 --> 00:45:52,380
好的 它跑到最前面去

567
00:45:53,870 --> 00:45:59,990
那么 有多少逆序对 产生或消除了？

568
00:46:00,620 --> 00:46:02,350
这里会产生多少？

569
00:46:02,500 --> 00:46:06,420
这大概有 有多少逆序对产生？

570
00:46:31,500 --> 00:46:33,740
有多少产生了？

571
00:46:33,980 --> 00:46:36,520
所以 我们把x移到最前

572
00:46:36,790 --> 00:46:38,370
而我们关心的是

573
00:46:38,470 --> 00:46:42,690
这些集合里 那些元素在变动后

574
00:46:43,510 --> 00:46:46,080
会与下面的元素产生逆序

575
00:46:47,040 --> 00:46:48,570
如果我观察B

576
00:46:48,940 --> 00:46:50,280
呃 我们先看一下A

577
00:46:51,120 --> 00:46:54,530
对于A 它们都保持同样顺序的

578
00:46:55,090 --> 00:46:56,130
两者之间

579
00:46:56,510 --> 00:46:57,820
所以A集合里的所有元素

580
00:46:57,930 --> 00:47:00,120
当我把x移到最前面的时候

581
00:47:01,060 --> 00:47:04,410
每一个A的元素都产生一对逆序

582
00:47:04,670 --> 00:47:05,510
都看懂了吗？

583
00:47:05,560 --> 00:47:11,430
所以 我产生的逆序对数 等于A的势

584
00:47:16,540 --> 00:47:22,470
而另一方面 我们会消除

585
00:47:22,620 --> 00:47:28,630
在L_(i-1)表里 B所有元素都在x前面

586
00:47:28,640 --> 00:47:30,080
在L_(i-1)*里 则在后面

587
00:47:30,090 --> 00:47:31,170
但我移动x之后

588
00:47:31,820 --> 00:47:33,180
它们的顺序则一样了

589
00:47:34,450 --> 00:47:37,640
所以 我消除了B集的逆序对

590
00:47:40,060 --> 00:47:43,420
逆序对的个数等于B的势

591
00:47:48,610 --> 00:47:52,970
所以这就是我们mtf操作的结果

592
00:47:53,250 --> 00:47:54,070
我们消除掉

593
00:47:54,180 --> 00:47:57,600
我们产生A的逆序并消除B的逆序

594
00:47:59,100 --> 00:48:00,860
好的 通过这个移动

595
00:48:02,120 --> 00:48:04,880
好的 现在 我们看看这个最优算法做了什么

596
00:48:05,030 --> 00:48:09,930
每次置换 我们都不知道它做了什么

597
00:48:10,040 --> 00:48:14,210
它可能把x移到这儿或那儿 我们不知道

598
00:48:14,350 --> 00:48:21,560
但最优算法的每次置换

599
00:48:24,380 --> 00:48:27,900
我们要找出它产生了多少对逆序

600
00:48:28,160 --> 00:48:30,350
我们已经讨论过

601
00:48:30,450 --> 00:48:37,790
它在一次置换中 最多产生一对逆序

602
00:48:38,860 --> 00:48:42,640
所以 他不会产生更多的逆序对 是吧？

603
00:48:44,680 --> 00:48:51,660
那么 我把它写在这里

604
00:49:03,030 --> 00:49:10,020
势能变化就是

605
00:49:10,130 --> 00:49:20,700
最大不超过两倍的A减B加上t_i

606
00:49:24,130 --> 00:49:36,320
好的 t_i 记住它就是第i步的时候

607
00:49:36,500 --> 00:49:42,760
最优表在第i次操作时 置换的次数

608
00:49:44,400 --> 00:49:49,800
好的 我们要产生的势能变化

609
00:49:49,840 --> 00:49:54,720
最大等于这条函数式的两倍

610
00:49:54,740 --> 00:49:57,920
那么 我们看看如何运用这个事实

611
00:49:58,340 --> 00:50:05,910
和另外两个事实 好吧

612
00:50:06,800 --> 00:50:15,910
来证明最优算法也不比MTF好很多

613
00:50:25,850 --> 00:50:27,520
好的

614
00:50:28,890 --> 00:50:29,760
我们的方法是

615
00:50:29,830 --> 00:50:33,210
研究第i次操作的平摊代价

616
00:50:34,030 --> 00:50:38,740
MTF的平摊代价是多少？

617
00:50:40,280 --> 00:50:41,920
然后我们给出一个论断

618
00:50:42,060 --> 00:50:43,260
也就是你经常用到的

619
00:50:43,370 --> 00:50:48,990
平摊代价是实际代价的上限 是吧？

620
00:50:49,230 --> 00:50:53,910
而且平摊代价更容易计算

621
00:51:00,030 --> 00:51:02,580
好的 用c^来表示均摊代价

622
00:51:02,800 --> 00:51:06,440
让我看看右边够不够位置

623
00:51:06,940 --> 00:51:10,980
c^i 等于实际代价

624
00:51:11,300 --> 00:51:13,260
加上势能的变化

625
00:51:19,500 --> 00:51:21,680
好的 这就是平摊代价的定义

626
00:51:21,790 --> 00:51:25,100
其中包含了势函数 对吧？

627
00:51:27,470 --> 00:51:33,690
那么 操作i的代价是多少

628
00:51:39,470 --> 00:51:41,940
在这种情况中

629
00:51:42,310 --> 00:51:43,780
好的 我们访问x

630
00:51:44,820 --> 00:51:47,250
操作i的代价是多少？

631
00:51:51,910 --> 00:51:57,430
2乘以x的排位 等于2r

632
00:51:58,110 --> 00:52:01,050
好的2r是它的一部分

633
00:52:03,800 --> 00:52:09,530
加上 我们有个势能变化的上限

634
00:52:10,370 --> 00:52:11,810
就是这个

635
00:52:14,170 --> 00:52:18,740
两倍的A的势

636
00:52:18,850 --> 00:52:23,690
减去B的势加上ti

637
00:52:29,270 --> 00:52:31,110
好吧 都跟上了吗？

638
00:52:31,510 --> 00:52:33,750
嗯？好的 很多人点头 很好

639
00:52:34,250 --> 00:52:44,840
好的 这个等于2r加上两倍A减去

640
00:52:44,950 --> 00:52:47,500
好的 我想把B代入

641
00:52:49,330 --> 00:52:51,130
结果会好看一点

642
00:52:51,480 --> 00:52:56,970
我有一个关于A B和r的式子

643
00:52:57,260 --> 00:53:02,000
我想消掉B的大小这个变量

644
00:53:02,000 --> 00:53:04,640
所以要把B代入

645
00:53:04,860 --> 00:53:07,540
好的 那这里我怎么代入？

646
00:53:10,810 --> 00:53:12,050
B等于什么？

647
00:53:12,130 --> 00:53:14,300
[学生]：...

648
00:53:14,370 --> 00:53:17,080
[教授]:对了 r-|A|-1

649
00:53:17,150 --> 00:53:18,550
我用另外一种形式写出来

650
00:53:21,420 --> 00:53:23,260
然后加上t_i

651
00:53:26,730 --> 00:53:37,350
由于r等于A加B加1

652
00:53:42,420 --> 00:53:44,370
好的 大家思路都跟上了吗？

653
00:53:44,460 --> 00:53:45,760
刚才只是代数运算

654
00:53:45,800 --> 00:53:48,450
我们要确保式子是对的

655
00:53:49,400 --> 00:53:50,470
好的 那这个等于

656
00:53:50,550 --> 00:53:55,430
我们把里面的全部乘出来得到 2r加上

657
00:53:55,570 --> 00:53:59,790
加上2A 这里减A

658
00:53:59,930 --> 00:54:01,650
所以是4A

659
00:54:05,320 --> 00:54:08,280
然后 2乘以负r等于负2r

660
00:54:08,470 --> 00:54:10,900
2乘以-1等于-2

661
00:54:11,470 --> 00:54:12,940
但它减去负二

662
00:54:13,050 --> 00:54:14,470
所以是正二

663
00:54:15,250 --> 00:54:19,330
好的 我有2t_i

664
00:54:21,630 --> 00:54:22,980
这些都是代数运算

665
00:54:25,800 --> 00:54:29,910
所以 这个还不错

666
00:54:30,010 --> 00:54:31,790
我们刚刚还消除了另一个变量

667
00:54:32,240 --> 00:54:35,550
是哪个变量？r

668
00:54:37,380 --> 00:54:38,590
排位是多少并不影响

669
00:54:38,700 --> 00:54:42,330
只要我知道这里的逆序对的数量就够了

670
00:54:42,970 --> 00:54:53,600
好的 现在它等于4A加上2加上2t_i

671
00:54:56,710 --> 00:55:00,890
而且 还小于等于 根据前面的

672
00:55:02,010 --> 00:55:13,230
4倍的r*与t_i的和

673
00:55:13,380 --> 00:55:16,160
因为r*等于

674
00:55:16,270 --> 00:55:20,860
A的大小加上C的大小 再加一

675
00:55:21,340 --> 00:55:27,350
它大于或等于的大小A加1

676
00:55:29,820 --> 00:55:31,460
好的 我在算这条式时

677
00:55:31,610 --> 00:55:37,200
我基本上都在算A

678
00:55:38,190 --> 00:55:43,710
这个A... 我做了些什么？

679
00:55:45,100 --> 00:55:52,410
我们有r*大于或等于A加1 对吧

680
00:55:52,560 --> 00:55:56,930
所以有A加1 好

681
00:56:02,280 --> 00:56:06,000
那么这里就是小于等于4A+4

682
00:56:06,250 --> 00:56:07,970
也就是4倍的A加1

683
00:56:08,380 --> 00:56:10,660
我这里应该再写多一步

684
00:56:11,070 --> 00:56:13,440
因为如果我没有验算一下的话

685
00:56:13,590 --> 00:56:15,500
我会感觉不踏实

686
00:56:15,720 --> 00:56:19,290
这里最大等于4A+4

687
00:56:19,390 --> 00:56:20,790
其实是4倍的A+1

688
00:56:21,020 --> 00:56:23,710
A+1是小于等于r*的

689
00:56:24,850 --> 00:56:28,040
2ti 最大不超过4t_i

690
00:56:29,230 --> 00:56:30,370
所以我得到这个

691
00:56:32,360 --> 00:56:34,660
大家都看懂了这是怎么来的吗？

692
00:56:35,590 --> 00:56:37,600
但是r*加t_i等于多少？

693
00:56:55,900 --> 00:56:57,480
r*加t_i等于多少？

694
00:57:00,500 --> 00:57:01,930
是多少？

695
00:57:03,250 --> 00:57:06,170
它等于c_i

696
00:57:07,240 --> 00:57:08,880
它就是c_i

697
00:57:15,000 --> 00:57:20,690
所以操作i的平摊代价

698
00:57:20,790 --> 00:57:26,210
最大不超过最优算法代价的4倍

699
00:57:31,980 --> 00:57:35,020
真的很强大

700
00:57:37,020 --> 00:57:39,500
好的 操作i的平摊代价

701
00:57:39,600 --> 00:57:41,680
刚好是最优算法代价的4倍

702
00:57:41,760 --> 00:57:43,710
当然 现在我们要检查一遍

703
00:57:44,040 --> 00:57:52,990
并分析总的代价

704
00:57:54,480 --> 00:58:00,970
但这已经是例行公事了

705
00:58:01,080 --> 00:58:05,350
我们用势函数来分析

706
00:58:05,520 --> 00:58:11,550
根据定义 MTF的代价就等于

707
00:58:15,570 --> 00:58:25,120
所有单步代价的总和

708
00:58:25,180 --> 00:58:30,400
这就是那个和 i从1到S

709
00:58:31,280 --> 00:58:38,310
它的平摊代价加上

710
00:58:38,520 --> 00:58:40,470
负的势能变化

711
00:58:48,190 --> 00:58:53,010
呃 我做对了吗？

712
00:58:53,220 --> 00:58:55,680
不对 我的括号放错位置了

713
00:58:59,350 --> 00:59:00,320
现在是对的了 好

714
00:59:00,390 --> 00:59:02,020
我刚漏了一个括号

715
00:59:04,520 --> 00:59:05,520
所以说

716
00:59:05,590 --> 00:59:11,220
之前那条式里 我是把平摊代价表示为

717
00:59:11,750 --> 00:59:14,560
c_i加上势能的变化

718
00:59:14,630 --> 00:59:16,670
现在我只是把这两项移到等号另一边去

719
00:59:16,740 --> 00:59:20,890
这次我们是看 实际代价怎么用平摊代价来表示？

720
00:59:21,170 --> 00:59:26,770
好的 所以我得出的是c^i加上ΦL_(i-1)

721
00:59:26,920 --> 00:59:31,520
再减去ΦL_i  移项后是变成这样

722
00:59:32,580 --> 00:59:36,560
所以它小于或等于... 因为它是线性的

723
00:59:36,660 --> 00:59:38,770
我又知道平摊代价的总和是多少

724
00:59:38,850 --> 00:59:42,070
最大等于4c_i

725
00:59:42,440 --> 00:59:44,490
所以它们的和最大等于

726
00:59:44,840 --> 00:59:52,300
i从1到S 4c_i*的总和

727
00:59:54,080 --> 00:59:56,540
然后 所有的这些项

728
00:59:56,690 --> 00:59:59,190
你都可以用缩进

729
00:59:59,260 --> 01:00:02,180
每一项被加进去一次 又被减去一次

730
01:00:02,290 --> 01:00:05,460
除了两个边界项之外

731
01:00:05,540 --> 01:00:09,740
所以 我要加上ΦL_0

732
01:00:10,350 --> 01:00:16,850
减去ΦL_S

733
01:00:19,870 --> 01:00:24,600
现在 已知这一项是0

734
01:00:26,090 --> 01:00:30,810
而这一项是大于等于0的

735
01:00:34,090 --> 01:00:36,750
因此整个式子小于等于

736
01:00:36,860 --> 01:00:38,320
咦 是多少？

737
01:00:40,170 --> 01:00:43,860
刚好就是最优算法代价的4倍

738
01:00:51,780 --> 01:00:53,310
所以 得出它是4竞争的

739
01:01:00,000 --> 01:01:04,910
好吧 我都觉得很神奇

740
01:01:05,170 --> 01:01:08,000
其实不难 好的

741
01:01:08,020 --> 01:01:12,450
但是仅仅用了一个简单的启发式

742
01:01:12,630 --> 01:01:14,810
性能就变得

743
01:01:15,420 --> 01:01:19,960
像上帝算法那么好

744
01:01:21,900 --> 01:01:23,390
已经差不多那么好了

745
01:01:23,650 --> 01:01:26,520
实际上 这是一个很强大的启发式

746
01:01:26,740 --> 01:01:28,610
假如说你有个哈希表

747
01:01:28,780 --> 01:01:31,510
如果你用的是链接法

748
01:01:31,720 --> 01:01:34,840
通常当你访问一个元素时

749
01:01:34,940 --> 01:01:36,740
你就把它移到链表的表头

750
01:01:36,880 --> 01:01:39,470
如果一开始它是无序的链表

751
01:01:39,470 --> 01:01:40,940
那就把它们移到前面

752
01:01:41,530 --> 01:01:46,650
这就可以节省30%到40%的时间

753
01:01:46,900 --> 01:01:48,960
来访问哈希表

754
01:01:49,010 --> 01:01:51,390
因为你会更容易找到里面的元素

755
01:01:51,430 --> 01:01:54,400
当然 这也取决于元素的分布

756
01:01:54,740 --> 01:01:56,590
实际用用才知道 但有一点就是

757
01:01:56,700 --> 01:01:58,860
你这样做得到的排列顺序

758
01:01:59,080 --> 01:02:09,320
不会和最优算法的顺序差太多

759
01:02:09,540 --> 01:02:12,500
最优离线算法 所以说 很犀利

760
01:02:13,490 --> 01:02:15,130
离线是最优的

761
01:02:16,020 --> 01:02:19,250
接下来 看到我们发的阅读材料

762
01:02:19,360 --> 01:02:23,620
我发给你们的是B.T.大.神.的原论文

763
01:02:25,230 --> 01:02:26,860
在论文里

764
01:02:36,590 --> 01:02:40,000
他们用了一个稍稍不同的模型

765
01:02:40,700 --> 01:02:51,940
他们把访问x时的置换操作...

766
01:02:55,630 --> 01:03:04,930
把置换到表头的代价 记为0

767
01:03:09,180 --> 01:03:12,960
好的 这种建模基本上...

768
01:03:13,330 --> 01:03:16,290
它的思路是 如果我实际有一个链表

769
01:03:18,140 --> 01:03:20,400
当我依次数下来 找到x的时候

770
01:03:20,580 --> 01:03:23,310
我把它移到表头的代价

771
01:03:24,320 --> 01:03:29,000
只是一两步常数级的指针运算

772
01:03:29,570 --> 01:03:31,510
把它的指针指向表头就好了

773
01:03:32,380 --> 01:03:35,920
我实际上用不着一路挨个地交换

774
01:03:36,100 --> 01:03:37,820
所以 他们用的是这样的模型

775
01:03:37,840 --> 01:03:39,630
更有实践意义

776
01:03:40,000 --> 01:03:42,470
我之所以讲这个命题 是因为它更为简单

777
01:03:43,030 --> 01:03:44,670
这个模型挺简单的

778
01:03:44,980 --> 01:03:46,340
但在他们的模型里

779
01:03:46,480 --> 01:03:47,830
当你访问某些元素时

780
01:03:47,870 --> 01:03:48,980
你想把它移到前面去

781
01:03:49,080 --> 01:03:52,380
或者当你正好在访问的时候

782
01:03:52,490 --> 01:03:57,100
你可以不耗费时间地把它移到前面

783
01:03:57,200 --> 01:03:59,840
这模型把链表拆分

784
01:04:02,450 --> 01:04:12,240
用常数时间来完成x的拆放

785
01:04:17,600 --> 01:04:23,810
然后 这样的MTF就是 双竞争的

786
01:04:28,210 --> 01:04:30,740
它是两倍的最优算法代价

787
01:04:32,140 --> 01:04:33,180
好的 如果你用这个

788
01:04:34,550 --> 01:04:36,880
这个用来当作业布置很不错

789
01:04:37,930 --> 01:04:39,220
你也可以读读论文

790
01:04:40,110 --> 01:04:41,270
更好地理解它

791
01:04:41,450 --> 01:04:43,980
想一想你要怎么使用这些东西

792
01:04:44,090 --> 01:04:47,220
你要用另外一项来表示这个

793
01:04:47,320 --> 01:04:49,080
免费的置换操作

794
01:04:49,690 --> 01:04:51,180
但是很明显

795
01:04:51,320 --> 01:04:53,790
这些数学工作都差不多

796
01:04:56,800 --> 01:04:58,730
另外 我答应过你们的

797
01:04:58,840 --> 01:05:00,420
如果 这例子里

798
01:05:00,490 --> 01:05:05,210
如果一开始是两个不同的表 那怎么办？

799
01:05:07,570 --> 01:05:13,210
它们从一开始就不一样 那怎么办？

800
01:05:13,440 --> 01:05:23,620
那么 一开始的势函数就可能

801
01:05:26,950 --> 01:05:27,800
等于多少？

802
01:05:31,170 --> 01:05:33,960
初始的势函数会有多大

803
01:05:35,640 --> 01:05:36,820
如果两个表不同的话？

804
01:05:40,600 --> 01:05:41,930
那么 假设我们一开始

805
01:05:42,030 --> 01:05:43,470
你有个列表 然后最优算法说

806
01:05:43,540 --> 01:05:46,720
好的 我要根据接下来的访问序列

807
01:05:47,070 --> 01:05:49,050
将列表调整为我想要的顺序

808
01:05:50,480 --> 01:05:53,310
好的 MTF根据序列也重新排列

809
01:05:53,410 --> 01:06:00,680
对于我们的宿敌来说 什么才是他初始的最优表？

810
01:06:02,260 --> 01:06:04,080
[学生]：...

811
01:06:04,600 --> 01:06:05,800
[教授]:对 它都打算采用和mtf相反的序列

812
01:06:05,940 --> 01:06:09,880
无论MTF的初始序列是怎么样

813
01:06:09,980 --> 01:06:12,730
因为 如果他的是反向的

814
01:06:12,870 --> 01:06:14,700
逆序对的数量是多少？

815
01:06:18,410 --> 01:06:25,410
反向的列表有多少逆序对？

816
01:06:31,770 --> 01:06:32,700
[学生]：...

817
01:06:32,840 --> 01:06:38,150
[教授]:C(n,2) 好的

818
01:06:38,370 --> 01:06:40,630
是C(n,2)的组合 还是C(n-1,2)的组合

819
01:06:41,750 --> 01:06:45,610
C(n-1,2)的组合 好的

820
01:06:46,010 --> 01:06:48,150
你得到的逆序对

821
01:06:48,290 --> 01:06:50,610
它其实是杨辉三角数

822
01:06:50,830 --> 01:06:51,790
当你把它们加起来

823
01:06:51,900 --> 01:06:58,520
最坏情况是n^2

824
01:06:59,330 --> 01:07:04,960
那它对我们的分析有什么影响？

825
01:07:06,030 --> 01:07:10,020
MTF对于序列S上的代价

826
01:07:10,120 --> 01:07:11,450
呃 不再是0了

827
01:07:11,530 --> 01:07:14,480
现在是n^2

828
01:07:14,590 --> 01:07:24,220
我们得到 S上的MTF算法的代价 最大不超过

829
01:07:25,460 --> 01:07:35,030
4倍的最优算法代价 加上n^2阶 对吧？

830
01:07:38,040 --> 01:07:39,890
然后 如果我们看这个定义

831
01:07:39,950 --> 01:07:41,980
我擦掉了吗？

832
01:07:41,980 --> 01:07:44,990
我又擦掉了一个竞争性的定义

833
01:07:46,490 --> 01:07:50,580
好吧 它仍然是4竞争的

834
01:08:05,470 --> 01:08:13,290
因为当S趋向无穷时 n^2是常数级的

835
01:08:16,700 --> 01:08:18,410
这个是.. 又要考考你们了

836
01:08:18,420 --> 01:08:20,950
n^2是常数级的是什么意思？

837
01:08:21,320 --> 01:08:24,040
即使列表越变越大

838
01:08:24,190 --> 01:08:25,370
但我们做的仅仅是访问

839
01:08:25,380 --> 01:08:27,890
无论这个数字n多大

840
01:08:28,000 --> 01:08:31,110
它的大小并不随着问题的规模变化

841
01:08:31,340 --> 01:08:34,300
好的 即便它一开始是个变量n

842
01:08:35,220 --> 01:08:36,870
它并不随问题的规模而变化

843
01:08:37,250 --> 01:08:41,550
我们仍然用竞争性来得出结果

844
01:08:41,660 --> 01:08:45,130
这就是竞争性定义里面的k

845
01:08:47,080 --> 01:08:50,970
好的 有问题吗？

846
01:08:51,110 --> 01:08:57,660
[学生]：...

847
01:08:58,520 --> 01:09:04,590
[教授]:嗯 那么你们把模型的代价改变一下

848
01:09:04,590 --> 01:09:06,080
[学生]：...

849
01:09:06,200 --> 01:09:10,380
[教授]:是的 这是个好方法

850
01:09:10,700 --> 01:09:12,850
但如果说到置换的代价

851
01:09:13,020 --> 01:09:16,460
它可能只是移动了两个指针

852
01:09:17,100 --> 01:09:18,760
大约是 不对

853
01:09:19,690 --> 01:09:22,280
一个...三个指针

854
01:09:22,510 --> 01:09:24,290
所以 假设这个代价等于

855
01:09:24,400 --> 01:09:27,410
哇噢 是个好作业题 对吧？

856
01:09:27,510 --> 01:09:30,940
假设置换的代价是3次

857
01:09:31,420 --> 01:09:35,810
一次访问的代价变成3次

858
01:09:36,340 --> 01:09:37,750
用指针访问

859
01:09:38,470 --> 01:09:40,590
好 这样改变了什么数？

860
01:09:41,090 --> 01:09:43,750
好的 好练习 好练习

861
01:09:44,180 --> 01:09:47,580
一想到这儿我都流口水了

862
01:09:50,520 --> 01:09:52,660
没错 它会影响到这个常数项

863
01:09:52,850 --> 01:09:55,790
就像B.T.大.神.用的免费置换一样

864
01:09:55,870 --> 01:09:58,050
我们把元素置换到前面

865
01:09:58,310 --> 01:10:01,290
不过把它看成是免费的

866
01:10:02,320 --> 01:10:08,420
你说的操作也会减少这个常数

867
01:10:09,000 --> 01:10:10,490
但是有一点

868
01:10:10,690 --> 01:10:14,230
这个常数和表中元素的数量

869
01:10:14,230 --> 01:10:16,650
这两个常数之间是相互独立的

870
01:10:16,760 --> 01:10:19,220
所以 这是另外一个常数

871
01:10:21,600 --> 01:10:22,610
这是个常数

872
01:10:27,100 --> 01:10:28,810
世事可以分两种

873
01:10:28,920 --> 01:10:30,840
两样东西 一个是理论

874
01:10:30,980 --> 01:10:32,810
理论支撑实践

875
01:10:33,390 --> 01:10:35,230
实践者知道他们在做些什么

876
01:10:35,930 --> 01:10:37,610
或是连自己在做什么都不知道

877
01:10:39,250 --> 01:10:41,020
所以 这样很好很和谐

878
01:10:41,070 --> 01:10:43,420
现在 我们有了更深入的认识了

879
01:10:43,490 --> 01:10:46,100
正如我说的 许多算法 比如

880
01:10:46,210 --> 01:10:48,120
比如像分页这种重要的算法

881
01:10:48,190 --> 01:10:52,660
人们一般学习的分页置换策略是什么？

882
01:10:52,800 --> 01:10:54,690
有学操作系统的人吗？

883
01:10:54,800 --> 01:10:57,420
谁上过6.033的课程？

884
01:11:01,650 --> 01:11:04,330
对了 "最近最少使用策略" LRU

885
01:11:04,510 --> 01:11:05,920
大家都听过的了

886
01:11:06,230 --> 01:11:07,930
你可以分析LRU的竞争性

887
01:11:08,070 --> 01:11:09,840
证明LRU也是很不错的

888
01:11:10,750 --> 01:11:14,110
即使是跟某种假设下的理想的换页策略来对比

889
01:11:14,960 --> 01:11:16,250
好的 还有别的东西

890
01:11:16,310 --> 01:11:18,360
比如 人们采用随机换页算法

891
01:11:18,430 --> 01:11:20,970
还有其他许多诸如此类的

892
01:11:21,110 --> 01:11:24,500
都可以在竞争分析这个框架下完成分析

893
01:11:26,190 --> 01:11:27,020
所以这一套真的很无解

894
01:11:27,090 --> 01:11:29,920
星期五的复习课会接触到

895
01:11:30,130 --> 01:11:32,720
一些别的更好玩得问题

896
01:11:32,790 --> 01:11:35,600
可能会比这个要简单一些

897
01:11:38,550 --> 01:11:40,170
好吧 肯定比这个简单

898
01:11:41,420 --> 01:11:45,210
肯定能让你们对竞争分析有很大的启发

899
01:11:46,170 --> 01:11:56,510
我还要提醒你们 关于下周的习题集

900
01:11:58,780 --> 01:12:00,470
那么 下周的习题集

901
01:12:00,620 --> 01:12:02,880
有一道是编程题

902
01:12:04,110 --> 01:12:09,650
这份编程作业是必做的

903
01:12:11,200 --> 01:12:14,070
也就是说 你们懂的

904
01:12:14,220 --> 01:12:17,220
如果不做这道编程题

905
01:12:17,330 --> 01:12:18,460
平时分要扣分

906
01:12:18,570 --> 01:12:22,030
而且如果你不做作业

907
01:12:22,320 --> 01:12:24,810
会扣很多平时分

908
01:12:25,130 --> 01:12:27,980
但是这题是必做中的战斗题

909
01:12:28,480 --> 01:12:30,150
不做就挂科

910
01:12:30,220 --> 01:12:33,350
如果你不做你的人参就是不完整的

911
01:12:33,510 --> 01:12:37,290
现在 我知道有些同学很少敲代码

912
01:12:37,850 --> 01:12:40,000
所以 我建议你周末时候

913
01:12:40,190 --> 01:12:42,050
花点时间

914
01:12:42,190 --> 01:12:45,830
敲敲代码

915
01:12:45,930 --> 01:12:47,740
如果你已经敲到条件反射的境界

916
01:12:47,850 --> 01:12:49,120
这个作业只是一眨眼的事

917
01:12:49,190 --> 01:12:53,600
但如果你是传说中的亚历山大 读写文件都不会

918
01:12:53,980 --> 01:12:59,330
半天才挤出一两行代码

919
01:12:59,430 --> 01:13:00,450
如果你很水

920
01:13:00,810 --> 01:13:03,290
这周末就是个升级刷经验的好机会

921
01:13:03,430 --> 01:13:04,550
读文件

922
01:13:04,650 --> 01:13:05,770
到时候是要读文件的

923
01:13:05,970 --> 01:13:07,540
从文件里面读数据

924
01:13:07,950 --> 01:13:09,550
然后做些操作

925
01:13:09,700 --> 01:13:12,090
再写回到文件里 好吧？

926
01:13:13,200 --> 01:13:16,810
我不希望有人连必做题都做不完

927
01:13:16,920 --> 01:13:18,220
然后还被我抓到

928
01:13:18,330 --> 01:13:20,780
因为他们总是想着

929
01:13:24,000 --> 01:13:25,710
能够走捷径

930
01:13:25,810 --> 01:13:27,110
我知道有人上这门课之前

931
01:13:27,210 --> 01:13:29,540
还没怎么编过程

932
01:13:29,770 --> 01:13:31,640
但现在你要用到了 有问题吗？

933
01:13:31,640 --> 01:13:32,880
[学生]：...

934
01:13:33,030 --> 01:13:35,000
[教授]:没有语言限制 随你

935
01:13:35,300 --> 01:13:37,630
官方答案可能会用 我想 用Java写

936
01:13:37,700 --> 01:13:40,870
然后Eric最喜欢用Python

937
01:13:42,360 --> 01:13:45,300
来写他的答案了

938
01:13:45,400 --> 01:13:48,030
我们看他到时是不是这么专一

939
01:13:48,100 --> 01:13:49,640
你已经写好了？

940
01:13:50,260 --> 01:13:52,490
George君说要用Java的

941
01:13:52,690 --> 01:13:54,000
还有 C语言也可以

942
01:13:55,150 --> 01:13:56,520
Matlab也可以

943
01:13:57,020 --> 01:14:01,240
还有什么呢？

944
01:14:01,390 --> 01:14:02,550
都是可以的

945
01:14:02,690 --> 01:14:05,930
Scheme可以 Scheme好东西

946
01:14:06,700 --> 01:14:09,680
这些东西都可以用

947
01:14:09,830 --> 01:14:12,290
我不介意你们用什么语言

948
01:14:12,390 --> 01:14:15,430
当你们就是要用编程来解决这些问题

949
01:14:15,660 --> 01:14:17,560
好的 非常感谢

950
01:14:17,700 --> 01:14:18,610
下周见

