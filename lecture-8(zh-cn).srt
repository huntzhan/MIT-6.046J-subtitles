1
00:00:08,190 --> 00:00:18,280
我们今天将研究关于哈希的一些神奇的内容

2
00:00:18,360 --> 00:00:22,580
对 真的是相当精巧  非常神奇

3
00:00:22,690 --> 00:00:32,340
我们由一个哈希的根本缺陷谈起

4
00:00:32,420 --> 00:00:40,080
对于任意哈希函数而言

5
00:00:47,810 --> 00:01:04,080
都存在一个不好的键集  所有键都会哈希映射到同一个槽

6
00:01:08,320 --> 00:01:11,200
当选择一个哈希函数时

7
00:01:11,270 --> 00:01:13,620
我们会找一些在实际应用中很不错的

8
00:01:13,700 --> 00:01:16,000
而且还很方便地嵌入到你的代码中的

9
00:01:16,080 --> 00:01:22,710
但不管你选择哪个 总有一些不好的键集

10
00:01:22,790 --> 00:01:29,680
你可以想像  这只是为了让我们更接近问题的本质

11
00:01:29,750 --> 00:01:38,710
试想你为一个客户建立了一个编译器

12
00:01:38,790 --> 00:01:41,730
有一个专门为编译器准备的符号表

13
00:01:41,810 --> 00:01:43,330
客户的要求之一是

14
00:01:43,400 --> 00:01:46,730
比较快速的编译过程

15
00:01:46,810 --> 00:01:49,860
他们可不想编译的时候就坐在旁边苦等

16
00:01:49,940 --> 00:01:54,080
你的一个竞争对手也建了一个编译器

17
00:01:54,160 --> 00:02:00,860
当客户准备测试编译器时

18
00:02:00,930 --> 00:02:05,370
假设两个编译器都有 一些类似溢出之类的问题

19
00:02:05,440 --> 00:02:06,700
在测试过程中

20
00:02:06,780 --> 00:02:08,090
客户会要求你

21
00:02:08,170 --> 00:02:12,100
不仅能运行客户的一套测试基准

22
00:02:12,170 --> 00:02:15,610
还要为对方的编译器

23
00:02:15,690 --> 00:02:19,450
建立一套测试基准

24
00:02:19,530 --> 00:02:25,000
而你的竞争对手也会为你建立一套测试基准

25
00:02:25,070 --> 00:02:29,110
不仅如此 你们还要共享代码

26
00:02:29,200 --> 00:02:31,530
你要知道对方在做什么

27
00:02:31,610 --> 00:02:35,960
他们采用的是什么哈希函数

28
00:02:36,040 --> 00:02:39,650
这很显然 在这种情况下

29
00:02:39,730 --> 00:02:43,400
你的竞争对手就会查看

30
00:02:43,480 --> 00:02:48,160
你用的是什么哈希函数

31
00:02:48,230 --> 00:02:52,330
然后对症下药 给你找一个

32
00:02:52,410 --> 00:02:55,700
全部都哈希到同一个槽的键集

33
00:02:55,780 --> 00:02:59,280
这样一来 当你的哈希表查找数据时

34
00:02:59,350 --> 00:03:05,480
就相当于是在遍历一个链表

35
00:03:05,560 --> 00:03:08,740
这样很大程度上减缓了程序的运行速度

36
00:03:08,820 --> 00:03:11,430
比起均匀分布的哈希表

37
00:03:11,500 --> 00:03:12,680
它运行要慢得多

38
00:03:12,700 --> 00:03:14,520
因为毕竟  那才称得上

39
00:03:14,610 --> 00:03:17,530
用到了哈希表

40
00:03:17,610 --> 00:03:21,660
但问题是  如何战胜你的对手？

41
00:03:21,730 --> 00:03:30,470
答案只要一个词

42
00:03:30,540 --> 00:03:34,380
一个词 如何做到？

43
00:03:34,460 --> 00:03:39,770
如何打败这个班里的所有对手？

44
00:03:39,850 --> 00:03:43,540
随机性 对 就是随机性

45
00:03:43,620 --> 00:03:45,770
你有了随机性那对手就没办法了

46
00:03:45,840 --> 00:03:51,120
解决方案是随机选择一个哈希函数

47
00:03:51,200 --> 00:03:53,780
相对独立地 对手可以查看代码

48
00:03:53,850 --> 00:03:55,000
但当程序运行时

49
00:03:55,070 --> 00:03:58,190
它将使用一个随机的哈希函数

50
00:03:58,260 --> 00:04:01,290
他没办法预测  你最终将用到的

51
00:04:01,370 --> 00:04:03,560
是哪个哈希函数

52
00:04:03,640 --> 00:04:07,520
这样的话  即使对手能提供一组输入

53
00:04:07,590 --> 00:04:08,880
但他们却不能

54
00:04:08,960 --> 00:04:13,160
保证它能减缓你的程序的运行速度

55
00:04:13,230 --> 00:04:16,560
你可能会随机到一个比较差的哈希函数

56
00:04:16,630 --> 00:04:20,340
但实际上不会 因为对手没办法预测

57
00:04:20,410 --> 00:04:33,600
所以问题关键是  选择哈希函数时

58
00:04:33,680 --> 00:04:36,980
要随机选择

59
00:04:37,050 --> 00:04:46,470
与输入的哈希运算的键

60
00:04:46,540 --> 00:04:48,710
保持相对独立

61
00:04:48,780 --> 00:04:52,270
这样即使你的对手能看到你的代码

62
00:04:52,340 --> 00:04:53,810
他也不能确定  实际运行时

63
00:04:53,890 --> 00:04:58,330
会用到哪一个哈希函数

64
00:04:58,410 --> 00:05:01,600
他无法预测随机数的输出

65
00:05:01,670 --> 00:05:05,880
看上去这个方法切实可行

66
00:05:05,950 --> 00:05:14,470
这个方法的名字叫全域哈希

67
00:05:14,550 --> 00:05:21,350
一个能实现该方案的哈希方法

68
00:05:21,420 --> 00:05:34,200
那么 我们写些数学定义  设U为键的全域

69
00:05:34,270 --> 00:05:50,770
H是哈希函数的有限集

70
00:05:54,860 --> 00:06:01,590
H的哈希函数将U的键映射到

71
00:06:01,670 --> 00:06:06,340
哈希表的槽里

72
00:06:06,410 --> 00:06:11,760
好的  我们有一个有限集H

73
00:06:11,830 --> 00:06:21,070
我们称H是全域的

74
00:06:21,140 --> 00:06:34,810
——如果满足 对于所有的键对

75
00:06:34,880 --> 00:06:44,610
——键与键两两互异 那下面的推论就能成立

76
00:07:02,070 --> 00:07:07,520
在这个函数集H里  对于任意键对

77
00:07:07,590 --> 00:07:10,680
都会将它们哈希映射到同个位置的

78
00:07:10,750 --> 00:07:13,410
哈希函数的数目

79
00:07:13,490 --> 00:07:20,670
等于|H|/m

80
00:07:20,750 --> 00:07:24,740
也可以这样看

81
00:07:24,810 --> 00:07:38,280
从另一个角度看 如果哈希函数h是

82
00:07:38,360 --> 00:07:44,700
随机地从函数集H里选出

83
00:07:44,770 --> 00:07:59,410
那x和y发生碰撞的几率是多少？

84
00:08:11,300 --> 00:08:18,180
如果我们选出了的一部分哈希函数...

85
00:08:18,260 --> 00:08:20,320
又或者说 选出的哈希函数的数目是H/m

86
00:08:20,400 --> 00:08:26,940
那么 x和y碰撞的几率是多少？

87
00:08:27,020 --> 00:08:30,880
如果我随机选择一个哈希函数

88
00:08:30,950 --> 00:08:33,190
那我就随机选一个哈希函数

89
00:08:33,270 --> 00:08:36,790
它们碰撞的几率是多少？

90
00:08:36,870 --> 00:08:39,790
1/m

91
00:08:39,870 --> 00:08:42,410
让我们画张图

92
00:08:42,480 --> 00:08:48,800
来帮助理解  实际上是这样子的

93
00:08:48,880 --> 00:08:59,530
假设这是所有哈希函数组成的集合

94
00:08:59,610 --> 00:09:07,420
如果选择一对特定的x和y

95
00:09:07,500 --> 00:09:12,740
假设这个子集里的哈希函数

96
00:09:12,810 --> 00:09:18,270
能使得h(x)=h(y)

97
00:09:18,350 --> 00:09:23,130
那么这个子集的势

98
00:09:23,210 --> 00:09:28,400
等于1/m * |H|

99
00:09:28,470 --> 00:09:32,430
就像投掷飞镖  随机投到一个哈希函数

100
00:09:32,510 --> 00:09:36,340
哈希函数落在这个特殊子集里的

101
00:09:36,410 --> 00:09:38,730
几率是1/m

102
00:09:38,810 --> 00:09:40,090
当然 对于每对x和y

103
00:09:40,170 --> 00:09:42,430
上述等式都是成立的

104
00:09:42,510 --> 00:09:44,420
另一边  则是不同的函数子集

105
00:09:44,490 --> 00:09:45,840
它们会把不同的x和y

106
00:09:45,920 --> 00:09:50,610
映射到不一样的地方

107
00:09:50,680 --> 00:09:54,280
但对于所选的任意x和y

108
00:09:54,360 --> 00:09:56,110
通过随机选择的哈希函数

109
00:09:56,180 --> 00:09:59,700
哈希到同一个位置的概率是 1/m

110
00:09:59,770 --> 00:10:01,010
这里有一点理解上的困难

111
00:10:01,080 --> 00:10:02,520
有时让人脑袋转不过来

112
00:10:02,600 --> 00:10:04,050
因为习惯性会想

113
00:10:04,130 --> 00:10:07,060
随机地选择键之类的

114
00:10:07,130 --> 00:10:08,620
跟这里的情况不一样

115
00:10:08,700 --> 00:10:11,320
我们是随机地选择哈希函数

116
00:10:11,390 --> 00:10:16,190
所以我们的概率空间 是给哈希函数定义的

117
00:10:16,260 --> 00:10:19,620
而不是键

118
00:10:19,690 --> 00:10:23,010
对于所选的任意两个不同的键

119
00:10:23,090 --> 00:10:26,740
这个等式都是成立的

120
00:10:26,820 --> 00:10:28,770
如果它们用的是

121
00:10:28,840 --> 00:10:30,010
这个子集里的哈希函数

122
00:10:30,090 --> 00:10:34,360
如果你仔细思考一下 就会发现这是一个不可思议的特性

123
00:10:34,440 --> 00:10:36,400
因为这意味着

124
00:10:36,480 --> 00:10:38,770
对于任意的两个键值

125
00:10:38,850 --> 00:10:42,410
一个随机抽取的哈希函数

126
00:10:42,490 --> 00:10:44,460
将它们哈希到同个位置的概率

127
00:10:44,540 --> 00:10:49,260
正好是1/m

128
00:10:49,340 --> 00:10:50,950
非常精巧

129
00:10:51,050 --> 00:10:52,420
非常 非常美妙的特性

130
00:10:52,490 --> 00:10:58,500
我们将会看到 它相关的数学运算真的非常酷

131
00:10:58,580 --> 00:11:13,600
那么 我们的定理是 如果从哈希函数集H里

132
00:11:14,690 --> 00:11:19,660
随机地选择函数h

133
00:11:19,730 --> 00:11:39,460
然后假设我们要将n个键 放进T表的m个槽里

134
00:11:43,190 --> 00:11:50,980
对于给定的键x

135
00:11:51,120 --> 00:12:02,260
它发生碰撞的期望次数

136
00:12:02,340 --> 00:12:07,100
小于n/m

137
00:12:07,170 --> 00:12:12,230
有谁还记得n/m是什么吗？

138
00:12:12,310 --> 00:12:19,170
α 我们用什么术语来称呼它？

139
00:12:19,250 --> 00:12:28,970
装载因子 哈希表的装载因子

140
00:12:29,060 --> 00:12:33,810
装载因子α

141
00:12:33,900 --> 00:12:36,110
平均到每个槽的键数

142
00:12:36,180 --> 00:12:42,050
就是哈希表的装载因子

143
00:12:42,120 --> 00:12:47,230
那这个定理在表达什么？

144
00:12:47,300 --> 00:12:52,370
是这样的

145
00:12:52,440 --> 00:13:03,140
如果我们有这样一个哈希函数的全域集

146
00:13:03,210 --> 00:13:08,320
那它的运行结果就会跟所预期的一样

147
00:13:08,400 --> 00:13:11,160
键的分布很均匀

148
00:13:11,230 --> 00:13:12,300
对于任意的键

149
00:13:12,380 --> 00:13:14,790
它发生碰撞的次数

150
00:13:14,870 --> 00:13:21,900
会等于n/m

151
00:13:21,980 --> 00:13:25,490
这真是一个不错的性质

152
00:13:25,560 --> 00:13:29,530
我还没有解释集合U怎么构建

153
00:13:29,600 --> 00:13:32,890
抱歉 应该是哈希函数集H怎么构建

154
00:13:32,960 --> 00:13:34,860
我们会在构建这块下一些功夫

155
00:13:34,930 --> 00:13:40,080
但首先我想解释下 为什么这是一个极好的性质

156
00:13:40,160 --> 00:13:42,130
这定理基本上就是这样子

157
00:13:42,200 --> 00:13:45,010
那我们来一起证明它

158
00:13:45,080 --> 00:13:50,920
对这个定理的表述还有什么问题吗？

159
00:13:51,000 --> 00:13:53,370
那接下来 我们要讲得快点了

160
00:13:53,440 --> 00:13:55,300
因为有很多东西要讲

161
00:13:55,390 --> 00:14:00,100
我想保证大家在整过程中都能跟上

162
00:14:00,170 --> 00:14:01,870
如果有任何问题  确保你要弄懂

163
00:14:01,940 --> 00:14:05,050
像定理的表述之类的 最好能先理解透彻

164
00:14:05,120 --> 00:14:07,030
这样在后面

165
00:14:07,240 --> 00:14:14,380
当内容稍微复杂起来时  才不会感到困惑

166
00:14:14,460 --> 00:14:18,190
好的 开始证明

167
00:14:18,260 --> 00:14:26,320
设C_x为一个随机变量

168
00:14:26,400 --> 00:14:37,250
它表示 哈希表T里的键与x

169
00:14:37,320 --> 00:14:47,350
发生碰撞的总次数

170
00:14:47,430 --> 00:14:49,940
这是一个总数 在随机化算法的

171
00:14:50,050 --> 00:14:54,390
概率分析里面

172
00:14:54,460 --> 00:14:56,590
这是经常用到的一种技巧之一

173
00:14:56,660 --> 00:14:59,780
你会意识到

174
00:14:59,860 --> 00:15:04,660
C_x实际上是指标随机变量的总和

175
00:15:04,730 --> 00:15:07,930
如果你能将事件分解成指标随机变量

176
00:15:08,010 --> 00:15:11,320
那分析起来就会比

177
00:15:11,420 --> 00:15:16,000
集中起来的变量容易很多

178
00:15:16,080 --> 00:15:20,570
在这里我们把

179
00:15:20,640 --> 00:15:26,190
指标随机变量 设为小写c_xy

180
00:15:26,260 --> 00:15:39,340
如果h(x)＝h(y) 值为1； 否则为0

181
00:15:39,410 --> 00:15:47,040
可以注意到两点

182
00:15:47,120 --> 00:15:56,450
首先 c_xy的期望值是多少

183
00:15:56,520 --> 00:15:57,930
如果有一个进程

184
00:15:58,000 --> 00:16:00,330
在随机选择哈希函数

185
00:16:00,400 --> 00:16:04,680
那c_xy的期望值是多少？

186
00:16:04,750 --> 00:16:06,660
1/m

187
00:16:06,740 --> 00:16:12,500
因为这基本上就是这里的定义

188
00:16:12,570 --> 00:16:15,520
换句话说 随机选择一个哈希函数

189
00:16:15,590 --> 00:16:18,900
哈希结果相同的概率是多少？

190
00:16:18,980 --> 00:16:20,740
1/m

191
00:16:20,830 --> 00:16:23,050
另外一方面

192
00:16:23,130 --> 00:16:25,400
选择这公式的原因是

193
00:16:25,480 --> 00:16:28,560
因为我们可以将大写C_x——

194
00:16:28,640 --> 00:16:31,560
这个表示碰撞总数的随机变量

195
00:16:31,640 --> 00:16:36,670
表示为  当y取T中的非x元素时

196
00:16:36,740 --> 00:16:44,730
对应的c_xy值的和

197
00:16:44,800 --> 00:16:54,830
那么 对于每个与x发生碰撞的的键

198
00:16:54,910 --> 00:17:00,340
我都给C_x上加1 如果没有发生碰撞 则加0

199
00:17:00,410 --> 00:17:05,430
那这就把表中所有和x发生的碰撞

200
00:17:05,500 --> 00:17:14,390
全部都加到一起

201
00:17:16,770 --> 00:17:18,380
到这里有什么问题没有？

202
00:17:18,470 --> 00:17:19,820
这部份是理论的基础架构

203
00:17:19,890 --> 00:17:20,960
是主要内容的基础架构

204
00:17:21,040 --> 00:17:24,830
是大多数学生容易出错的地方

205
00:17:24,910 --> 00:17:27,040
很多研究员新手

206
00:17:27,130 --> 00:17:29,810
也同样在这里出错

207
00:17:29,890 --> 00:17:31,200
但只要你把架构做好了

208
00:17:31,270 --> 00:17:32,590
之后的数学工作就好做了

209
00:17:32,660 --> 00:17:35,310
而通常 这些架构是将...

210
00:17:35,390 --> 00:17:39,550
实际情况转换为数学问题的建模结果

211
00:17:39,620 --> 00:17:42,230
这部分是难点 只要你搞明白了

212
00:17:42,310 --> 00:17:44,030
那接下来的代数运算...

213
00:17:44,100 --> 00:17:46,770
当然 代数运算中也可能出错

214
00:17:46,860 --> 00:17:49,950
但至少检查起来容易得多

215
00:17:50,020 --> 00:17:52,500
相对于转换过程而言

216
00:17:52,580 --> 00:17:55,300
所以我想保证大家都能理解

217
00:17:55,380 --> 00:17:57,370
这个是如何架构的

218
00:17:57,450 --> 00:18:04,580
现在就要用到我们的数学技能了

219
00:18:04,650 --> 00:18:07,480
碰撞次数的期望值是

220
00:18:07,570 --> 00:18:10,040
C_x的期望值

221
00:18:10,130 --> 00:18:17,490
等于这个期望值...这里是对所有c_xy的求和

222
00:18:17,560 --> 00:18:25,300
y属于T 而且y不等于x

223
00:18:25,370 --> 00:18:28,190
这就是定义

224
00:18:28,270 --> 00:18:31,530
也就等于对所有E[c_xy]求和

225
00:18:31,600 --> 00:18:38,480
y属于T 而且y不等于x

226
00:18:38,560 --> 00:18:41,790
为什么会等于这个

227
00:18:41,870 --> 00:18:50,900
对 期望的线性性质

228
00:18:50,970 --> 00:18:54,770
这是期望的线性性质 和独立性无关

229
00:18:54,850 --> 00:18:59,850
对任意随机变量都是成立的

230
00:18:59,930 --> 00:19:08,630
还等于 下面的数学比较简单

231
00:19:08,700 --> 00:19:12,200
这是多少？

232
00:19:12,270 --> 00:19:14,770
1/m

233
00:19:14,880 --> 00:19:17,700
这样一来 总和就很容易算了

234
00:19:17,790 --> 00:19:25,270
得出(n-1)/m

235
00:19:28,540 --> 00:19:33,010
相当简洁的分析 这就是为什么..

236
00:19:33,090 --> 00:19:38,920
我们会喜欢上全域哈希的原因

237
00:19:39,000 --> 00:19:41,600
因为一旦有了它

238
00:19:41,680 --> 00:19:47,220
那结果就会像我们期望中的那样

239
00:19:47,290 --> 00:19:49,410
这样一来你就能打败你的对手了

240
00:19:49,490 --> 00:19:52,510
只需随机地选择一个哈希函数

241
00:19:52,590 --> 00:19:58,730
他或她 都会对此无能为力

242
00:19:58,820 --> 00:20:01,520
对这个证明还有什么问题没有？

243
00:20:01,600 --> 00:20:04,920
好的 现在进入有趣的数学部分

244
00:20:04,990 --> 00:20:10,050
造这些可爱的孩纸

245
00:20:19,490 --> 00:20:23,310
这并不是唯一的构造方法

246
00:20:23,390 --> 00:20:29,710
只是一种构造经典的全域哈希的方法

247
00:20:29,780 --> 00:20:34,310
一些出版物里会有其它的结构

248
00:20:34,400 --> 00:20:41,710
在练习测试中会用到其中一个

249
00:20:41,780 --> 00:20:50,190
咱们看这里 这个是当m为质数时成立

250
00:20:50,270 --> 00:20:55,010
即当槽的总数 为质数时有效

251
00:20:55,090 --> 00:20:58,710
槽数为质数

252
00:20:58,780 --> 00:21:04,990
做法是 把全域里的任意键k

253
00:21:05,070 --> 00:21:19,120
分解成r+1位

254
00:21:19,200 --> 00:21:33,390
可以把k看成k_0 k_1 ...k_r

255
00:21:33,470 --> 00:21:37,520
这里  k_i大于等于0

256
00:21:37,600 --> 00:21:42,420
小于等于m-1

257
00:21:42,490 --> 00:21:47,230
这种做法的思想是

258
00:21:47,300 --> 00:21:54,560
把k用"m进制"来表示是什么样子

259
00:21:54,630 --> 00:21:58,730
如果我们用二进制  那每一位就最多有1

260
00:21:58,810 --> 00:22:00,580
这些就是不同的位

261
00:22:00,660 --> 00:22:02,770
我们不打算用二进制

262
00:22:02,840 --> 00:22:05,260
我们把它一般化成"m进制"

263
00:22:05,350 --> 00:22:09,400
这里每一个都代表一个位

264
00:22:09,480 --> 00:22:12,200
我们这里把第一个数定为最低位

265
00:22:12,270 --> 00:22:14,480
实际上没有关系

266
00:22:14,560 --> 00:22:16,870
实际上并不用太在乎顺序

267
00:22:16,950 --> 00:22:19,130
我们实际上是要换一种k的表示方式

268
00:22:19,210 --> 00:22:23,770
把它打散成一位一位的数字

269
00:22:23,850 --> 00:22:27,530
把k换算成"m进制"的一种算法是

270
00:22:27,610 --> 00:22:30,340
不断地对k除m再取余

271
00:22:30,410 --> 00:22:33,120
第一次先用k对m取余 求出最低位

272
00:22:33,200 --> 00:22:34,430
然后将k除m的商

273
00:22:34,510 --> 00:22:36,680
再用来对m取余

274
00:22:36,750 --> 00:22:38,200
然后再把商在除m  一直循环下去

275
00:22:38,280 --> 00:22:41,570
大家应该对改变进制的运算很熟悉了

276
00:22:41,650 --> 00:22:45,130
我们就是用它 来求出这种表达式的

277
00:22:45,210 --> 00:22:47,730
这只是一个表示方法的问题

278
00:22:47,810 --> 00:22:56,770
而我们这里是将k  看成一个r+1位的m进制数

279
00:22:56,840 --> 00:23:01,630
现在就可以引入随机化策略了

280
00:23:01,700 --> 00:23:03,550
随机化策略就是

281
00:23:03,620 --> 00:23:05,260
我们哈希函数集合的选取

282
00:23:05,340 --> 00:23:09,310
是取决于随机数的

283
00:23:09,320 --> 00:23:11,470
而我们要用到的随机数则是..

284
00:23:11,540 --> 00:23:24,530
我们要随机地选择一个数a

285
00:23:24,600 --> 00:23:33,370
——同样地  我们也把a看成是m进制数

286
00:23:33,440 --> 00:23:47,710
a的每个位a_i都是在0到m-1这个区间里

287
00:23:47,790 --> 00:23:56,300
随机选择的

288
00:23:56,380 --> 00:23:58,600
它是随机的...如果你愿意

289
00:23:58,670 --> 00:24:03,470
它是随机的m进制数

290
00:24:03,540 --> 00:24:06,110
随机的m进制数

291
00:24:06,190 --> 00:24:08,230
这里每一位都是随机选择的

292
00:24:08,300 --> 00:24:12,680
对于a的每一位 可能的值

293
00:24:12,750 --> 00:24:15,470
我们都找一个对应的 不同的哈希函数

294
00:24:15,550 --> 00:24:19,400
所以我们是用这一个随机数来表示哈希函数

295
00:24:19,470 --> 00:24:22,410
这就是产生随机性的地方

296
00:24:22,480 --> 00:24:25,820
大家跟得上吗？

297
00:24:25,900 --> 00:24:32,070
接下来是哈希函数

298
00:24:54,870 --> 00:25:00,210
那我们要做的就是  拿这个向量(a)

299
00:25:00,290 --> 00:25:09,800
跟这个向量(k)点乘  乘积再对m取余

300
00:25:09,870 --> 00:25:13,670
那么 键k的每一位

301
00:25:13,740 --> 00:25:18,960
都会乘以一个随机数

302
00:25:19,030 --> 00:25:26,170
我们把乘积全部加起来 再对m取余

303
00:25:26,240 --> 00:25:31,330
注意这里是点乘

304
00:25:31,410 --> 00:25:33,700
我们要证明 这种哈希是全域的

305
00:25:33,770 --> 00:25:38,860
集合h_a是在整个哈希函数集中的一个全域集

306
00:25:38,940 --> 00:25:41,130
我们要先了解的事情之一是

307
00:25:41,210 --> 00:25:51,420
这里的哈希函数集有多大

308
00:25:58,450 --> 00:26:03,100
这个哈希函数集究竟有多大?

309
00:26:03,170 --> 00:26:11,050
在这个集合里有多少种不同的哈希函数？

310
00:26:23,500 --> 00:26:27,620
这是6.042课程的基本问题

311
00:26:27,690 --> 00:26:35,120
这就是相当于计算  对于一个长度为r+1的向量

312
00:26:35,190 --> 00:26:41,550
向量的每个元素 都是从0到m-1之间取值

313
00:26:41,630 --> 00:26:44,130
也就是可能有m个不同的值

314
00:26:44,210 --> 00:26:51,110
那总共有多少种可能的值？ (m-1)^r

315
00:26:51,190 --> 00:26:55,400
不对 但很接近了

316
00:26:55,470 --> 00:27:00,200
这是一个大数  m^(r+1)

317
00:27:00,270 --> 00:27:09,810
没错  H的大小等于m^(r+1)

318
00:27:09,880 --> 00:27:12,760
我们要记住这个结论

319
00:27:12,840 --> 00:27:14,630
先来理解一下为什么是这样

320
00:27:14,710 --> 00:27:19,810
a的第一个元素有m个选择 第二个也是 以此类推

321
00:27:19,880 --> 00:27:22,600
第r个元素也有m个选择

322
00:27:22,680 --> 00:27:27,750
因为这里有r+1个元素 对于每一个

323
00:27:27,830 --> 00:27:32,230
我们都有这么多种的选择  所以是乘积

324
00:27:32,300 --> 00:27:35,220
这是计数的乘法法则

325
00:27:35,300 --> 00:27:41,820
如果你们忘了6.042课程里的计数方面的内容

326
00:27:41,900 --> 00:27:45,790
最好回去复习一下

327
00:27:45,860 --> 00:27:48,770
因为我们是根据那个规则来运算的

328
00:27:48,850 --> 00:27:56,160
这里用到的是乘法定则

329
00:27:56,240 --> 00:28:00,660
好的 我们想要证明的定理是

330
00:28:00,730 --> 00:28:08,750
H是全域的

331
00:28:08,820 --> 00:28:11,200
这个会涉及到一些数论问题

332
00:28:11,280 --> 00:28:14,140
还是挺带感的

333
00:28:14,220 --> 00:28:16,430
而且这将是一个犀利的证明

334
00:28:16,500 --> 00:28:18,950
如果讲解过程中有任何问题

335
00:28:19,020 --> 00:28:25,310
请主动提问  因为这个论证

336
00:28:25,390 --> 00:28:30,050
会比我们目前学习到的其它论证都要难

337
00:28:30,130 --> 00:28:32,320
不像我们之前看过的论证那么简单

338
00:28:32,400 --> 00:28:38,710
但这个问题 绝对会涉及到更多数学论证

339
00:28:38,790 --> 00:28:46,810
好 我们来证明  假设我们有两个键

340
00:28:46,880 --> 00:28:48,910
我们要证明H是全域的

341
00:28:48,980 --> 00:28:54,680
那H就满足  把任意两个键

342
00:28:54,760 --> 00:28:57,890
哈希到同一位置的 哈希函数的数量

343
00:28:57,960 --> 00:29:04,640
等于集合H的大小除以m

344
00:29:04,720 --> 00:29:06,600
好的 我们来研究下这两个键

345
00:29:06,680 --> 00:29:09,230
首先任意选择两个键

346
00:29:09,310 --> 00:29:14,090
把x分解成

347
00:29:14,170 --> 00:29:29,700
r进制的表示形式 同样 y也分解成y_0, y_1...y_r

348
00:29:31,530 --> 00:29:36,780
这是两个互异的键

349
00:29:36,860 --> 00:29:41,100
如果这是两个互异的键

350
00:29:41,180 --> 00:29:43,300
那么它们就不相同

351
00:29:43,380 --> 00:29:47,190
那么 在这种数位表达式  它就表现为

352
00:29:47,270 --> 00:29:51,390
它们在某个位是不同的

353
00:29:51,470 --> 00:29:57,040
至少有一个位是不同的

354
00:30:06,690 --> 00:30:11,740
这是大多数人都忽略的

355
00:30:11,810 --> 00:30:14,760
我们来将它简化一下

356
00:30:14,830 --> 00:30:20,120
它们可能在任意数位有不同

357
00:30:20,190 --> 00:30:25,170
假设它们的0位不同

358
00:30:25,250 --> 00:30:27,150
哪个位不同并没有关系

359
00:30:27,220 --> 00:30:28,990
数学原理都是一样的

360
00:30:29,070 --> 00:30:32,990
但如果我选择它们在第i位不同

361
00:30:33,070 --> 00:30:35,330
那接下来要做加法的话

362
00:30:35,400 --> 00:30:39,300
就要把i排除出来 问题会变得很复杂

363
00:30:39,380 --> 00:30:41,680
但如果选择0位

364
00:30:41,760 --> 00:30:44,930
那我只需把剩下的位相加就好

365
00:30:45,000 --> 00:30:46,330
不管在哪一个位置相异

366
00:30:46,410 --> 00:30:48,000
数学运算都是相同的

367
00:30:48,070 --> 00:30:49,410
因为它是对称的

368
00:30:49,490 --> 00:30:51,050
所有的位都是对称的

369
00:30:51,130 --> 00:30:53,800
所以这里假设它们在0位不同

370
00:30:53,880 --> 00:30:55,550
但即使它们在其他位置互异

371
00:30:55,630 --> 00:30:59,690
结论还是成立的

372
00:30:59,760 --> 00:31:03,000
这样的假设保证大部分情况都适用

373
00:31:03,070 --> 00:31:06,530
不会丢失其一般性

374
00:31:06,600 --> 00:31:11,090
第0位

375
00:31:11,160 --> 00:31:14,700
因为这里所有的位都是对称的

376
00:31:14,780 --> 00:31:23,530
现在我要问

377
00:31:23,610 --> 00:31:27,880
——全域集里据称有多少哈希函数...

378
00:31:27,950 --> 00:31:37,910
会使得x和y发生碰撞？

379
00:31:37,980 --> 00:31:39,490
我们要把数目数出来

380
00:31:39,560 --> 00:31:41,730
它们碰撞的频率是多少？

381
00:31:41,800 --> 00:31:43,560
这里将引出

382
00:31:43,630 --> 00:31:47,880
一些重量级的数论

383
00:31:47,960 --> 00:31:53,230
如果发生碰撞

384
00:31:55,210 --> 00:32:02,340
——那么h_a(x)=h_a(y)

385
00:32:02,420 --> 00:32:07,200
这就是发生碰撞

386
00:32:07,270 --> 00:32:21,540
亦即∑(i=0到r)a_i * x_i

387
00:32:21,610 --> 00:32:32,030
等于∑(i=0到r)a_i * y_i

388
00:32:32,100 --> 00:32:34,810
实际上这里是全等  两边还要对m取余

389
00:32:34,890 --> 00:32:36,710
这个全等号 对于那些

390
00:32:36,790 --> 00:32:38,560
没怎么接触过数论的人来说

391
00:32:38,640 --> 00:32:41,940
可以理解为

392
00:32:42,020 --> 00:32:45,620
我们不需要对左边的每一项都取余

393
00:32:45,700 --> 00:32:47,720
右边也不需要

394
00:32:47,800 --> 00:32:52,800
这里只需要在最后取余一次就好了

395
00:32:52,880 --> 00:32:57,540
在最后 等所有都运算完 再取余

396
00:32:57,620 --> 00:33:00,710
然后在这里特别地写上一个全等号

397
00:33:00,780 --> 00:33:04,030
其实还有一些更数学化的定义

398
00:33:04,110 --> 00:33:08,970
但对于我们工程师而言 这已经足够了

399
00:33:12,290 --> 00:33:14,590
到目前为止 大家都跟得上吧？

400
00:33:14,670 --> 00:33:18,580
这只是运用了一下定义

401
00:33:18,680 --> 00:33:23,140
我们可以推导出

402
00:33:23,240 --> 00:33:31,660
Σ(i=0到r)a_i*(x_i-y_i)

403
00:33:31,750 --> 00:33:38,350
全等于0 对m取余

404
00:33:38,430 --> 00:33:41,300
其实只是移了下项

405
00:33:41,380 --> 00:33:46,030
然后应用了分配律

406
00:33:46,100 --> 00:33:52,220
现在要做的是引出第0位

407
00:33:52,300 --> 00:33:54,400
因为这是我所关注的位置

408
00:33:54,470 --> 00:33:56,770
这就是我之前在数学上做的一个保留

409
00:33:56,860 --> 00:33:59,630
即使我们假设的互异位不是第0位

410
00:33:59,810 --> 00:34:01,350
如果引出的是x_i

411
00:34:01,450 --> 00:34:02,860
也没有关系的

412
00:34:02,940 --> 00:34:09,250
只是会让数学显得不是很规整

413
00:34:22,490 --> 00:34:28,730
现在只需抽出一项

414
00:34:28,810 --> 00:34:39,330
推导出a_0*(x_0－y_0)

415
00:34:39,410 --> 00:34:54,720
全等于负的这一大块 对m取余

416
00:34:54,800 --> 00:35:00,250
还记得 当用一个负数对m取余时

417
00:35:00,330 --> 00:35:02,230
我是将它映射到...

418
00:35:02,300 --> 00:35:06,460
0到m-1的区间里

419
00:35:06,530 --> 00:35:15,890
举个例子 -5对7取余 等于2

420
00:35:15,970 --> 00:35:19,170
所以对于任意负数的取余

421
00:35:19,250 --> 00:35:24,620
我们只要简单地 转化成加上m的倍数

422
00:35:24,700 --> 00:35:35,080
因为加上m的倍数并不影响全等

423
00:35:38,270 --> 00:35:40,960
好的 我们的下一步工作

424
00:35:41,040 --> 00:35:42,990
要应用到一个数论事实

425
00:35:43,070 --> 00:35:50,870
那我们先把频道转到数论上

426
00:35:56,280 --> 00:36:05,510
说一点题外话

427
00:36:09,820 --> 00:36:14,150
这源于一个有限域的理论

428
00:36:14,220 --> 00:36:18,600
对于那些学识丰富的人

429
00:36:18,670 --> 00:36:20,920
这是你们晒知识的时候了

430
00:36:21,000 --> 00:36:22,030
但如果你不是很博学

431
00:36:22,110 --> 00:36:26,040
这是一个很值得学习的数学领域

432
00:36:26,120 --> 00:36:32,320
令m为一个质数

433
00:36:33,560 --> 00:36:43,190
对于任意的z 小写z 属于Z_m中的元素

434
00:36:43,260 --> 00:36:52,100
Zm是对m取余后的整数

435
00:36:52,180 --> 00:37:00,190
实际上 所有整数都是 由0到m-1间的数

436
00:37:00,260 --> 00:37:05,480
经过加 减 乘等运算变换得来的

437
00:37:05,550 --> 00:37:09,160
如果这个数的取值范围

438
00:37:09,230 --> 00:37:12,930
在0到m-1之外

439
00:37:13,010 --> 00:37:16,420
你可以通过加或减m的倍数来使之重新标准化

440
00:37:16,490 --> 00:37:20,000
回到0到m-1这个区间里

441
00:37:20,070 --> 00:37:25,710
这是一种标准化方法 只需要对m取余

442
00:37:25,790 --> 00:37:35,070
对于任意的不全等于0的z

443
00:37:35,150 --> 00:37:47,210
存在唯一一个属于Zm的z的倒数

444
00:37:47,280 --> 00:37:52,520
如果用z乘以z的倒数

445
00:37:52,600 --> 00:38:01,020
得到的结果对m取余得1

446
00:38:01,090 --> 00:38:03,830
对于任意的一个数

447
00:38:03,900 --> 00:38:06,160
我总能找到另外一个数

448
00:38:06,230 --> 00:38:10,200
与之相乘得到1

449
00:38:10,280 --> 00:38:18,980
举一个例子 让m等于7

450
00:38:19,050 --> 00:38:21,760
我们在这里画一个小表格

451
00:38:21,830 --> 00:38:23,660
z不等于0

452
00:38:23,740 --> 00:38:28,350
所以我只需要写出剩余的数

453
00:38:28,420 --> 00:38:33,210
我们来算一下z的倒数

454
00:38:33,280 --> 00:38:36,970
1的倒数是多少

455
00:38:37,050 --> 00:38:40,160
什么数乘以1会得到1？

456
00:38:40,240 --> 00:38:44,120
1 好的 2的话呢

457
00:38:44,210 --> 00:38:49,070
什么数乘以2会得到1？

458
00:38:49,150 --> 00:38:53,940
4 因为2乘以4等于8

459
00:38:54,020 --> 00:38:59,340
8对7取余后全等于1

460
00:38:59,420 --> 00:39:05,630
我们把它标准化了 那3呢？

461
00:39:11,600 --> 00:39:15,340
5 非常好 3乘以5等于15

462
00:39:15,410 --> 00:39:17,540
15对7取余后全等于1

463
00:39:17,610 --> 00:39:23,930
因为15除以7等于2 余1

464
00:39:24,000 --> 00:39:29,680
就是这样 4呢 2

465
00:39:31,120 --> 00:39:39,360
5呢 3  还有6 倒数是6

466
00:39:42,000 --> 00:39:48,990
6乘以6等于36

467
00:39:49,070 --> 00:39:50,320
再对7取余

468
00:39:50,400 --> 00:39:55,240
减去35 余下1

469
00:39:55,310 --> 00:39:58,460
人们观察到一些有趣的事实

470
00:39:58,540 --> 00:40:03,650
如果一个数是另一个数的倒数

471
00:40:03,730 --> 00:40:07,170
那另一个数同时也是这个数的倒数

472
00:40:07,250 --> 00:40:10,660
这实际上是你研究群论或场论等理论时

473
00:40:10,740 --> 00:40:15,090
会证明的事实之一

474
00:40:15,160 --> 00:40:16,530
这些全是这类数学中

475
00:40:16,610 --> 00:40:21,650
的某些重要的性质

476
00:40:21,720 --> 00:40:23,010
但主要的是

477
00:40:23,080 --> 00:40:27,320
如果m不是质数 这个性质就并不成立

478
00:40:27,400 --> 00:40:32,500
谁能想一个...假设我们对10取余

479
00:40:32,580 --> 00:40:33,650
谁能够找出一个

480
00:40:33,740 --> 00:40:36,870
对10取余后没有倒数的数？

481
00:40:36,950 --> 00:40:42,320
对了 2  还有5

482
00:40:42,400 --> 00:40:47,950
实际上 如果除数...

483
00:40:48,030 --> 00:40:55,420
通俗一点说 如果两个数不是互质的话...

484
00:40:55,500 --> 00:40:57,420
——互质就是指没有公因数

485
00:40:57,500 --> 00:41:02,510
那这个数和模数m的GCD(最大公约数)就不是1

486
00:41:02,590 --> 00:41:08,020
那么 这些数对m取余就求不出倒数来了

487
00:41:08,090 --> 00:41:09,350
但如果m是个质数

488
00:41:09,440 --> 00:41:14,530
那么每个数就都会和m互质

489
00:41:14,610 --> 00:41:17,460
这就是我们要利用到的性质

490
00:41:17,540 --> 00:41:21,700
那在这种情况下

491
00:41:21,800 --> 00:41:29,070
我想要 拿m来除(x_0-y_0)

492
00:41:29,150 --> 00:41:31,680
这就是现在我想做的

493
00:41:31,770 --> 00:41:38,600
不过首先  如果m不是质数

494
00:41:38,670 --> 00:41:40,420
那就不必要这么做了

495
00:41:40,490 --> 00:41:42,860
虽然也可以这样做 但没必要

496
00:41:42,950 --> 00:41:47,030
但如果m是质数 我就肯定可以拿它来除(x_0-y_0)

497
00:41:47,120 --> 00:41:48,740
并能够求出倒数

498
00:41:48,840 --> 00:41:50,230
另一个必须做的事是

499
00:41:50,300 --> 00:41:55,080
保证(x_0-y_0)不为0

500
00:41:55,180 --> 00:41:56,730
如果x_0等于y_0  这就等于0了

501
00:41:56,810 --> 00:41:58,820
但我们假设是它们并不相等

502
00:41:58,900 --> 00:42:00,990
再说一次 回到之前的内容

503
00:42:01,070 --> 00:42:02,410
为了不失一般性

504
00:42:02,500 --> 00:42:08,020
如果我们考虑的不是第0位 而是其他位

505
00:42:08,100 --> 00:42:12,460
我也会对它做同样的操作

506
00:42:12,560 --> 00:42:16,760
现在可以进行除法了

507
00:42:16,850 --> 00:42:19,980
继续我们的...

508
00:42:23,660 --> 00:42:27,500
——继续我们的证明

509
00:42:27,580 --> 00:42:34,000
因为x_0不等于y_0

510
00:42:34,110 --> 00:42:41,210
所以存在（x_0-y_0）的倒数

511
00:42:41,280 --> 00:42:44,670
这就能推出...承接着那边的内容

512
00:42:44,740 --> 00:42:51,380
a_0全等于...

513
00:42:51,460 --> 00:43:03,160
-Σ（i=1)a_i(x_i-y_i)乘以(x_0-y_0)^-1

514
00:43:05,770 --> 00:43:09,540
让我们回到证明的开始阶段

515
00:43:09,620 --> 00:43:12,770
看看我们推导出了什么

516
00:43:12,840 --> 00:43:15,530
假设我们有两个互异的键

517
00:43:15,620 --> 00:43:20,380
然后我们随机选出了这些a_i

518
00:43:20,460 --> 00:43:23,230
并且假设

519
00:43:23,300 --> 00:43:27,930
这两个互异的键被哈希到同个位置上

520
00:43:28,000 --> 00:43:30,240
如果它们被哈希到同一个地方

521
00:43:30,310 --> 00:43:38,620
那我们就能推出 a_0实际上是...

522
00:43:38,700 --> 00:43:45,510
由其他所有的a_i所决定的

523
00:43:45,520 --> 00:43:46,520
因为换句话说

524
00:43:46,530 --> 00:43:50,430
一旦其他a_i都选定下来了

525
00:43:50,480 --> 00:43:53,600
打个比方 如果是按a_1到a_r顺序的话

526
00:43:53,680 --> 00:43:55,080
那么能发生碰撞的

527
00:43:55,150 --> 00:43:57,410
就只有一个特定的a_0

528
00:43:57,490 --> 00:44:00,200
只有一个特定的值会发生碰撞

529
00:44:00,290 --> 00:44:03,900
就是由这条式算出的这个a_0

530
00:44:03,970 --> 00:44:06,370
如果a_0选另一个值

531
00:44:06,450 --> 00:44:10,240
则不会发生碰撞

532
00:44:10,320 --> 00:44:12,100
让我写到黑板上

533
00:44:12,190 --> 00:44:18,100
同时你可以思考一下

534
00:45:10,930 --> 00:45:14,800
对于任意一组的a_i

535
00:45:14,870 --> 00:45:18,330
只有一个 a_0的可能选项

536
00:45:18,410 --> 00:45:23,620
使之发生碰撞

537
00:45:23,690 --> 00:45:25,260
对于a_0的其它所有选值

538
00:45:25,330 --> 00:45:30,470
都不会有碰撞

539
00:45:32,740 --> 00:45:36,670
所以...  如果发生碰撞的话

540
00:45:36,750 --> 00:45:39,370
随机哈希函数的自由组合数

541
00:45:39,450 --> 00:45:45,270
就减少了m倍

542
00:45:45,350 --> 00:45:51,210
如果合计出 让x和y发生碰撞的

543
00:45:51,280 --> 00:45:59,290
哈希函数h_a的数量

544
00:45:59,360 --> 00:46:03,740
它就等于...这有m个选择

545
00:46:03,830 --> 00:46:05,340
再次用到乘法定则

546
00:46:05,430 --> 00:46:09,290
对a_1来说有m个选择  乘以a_2的m个选择

547
00:46:09,370 --> 00:46:16,420
直到a_r都有m个选择

548
00:46:16,510 --> 00:46:21,090
但a_0只有一个选择

549
00:46:21,160 --> 00:46:31,560
这些是a_1 a_2... a_r的选择

550
00:46:31,650 --> 00:46:33,920
如果发生碰撞 a_0就只有一个选择

551
00:46:33,980 --> 00:46:36,540
如果没有发生碰撞  a_0会有更多的选择

552
00:46:36,630 --> 00:46:38,280
但我想要它们碰撞

553
00:46:38,360 --> 00:46:44,890
所以只有一个值能选 就是这个值

554
00:46:45,020 --> 00:46:49,450
这是唯一我能选的值

555
00:46:49,530 --> 00:46:53,380
这里等于m^r

556
00:46:53,460 --> 00:47:00,680
也就是H的大小除以m

557
00:47:00,750 --> 00:47:06,310
证明完成了

558
00:47:09,930 --> 00:47:11,970
当然还有其它的全域架构

559
00:47:12,050 --> 00:47:15,870
但这是特别精妙的一个

560
00:47:15,940 --> 00:47:21,950
关键是  我们有m+1个...

561
00:47:22,040 --> 00:47:24,840
不对 是r+1的自由度

562
00:47:24,930 --> 00:47:28,900
每个自由度都有m个选值

563
00:47:28,980 --> 00:47:38,880
但如果我想让它们发生碰撞

564
00:47:38,970 --> 00:47:45,740
一旦确定了其他r个选择

565
00:47:45,820 --> 00:47:51,490
要发生碰撞的话 最后一个也就已经确定了

566
00:47:51,570 --> 00:47:53,130
这样一来 能发生碰撞的函数

567
00:47:53,200 --> 00:47:56,360
就只能是m种函数中的一个

568
00:47:56,440 --> 00:47:58,560
非常巧妙的架构

569
00:47:58,630 --> 00:48:01,140
非常巧妙 大家都清楚了？

570
00:48:01,990 --> 00:48:03,120
有多少人听到崩溃了？

571
00:48:03,190 --> 00:48:04,280
[教授]什么问题？

572
00:48:04,350 --> 00:48:10,000
学生：...

573
00:48:13,600 --> 00:48:15,100
嗯 差不多 实际上

574
00:48:15,180 --> 00:48:18,140
这其实都是一个很常见的运算

575
00:48:18,220 --> 00:48:19,320
如果你去上一门课

576
00:48:19,400 --> 00:48:24,020
就例如 像密码学之类的课程

577
00:48:24,090 --> 00:48:28,360
像这些点乘运算

578
00:48:28,440 --> 00:48:32,260
取余运算  还有"伽罗瓦域"

579
00:48:32,330 --> 00:48:35,800
也就是一种比较简单的有限域

580
00:48:35,880 --> 00:48:39,360
像这些运算 人们都一直都在做

581
00:48:39,430 --> 00:48:41,920
伽罗瓦域是用的是x阶（即有x个元素）

582
00:48:42,000 --> 00:48:45,770
就跟这里差不多  除了二阶的情况更特殊一点

583
00:48:45,850 --> 00:48:48,210
在这方面有很多的研究

584
00:48:48,280 --> 00:48:50,990
所以人们知道有这些性质

585
00:48:51,060 --> 00:48:53,160
但世上有没有一种算法

586
00:48:53,230 --> 00:48:56,080
能让你洞悉一切的算法呢？

587
00:48:56,160 --> 00:49:01,790
我也想知道

588
00:49:01,870 --> 00:49:03,130
那样的话 我就成算法帝了

589
00:49:03,200 --> 00:49:04,810
[笑]

590
00:49:04,890 --> 00:49:06,080
但如果有那么容易

591
00:49:06,150 --> 00:49:08,170
那我今天就不会站在这里了

592
00:49:08,260 --> 00:49:10,800
[笑]

593
00:49:10,880 --> 00:49:17,390
接下来 进入下一个主题

594
00:49:17,460 --> 00:49:18,800
这个主题也...

595
00:49:18,880 --> 00:49:20,790
相当地犀利

596
00:49:20,860 --> 00:49:25,270
非常美丽的数学

597
00:49:25,350 --> 00:49:32,900
对于锻炼你构造好的哈希函数能力 会有很大的帮助

598
00:49:32,980 --> 00:49:35,180
那我们现在要讲的另一个主题

599
00:49:35,260 --> 00:49:43,680
跟之前也是相关的 那就是完全哈希

600
00:49:52,370 --> 00:49:55,240
目前为止 我们所做的..

601
00:49:55,320 --> 00:49:57,610
都是跟预期时间相关

602
00:49:57,680 --> 00:50:02,030
哈希在预期时间上还是不错的

603
00:50:02,100 --> 00:50:04,240
而完全哈希则是考虑以下的问题

604
00:50:04,330 --> 00:50:07,800
假设我给你一个键集

605
00:50:07,880 --> 00:50:11,810
要求你帮我创建一个静态表

606
00:50:11,920 --> 00:50:17,620
那我如果要在查看一个键是否在表中

607
00:50:17,790 --> 00:50:21,930
在最坏的情况下

608
00:50:22,010 --> 00:50:24,970
怎样做得更好

609
00:50:25,050 --> 00:50:27,880
如果有一个固定的键集

610
00:50:27,950 --> 00:50:30,560
举个例子  假设是表里存的是

611
00:50:30,640 --> 00:50:35,080
最常见的一百个

612
00:50:35,150 --> 00:50:39,180
或最常见的一千个的英语单词

613
00:50:39,270 --> 00:50:42,880
当我拿到一个单词 我想要迅速地查一下表

614
00:50:42,950 --> 00:50:45,390
看看这个单词

615
00:50:45,470 --> 00:50:47,770
是不是英语里最常见的单词之一

616
00:50:47,890 --> 00:50:51,150
我要的并不是用预期的性能

617
00:50:51,230 --> 00:50:54,190
但我要确保最坏情况的性能

618
00:50:54,270 --> 00:51:02,850
有没有相应的建表方法  能让我快速地查找？

619
00:51:02,930 --> 00:51:09,250
问题是 给定n个键

620
00:51:10,890 --> 00:51:15,940
——创建一个静态哈希表

621
00:51:16,020 --> 00:51:17,400
换句话说 没有插入或删除

622
00:51:17,470 --> 00:51:20,770
表里一直都是那些元素

623
00:51:20,850 --> 00:51:31,200
表的大小是m=O(n)

624
00:51:31,280 --> 00:51:34,910
我不需要一张很大的表

625
00:51:34,990 --> 00:51:40,930
我只想让表的大小刚好和键数一致

626
00:51:41,000 --> 00:51:44,440
表的大小是m=O(n)

627
00:51:44,520 --> 00:51:59,990
使得在最坏情况下 查找的时间是O(1)

628
00:52:05,410 --> 00:52:09,400
所以在这个表里就不会有多余的空间

629
00:52:09,480 --> 00:52:10,930
在平均情况下

630
00:52:11,010 --> 00:52:13,410
这个并不难完成

631
00:52:13,480 --> 00:52:15,200
但在最坏情况下

632
00:52:15,270 --> 00:52:18,020
我想确保不会出现...

633
00:52:18,110 --> 00:52:26,060
一个槽里面堆了大量的键的情况

634
00:52:26,130 --> 00:52:27,920
我不希望出现这种情况

635
00:52:28,020 --> 00:52:31,290
每个查找都应该是O(1)的时间

636
00:52:31,370 --> 00:52:34,870
在查找所需花费的时间上

637
00:52:34,930 --> 00:52:40,190
不应有任何变化

638
00:52:40,270 --> 00:52:43,290
大家都明白这个问题没有？

639
00:52:43,370 --> 00:52:44,750
这点很重要

640
00:52:44,830 --> 00:52:49,100
因为它有很大的用途

641
00:52:49,170 --> 00:52:51,820
因为当你要创建一个表

642
00:52:51,900 --> 00:52:53,430
而你已经知道

643
00:52:53,510 --> 00:52:54,570
你要查找的是什么值的时候

644
00:52:54,670 --> 00:52:58,200
你就不希望浪费大量空间等等

645
00:52:58,270 --> 00:53:00,040
那解决方案就是

646
00:53:00,120 --> 00:53:03,970
使用一个双级结构

647
00:53:07,830 --> 00:53:14,940
关键是使用一个双级结构

648
00:53:17,740 --> 00:53:26,530
并且在每一级都使用全域哈希

649
00:53:29,840 --> 00:53:32,240
那我们的做法是...

650
00:53:32,310 --> 00:53:33,330
建立一张哈希表

651
00:53:33,410 --> 00:53:34,660
但不使用链接技术

652
00:53:34,720 --> 00:53:37,010
只是哈希到槽里

653
00:53:37,090 --> 00:53:41,290
然后我们再建立另一张哈希表

654
00:53:41,370 --> 00:53:45,990
在第二个表里做二次哈希

655
00:53:46,070 --> 00:53:50,120
通过这种方法 我们就能实现

656
00:53:50,200 --> 00:53:57,420
在第二级没有碰撞

657
00:54:00,330 --> 00:54:01,890
虽然在第一级可能会发生碰撞

658
00:54:01,970 --> 00:54:03,620
但我们要把碰撞限制在第一级

659
00:54:03,700 --> 00:54:07,100
先把键放入一级哈希表

660
00:54:07,170 --> 00:54:08,610
然后是再放进二级哈希表

661
00:54:08,690 --> 00:54:11,820
但在二级哈希表里  没有碰撞

662
00:54:11,900 --> 00:54:16,060
完美匹配 恰好都能哈希到这里面

663
00:54:16,130 --> 00:54:18,660
刚刚好平均到每个槽

664
00:54:18,730 --> 00:54:25,460
画一个图来说明这个结构

665
00:54:26,830 --> 00:54:37,590
这里有0，1...6...到m-1

666
00:54:37,660 --> 00:54:40,610
这是我们的哈希表

667
00:54:40,690 --> 00:54:41,900
我们要做的是

668
00:54:42,120 --> 00:54:46,890
在第一级使用全域哈希

669
00:54:46,970 --> 00:54:48,690
找一个全域哈希函数

670
00:54:48,770 --> 00:54:51,740
随机选择一个哈希函数

671
00:54:51,810 --> 00:54:56,140
把键哈希映射到这一级上

672
00:54:56,210 --> 00:55:03,020
然后我们要注意两件事

673
00:55:03,090 --> 00:55:07,210
一件是 下一级的哈希表有多大

674
00:55:07,290 --> 00:55:10,170
在这里 哈希表的大小

675
00:55:10,180 --> 00:55:11,020
就用槽数来表示

676
00:55:11,030 --> 00:55:13,610
这里是4  另外 我们还要

677
00:55:13,690 --> 00:55:17,430
为第二级保留一个独立的哈希键

678
00:55:17,510 --> 00:55:21,450
这样 每个槽里都定义了一个哈希函数

679
00:55:21,510 --> 00:55:23,340
给下一级哈希用

680
00:55:23,410 --> 00:55:24,950
比如 这个可能有

681
00:55:25,020 --> 00:55:29,120
一个键值为31的随机数

682
00:55:29,210 --> 00:55:31,920
a在这里...在上面

683
00:55:32,000 --> 00:55:33,880
a在那里

684
00:55:33,970 --> 00:55:36,440
而这个数就和将要被哈希的键一起

685
00:55:36,520 --> 00:55:39,010
组成了哈希函数的基础

686
00:55:39,080 --> 00:55:42,690
这里假设是86

687
00:55:42,780 --> 00:55:47,350
然后 有一个二级哈希表的指针

688
00:55:47,430 --> 00:55:53,300
这个表称为S_1  有四个槽

689
00:55:53,370 --> 00:55:55,460
里面放着14和27

690
00:55:55,550 --> 00:56:00,020
另外两个槽为空

691
00:56:00,100 --> 00:56:07,280
还有这里 举个例子

692
00:56:07,360 --> 00:56:12,460
存了29

693
00:56:27,230 --> 00:56:30,140
那在这里 我们的做法是

694
00:56:30,220 --> 00:56:33,450
当我们先看第一级的全部哈希函数

695
00:56:33,530 --> 00:56:35,340
我们把它们称为H

696
00:56:35,420 --> 00:56:45,590
我们有H(14)=H(27)=1

697
00:56:45,660 --> 00:56:48,560
因为这是槽1

698
00:56:48,640 --> 00:56:52,620
这两个数都哈希到

699
00:56:52,700 --> 00:56:54,730
第一级哈希表里同个槽

700
00:56:54,810 --> 00:56:57,750
这是第一级

701
00:56:57,820 --> 00:57:03,460
这是第二级

702
00:57:03,540 --> 00:57:06,740
在第一级 哈希运算后 14和27碰撞

703
00:57:06,830 --> 00:57:11,060
它们跑到同一个槽里了

704
00:57:11,130 --> 00:57:16,140
但在第二级 它们则被哈希到不同的地方

705
00:57:16,210 --> 00:57:18,670
而我所用的哈希函数

706
00:57:18,740 --> 00:57:21,180
则是被我们选的这个随机数...

707
00:57:21,260 --> 00:57:22,580
所标记

708
00:57:22,650 --> 00:57:25,850
我会说明如何选择这个随机数

709
00:57:25,920 --> 00:57:34,200
h_31(14)=1

710
00:57:34,290 --> 00:57:41,650
h_31(27)=2

711
00:57:41,730 --> 00:57:45,140
这是第二级的哈希

712
00:57:45,990 --> 00:57:50,240
在第一级  我们哈希到这

713
00:57:50,260 --> 00:57:53,060
把它作为二级哈希的基底

714
00:57:53,120 --> 00:57:57,650
然后再哈希到这边的表里

715
00:57:57,720 --> 00:57:59,540
如果没有...

716
00:57:59,620 --> 00:58:03,080
如果能保证在第二级没有碰撞

717
00:58:03,160 --> 00:58:05,270
那我只需要花费O(1)的时间

718
00:58:05,350 --> 00:58:07,200
就能在最坏情况下 完成数据的查找

719
00:58:07,280 --> 00:58:09,770
如何查找？用这个值

720
00:58:09,850 --> 00:58:15,180
代入函数h 哈希到某个槽

721
00:58:15,260 --> 00:58:18,200
再看一下 二级哈希函数的键是多少

722
00:58:18,200 --> 00:58:20,460
再用这个哈希函数

723
00:58:20,530 --> 00:58:22,880
哈希到另外一个槽

724
00:58:22,960 --> 00:58:25,150
这样就完成了

725
00:58:25,240 --> 00:58:28,010
整个过程应用了两个哈希函数

726
00:58:28,090 --> 00:58:30,170
外加一些查找操作

727
00:58:30,250 --> 00:58:34,440
还有一些小的 类似记录的操作

728
00:58:34,520 --> 00:58:39,440
那么  为什么在这一级...

729
00:58:39,510 --> 00:58:45,340
不会发生碰撞的原因如下:

730
00:58:45,420 --> 00:59:03,690
如果有n_i个项  被同时哈希到第一级表的槽i

731
00:59:05,700 --> 00:59:10,770
那我们则有m_i个槽——

732
00:59:10,850 --> 00:59:18,040
m_i=n_i^2

733
00:59:18,120 --> 00:59:22,000
——m_i个槽在第二级哈希表里

734
00:59:28,050 --> 00:59:29,820
我应该在这里提过

735
00:59:29,890 --> 00:59:33,470
这里是m_i

736
00:59:33,540 --> 00:59:34,870
哈希表的大小

737
00:59:34,940 --> 00:59:41,160
这里是a_i

738
00:59:44,090 --> 00:59:46,750
实际上 我们是把n_i个项

739
00:59:46,760 --> 00:59:53,480
分别哈希到n_i^2个位置里

740
00:59:53,560 --> 00:59:58,990
因此 第二级表将会非常稀疏

741
00:59:59,060 --> 01:00:03,180
它的大小是一级表的二次方

742
01:00:03,250 --> 01:00:07,410
那我要证明的是  在这种情况下

743
01:00:07,490 --> 01:00:09,620
我们很容易就能找到

744
01:00:09,700 --> 01:00:12,640
不会发生碰撞的哈希函数

745
01:00:12,730 --> 01:00:14,680
这就是为什么叫完全哈希

746
01:00:14,750 --> 01:00:16,590
试想一下 我要怎样才能让这些哈希函数

747
01:00:16,660 --> 01:00:18,360
不发生碰撞

748
01:00:18,440 --> 01:00:21,790
这就是为什么我在这里只写了很少的元素

749
01:00:21,900 --> 01:00:24,500
举个例子 我有两个元素

750
01:00:24,570 --> 01:00:26,310
那我的表的大小就是4

751
01:00:26,410 --> 01:00:27,470
三个元素的话

752
01:00:27,540 --> 01:00:30,390
表的大小就是9

753
01:00:30,470 --> 01:00:31,530
如果有100个元素

754
01:00:31,610 --> 01:00:35,390
表的大小就是10,000

755
01:00:35,480 --> 01:00:36,830
大小不是我定的

756
01:00:36,900 --> 01:00:40,010
这个大小可能是任意的东西

757
01:00:40,080 --> 01:00:42,000
实际上  这种算法是可行的

758
01:00:42,010 --> 01:00:44,330
它还具备了我们想要的所有性质

759
01:00:44,410 --> 01:00:47,660
这是分析的一部分 大家都懂了吧？

760
01:00:47,740 --> 01:00:49,930
它在最坏情况下时间为O(1)

761
01:00:50,030 --> 01:00:52,820
还有它的基础结构是什么？

762
01:00:52,900 --> 01:00:54,400
顺便说一下 这里所用的哈希键

763
01:00:54,490 --> 01:00:56,320
不一定是用质数

764
01:00:56,400 --> 01:00:58,530
虽然我可以像这样找一些质数

765
01:00:58,610 --> 01:00:59,810
但我在这里并没有这样做

766
01:00:59,910 --> 01:01:02,170
又或者 我可以用一个全域哈希函数

767
01:01:02,250 --> 01:01:05,580
实际效果要比用质数更好

768
01:01:05,650 --> 01:01:11,160
但在这个例子里 我也没有使用

769
01:01:11,240 --> 01:01:15,360
都准备好了没？ 要进行分析了

770
01:01:15,430 --> 01:01:18,660
好的 我们开始做些分析

771
01:01:28,700 --> 01:01:29,800
这确实是一个美妙的分析

772
01:01:29,800 --> 01:01:31,670
你们可能也有这种感觉

773
01:01:31,750 --> 01:01:34,630
因为我们已经做了一部分分析了

774
01:01:49,550 --> 01:01:53,190
技巧在于 对第二级的分析

775
01:01:53,270 --> 01:01:58,940
这是我要分析的主要内容

776
01:01:59,010 --> 01:02:04,870
我们要证明  我们能找到一种哈希函数

777
01:02:04,950 --> 01:02:07,010
使得数据到数组的映射

778
01:02:07,080 --> 01:02:11,250
变得非常的稀疏  而实际上

779
01:02:11,320 --> 01:02:12,630
这样的哈希函数是存在的

780
01:02:12,700 --> 01:02:15,240
而且我可以事先把它们算出来

781
01:02:15,320 --> 01:02:17,800
所以我们能把它们很好地存起来

782
01:02:17,880 --> 01:02:21,070
那么 这就是我们即将用到的定理

783
01:02:21,140 --> 01:02:31,850
如果我们把n个键哈希映射到m=n^2个槽里

784
01:02:35,140 --> 01:02:42,760
而用到的哈希函数  是从全域集合H里随机挑选的话

785
01:02:48,150 --> 01:02:59,300
那么期望的碰撞次数 则小于1/2

786
01:03:00,890 --> 01:03:04,400
碰撞次数的期望值

787
01:03:04,470 --> 01:03:08,300
我不希望它发生哪怕一次碰撞

788
01:03:09,110 --> 01:03:15,420
我希望平均下来 只发生小于半次的碰撞

789
01:03:17,270 --> 01:03:22,400
好的 我们来证明它

790
01:03:23,920 --> 01:03:30,630
那么  对于两个给定的键

791
01:03:33,100 --> 01:03:39,960
碰撞的几率是多少？

792
01:03:41,220 --> 01:03:44,670
对于两个给定的键  经过h哈希后  碰撞的概率是多少？

793
01:03:44,750 --> 01:03:49,130
如果h是从全域集合里随机挑选出来的话？

794
01:03:51,390 --> 01:03:54,420
1/m  对 这是定义

795
01:03:54,490 --> 01:03:59,880
那在这个情况下 它就等于1/（n^2）

796
01:04:03,360 --> 01:04:08,220
那现在有多少个...

797
01:04:09,330 --> 01:04:12,730
在这个表里有多少对键...

798
01:04:14,840 --> 01:04:19,260
有多少对键可能会发生碰撞？

799
01:04:19,330 --> 01:04:22,390
这其实是要通过键对的数量

800
01:04:22,460 --> 01:04:25,670
来评估这条式子

801
01:04:25,740 --> 01:04:30,310
有（n 2）对键

802
01:04:31,060 --> 01:04:38,360
（n 2）对键

803
01:04:39,810 --> 01:04:48,280
因此 碰撞次数的期望值等于

804
01:04:48,360 --> 01:04:51,730
对于这里...错了 不是n/2

805
01:04:51,800 --> 01:04:58,580
对于这（n 2)对键的每一对

806
01:04:58,660 --> 01:05:06,530
发生碰撞的概率都是1/n^2

807
01:05:06,610 --> 01:05:10,220
所以这里等于n(n-1)/2

808
01:05:10,300 --> 01:05:13,700
如果你还记得公式  然后再乘以1/n^2

809
01:05:13,790 --> 01:05:18,140
这个值小于1/2

810
01:05:23,350 --> 01:05:24,690
对于每对键都成立

811
01:05:24,760 --> 01:05:30,270
哪些同学还记得6.042课程里说的生日悖论

812
01:05:30,360 --> 01:05:33,910
这和生日悖论有一点点相关

813
01:05:33,990 --> 01:05:36,660
但这是一个大的集合

814
01:05:36,740 --> 01:05:38,000
而且我要照顾到所有的键对

815
01:05:38,200 --> 01:05:41,120
但哈希表是足够大的  以致于

816
01:05:41,200 --> 01:05:45,630
发生碰撞的概率相对很小

817
01:05:45,700 --> 01:05:51,670
但如果我把元素的数量增大

818
01:05:51,750 --> 01:05:53,370
并且超过根号m

819
01:05:53,460 --> 01:05:55,460
如果元素数量超过了根号m

820
01:05:55,540 --> 01:05:57,140
那么碰撞几率会急剧上升

821
01:05:57,320 --> 01:05:59,160
正如你们学过的生日悖论

822
01:05:59,290 --> 01:06:01,550
但如果n小于根号m  如果空间非常稀疏

823
01:06:01,680 --> 01:06:03,560
就不会碰撞

824
01:06:03,660 --> 01:06:08,250
或至少得出一个相对较小的期望值

825
01:06:08,810 --> 01:06:10,440
那现在 我想让你们回忆起某些内容

826
01:06:10,550 --> 01:06:14,010
实际上刚才已经用到过

827
01:06:14,130 --> 01:06:17,060
但我想简单地分析一下

828
01:06:17,150 --> 01:06:20,190
就是马尔可夫不等式

829
01:06:20,260 --> 01:06:23,870
谁还记得马尔可夫不等式？

830
01:06:23,950 --> 01:06:25,900
还记得贝尔加湖畔的马尔科夫吗？

831
01:06:25,980 --> 01:06:29,450
马尔可夫不等式说的是...

832
01:06:29,530 --> 01:06:32,210
它是最伟大的概率定理之一

833
01:06:32,300 --> 01:06:39,420
对于下界为0的随机变量x

834
01:06:39,490 --> 01:06:42,490
x大于或等于...

835
01:06:42,570 --> 01:06:46,490
任意给定的t的概率

836
01:06:46,600 --> 01:06:52,880
不超过x的期望值除以t

837
01:06:52,970 --> 01:06:54,560
一个伟大的定理

838
01:06:54,640 --> 01:06:58,660
虽然x的下界不为0 则不成立

839
01:06:58,740 --> 01:06:59,770
但仍然是个伟大的定理

840
01:06:59,870 --> 01:07:03,520
它把概率和期望...

841
01:07:03,600 --> 01:07:09,000
关联在一起

842
01:07:09,080 --> 01:07:11,440
我们通常理解为

843
01:07:11,530 --> 01:07:19,150
如果期望值很小

844
01:07:19,240 --> 01:07:22,030
那出现大的随机变量值

845
01:07:22,110 --> 01:07:25,210
的概率也很小

846
01:07:25,280 --> 01:07:26,420
因为那讲不通

847
01:07:26,490 --> 01:07:29,280
因为你不可能满足 一百万的概率很高

848
01:07:29,350 --> 01:07:31,630
而同时你的期望只有1  而在这里

849
01:07:31,700 --> 01:07:34,960
我们的期望更是只有1/2

850
01:07:35,040 --> 01:07:36,270
那是不可能的

851
01:07:36,350 --> 01:07:39,640
而它的证明则是恰恰

852
01:07:39,720 --> 01:07:43,090
直接用到了期望的定义

853
01:07:43,170 --> 01:07:47,200
所以我这里就要用到离散的随机变量

854
01:07:47,280 --> 01:07:50,260
那么 期望值的定义是

855
01:07:50,330 --> 01:07:55,230
∑（x=0到∞）

856
01:07:55,300 --> 01:07:57,100
小写x乘以

857
01:07:57,190 --> 01:08:01,610
Pr(X=x)

858
01:08:01,690 --> 01:08:03,740
这就是定义

859
01:08:03,810 --> 01:08:06,360
现在接下来 我们要做的

860
01:08:06,460 --> 01:08:08,710
就是你能想像到的最粗糙的近似

861
01:08:08,790 --> 01:08:12,460
首先 直接去除所有小的项

862
01:08:12,530 --> 01:08:18,960
它大于或等于 ∑（x=t到∞）

863
01:08:19,050 --> 01:08:24,210
小写x乘以Pr(X=x)

864
01:08:24,280 --> 01:08:26,740
这样就去掉了所有低顺次的数

865
01:08:26,830 --> 01:08:31,980
接下来 我们要把这些每一项里的小写x

866
01:08:32,050 --> 01:08:37,680
都替换成下界x=t

867
01:08:37,760 --> 01:08:47,160
这里变成 ∑（x=t到∞）

868
01:08:47,230 --> 01:08:51,770
t乘以Pr(X=x)

869
01:08:51,840 --> 01:08:54,790
从x大于t开始

870
01:08:54,870 --> 01:08:57,630
因为这些值只可能更大

871
01:08:57,710 --> 01:09:01,020
那这式子就等于t...

872
01:09:01,100 --> 01:09:02,460
因为能把t写在外面

873
01:09:02,540 --> 01:09:05,670
并且x从t到正无穷的

874
01:09:05,740 --> 01:09:09,990
X=x概率的总和

875
01:09:10,080 --> 01:09:15,320
也就是x大于或等于t的概率

876
01:09:19,870 --> 01:09:26,460
完成证明  因为只要把t除过去

877
01:09:29,450 --> 01:09:31,170
就得到马尔可夫不等式

878
01:09:31,250 --> 01:09:34,610
非常整洁 非常简单

879
01:09:34,680 --> 01:09:40,630
比诸如切比雪夫不等式

880
01:09:40,710 --> 01:09:44,870
切尔诺夫不等式之类的更加强大

881
01:09:44,940 --> 01:09:49,130
但是马尔可夫不等式 却出乎意料地简单而实用

882
01:09:49,210 --> 01:09:55,210
所以我们打算把它做为一个引理来运用一下

883
01:10:05,040 --> 01:10:11,900
那么 没有碰撞的概率

884
01:10:12,770 --> 01:10:16,490
当我们用一个全域哈希函数

885
01:10:16,580 --> 01:10:22,070
把n个键哈希到n^2个槽时

886
01:10:22,150 --> 01:10:25,230
我称之为没有碰撞的概率

887
01:10:25,320 --> 01:10:28,160
它大于或等于1/2

888
01:10:28,640 --> 01:10:32,620
那我随机选择一个哈希函数

889
01:10:32,700 --> 01:10:34,710
把这n个键哈希到n^2个槽时

890
01:10:34,810 --> 01:10:38,710
没有碰撞的概率是多少

891
01:10:38,780 --> 01:10:43,290
答案是 无碰撞的几率至少也有1/2

892
01:10:43,370 --> 01:10:48,970
我保证至少一半的情况不会有碰撞

893
01:10:49,040 --> 01:10:51,160
证明相当简单

894
01:10:51,240 --> 01:10:54,070
无碰撞的概率

895
01:10:54,140 --> 01:10:57,220
与之相同的概率

896
01:10:57,290 --> 01:10:59,910
抱歉 是1减去

897
01:11:00,000 --> 01:11:03,890
至多一个碰撞的概率

898
01:11:03,970 --> 01:11:07,810
抱歉 是至少一个碰撞的概率

899
01:11:07,950 --> 01:11:11,240
至少有一个碰撞的概率

900
01:11:11,330 --> 01:11:13,150
发生大于或等于1次碰撞的概率

901
01:11:13,260 --> 01:11:14,330
小于或等于...

902
01:11:14,420 --> 01:11:20,810
运用马尔可夫不等式

903
01:11:20,890 --> 01:11:26,810
等于碰撞的期望值

904
01:11:28,290 --> 01:11:33,030
——除以1

905
01:11:33,110 --> 01:11:37,330
由马尔可夫不等式可知  小于...

906
01:11:37,410 --> 01:11:40,420
由定义 不好意思 碰撞的期望值

907
01:11:40,540 --> 01:11:42,810
已经证明过了 小于1/2

908
01:11:42,890 --> 01:11:45,900
所以至少一次碰撞的概率小于1/2

909
01:11:45,970 --> 01:11:51,890
那么 0碰撞的概率 就至少是1/2

910
01:11:51,970 --> 01:11:56,300
毕明完毕

911
01:11:56,390 --> 01:12:01,170
所以  要找一个好的哈希函数是很容易的

912
01:12:01,260 --> 01:12:04,500
随机测试几个

913
01:12:04,590 --> 01:12:06,940
它们的大部分

914
01:12:07,030 --> 01:12:14,630
至少一半都是可行的

915
01:12:14,700 --> 01:12:18,640
这在某种程度上 你可以想一下

916
01:12:18,710 --> 01:12:21,800
它就是一个随机化的架构

917
01:12:21,870 --> 01:12:23,780
因为我说不准哪个是可行的

918
01:12:23,780 --> 01:12:25,700
虽然这样说 它好像是无结构的

919
01:12:25,780 --> 01:12:29,230
但它是一个随机化结构

920
01:12:29,340 --> 01:12:32,380
所以必定会存在有效函数  因为它们大部分

921
01:12:32,460 --> 01:12:38,670
都有好的性质

922
01:12:38,750 --> 01:12:41,020
所以我能够从他们之中找到...

923
01:12:41,100 --> 01:12:44,110
只要随机测试几个 就能找到一个

924
01:12:44,220 --> 01:12:46,240
再测试几个 就又有一个

925
01:12:46,320 --> 01:12:48,570
然后写进表里

926
01:12:48,660 --> 01:12:50,580
因为所有的函数都是预先计算好的

927
01:12:50,660 --> 01:12:51,720
那我就想要把它们找出来

928
01:12:51,790 --> 01:12:57,740
因为有效的函数存在的概率是很大的

929
01:12:57,840 --> 01:13:01,880
所以——

930
01:13:11,740 --> 01:13:16,950
只需要随机测试几个

931
01:13:21,610 --> 01:13:27,400
就能很快地找到一个

932
01:13:31,230 --> 01:13:37,710
因为至少一半是有效可行的

933
01:13:37,790 --> 01:13:39,800
我只需要证明存在有效的函数

934
01:13:39,890 --> 01:13:41,200
其实我只要证明

935
01:13:41,300 --> 01:13:43,960
对于每种情况至少都有一个是可行的

936
01:13:44,040 --> 01:13:46,720
实际上 我们已经证明绝大多数都是可行的

937
01:13:46,800 --> 01:13:49,430
起码有一半是可行的

938
01:13:49,440 --> 01:13:51,680
但如果只是证明它是存在的 那我就只需要证明

939
01:13:51,760 --> 01:13:54,830
其概率大于0

940
01:13:54,910 --> 01:13:57,210
为了完善 我们还需要分析一下存储

941
01:13:57,290 --> 01:14:01,060
因为我保证过在这个定理中

942
01:14:01,140 --> 01:14:02,880
表的大小仅为O(n)

943
01:14:03,030 --> 01:14:04,570
但我也说过

944
01:14:04,650 --> 01:14:13,410
这里所有的槽数都是二次方阶的大小

945
01:14:16,100 --> 01:14:22,870
所以我要证明 这是O(n)大小

946
01:14:30,250 --> 01:14:36,510
对于第一级 很简单

947
01:14:36,590 --> 01:14:41,870
我会把槽的数量

948
01:14:41,960 --> 01:14:45,970
设成等于键的数量

949
01:14:46,060 --> 01:14:57,500
这样第一级的存储就是O(n)

950
01:14:57,600 --> 01:15:03,020
然后 我们令n_i

951
01:15:03,130 --> 01:15:11,420
做为被哈希到表T的槽i里 所有键的数量

952
01:15:12,390 --> 01:15:20,270
——的一个随机变量

953
01:15:20,360 --> 01:15:22,760
n_i就是之前提到的

954
01:15:22,860 --> 01:15:25,000
槽i所拥有的键数

955
01:15:25,100 --> 01:15:33,410
对于每个二级表S_i

956
01:15:33,510 --> 01:15:44,430
我们都设槽数m_i=n_i^2

957
01:15:44,520 --> 01:15:49,730
那么  总存储空间的期望值等于

958
01:15:53,340 --> 01:15:59,670
——第一级的n 也可以说是O(n)

959
01:15:59,750 --> 01:16:10,410
因为第一级是n个槽  然后再加上

960
01:16:10,540 --> 01:16:17,890
∑（i=0到m-1）Θ(n_i^2)

961
01:16:17,990 --> 01:16:26,750
的期望值

962
01:16:29,660 --> 01:16:31,730
因为我要把所有二级表的...

963
01:16:31,820 --> 01:16:34,240
平方阶大小全部加起来

964
01:16:34,320 --> 01:16:39,080
每一个二级表的平方阶大小

965
01:16:39,160 --> 01:16:41,870
谁认得这个总和？

966
01:16:41,950 --> 01:16:44,490
在哪里见过？

967
01:16:46,610 --> 01:16:49,590
谁去了复习课？

968
01:16:51,150 --> 01:16:55,170
我们在复习课上见过这式子？

969
01:17:01,960 --> 01:17:06,530
这里是加上一个一大块东西的期望...

970
01:17:08,620 --> 01:17:13,920
对 是什么算法？

971
01:17:14,010 --> 01:17:15,970
是个排序算法 是吧？

972
01:17:16,060 --> 01:17:17,890
在什么排序算法里

973
01:17:17,980 --> 01:17:21,780
它是一个重要的测量值？

974
01:17:25,090 --> 01:17:28,540
有谁知道马上大声说出来

975
01:17:29,920 --> 01:17:33,010
那个排序算法叫什么？

976
01:17:33,110 --> 01:17:35,930
桶排序 对了 就是桶排序

977
01:17:36,020 --> 01:17:42,630
当变量随机分布到n个桶时

978
01:17:42,710 --> 01:17:56,400
我们证明过它们平方的总和 是Θ(n)  对吧？

979
01:18:15,090 --> 01:18:16,870
你也可以从这里得出一个...

980
01:18:16,960 --> 01:18:19,180
正如之前所做的 得出一个概率界限

981
01:18:19,260 --> 01:18:20,950
根据这个期望  可以用马尔科夫不等式

982
01:18:21,030 --> 01:18:28,120
得到总储存空间大于n乘以某个值的概率

983
01:18:28,200 --> 01:18:33,140
这是分析的关键点

984
01:18:33,230 --> 01:18:36,670
恰好这里用得上 有点巧合

985
01:18:36,760 --> 01:18:38,600
但这也是我们在学期的开始

986
01:18:38,690 --> 01:18:40,560
就学习排序的原因之一

987
01:18:40,660 --> 01:18:42,730
因为排序的技巧

988
01:18:42,810 --> 01:18:48,020
会应用到其它的分析领域

989
01:18:48,150 --> 01:18:50,600
你会发现很多相似的情况

990
01:18:50,680 --> 01:18:55,270
因为你们已经清楚地理解了桶排序

991
01:18:55,360 --> 01:19:00,620
所以能很快得出结果 不用做多余的工作

992
01:19:00,700 --> 01:19:01,820
但你们回去可能要

993
01:19:01,930 --> 01:19:04,800
再复习一下桶排序的分析

994
01:19:04,870 --> 01:19:07,070
因为在这里会用到

995
01:19:07,150 --> 01:19:10,880
一样的分析 用在两个地方

996
01:19:10,950 --> 01:19:14,540
做好复习 在本周五

997
01:19:14,630 --> 01:19:19,830
我们会有一个复习测验 接下来还有测验

998
01:19:19,930 --> 01:19:22,000
周一没有课

999
01:19:22,100 --> 01:19:28,170
下周三做一个测验

1000
01:19:28,260 --> 01:19:30,260
希望到时大家有不错的表现

1001
01:19:30,340 --> 01:19:32,710
确保有足够的睡眠

