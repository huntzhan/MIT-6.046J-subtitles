1
00:00:06,680 --> 00:00:08,240
好

2
00:00:09,150 --> 00:00:14,440
今天我们来讲一个很有意思的算法

3
00:00:14,440 --> 00:00:15,880
快速排序

4
00:00:21,560 --> 00:00:27,360
由Tony Hoare在1962年发明

5
00:00:29,650 --> 00:00:33,990
在很多方面看来它最终发展为

6
00:00:33,990 --> 00:00:35,630
一个很有意思的算法

7
00:00:37,800 --> 00:00:40,250
所以今天的课

8
00:00:40,250 --> 00:00:43,070
内容较难 讲的也会较快

9
00:00:47,680 --> 00:00:52,870
如果你旁边有同学在睡觉

10
00:00:52,870 --> 00:00:56,320
你可以叫醒他 让我们出发吧

11
00:00:56,530 --> 00:00:58,590
这是一个分治算法

12
00:01:04,640 --> 00:01:10,470
而且它就在原地排序

13
00:01:12,680 --> 00:01:14,200
也就是说

14
00:01:14,200 --> 00:01:17,090
它就在原来的数据区域内进行重排

15
00:01:17,200 --> 00:01:19,850
就像插入排序一样

16
00:01:19,850 --> 00:01:22,330
就在原地完成排序

17
00:01:22,480 --> 00:01:25,340
归并排序就不一样 它需要额外的

18
00:01:25,340 --> 00:01:28,710
空间来进行归并排序操作

19
00:01:29,500 --> 00:01:32,030
为了在线性时间与空间内归并

20
00:01:32,030 --> 00:01:34,960
它不能在线性时间内实现就地排序

21
00:01:34,960 --> 00:01:36,730
原地排序对它来说并不足够

22
00:01:37,060 --> 00:01:38,640
而快速排序的优点就在于它是原地的

23
00:01:38,640 --> 00:01:39,900
也就是说

24
00:01:39,900 --> 00:01:43,310
它很节省内存

25
00:01:43,950 --> 00:01:47,750
事实上它也很实用

26
00:01:50,750 --> 00:01:53,050
如果你微调一下的话

27
00:01:54,860 --> 00:01:57,700
这个基础算法表明

28
00:01:57,700 --> 00:01:59,100
如果你直接拿来用它

29
00:01:59,570 --> 00:02:01,910
可能并不那么高效

30
00:02:01,910 --> 00:02:03,260
但如果你接下来

31
00:02:03,260 --> 00:02:05,630
按照标准的步骤进行一些微调

32
00:02:05,630 --> 00:02:07,480
来改进它的运行时间的话

33
00:02:07,680 --> 00:02:09,990
待会我们会提到怎样改进

34
00:02:10,330 --> 00:02:13,900
届时快速排序可以变得非常实用

35
00:02:14,610 --> 00:02:18,630
因此快速排序采取分治策略

36
00:02:31,250 --> 00:02:34,950
第一步是分解问题

37
00:02:35,620 --> 00:02:40,210
本质上快速排序把数据分划成几份

38
00:02:41,310 --> 00:02:47,600
所以 快速排序通过选取一个关键数据

39
00:02:47,600 --> 00:02:52,790
再根据它的大小

40
00:02:53,780 --> 00:02:57,760
把原数组分成两个子数组

41
00:03:02,550 --> 00:03:09,280
第一个数组里的数都比

42
00:03:09,280 --> 00:03:13,790
这个主元数据要小

43
00:03:13,790 --> 00:03:16,090
而另一个数组里的数都

44
00:03:16,090 --> 00:03:23,490
大于或者等于它

45
00:03:26,060 --> 00:03:35,230
如果我们把输入的数组画出来

46
00:03:35,740 --> 00:03:39,650
这个分划的步骤就是选取某个数据x

47
00:03:39,650 --> 00:03:42,400
然后把所有小于或者等于x的

48
00:03:42,400 --> 00:03:44,710
数据都放在这边

49
00:03:44,850 --> 00:03:48,800
所有大于或等于x的数据都放在那边

50
00:03:52,490 --> 00:03:55,420
这样一来解决问题的步骤就非常容易

51
00:04:00,340 --> 00:04:09,670
用递归来处理两个子数组的排序就可以了

52
00:04:12,630 --> 00:04:14,060
那么我们用递归排序来处理

53
00:04:14,060 --> 00:04:16,160
比x小的数据

54
00:04:16,160 --> 00:04:17,630
同样的方法

55
00:04:17,630 --> 00:04:20,090
来处理比x大的数据

56
00:04:21,800 --> 00:04:28,670
最后把它们联接倒不那么重要

57
00:04:30,740 --> 00:04:32,850
因为一但我把

58
00:04:32,850 --> 00:04:34,450
等于或者比x小

59
00:04:34,450 --> 00:04:35,910
和比x大的数都排好了

60
00:04:35,910 --> 00:04:37,600
整个数组里的数据也就排好了序

61
00:04:38,190 --> 00:04:42,200
所以最后把它们放到一起是小菜一碟

62
00:04:42,350 --> 00:04:47,900
快速排序里面最关键的一步是分划的步骤

63
00:04:49,030 --> 00:04:53,850
这是这个算法处理问题的核心

64
00:04:53,850 --> 00:04:55,880
所以你可以把快速排序看成是

65
00:04:55,880 --> 00:04:57,340
递归地分划数组

66
00:04:57,340 --> 00:04:58,700
基本上就是这样

67
00:04:58,850 --> 00:05:01,880
就像合并排序就是递归地合并一样

68
00:05:03,000 --> 00:05:05,530
快速排序某种程度走了另一条路

69
00:05:05,530 --> 00:05:07,760
也就是递归着分划

70
00:05:12,020 --> 00:05:22,980
当然最重要的是它的复杂度是线性的

71
00:05:26,060 --> 00:05:38,600
也就是Θ(n)个分划的子程序

72
00:05:42,430 --> 00:05:44,440
接下来我来写伪代码

73
00:05:44,440 --> 00:05:47,000
这其实和课本上的稍有不同

74
00:05:47,850 --> 00:05:50,870
课后习题里面有个不错的问题

75
00:05:50,870 --> 00:05:53,080
其中的伪代码又稍有不同

76
00:05:53,080 --> 00:05:59,100
但它们的原理都一样

77
00:05:59,230 --> 00:06:02,600
这个partition(A, p, q)函数

78
00:06:02,600 --> 00:06:06,920
在递归的步骤上来看

79
00:06:06,920 --> 00:06:10,150
处理的是A数组中从p到q的部分

80
00:06:11,780 --> 00:06:14,520
首先我们选一个主元数据

81
00:06:14,520 --> 00:06:17,500
这里我们选了数组的第一个元素p

82
00:06:24,220 --> 00:06:28,170
课本里稍有不同 选了q

83
00:06:28,500 --> 00:06:31,180
我们这里用了p 但这其实无关紧要

84
00:06:32,980 --> 00:06:36,730
然后我们设置p的索引

85
00:06:36,730 --> 00:06:38,550
然后是一个循环

86
00:07:33,460 --> 00:07:35,350
这是循环的代码

87
00:07:35,350 --> 00:07:39,450
基本的结构就是一个for循环语句

88
00:07:39,450 --> 00:07:41,560
中间加上一个if条件语句

89
00:07:44,370 --> 00:07:50,710
这个分划步骤的

90
00:07:50,710 --> 00:07:53,030
算法结构可以画出来

91
00:07:56,050 --> 00:07:58,250
我们先把第一个数据

92
00:07:58,580 --> 00:08:03,100
选作主元 这里是p 这里是q

93
00:08:04,110 --> 00:08:08,680
这将是我们的循环不变量

94
00:08:11,460 --> 00:08:17,980
那么在运行的过程中

95
00:08:17,980 --> 00:08:21,950
数组里比x小的数

96
00:08:21,950 --> 00:08:24,120
都被移动到了索引i以前

97
00:08:24,120 --> 00:08:29,550
而索引i+1到j-1中的数据

98
00:08:29,780 --> 00:08:32,640
就是等于或者比x大的数

99
00:08:32,640 --> 00:08:35,320
j以后的数据 我们还不知道

100
00:08:37,370 --> 00:08:40,850
所以最开始的时候i等于p

101
00:08:40,850 --> 00:08:46,780
j等于p+1 从p+1开始

102
00:08:46,780 --> 00:08:51,520
所以除了x其他东西都还是未知

103
00:08:55,010 --> 00:08:57,810
那这个循环想要

104
00:08:57,810 --> 00:08:59,260
保持这个不变量

105
00:08:59,260 --> 00:09:02,240
所以在执行的过程中

106
00:09:02,240 --> 00:09:04,230
它检查索引j下的数据

107
00:09:04,230 --> 00:09:07,410
看它是否大于或等于x

108
00:09:07,410 --> 00:09:09,510
不 应该是核查它是否小于或等于x

109
00:09:09,510 --> 00:09:13,010
那如果这个数据大于或等于x

110
00:09:13,820 --> 00:09:15,430
那我们什么都不用做了

111
00:09:15,430 --> 00:09:16,830
如果它等于或比x大

112
00:09:17,060 --> 00:09:19,260
只用把j这个界限

113
00:09:19,260 --> 00:09:21,130
加上1就好了

114
00:09:21,130 --> 00:09:24,040
然后循环不变量就满足了 都清楚了吗

115
00:09:25,960 --> 00:09:29,120
好 那如果这个数据小于或者等于x

116
00:09:29,120 --> 00:09:32,950
那我们就得做些什么来维持循环不变量

117
00:09:32,950 --> 00:09:35,550
如果这个数据比x小或者等于x

118
00:09:35,790 --> 00:09:38,430
那它就把索引i+1下的

119
00:09:38,760 --> 00:09:42,120
比x大的数据

120
00:09:42,120 --> 00:09:44,610
和当前的比x小的数据

121
00:09:44,610 --> 00:09:47,320
的位置互换

122
00:09:48,310 --> 00:09:52,360
然后再移动界限的位置

123
00:09:52,360 --> 00:09:54,930
这样不变量就又被满足了

124
00:09:55,640 --> 00:09:59,150
这是个很简单的算法

125
00:09:59,150 --> 00:10:01,630
这事实上是一个很简洁和简单的算法

126
00:10:01,630 --> 00:10:05,330
这也是为什么这个代码非常漂亮的原因

127
00:10:06,890 --> 00:10:08,900
因为它很高效

128
00:10:10,520 --> 00:10:14,650
那么这个算法在n个数据下的

129
00:10:15,110 --> 00:10:19,810
运行时间大约是n

130
00:10:26,470 --> 00:10:28,920
因为它基本上就是

131
00:10:28,920 --> 00:10:30,390
把n个数据过了一遍

132
00:10:30,390 --> 00:10:32,750
而每个步骤所需的时间

133
00:10:32,750 --> 00:10:35,420
和拼起每个步骤所需的时间都是常数

134
00:10:36,310 --> 00:10:38,100
这是一段很好的代码

135
00:10:38,100 --> 00:10:41,280
事实上 如果我们不考虑原地排序的话

136
00:10:41,530 --> 00:10:43,930
分划是非常容易的 对吧

137
00:10:43,930 --> 00:10:45,580
我们可以很轻松的就做到

138
00:10:45,580 --> 00:10:46,650
我随便选个数据

139
00:10:46,650 --> 00:10:49,060
然后和其他每个数据比较

140
00:10:49,470 --> 00:10:51,900
比它大的扔到这一边 小的到另一边

141
00:10:51,900 --> 00:10:54,030
很明显是线性时间

142
00:10:54,670 --> 00:10:58,930
但你通常会发现

143
00:10:58,930 --> 00:11:01,520
理论上你能这样做并不意味着

144
00:11:01,520 --> 00:11:04,520
最终你能够写出好的代码

145
00:11:04,520 --> 00:11:06,200
而这是一段非常漂亮的代码

146
00:11:06,200 --> 00:11:08,420
让你很好地应用这个算法

147
00:11:08,600 --> 00:11:11,730
这也是为什么这个算法很不错的原因

148
00:11:11,730 --> 00:11:13,550
因为线性时间的常数不大

149
00:11:14,290 --> 00:11:18,630
因此我们在做渐进分析时倾向于忽略常数

150
00:11:18,630 --> 00:11:22,900
但当在写代码的时候你得考虑常数

151
00:11:23,290 --> 00:11:29,000
但首先你要考虑的不仅仅是常数

152
00:11:29,000 --> 00:11:31,830
是这个算法整体上是否足够快

153
00:11:32,870 --> 00:11:35,130
那我们来看一个例子

154
00:11:35,700 --> 00:11:37,830
在这里

155
00:11:37,890 --> 00:11:41,000
来看看你们有没有领会要点

156
00:11:42,420 --> 00:11:49,840
这是我随便写的一个数组

157
00:11:54,550 --> 00:12:01,230
主元设为6

158
00:12:04,400 --> 00:12:07,210
那我们来看看这个算法怎样运行

159
00:12:07,590 --> 00:12:12,730
i从这开始 j从这开始

160
00:12:14,950 --> 00:12:17,610
如果我们初始化

161
00:12:18,420 --> 00:12:22,980
然后开始逐个向右扫描

162
00:12:23,160 --> 00:12:25,850
直到发现一个

163
00:12:25,850 --> 00:12:28,250
小或者等于主元的数

164
00:12:28,250 --> 00:12:30,460
j不断的加1

165
00:12:30,460 --> 00:12:32,960
直到它发现一个

166
00:12:32,960 --> 00:12:34,670
小于或者等于主元的数

167
00:12:34,670 --> 00:12:37,460
在这里这个数就是5

168
00:12:37,460 --> 00:12:40,100
然后我们把这两个数互换

169
00:12:43,330 --> 00:12:46,750
于是我们得到了

170
00:12:46,750 --> 00:12:53,290
6 5 13 10 8 3 2 11

171
00:12:53,920 --> 00:12:57,050
同时i加一

172
00:12:57,050 --> 00:13:00,050
j还是在原来的地方

173
00:13:01,660 --> 00:13:03,440
然后我们继续往右

174
00:13:03,440 --> 00:13:04,330
直到又遇到一个

175
00:13:04,330 --> 00:13:06,320
小于或者等于主元的数

176
00:13:06,320 --> 00:13:07,990
这里就是3

177
00:13:07,990 --> 00:13:18,410
我们把3和5互换 就得到了6, 3 等等

178
00:13:20,610 --> 00:13:25,060
然后我们再把i加上1

179
00:13:25,060 --> 00:13:27,200
j从这开始

180
00:13:27,200 --> 00:13:29,350
那在这里我们立刻就看到了一个

181
00:13:29,350 --> 00:13:34,970
小于或者等于主元x的数

182
00:13:34,970 --> 00:13:36,820
那我们就把它们互换

183
00:13:37,240 --> 00:13:40,920
啊 我搞错了 对吧 我哪里做错了

184
00:13:41,530 --> 00:13:43,880
我换错了数 是不是 这里

185
00:13:47,480 --> 00:13:49,300
这是因为我不是一台计算机

186
00:13:51,570 --> 00:13:54,150
好 我们应该交换这个

187
00:13:54,570 --> 00:13:57,930
交换i+1 对吗

188
00:13:58,230 --> 00:13:59,820
这里是i

189
00:13:59,820 --> 00:14:01,810
交换i+1

190
00:14:01,810 --> 00:14:04,400
这些都错了

191
00:14:04,830 --> 00:14:06,820
我们按照正确顺序交换下

192
00:14:07,000 --> 00:14:14,620
现在是6 5 3 10 8 13 2 11

193
00:14:14,780 --> 00:14:19,960
这下和我的教案一样了

194
00:14:20,400 --> 00:14:23,710
这里是i 这里是j

195
00:14:24,300 --> 00:14:27,840
我们看看这里

196
00:14:27,840 --> 00:14:32,080
它小于等于主元

197
00:14:32,080 --> 00:14:38,330
和这里交换 i加上1

198
00:14:38,330 --> 00:14:45,110
现在得到6 5 3 2 8 13 10 11

199
00:14:45,660 --> 00:14:55,090
将i加1到这里

200
00:14:55,090 --> 00:15:00,100
j向前进移动 这里j到达末尾

201
00:15:01,020 --> 00:15:02,780
现在循环结束了

202
00:15:02,780 --> 00:15:06,170
当循环结束时我们还要做最后一次交换

203
00:15:06,170 --> 00:15:12,280
把主元放在两个子串中间

204
00:15:12,590 --> 00:15:16,430
我们交换这个和这个

205
00:15:16,750 --> 00:15:25,550
现在得到2 5 3 6 8 13 10 11

206
00:15:25,550 --> 00:15:29,030
这里是主元

207
00:15:30,560 --> 00:15:35,750
左边的数都小于等于主元

208
00:15:36,830 --> 00:15:42,400
右边的数都大于等于主元

209
00:15:54,280 --> 00:15:56,330
好了 这就是快速排序的方法

210
00:15:56,330 --> 00:15:58,380
当我们知道了分划方法

211
00:15:58,620 --> 00:16:01,840
快速排序在代码上很容易实现

212
00:16:16,700 --> 00:16:22,060
这里应该返回i 对吧

213
00:16:22,310 --> 00:16:24,440
应该要返回主元

214
00:16:24,880 --> 00:16:27,370
这里要返回i

215
00:16:27,370 --> 00:16:30,230
因为我们需要知道主元是什么

216
00:16:31,230 --> 00:16:32,560
抱歉

217
00:16:32,810 --> 00:16:34,570
要改改代码了

218
00:16:36,090 --> 00:16:44,200
r得到A p q分划的结果

219
00:16:45,010 --> 00:16:54,360
接着我们快排两个子串 A p r-1

220
00:16:54,360 --> 00:17:04,310
和 A r+1 q

221
00:17:04,870 --> 00:17:07,640
就是这样了 这是实现代码

222
00:17:07,770 --> 00:17:21,660
初始调用快排A 1 n

223
00:17:23,170 --> 00:17:26,160
因为分划之后

224
00:17:26,160 --> 00:17:30,790
只需要快排两部分 左边和右边的部分

225
00:17:36,560 --> 00:17:40,340
我们需要特别说明一下边界状态

226
00:17:40,340 --> 00:17:43,090
如果有0个或1个元素

227
00:17:43,090 --> 00:17:45,670
那么在这里将会是

228
00:17:45,670 --> 00:17:47,510
当这里是0个或1个元素的时候

229
00:17:47,510 --> 00:17:50,080
那么这里就没有工作量

230
00:17:50,080 --> 00:17:51,880
因为数组要么为空

231
00:17:51,880 --> 00:17:54,260
要么只有一个元素

232
00:17:54,670 --> 00:17:57,600
一个让快速排序运行更快的方法

233
00:17:57,600 --> 00:18:00,810
是调整这里的代码

234
00:18:00,980 --> 00:18:08,760
找到适合元素数目较少时的特别的算法

235
00:18:08,760 --> 00:18:11,370
比如说 最后只剩下5个元素

236
00:18:11,370 --> 00:18:13,410
你已经知道了一些代码

237
00:18:13,410 --> 00:18:15,840
来高效地排序5个元素

238
00:18:16,050 --> 00:18:18,580
相对于用这里的递归

239
00:18:18,580 --> 00:18:21,070
就会好一些

240
00:18:21,240 --> 00:18:22,810
还有一些其他的方法

241
00:18:22,810 --> 00:18:24,440
这是尾递归的代码

242
00:18:24,590 --> 00:18:27,640
那么就可以使用一些尾递归的优化

243
00:18:28,120 --> 00:18:31,710
还有很多优化的方法

244
00:18:31,710 --> 00:18:33,600
你可以用这些方法使得代码运行更快

245
00:18:33,600 --> 00:18:35,890
对 你可以做一些修改

246
00:18:35,890 --> 00:18:39,270
但是核心部分

247
00:18:39,270 --> 00:18:41,890
是这里的很有效的分划方法

248
00:18:49,810 --> 00:18:52,730
这就是快速排序算法

249
00:18:53,090 --> 00:19:00,190
实际上要得知这个算法运行的速度

250
00:19:00,190 --> 00:19:02,100
是有一些困难的

251
00:19:03,820 --> 00:19:06,610
在分析中我们假设

252
00:19:07,710 --> 00:19:11,030
所有的元素都是不同的

253
00:19:14,740 --> 00:19:17,370
然后当重复元素存在时

254
00:19:17,370 --> 00:19:21,530
代码就运行得不是很好

255
00:19:21,530 --> 00:19:25,050
但Hoare最初的分划方法

256
00:19:25,240 --> 00:19:27,640
在这种情况下更为高效

257
00:19:27,640 --> 00:19:31,530
如果待排序的元素中有重复的话

258
00:19:31,530 --> 00:19:34,420
我建议你看看那个方法

259
00:19:34,420 --> 00:19:39,010
它使用一个更加复杂的不变量用来实现分划过程

260
00:19:39,010 --> 00:19:40,800
但本质上是一样的

261
00:19:40,800 --> 00:19:42,710
只是有点复杂而已

262
00:19:46,290 --> 00:19:49,300
如果元素有重复的 你可以把重复去掉

263
00:19:49,560 --> 00:19:54,880
或者使用这个代码

264
00:19:54,880 --> 00:19:57,940
用Hoare的代码是最简单的一种方式

265
00:19:57,940 --> 00:20:00,580
当元素有重复的时候 它运行得很好

266
00:20:02,440 --> 00:20:04,880
但是这个要相对容易理解些

267
00:20:06,460 --> 00:20:10,470
假设T(n)是n个元素

268
00:20:10,470 --> 00:20:14,490
在最差情况下的运行时间

269
00:20:18,970 --> 00:20:21,580
最差情况是什么

270
00:20:23,550 --> 00:20:29,420
快速排序的最差情况是什么

271
00:20:38,780 --> 00:20:40,840
没错 如果你每次都选择这样一个数做主元

272
00:20:40,840 --> 00:20:43,950
其他每个数都比这个数大或者小

273
00:20:43,950 --> 00:20:46,760
那么分划就不正常了

274
00:20:46,760 --> 00:20:48,930
什么时候会发生这种情况

275
00:20:48,930 --> 00:20:53,060
最初的输入数据是什么样子

276
00:20:54,240 --> 00:20:59,220
如果数据已经排序或者逆序排好了

277
00:20:59,690 --> 00:21:02,200
如果输入正序排好了

278
00:21:06,900 --> 00:21:08,710
或者逆序排好

279
00:21:10,020 --> 00:21:11,930
我们需要明白这一点很重要

280
00:21:11,930 --> 00:21:14,970
因为很常见的情况就是

281
00:21:14,970 --> 00:21:17,610
数已经排好序 这很令人吃惊吧

282
00:21:19,790 --> 00:21:24,230
或者几乎要排好

283
00:21:24,230 --> 00:21:26,080
但是通常已经是排好了

284
00:21:26,080 --> 00:21:27,890
而人们想要确认是不是排好的办法

285
00:21:28,250 --> 00:21:29,340
通常是再排序一次

286
00:21:29,340 --> 00:21:32,370
而不是检查是不是已经排好

287
00:21:32,840 --> 00:21:35,550
在那些情况下 分划的一边

288
00:21:37,130 --> 00:21:48,500
每个分划的一边都没有元素

289
00:21:51,120 --> 00:21:54,300
我们可以写出这种递归

290
00:21:54,300 --> 00:21:55,830
对于T(n)

291
00:21:55,830 --> 00:21:58,160
如果分划的一边没有元素

292
00:21:58,320 --> 00:22:01,130
那么这一边是T(0)

293
00:22:01,260 --> 00:22:04,090
分划的另一边是T(n-1)

294
00:22:05,030 --> 00:22:07,720
我们把递归写出来

295
00:22:10,080 --> 00:22:14,550
一边没有元素 另一边有n-1个元素

296
00:22:14,720 --> 00:22:19,090
分划和记录等工作是Θ(n)

297
00:22:23,230 --> 00:22:25,320
T(0)是多少

298
00:22:30,860 --> 00:22:35,120
T(0)是多少 它趋向于多少

299
00:22:36,260 --> 00:22:38,490
常量 Θ(1)

300
00:22:38,630 --> 00:22:46,850
Θ(1)+T(n-1)+Θ(n)

301
00:22:46,850 --> 00:22:50,550
Θ(1)可以算到Θ(n)中去

302
00:22:50,550 --> 00:22:57,820
这实际上是T(n-1)+Θ(n)

303
00:22:57,990 --> 00:23:00,270
这等于多少

304
00:23:02,280 --> 00:23:04,400
是Θ(n²)

305
00:23:08,850 --> 00:23:10,820
为什么是Θ(n²)

306
00:23:12,360 --> 00:23:14,660
这是一个等差级数

307
00:23:20,650 --> 00:23:26,410
实际上就像插入排序一样

308
00:23:29,190 --> 00:23:31,060
就像插入排序一样

309
00:23:33,420 --> 00:23:35,130
这是一个等差级数

310
00:23:35,290 --> 00:23:37,140
我们用快速排序

311
00:23:37,290 --> 00:23:39,890
完成这些工作

312
00:23:41,780 --> 00:23:48,210
不比插入排序快

313
00:23:50,580 --> 00:23:52,860
尽管如此 我说它是个好算法

314
00:23:54,130 --> 00:23:56,200
快速排序是个好算法是因为

315
00:23:56,200 --> 00:23:58,860
它的平均情况时间是很好的

316
00:23:58,860 --> 00:24:00,560
这点我们就要看到

317
00:24:02,940 --> 00:24:05,870
但是我们先来好好理解下这个

318
00:24:05,870 --> 00:24:08,470
然后我们就能看出

319
00:24:08,470 --> 00:24:14,400
平均情况和最坏情况的差别

320
00:24:14,400 --> 00:24:17,050
我们为最差情况画个递归树

321
00:24:21,540 --> 00:24:32,920
T(n)=T(0)+T(n-1)+cn cn展开出来

322
00:24:32,920 --> 00:24:34,980
现在我们知道怎么做了

323
00:24:34,980 --> 00:24:37,050
某个常数乘以n

324
00:24:38,210 --> 00:24:41,780
T(n)等于

325
00:24:41,780 --> 00:24:45,310
这里的常数部分cn

326
00:24:45,650 --> 00:24:47,550
T(0)在这里

327
00:24:47,710 --> 00:24:51,160
T(n-1)在这里

328
00:24:51,160 --> 00:24:53,090
我知道你们这些家伙都算的很快

329
00:24:53,090 --> 00:24:56,210
你们想直接跳到完整的树的底部

330
00:24:56,390 --> 00:24:58,250
但是我告诉你们 我的建议是

331
00:24:58,250 --> 00:25:01,590
你们花几分钟时间把它写出来

332
00:25:01,590 --> 00:25:04,770
因为树呈指数级的增长

333
00:25:04,770 --> 00:25:07,130
你只需花一点时间

334
00:25:07,320 --> 00:25:10,230
写出小的情况

335
00:25:10,380 --> 00:25:12,160
并且确保你明白了这个模式

336
00:25:12,160 --> 00:25:14,190
我再做一步

337
00:25:14,610 --> 00:25:16,630
这里是T(0)

338
00:25:17,000 --> 00:25:21,940
这里是c(n-1)

339
00:25:21,940 --> 00:25:28,220
这里是另外一个T(0)和T(n-2)

340
00:25:28,610 --> 00:25:32,450
我们接着这样做下去

341
00:25:32,630 --> 00:25:34,610
直到到达

342
00:25:35,450 --> 00:25:40,830
等于cn下面是T(0)

343
00:25:41,540 --> 00:25:44,130
c(n-1)下面是T(0)

344
00:25:48,210 --> 00:25:51,180
c(n-2)

345
00:25:52,100 --> 00:25:54,150
这里是T(0)

346
00:25:55,600 --> 00:25:59,480
这样一直下来直到Θ(1)为止

347
00:26:02,290 --> 00:26:05,980
树的高度是多少

348
00:26:15,210 --> 00:26:17,270
这里树的高度是多少

349
00:26:19,010 --> 00:26:21,790
对 n 很好

350
00:26:22,310 --> 00:26:28,050
因为在每一步我们的参数只减少了1

351
00:26:28,400 --> 00:26:30,430
所以 高度为n

352
00:26:30,430 --> 00:26:35,710
为了分析这个问题 我们首先把这里的所有式子相加

353
00:26:37,800 --> 00:26:42,570
刚刚我们分析了这些项是怎么产生的

354
00:26:42,740 --> 00:26:51,000
这些是 Θ(k从1累加到n的和)

355
00:26:51,840 --> 00:26:53,940
实际上是ck

356
00:26:59,890 --> 00:27:01,420
这就是这里的结果

357
00:27:01,420 --> 00:27:04,200
并且这就等于Θ(n²)

358
00:27:04,200 --> 00:27:07,150
这就使我们的算法复杂度如何得到的

359
00:27:11,890 --> 00:27:16,460
这里的所有项 都是Θ(1)

360
00:27:20,960 --> 00:27:22,810
这里有多少项?

361
00:27:26,830 --> 00:27:31,350
这里有n个Θ(1)

362
00:27:31,350 --> 00:27:58,320
所以总量是T(n)=Θ(n)+Θ(n²)=Θ(n²)

363
00:28:01,650 --> 00:28:07,250
我们来看根据递归树我们得到了什么样的结构

364
00:28:07,550 --> 00:28:10,830
这是一棵高度不平衡的递归树

365
00:28:12,700 --> 00:28:16,060
现在我将要分析一个我们以后不会去做的问题

366
00:28:17,400 --> 00:28:20,160
我们来分析一下最优情况

367
00:28:21,570 --> 00:28:24,130
这只是为了直观理解

368
00:28:25,450 --> 00:28:31,350
通常情况下 我们是不会进行最优情况分析的

369
00:28:31,350 --> 00:28:33,190
因为它不会说明任何问题

370
00:28:34,400 --> 00:28:37,130
除非我们需要一些直观的理解

371
00:28:37,130 --> 00:28:39,510
但是 在数学上它并不能代表任何问题

372
00:28:39,510 --> 00:28:41,810
因为我们无法保证处于最优情况中

373
00:28:53,730 --> 00:28:56,240
所以这只是为了直观理解

374
00:29:03,490 --> 00:29:16,590
如果我们足够的幸运 分划会发生在什么地方?

375
00:29:16,990 --> 00:29:19,490
什么情况是最幸运的情况?

376
00:29:25,060 --> 00:29:28,010
是的 分划发生在正中央

377
00:29:28,010 --> 00:29:30,740
也就是正好在

378
00:29:40,760 --> 00:29:44,940
n/2

379
00:29:45,450 --> 00:29:49,570
这时是n/2:n/2

380
00:29:49,570 --> 00:29:51,800
在这里我们不过多地考虑细节因为

381
00:29:51,800 --> 00:29:54,340
我们分析最优情况只是为了直观理解 因为

382
00:29:54,340 --> 00:29:56,740
最优情况并不是我们想要真正分析的

383
00:29:56,740 --> 00:29:59,570
如果分划发生在正中央 我们会得到怎样的递归式?

384
00:30:02,370 --> 00:30:05,660
想象一下 每一次分划都发生在正中央

385
00:30:10,410 --> 00:30:12,380
会发生什么?

386
00:30:14,610 --> 00:30:29,780
可以得到 T(n) = 2T(n/2) 加上分划与合并的复杂度

387
00:30:29,780 --> 00:30:32,400
这个递归式的结果是什么?

388
00:30:33,030 --> 00:30:36,390
是nlgn 也就是和归并排序的结果一样

389
00:30:39,180 --> 00:30:41,970
这是主定理的第几种情况?

390
00:30:44,380 --> 00:30:47,180
第二种情况 对吗?

391
00:30:47,180 --> 00:30:52,420
n的log₂2次方

392
00:30:52,690 --> 00:30:55,040
就是n的一次方 是一样的

393
00:30:55,040 --> 00:30:57,720
所以还有一个附加的lgn

394
00:30:59,610 --> 00:31:01,900
就是主定理的第二种情况

395
00:31:04,530 --> 00:31:05,890
非常好

396
00:31:06,030 --> 00:31:09,350
也就是说 在最优情况下 快速排序的效率非常高

397
00:31:10,800 --> 00:31:13,680
如果我们假设分划永远发生在

398
00:31:15,900 --> 00:31:26,390
比如1/10:9/10的位置呢

399
00:31:27,490 --> 00:31:33,460
n/10:9n/10

400
00:31:34,180 --> 00:31:42,090
在这种情况下 我们是否幸运呢?

401
00:31:51,130 --> 00:31:54,000
也就是说 分划的地方非常的偏斜

402
00:31:54,280 --> 00:31:56,340
很显然我们是不幸的

403
00:31:57,300 --> 00:32:00,370
因为 从1到n

404
00:32:00,530 --> 00:32:02,600
如果真的在中间分划 结果是nlgn

405
00:32:02,600 --> 00:32:06,590
如果是1/10:9/10

406
00:32:06,590 --> 00:32:08,880
我们是幸运还是不幸运?

407
00:32:10,710 --> 00:32:14,020
我们需要进行一次投票

408
00:32:14,460 --> 00:32:17,850
谁认为这种情况是幸运的?

409
00:32:18,480 --> 00:32:20,030
也就是说运行时间会比较快

410
00:32:20,030 --> 00:32:22,910
谁认为这种情况是不幸的?

411
00:32:22,910 --> 00:32:24,900
好 我们有很多勇士

412
00:32:24,900 --> 00:32:29,640
谁没有投票? 来 来 来

413
00:32:29,830 --> 00:32:34,110
顺便说一下 回答yes或者no

414
00:32:34,110 --> 00:32:36,830
不管正确与否都会更好

415
00:32:36,830 --> 00:32:38,870
因为你投入了自己的感情在这个问题上

416
00:32:38,870 --> 00:32:40,320
所以我们会记得更牢

417
00:32:40,680 --> 00:32:42,920
相比仅仅是坐在那里保持沉默而言

418
00:32:42,920 --> 00:32:46,220
你们没有调动自己的感情

419
00:32:46,220 --> 00:32:48,020
就不会印象深刻

420
00:32:48,180 --> 00:32:51,870
那些参与投票的人 不管回答的正确与否

421
00:32:51,870 --> 00:32:53,880
总比那些沉默的人有收获

422
00:32:55,410 --> 00:32:59,450
好 我们来看一下 这是递归式

423
00:32:59,450 --> 00:33:12,240
T(n)=T(n/10)+T(9n/10)+Θ(n)

424
00:33:12,240 --> 00:33:15,670
我们假设这部分是

425
00:33:15,670 --> 00:33:22,550
小于或者等于一个cn的

426
00:33:22,550 --> 00:33:26,440
我们为这个递归式建立一棵递归树

427
00:33:26,440 --> 00:33:28,580
这里是递归树

428
00:33:33,560 --> 00:33:46,170
我们有 T(n) = cn T(n/10) T(9n/10)

429
00:33:47,620 --> 00:33:50,720
现在 我们依然把cn写在最上面

430
00:33:50,870 --> 00:33:52,420
这很复杂 是吧

431
00:33:52,420 --> 00:33:58,370
这里是cn/10 这里我们有1/10

432
00:33:58,370 --> 00:34:01,190
因此我们再一次将其计算进递归式

433
00:34:01,190 --> 00:34:15,730
因此我们得到 T(n/100) 和 T(9n/100)

434
00:34:16,460 --> 00:34:22,200
在这里 我们得到9cn/10

435
00:34:22,340 --> 00:34:32,230
这里再一次有T(9n/100)

436
00:34:32,380 --> 00:34:37,910
这里有T(81n/100)

437
00:34:40,380 --> 00:34:42,510
我们继续计算

438
00:34:47,120 --> 00:34:57,920
这等于 cn 这里是1/10cn

439
00:34:57,920 --> 00:35:01,930
下面有1/100cn

440
00:35:01,930 --> 00:35:06,690
这样继续下去 知道我们到达Θ(1)

441
00:35:07,720 --> 00:35:13,280
在这里我们有9/10cn

442
00:35:13,710 --> 00:35:19,440
这里是9/100cn

443
00:35:19,850 --> 00:35:28,690
这里是9/100cn 这里是81/100cn

444
00:35:30,250 --> 00:35:35,210
这些计算都进行下去 知道我们达到Θ(1)

445
00:35:35,580 --> 00:35:38,750
但是这些叶结点并不都在同一深度 对吧?

446
00:35:39,410 --> 00:35:48,000
这边远高于这边 对吧?

447
00:35:48,000 --> 00:35:51,060
因为在这边每次只下降了9/10

448
00:35:51,220 --> 00:35:56,840
所以实际上 这条路径的长度是多少?

449
00:35:59,900 --> 00:36:01,880
这条路径到这里的长度是多少?

450
00:36:01,880 --> 00:36:04,280
如果我们只看最左边的这枝

451
00:36:13,850 --> 00:36:16,190
有人举手吗? 你

452
00:36:17,020 --> 00:36:26,360
log₁₀n

453
00:36:26,830 --> 00:36:30,030
因为我每次减少到1/10

454
00:36:30,030 --> 00:36:31,870
我需要多久能到达1?

455
00:36:31,870 --> 00:36:37,030
这就是以10为底对数的定义

456
00:36:37,030 --> 00:36:39,030
那么这边呢?

457
00:36:39,030 --> 00:36:41,780
这条路径的长度呢?

458
00:36:51,320 --> 00:36:59,320
以10/9为底n的对数

459
00:36:59,470 --> 00:37:02,340
因为我们每次减少9/10

460
00:37:04,550 --> 00:37:07,630
再一次很显然 这就是log的定义

461
00:37:07,630 --> 00:37:09,190
所有在这之间的便是

462
00:37:09,190 --> 00:37:14,690
在lg10n和lg10/9n之间的

463
00:37:16,430 --> 00:37:19,440
所有一切都在这之间

464
00:37:19,730 --> 00:37:22,980
现在我能做的便和分析归并排序一样

465
00:37:22,980 --> 00:37:25,610
观察把这些每一层都加起来的值

466
00:37:25,610 --> 00:37:29,860
观察把这些每一层都加起来的值

467
00:37:29,860 --> 00:37:31,780
这里就是cn

468
00:37:31,780 --> 00:37:34,000
下一层是多少?

469
00:37:35,800 --> 00:37:37,670
cn

470
00:37:37,670 --> 00:37:40,110
再下一层呢?

471
00:37:40,530 --> 00:37:42,020
cn

472
00:37:42,990 --> 00:37:47,760
每一层我们都做了同样份额的工作

473
00:37:50,440 --> 00:37:52,850
我们把这些都计算出来

474
00:37:55,510 --> 00:37:58,630
在最后一层

475
00:37:58,630 --> 00:38:00,990
实际上我们在一些地方并不是cn

476
00:38:00,990 --> 00:38:03,350
这时 我们开始获得小于等于cn的值

477
00:38:03,510 --> 00:38:07,970
这是因为在一些层 叶子便不会继续向下扩展了

478
00:38:09,350 --> 00:38:14,960
基本上 这部分是log10n

479
00:38:14,960 --> 00:38:17,970
接着计算结果便会小于或者等于cn

480
00:38:20,810 --> 00:38:26,920
一直下去 直到我们把它们都加起来

481
00:38:27,640 --> 00:38:35,090
T(n)将会小于或者等于cn乘以

482
00:38:35,090 --> 00:38:38,750
最长的路径可能会多长?

483
00:38:39,080 --> 00:38:42,180
log10/9n

484
00:38:47,890 --> 00:38:53,750
加上所有的这些叶子

485
00:38:54,110 --> 00:38:57,630
但是这些叶子加在一起只有Θ(n)

486
00:38:58,740 --> 00:39:04,210
所有这些叶子加在一起只有Θ(n) 所以+Θ(n)

487
00:39:05,430 --> 00:39:08,350
这等于多少?

488
00:39:08,350 --> 00:39:11,460
如果我把这些都加在一起 渐近地是多少?

489
00:39:13,930 --> 00:39:15,760
是nlgn

490
00:39:16,800 --> 00:39:20,120
所以T被界定在nlgn以内

491
00:39:20,310 --> 00:39:23,440
我们是幸运的 那些认为我们是幸运的人赢了

492
00:39:25,120 --> 00:39:31,770
9/10的分划和50:50的分划趋向于同样好

493
00:39:34,220 --> 00:39:37,200
事实上 我们可以找到它的下界

494
00:39:37,200 --> 00:39:41,150
观察这些项 可以发现

495
00:39:41,150 --> 00:39:49,950
事实上 T(n)的下界是cnlog10n+Θ(n)

496
00:39:50,840 --> 00:39:55,890
所以T(n)的下界也渐近为nlgn

497
00:39:55,890 --> 00:39:59,030
所以 事实上T(n)=Θ(nlgn)

498
00:39:59,030 --> 00:40:01,060
这并不是严格意义上的证明

499
00:40:01,060 --> 00:40:02,330
我建议你们

500
00:40:02,330 --> 00:40:06,750
不要这样去进行证明

501
00:40:06,750 --> 00:40:08,580
这只是一个很好的直观理解递归树的例子

502
00:40:08,580 --> 00:40:10,710
怎么去真正的证明?

503
00:40:12,800 --> 00:40:14,580
代换法 很好

504
00:40:14,850 --> 00:40:18,870
你需要做的就是使用这些来获得你的假设

505
00:40:18,870 --> 00:40:23,080
使用代换法来证明你的假设成立

506
00:40:23,250 --> 00:40:26,350
使用这种方法非常容易犯错误

507
00:40:26,750 --> 00:40:28,240
非常容易犯错误

508
00:40:28,240 --> 00:40:29,560
使用代换法

509
00:40:30,000 --> 00:40:32,110
很难犯错误

510
00:40:33,290 --> 00:40:36,070
因为你只涉及了代数运算

511
00:40:36,070 --> 00:40:38,730
相对于递归树法 代换法更容易证实

512
00:40:38,730 --> 00:40:40,490
递归树则有画的不准确

513
00:40:40,490 --> 00:40:43,570
数量不对等等问题

514
00:40:46,360 --> 00:40:48,940
所以是nlgn 结果很好

515
00:40:49,720 --> 00:40:52,880
nlgn的复杂度 很幸运

516
00:40:55,550 --> 00:40:57,730
换一种情况

517
00:40:58,180 --> 00:41:00,900
为的是更直观的理解它

518
00:41:00,900 --> 00:41:01,660
我告诉你

519
00:41:01,670 --> 00:41:03,400
当这节课结束时

520
00:41:03,400 --> 00:41:05,920
你们都会夺门而逃

521
00:41:07,240 --> 00:41:09,560
因为今天涉及很多美妙的数学

522
00:41:09,560 --> 00:41:11,910
我觉得挺有趣的

523
00:41:12,880 --> 00:41:14,480
但也有挑战性

524
00:41:14,480 --> 00:41:16,250
如果你不清醒

525
00:41:17,100 --> 00:41:20,350
你可以继续睡 该醒时我叫你

526
00:41:22,280 --> 00:41:24,520
多一些直观上的感觉

527
00:41:24,520 --> 00:41:28,120
假设我们交替进行

528
00:41:28,390 --> 00:41:31,210
在分划的时候

529
00:41:31,210 --> 00:41:36,220
开始时是幸运的

530
00:41:36,420 --> 00:41:40,330
接着的是不幸运的分划

531
00:41:40,330 --> 00:41:42,660
接着又是幸运的分划

532
00:41:42,660 --> 00:41:44,920
然后是不幸运的

533
00:41:44,920 --> 00:41:47,170
这样交替下去

534
00:41:47,170 --> 00:41:52,550
假设如此交替进行

535
00:42:05,670 --> 00:42:09,170
这样的话 总体上我们是幸运的吗

536
00:42:09,610 --> 00:42:11,400
这次大家都来投票

537
00:42:11,400 --> 00:42:13,380
你的答案是什么不重要

538
00:42:13,380 --> 00:42:15,430
每个人都得有个立场

539
00:42:15,580 --> 00:42:16,810
就像赛马一样

540
00:42:16,810 --> 00:42:18,950
如果看过赛马 你会发现它很无聊

541
00:42:19,230 --> 00:42:21,130
但如果你押点钱

542
00:42:21,680 --> 00:42:24,020
有一些投入

543
00:42:24,190 --> 00:42:26,470
突然它就有意思了

544
00:42:26,470 --> 00:42:28,280
这里一样

545
00:42:28,280 --> 00:42:30,660
我希望每个人都投入进来

546
00:42:30,660 --> 00:42:32,730
哪些人觉得是幸运的

547
00:42:33,610 --> 00:42:36,000
哪些人觉得是不幸运的

548
00:42:36,630 --> 00:42:39,710
谁没投票

549
00:42:43,450 --> 00:42:47,000
你们这些家伙 一点都不投入呀

550
00:42:47,190 --> 00:42:51,700
我们分析一下 写出它的递归式

551
00:42:51,700 --> 00:42:54,200
幸运的时候

552
00:42:54,360 --> 00:42:57,790
L(n)是规模为n的运行时间

553
00:42:58,420 --> 00:42:59,700
这是两倍

554
00:42:59,700 --> 00:43:01,640
考虑到下一步是不幸运的

555
00:43:01,640 --> 00:43:06,330
就是2U(n/2)+Θ(n)

556
00:43:06,330 --> 00:43:08,440
这是幸运的步骤

557
00:43:09,230 --> 00:43:11,590
不幸运时

558
00:43:12,140 --> 00:43:15,460
考虑到下一步是幸运的

559
00:43:15,460 --> 00:43:18,880
就是L(n-1)+Θ(n)

560
00:43:19,350 --> 00:43:20,920
这是不幸运的步骤

561
00:43:26,560 --> 00:43:30,470
看看我是如何用递归描述了

562
00:43:30,470 --> 00:43:33,670
我们假设的行为

563
00:43:33,670 --> 00:43:36,210
这两个递归式相互依赖

564
00:43:36,210 --> 00:43:38,010
递归边界没有写出来

565
00:43:38,010 --> 00:43:43,160
它在常数的输入规模里花费常数时间

566
00:43:45,220 --> 00:43:50,100
现在用代换法做点代数运算

567
00:43:50,100 --> 00:43:54,150
L(n)等于

568
00:43:54,150 --> 00:44:00,570
替换掉U(n/2)

569
00:44:00,570 --> 00:44:15,880
得到2(L(n/2–1)+Θ(n))+Θ(n)

570
00:44:16,850 --> 00:44:19,930
看懂了吗

571
00:44:20,080 --> 00:44:26,700
用递归式替换掉了U(n/2)

572
00:44:26,700 --> 00:44:29,790
严格的说 这里是Θ(n/2)

573
00:44:29,790 --> 00:44:33,890
这样代换显得更直观

574
00:44:33,890 --> 00:44:38,120
结果是一样的 只是没有跳过这一步

575
00:44:42,820 --> 00:44:45,470
现在更进一步

576
00:44:45,470 --> 00:44:51,880
得到2L(n/2-1)加上

577
00:44:52,020 --> 00:44:57,100
两个Θ(n/2) 再加上Θ(n)

578
00:44:57,100 --> 00:44:59,610
加在一起是Θ(n)

579
00:45:01,980 --> 00:45:04,380
递归式的结果是多少

580
00:45:07,780 --> 00:45:09,670
nlgn

581
00:45:15,770 --> 00:45:17,970
Θ(nlgn)

582
00:45:18,410 --> 00:45:19,860
都明白了吗

583
00:45:21,460 --> 00:45:23,660
对的吧 Θ(nlgn)

584
00:45:23,660 --> 00:45:25,960
我们再一次

585
00:45:25,960 --> 00:45:29,050
用到了主定理 除了一点小区别

586
00:45:29,530 --> 00:45:32,980
这个减一其实在主定理中

587
00:45:32,980 --> 00:45:35,470
只会帮助我们

588
00:45:36,860 --> 00:45:38,600
综上所述 nlgn

589
00:45:38,600 --> 00:45:40,360
是幸运的

590
00:45:42,360 --> 00:45:45,470
交替幸运与不幸的分划 总体是幸运的

591
00:45:46,170 --> 00:45:50,790
如何确保我们总是幸运的呢

592
00:45:53,500 --> 00:45:57,450
若输入本身已被排序 那么就糟了

593
00:46:00,970 --> 00:46:02,560
能再说一遍吗

594
00:46:02,850 --> 00:46:05,910
随机排列序列中的元素 这是一种

595
00:46:07,010 --> 00:46:10,060
另一种呢

596
00:46:11,040 --> 00:46:13,230
实际上这是一个相当好的方法

597
00:46:13,420 --> 00:46:16,040
也是一个常见的方法

598
00:46:17,380 --> 00:46:20,260
随机选择主元

599
00:46:20,260 --> 00:46:25,000
实际上这两种都是有效的

600
00:46:25,000 --> 00:46:26,990
但是这里 我们随机选择主元

601
00:46:26,990 --> 00:46:29,210
因为它更容易分析

602
00:46:29,410 --> 00:46:31,920
但它们都是有效的

603
00:46:31,920 --> 00:46:37,780
这个算法被称为随机化快速排序

604
00:46:44,710 --> 00:46:47,640
这种快排的好处是

605
00:46:47,640 --> 00:46:57,870
其运行时间不依赖于输入序列的顺序

606
00:47:02,180 --> 00:47:05,200
这点和置乱输入序列很像

607
00:47:05,200 --> 00:47:07,890
算法的效率与输入顺序无关

608
00:47:07,890 --> 00:47:10,440
如果我随机的排列输入序列

609
00:47:10,820 --> 00:47:13,610
那么输入序列的顺序就无所谓了

610
00:47:14,120 --> 00:47:18,250
然而 原始的快速排序

611
00:47:18,970 --> 00:47:20,920
在输入顺序或者逆序时则很慢

612
00:47:20,920 --> 00:47:24,630
在其余情况则表现良好

613
00:47:24,630 --> 00:47:28,240
尤其是当输入顺序是随机的时候

614
00:47:28,360 --> 00:47:30,830
如果我随机的排列输入

615
00:47:30,830 --> 00:47:34,490
或者是随机的选择主元

616
00:47:35,420 --> 00:47:38,850
那么输入的顺序就无关紧要

617
00:47:39,860 --> 00:47:43,400
思考这个问题时 你可想象一个对手

618
00:47:43,400 --> 00:47:44,620
想象一个对手

619
00:47:44,620 --> 00:47:46,660
你有一个排序算法

620
00:47:46,850 --> 00:47:48,490
他也有一个排序算法

621
00:47:48,490 --> 00:47:50,810
你们都想把它卖给一个客户

622
00:47:51,000 --> 00:47:52,040
客户说 好吧

623
00:47:52,040 --> 00:47:54,490
你们两个制定比较算法的基准出来

624
00:47:54,490 --> 00:47:56,370
你观察他的算法

625
00:47:56,370 --> 00:47:58,360
发现用的是快速排序

626
00:47:58,360 --> 00:48:00,630
你就可以给他已经排好序的序列

627
00:48:01,060 --> 00:48:02,270
可以这样对付他

628
00:48:02,270 --> 00:48:04,960
如果你是快速排序 他也会这么对你

629
00:48:06,260 --> 00:48:08,220
那你如果打败他

630
00:48:08,220 --> 00:48:10,750
一种方法就是随机化

631
00:48:11,380 --> 00:48:15,850
计算机科学中的重要概念 随机数

632
00:48:16,080 --> 00:48:21,060
如果我随机的排列序列元素

633
00:48:21,060 --> 00:48:24,850
或者 随机选取主元

634
00:48:26,240 --> 00:48:28,560
则输入序列的顺序不影响算法效率

635
00:48:28,760 --> 00:48:31,720
就不能找到任何一种序列

636
00:48:31,720 --> 00:48:34,280
让我的代码效率极低

637
00:48:34,280 --> 00:48:35,660
我有时可能不走运

638
00:48:35,660 --> 00:48:38,880
但不走运的原因是使用的随机数生成器

639
00:48:38,880 --> 00:48:42,190
而不是来自输入

640
00:48:42,190 --> 00:48:43,980
输入是什么无所谓

641
00:48:44,160 --> 00:48:45,840
大家都懂了吗

642
00:48:46,540 --> 00:48:51,430
随机化快速排序的优点是

643
00:48:51,430 --> 00:49:00,440
无需对输入序列的分布做任何假设

644
00:49:02,960 --> 00:49:07,430
无需假设输入数据的所有排列是等可能的

645
00:49:07,430 --> 00:49:08,980
因为 要么你可以使它变成那样

646
00:49:08,980 --> 00:49:14,560
要么随机主元也会使算法总体有效

647
00:49:14,740 --> 00:49:21,090
具体的说 没有一种特定的输入

648
00:49:21,670 --> 00:49:29,940
会引起最差的运行效率

649
00:49:33,930 --> 00:49:54,830
最差的情况由随机数产生器决定

650
00:49:58,980 --> 00:50:00,600
因此 既然它只是

651
00:50:00,600 --> 00:50:02,730
由随机数生成器决定

652
00:50:02,730 --> 00:50:06,630
可以在数学上确定不幸运情况的边界

653
00:50:06,630 --> 00:50:08,460
确定不幸运情况发生的可能性

654
00:50:10,610 --> 00:50:13,730
现在去分析它

655
00:50:14,890 --> 00:50:22,450
现在 你就知道是否适合这门课了

656
00:50:22,800 --> 00:50:26,100
如果你跳过6.042没修的话

657
00:50:26,280 --> 00:50:28,730
这里你可以对照一下自己

658
00:50:28,730 --> 00:50:29,930
考虑到等会儿有点…

659
00:50:29,930 --> 00:50:33,140
你们站起来放松放松吧

660
00:50:37,060 --> 00:50:41,590
等会儿有很多

661
00:50:41,590 --> 00:50:43,490
数学方面的内容

662
00:50:43,490 --> 00:50:45,860
你们要做好准备

663
00:51:01,270 --> 00:51:03,200
休息时间到

664
00:51:08,870 --> 00:51:10,540
分析

665
00:51:12,290 --> 00:51:13,680
好的

666
00:51:16,160 --> 00:51:17,640
我想应该讲得完

667
00:51:18,650 --> 00:51:21,330
讲的比较快 因为今天内容很多

668
00:51:22,700 --> 00:51:23,810
好的

669
00:51:23,810 --> 00:51:39,690
令T(n)为运行时间的随机变量 假设…

670
00:51:44,870 --> 00:51:47,130
哇 我都没写我们怎么做的

671
00:51:47,130 --> 00:51:49,490
我们要随机选择一个主元

672
00:51:57,930 --> 00:52:00,550
这就是基本的框架

673
00:52:00,550 --> 00:52:01,880
随便说下

674
00:52:01,880 --> 00:52:04,870
在分划的代码中

675
00:52:04,870 --> 00:52:06,820
不像之前是把首元素作为主元

676
00:52:06,820 --> 00:52:08,460
而是 在分划之前

677
00:52:08,460 --> 00:52:11,660
把首元素与序列中其他一个元素交换

678
00:52:11,660 --> 00:52:14,390
被随机选择 也有可能是它们自己

679
00:52:14,390 --> 00:52:17,040
所以它们都有一样的几率被作为主元

680
00:52:17,040 --> 00:52:19,330
然后再运行传统的分划程序

681
00:52:21,330 --> 00:52:24,740
这是一个随机变量 用来表示运行时间

682
00:52:25,410 --> 00:52:28,340
我们还要做一个假设

683
00:52:28,340 --> 00:52:35,000
假设这些随机数是独立的

684
00:52:38,750 --> 00:52:40,430
所以当我选择一个元素作为主元时

685
00:52:40,430 --> 00:52:43,050
与我在运行这个算法的其它情况下

686
00:52:43,050 --> 00:52:45,010
选择的主元的事件是独立的

687
00:52:47,690 --> 00:52:50,080
为了进行分析

688
00:52:50,080 --> 00:52:52,670
我想知道我们选择哪个元素作为主元

689
00:52:52,670 --> 00:52:59,160
让 k = 0, 1, ..., n-1,

690
00:52:59,590 --> 00:53:04,040
在我们选择一个特定分划的情况下

691
00:53:04,040 --> 00:53:25,310
当产生k:(n-k-1)分划时 随机变量xk=1

692
00:53:26,540 --> 00:53:29,130
其它分划则为 0

693
00:53:32,990 --> 00:53:35,570
在分划函数中 我选择

694
00:53:35,570 --> 00:53:39,370
一个随机元素作为主元

695
00:53:40,390 --> 00:53:46,120
xk 是一个随机变量 如果它为1

696
00:53:46,120 --> 00:53:50,930
表示它构造了一个分划 k个元素在主元左边

697
00:53:50,930 --> 00:53:54,360
n-k-1个元素在主元右边

698
00:53:54,640 --> 00:53:56,320
当然有些情况

699
00:53:56,320 --> 00:53:59,180
可能选择到主元导致主元右边有n-1个

700
00:54:02,280 --> 00:54:08,170
其他情况是0 所以现在有了n个随机变量

701
00:54:08,320 --> 00:54:14,430
通过单独的一次分划造成了n个相联系的随机变量

702
00:54:15,340 --> 00:54:17,820
除了一个以外 其它都是0

703
00:54:17,820 --> 00:54:20,340
不管怎么样

704
00:54:21,730 --> 00:54:23,660
总有一个变量的值为1

705
00:54:23,820 --> 00:54:25,550
顺便一提

706
00:54:25,550 --> 00:54:28,260
这种随机变量的名字是什么

707
00:54:36,010 --> 00:54:39,490
Bernoulli Bernoulli有其它的假设

708
00:54:42,070 --> 00:54:44,260
这是一个指示器随机变量

709
00:54:45,400 --> 00:54:48,730
也可能是Bernoulli的 没关系

710
00:54:48,730 --> 00:54:53,850
这是一个指示器随机变量

711
00:54:54,130 --> 00:54:56,270
它们的值只能为1或者0

712
00:54:56,270 --> 00:54:57,980
Bernoulli随机变量

713
00:54:57,980 --> 00:55:00,470
是一种特定的指示器随机变量

714
00:55:00,470 --> 00:55:02,100
但是这些变量

715
00:55:03,450 --> 00:55:05,950
是指示器随机变量

716
00:55:05,950 --> 00:55:08,320
指示器随机变量是一个很好的工具

717
00:55:08,320 --> 00:55:09,830
当你试图了解

718
00:55:09,830 --> 00:55:12,300
一堆东西的和是什么

719
00:55:12,730 --> 00:55:17,720
它是一个很好的工具来分解一些大的随机变量

720
00:55:17,720 --> 00:55:20,230
将它们分解小 就可以分析它们

721
00:55:20,790 --> 00:55:24,170
让我们分析下这个指示器随机变量

722
00:55:24,170 --> 00:55:30,530
xk 的期望值是什么

723
00:55:41,030 --> 00:55:46,570
换句话说 生成一次k:(n-k-1)分划的概率是多少

724
00:55:57,810 --> 00:56:05,470
我们写一下 什么表示期望

725
00:56:05,470 --> 00:56:07,230
来让你们回忆一下

726
00:56:07,230 --> 00:56:12,930
0乘以xk为0的概率

727
00:56:13,280 --> 00:56:20,300
加上1乘以xk为1的概率

728
00:56:21,990 --> 00:56:25,850
这些都是0

729
00:56:26,300 --> 00:56:30,660
所得的结果就是xk为1的概率

730
00:56:30,660 --> 00:56:35,390
这也是指示器随机变量一个很好的性质

731
00:56:36,120 --> 00:56:39,920
就是它们的期望等于它们为1的概率

732
00:56:40,130 --> 00:56:43,820
指示器随机变量的优点在于

733
00:56:43,820 --> 00:56:46,560
它将概率直接地联系到了期望

734
00:56:46,560 --> 00:56:50,380
而没有产生其它项

735
00:56:50,380 --> 00:56:53,490
xk为1的概率是多少

736
00:56:55,270 --> 00:56:59,150
1/n

737
00:57:02,110 --> 00:57:05,110
因为所有分划都是相同概率额

738
00:57:06,080 --> 00:57:08,390
我有n个数

739
00:57:08,390 --> 00:57:12,910
所以每个数有1/n的几率被选为主元

740
00:57:12,910 --> 00:57:14,850
一旦你选了一个主元

741
00:57:15,040 --> 00:57:18,370
就已经决定了哪些数在左边 哪些在右边

742
00:57:18,550 --> 00:57:20,240
所以概率是1/n

743
00:57:20,830 --> 00:57:22,980
跟得上吗

744
00:57:23,950 --> 00:57:25,500
或多或少跟得上吗

745
00:57:25,500 --> 00:57:28,860
这是一个测试你们有没有走神的方式

746
00:57:29,030 --> 00:57:33,380
如果你回家看书还是搞不明白

747
00:57:33,380 --> 00:57:36,890
那表示你在这门课学习的数学基础有点问题

748
00:57:37,190 --> 00:57:40,920
这很好地表示了这个问题

749
00:57:40,920 --> 00:57:46,690
很可能你选了一些太难的内容

750
00:57:48,090 --> 00:57:52,680
我们写一下T(n)等于什么

751
00:57:58,860 --> 00:58:13,210
如果是0:(n-1)分划 T(n)=T(0)+T(n-1)+Θ(n)

752
00:58:16,210 --> 00:58:29,500
而如果是1:(n-2)分划 T(n)=T(1)+T(n-2)+Θ(n)

753
00:58:34,970 --> 00:58:44,470
到这里就成为 T(n-1)+T(0)+Θ(n)

754
00:58:44,470 --> 00:58:49,810
如果是(n-1):0分划即是如此

755
00:58:53,900 --> 00:58:58,700
所以这就是关于T(n)的递归

756
00:58:58,700 --> 00:59:01,820
但是 这个递归有点麻烦

757
00:59:01,820 --> 00:59:04,130
因为它有n种情况

758
00:59:04,130 --> 00:59:06,390
所以马上我们就可以看到

759
00:59:06,390 --> 00:59:09,510
指示器随机变量的优美性了

760
00:59:09,620 --> 00:59:12,620
因为我们有能力对这些情况进行分析

761
00:59:12,790 --> 00:59:15,390
并且将它规约到数学上

762
00:59:15,820 --> 00:59:21,070
这样使用指示器随机变量时 就不用考虑这么多情况了

763
00:59:23,130 --> 00:59:32,340
怎么做呢 就是下面的小技巧

764
00:59:34,510 --> 00:59:37,900
将这么多种情况放到一个累加式里面

765
00:59:53,020 --> 00:59:58,270
我们看看为什么这两种东西很像

766
01:00:00,670 --> 01:00:03,390
指示器随机变量一直是0

767
01:00:03,390 --> 01:00:08,380
除非你们获得了一个特定的分划

768
01:00:08,880 --> 01:00:11,620
所以 累加式会一直成为0

769
01:00:11,620 --> 01:00:14,380
除非这种k分划出现了

770
01:00:14,650 --> 01:00:17,910
这样情况下就有了我们说的这个值

771
01:00:18,940 --> 01:00:21,990
明白了这种

772
01:00:21,990 --> 01:00:26,880
通过相乘0, 1变量处理所有情况的小技巧了吗

773
01:00:27,520 --> 01:00:29,720
我觉得真聪明

774
01:00:29,720 --> 01:00:32,330
我觉得很聪明

775
01:00:32,980 --> 01:00:35,130
这就是一种经典的方式

776
01:00:35,130 --> 01:00:37,100
来使用指示器随机变量

777
01:00:37,100 --> 01:00:41,820
这也是它们很有用的原因之一

778
01:00:41,820 --> 01:00:45,280
因为我们现在用了一个数学表达式

779
01:00:45,280 --> 01:00:50,330
虽然对于递归来说还是很乱

780
01:00:52,840 --> 01:00:56,860
现在 我们就来讨论下 T(n)的期望

781
01:00:57,720 --> 01:00:59,560
这就是我们想做的事情

782
01:00:59,910 --> 01:01:02,820
T(n)的期望值是多少

783
01:01:03,570 --> 01:01:07,770
为了计算它 我需要写出T(n)的期望

784
01:01:08,400 --> 01:01:14,500
它等于接下来这个巨大累加式的期望

785
01:01:17,970 --> 01:01:20,340
现在我们就可以开始

786
01:01:20,340 --> 01:01:23,370
计算这个累加式的值了

787
01:01:27,190 --> 01:01:28,890
都跟上了吗

788
01:01:30,110 --> 01:01:32,480
有没有什么问题

789
01:01:32,480 --> 01:01:34,470
我看到有人竖起了大拇指 不错

790
01:01:34,630 --> 01:01:36,370
但是我认为

791
01:01:36,370 --> 01:01:39,680
我真正想看到的是没有人不懂

792
01:01:41,510 --> 01:01:44,110
能看到竖起大拇指虽然很好

793
01:01:44,110 --> 01:01:46,970
但是那只表示有一个人理解

794
01:01:46,970 --> 01:01:48,920
或者认为他理解了

795
01:01:51,090 --> 01:01:54,220
所以 这个式子等于以下这些

796
01:01:54,220 --> 01:01:56,400
我需要一点空间

797
01:01:56,400 --> 01:01:59,660
我会把等号移动一下

798
01:02:24,420 --> 01:02:27,130
使这个累加式等于它

799
01:02:27,130 --> 01:02:31,250
这个期望等于期望的和

800
01:02:33,340 --> 01:02:35,230
为什么

801
01:02:37,180 --> 01:02:40,360
是什么性质使这一步成立

802
01:02:41,570 --> 01:02:43,970
期望的线性叠加性

803
01:02:45,780 --> 01:02:49,600
期望的和等于和的期望

804
01:02:50,080 --> 01:02:51,770
这就是期望的线性

805
01:02:51,770 --> 01:02:53,710
并不需要独立性

806
01:02:53,810 --> 01:02:58,710
这条性质对于任何随机变量来说 都是对的

807
01:03:00,010 --> 01:03:04,100
期望的和等于和的期望 反之亦然

808
01:03:05,600 --> 01:03:07,540
这里我们就是把该性质反过来用的

809
01:03:07,540 --> 01:03:19,000
现在它就等于让k=0到n-1求和xk的期望

810
01:03:19,000 --> 01:03:33,900
乘以这个期望

811
01:03:34,080 --> 01:03:36,360
为什么这个正确

812
01:03:39,470 --> 01:03:42,720
我刚刚做的表示积的期望

813
01:03:42,720 --> 01:03:46,560
等于期望的积

814
01:03:51,770 --> 01:03:53,280
就是因为它的独立性

815
01:03:53,280 --> 01:03:55,210
什么独立于什么

816
01:03:58,820 --> 01:04:04,240
xk 随机变量

817
01:04:04,240 --> 01:04:09,590
独立于任何其它的分划

818
01:04:09,590 --> 01:04:15,020
也就是说 xk区别于其它递归调用

819
01:04:16,480 --> 01:04:20,960
所以 这里发生的一切 都独立于递归后的一切

820
01:04:21,370 --> 01:04:24,320
我们实际上正在对另一个递归调用

821
01:04:24,320 --> 01:04:27,260
进行另一次分划

822
01:04:27,260 --> 01:04:28,280
两次分划之前是不同的

823
01:04:28,280 --> 01:04:30,910
我们正在关注原理的数学

824
01:04:30,910 --> 01:04:33,810
必须注意的是 这个数学

825
01:04:33,810 --> 01:04:38,480
其实不难 那个T(n)事实上

826
01:04:38,480 --> 01:04:43,700
是一系列已经被决定的随机选择

827
01:04:44,530 --> 01:04:47,470
所以你需要明白这些是相独立的

828
01:04:47,470 --> 01:04:51,430
所以我们才能将它们的期望相乘

829
01:04:51,430 --> 01:04:53,330
大家跟上了吗

830
01:04:53,740 --> 01:04:58,620
这个很重要 使xk与其它随机选择独立

831
01:04:58,620 --> 01:05:06,920
现在等于这样了 很漂亮

832
01:05:07,480 --> 01:05:10,160
xk的期望是什么

833
01:05:10,770 --> 01:05:12,710
1/n

834
01:05:12,710 --> 01:05:15,000
事实上它并不属于这个累加式

835
01:05:15,000 --> 01:05:16,750
我们可以将它提出来

836
01:05:16,960 --> 01:05:31,440
我有了1/n乘以从k=0到n-1的T(k)期望之和

837
01:05:31,440 --> 01:05:45,130
1/n乘以从k=0到n-1的T(n-k-1)期望之和

838
01:05:46,000 --> 01:05:55,920
还有将k=0一直到n-1的Θ(n)之和

839
01:05:56,690 --> 01:06:01,730
这里又一次用到了期望的线性性质

840
01:06:01,730 --> 01:06:05,570
把这些项拆开

841
01:06:06,220 --> 01:06:12,650
提出xk的期望值1/n

842
01:06:14,650 --> 01:06:16,410
大家还能听懂吗

843
01:06:20,420 --> 01:06:22,000
所有的这些都是比较基础的

844
01:06:22,000 --> 01:06:23,920
唯一比较困难的就是

845
01:06:23,920 --> 01:06:26,020
推导步骤很长

846
01:06:27,280 --> 01:06:31,130
你们以前应该见过这类问题

847
01:06:31,930 --> 01:06:33,810
另一个显而易见的发现是

848
01:06:33,810 --> 01:06:37,200
这两个和显然是一样的

849
01:06:38,100 --> 01:06:41,020
它们其实是同一个和 只是顺序不同

850
01:06:41,020 --> 01:06:48,730
这个式子从 T₀开始 一直加到Tn-1

851
01:06:48,730 --> 01:06:56,800
这个是从 Tn-1加到T₀

852
01:06:58,420 --> 01:07:01,220
它们实际上是相等的

853
01:07:01,920 --> 01:07:03,760
所以 现在是它们的2倍

854
01:07:17,720 --> 01:07:20,510
那么这部分又等于多少呢

855
01:07:35,900 --> 01:07:37,730
这一项等于什么

856
01:07:40,890 --> 01:07:42,650
Θ(n)

857
01:07:42,650 --> 01:07:45,420
看看这是为什么

858
01:07:45,730 --> 01:07:54,170
Θ(n)从0到n求和 得到的是Θ(n²)/n

859
01:07:54,170 --> 01:07:56,900
或者把Θ(n)提出来 就是

860
01:07:56,900 --> 01:08:01,550
1/n乘以n个Θ(n)的和 就是1个Θ(n)

861
01:08:01,550 --> 01:08:06,030
所以你得到了Θ(n) 不管用了哪种方法

862
01:08:09,650 --> 01:08:14,560
这就是 因为这些和

863
01:08:14,560 --> 01:08:18,040
有一样的项 这只是代数知识

864
01:08:19,410 --> 01:08:23,690
现在我们要做一些使它更简的事

865
01:08:23,690 --> 01:08:30,250
我们要把k=0,1时的项吸收到

866
01:08:32,460 --> 01:08:40,140
Θ(n)中 为了使它更简洁

867
01:08:43,720 --> 01:08:47,420
我们这里有一个规模是n的递归式

868
01:08:48,940 --> 01:08:52,680
假如我们观察 k=0 或 k=1 的情况

869
01:08:52,680 --> 01:08:55,250
我们就知道它的期望值是多少

870
01:08:55,250 --> 01:09:01,770
对于0或1 期望代价就是最坏情况代价 是一个常数

871
01:09:01,770 --> 01:09:09,290
因为我们解决的是一个固定规模的问题

872
01:09:09,290 --> 01:09:14,210
我们知道对于任何边界情况

873
01:09:14,210 --> 01:09:17,140
我们假定递归式的解是一个常数

874
01:09:17,140 --> 01:09:20,510
所以 我就可以将这两项分离出来

875
01:09:20,510 --> 01:09:25,180
这只是让Θ(n)中的常数更大了些

876
01:09:25,180 --> 01:09:28,250
这将使求解这个递归式稍微简单一点

877
01:09:28,980 --> 01:09:31,530
假如这样 期望值就变成了

878
01:09:31,530 --> 01:09:49,490
2/n乘以k从2到n-1的T(k)之和加上Θ(n) 

879
01:09:57,820 --> 01:10:03,400
所有的这些是为了推导出递归式

880
01:10:04,990 --> 01:10:07,210
现在我们要求解它

881
01:10:11,280 --> 01:10:13,890
先回顾一下我们都做了什么

882
01:10:16,420 --> 01:10:20,990
我们从一个递归式开始

883
01:10:21,560 --> 01:10:27,700
它是关于选择语句中的随机变量的

884
01:10:27,700 --> 01:10:31,620
我们把这些转换成数学语言

885
01:10:32,000 --> 01:10:34,680
除去这个条件语句 换成一个积的形式

886
01:10:34,680 --> 01:10:40,130
然后我们推导出了期望运行时间的一个递归式

887
01:10:41,050 --> 01:10:44,130
现在我们要尝试求解这个递归式

888
01:10:44,130 --> 01:10:47,130
我们已经做了一些递归式的化简工作

889
01:10:47,130 --> 01:10:50,680
我们要清楚我们要做什么

890
01:10:53,090 --> 01:10:56,250
顺便说 我不会在测验中给出这样的问题的

891
01:10:56,560 --> 01:10:58,240
我想让你们了解这一点

892
01:10:58,240 --> 01:11:00,860
也就是这其中的一部分会出现在测验中

893
01:11:01,070 --> 01:11:04,160
这其中有许多要解决的问题

894
01:11:04,160 --> 01:11:06,130
留给聪明人来做吧

895
01:11:06,530 --> 01:11:09,030
虽然这些都是基础

896
01:11:09,030 --> 01:11:11,650
但是算出这些基础的东西

897
01:11:11,650 --> 01:11:15,430
仍然是艰苦的工作

898
01:11:15,430 --> 01:11:18,030
即使是对于这方面的专家来说

899
01:11:18,650 --> 01:11:22,550
现在我们要求解那最后一个递归式

900
01:11:22,690 --> 01:11:30,800
我们要证明T(n)的运行时间期望值

901
01:11:31,500 --> 01:11:43,660
小于或等于anlgn 其中a是>0的常数

902
01:11:46,020 --> 01:11:47,680
这就是我们要解决的问题

903
01:11:47,680 --> 01:11:52,600
那么在你看来 我们应该用什么方法来证明呢

904
01:11:53,840 --> 01:11:56,910
看起来像是主方法吗

905
01:12:01,520 --> 01:12:03,710
显然一点也不一样

906
01:12:04,060 --> 01:12:09,030
所以存疑时采用代换法

907
01:12:10,010 --> 01:12:14,030
它是万法之宗

908
01:12:14,460 --> 01:12:17,310
我们要做的就是证明基础情况

909
01:12:17,310 --> 01:12:20,700
仅仅通过选择一个足够大的a

910
01:12:25,160 --> 01:12:36,000
使anlgn大于T(n)的期望值

911
01:12:39,770 --> 01:12:42,980
对于足够大的较小的n

912
01:12:45,920 --> 01:12:49,410
所以只是要选取一个足够大的a

913
01:12:49,410 --> 01:12:51,210
同时 这也就是为什么

914
01:12:51,210 --> 01:12:56,180
我要把0和1从递归式中除去

915
01:12:56,830 --> 01:13:06,470
比如当n=0时0的对数是

916
01:13:10,200 --> 01:13:12,690
就像是0做除数 没有定义

917
01:13:12,690 --> 01:13:18,160
1的对数是0 所以即使把它限制到1

918
01:13:18,430 --> 01:13:21,130
这里就可能为0所以在这些情况中

919
01:13:21,130 --> 01:13:24,310
选不出一个足够大的a使它比E[T(n)]大

920
01:13:24,310 --> 01:13:28,050
所以我在前面就说

921
01:13:28,050 --> 01:13:31,510
我们把那两种情况并入Θ(n)中 为了使它更简便

922
01:13:31,510 --> 01:13:34,080
这让我可以说

923
01:13:34,080 --> 01:13:38,040
能够选取一个足够大的anlgn处理掉基础情况

924
01:13:38,310 --> 01:13:41,040
这就是为什么我们做出那样的假设

925
01:13:42,360 --> 01:13:45,470
我们将要用到一个事实

926
01:13:49,890 --> 01:13:57,820
klgk从2到n-1求和

927
01:13:57,820 --> 01:14:07,620
小于等于(1/2)n²lgn-(1/8)n²

928
01:14:08,510 --> 01:14:11,370
我想把这留作一个练习让你来完成

929
01:14:11,370 --> 01:14:13,320
我想这也是课本里的一个练习题

930
01:14:15,430 --> 01:14:20,000
我想要你做出这个

931
01:14:20,000 --> 01:14:21,640
有两种方法

932
01:14:21,640 --> 01:14:26,110
一种是仅利用和的性质

933
01:14:26,110 --> 01:14:28,690
把和拆成两部分

934
01:14:28,690 --> 01:14:31,700
然后再重新组合来证明这个上界

935
01:14:31,700 --> 01:14:36,700
另一个是利用求和的积分方法

936
01:14:37,070 --> 01:14:39,620
都可以证明

937
01:14:39,620 --> 01:14:42,440
积分方法实际上提供了一个更紧的上界

938
01:14:43,250 --> 01:14:48,300
这是基本事实 你应该去了解

939
01:14:48,300 --> 01:14:49,990
知道它是怎么算出来的

940
01:14:51,020 --> 01:14:53,540
现在我们来做代换

941
01:15:04,670 --> 01:15:12,230
T(n)的期望值小于等于

942
01:15:12,230 --> 01:15:24,400
2/n k从2到n-1求和 现在我们做替换

943
01:15:24,400 --> 01:15:35,500
换成aklgk 小一些的值 加上Θ(n) 

944
01:15:37,030 --> 01:15:39,730
我要提到这里的困难部分

945
01:15:39,730 --> 01:15:42,710
求出没有这一项的上界是容易的

946
01:15:44,480 --> 01:15:48,660
即(1/2)n²lgn

947
01:15:49,230 --> 01:15:51,620
得到第二项稍微困难些

948
01:15:51,770 --> 01:15:53,810
显然你需要这第二项

949
01:15:53,810 --> 01:15:56,290
来解决我们这里的问题

950
01:15:57,050 --> 01:15:59,990
你需要分离出一个二次式

951
01:15:59,990 --> 01:16:04,430
从n²lgn中来 进行这个证明

952
01:16:04,430 --> 01:16:09,080
这是求这个和比较棘手的部分

953
01:16:09,960 --> 01:16:11,760
所以我们得到了这个

954
01:16:11,980 --> 01:16:14,260
这个式子小于等于

955
01:16:14,260 --> 01:16:18,220
我碰巧从那个公式中知道了这一项等于什么

956
01:16:18,220 --> 01:16:32,300
应用此事实 得到2a/n(1/2nlgn-1/8n²)+Θ(n)

957
01:16:34,000 --> 01:16:37,700
我哪里做错了吗

958
01:16:39,490 --> 01:16:48,050
这里

959
01:16:48,390 --> 01:16:49,430
很好

960
01:16:54,590 --> 01:16:57,150
这个就等于

961
01:17:00,320 --> 01:17:07,460
把第一项乘进去就得到了一个anlgn

962
01:17:14,280 --> 01:17:16,630
现在 我没有犯错误

963
01:17:16,630 --> 01:17:25,160
这一项是我们想要的

964
01:17:25,160 --> 01:17:31,100
这是我们想要的形式 减去剩余的项

965
01:17:33,390 --> 01:17:39,030
我要把剩余的写成这一部分

966
01:17:39,030 --> 01:17:42,990
因此我们要这样写 这里是一个减号

967
01:17:43,150 --> 01:17:47,080
这一项应该在这里

968
01:17:47,080 --> 01:17:58,410
它将是a(n/4)-Θ(n)

969
01:18:04,970 --> 01:18:08,160
这个式子将不大于

970
01:18:08,710 --> 01:18:16,810
anlgn 如果这一部分是正的

971
01:18:18,260 --> 01:18:22,360
我可以选取一个足够大的n来使它为正

972
01:18:22,690 --> 01:18:27,090
使an/4大于Θ(n)里面的常数

973
01:18:27,090 --> 01:18:28,750
不论这里的常数是多少

974
01:18:28,750 --> 01:18:30,900
我都可以找到一个足够大的a

975
01:18:32,820 --> 01:18:36,440
使这一部分为正

976
01:18:36,790 --> 01:18:55,800
如果a足够大 使得an/4>Θ(n)

977
01:18:57,170 --> 01:19:02,490
所以随机化快速排序的时间复杂度的阶是 nlgn

978
01:19:02,920 --> 01:19:04,060
这就是我们刚刚证明的

979
01:19:04,060 --> 01:19:07,450
期望运行时间的阶就是 nlgn

980
01:19:08,130 --> 01:19:11,730
现在 在实践中快速排序是一个很好的算法

981
01:19:12,080 --> 01:19:19,810
它通常比归并排序快三倍以上

982
01:19:21,000 --> 01:19:24,320
它不能保证归并排序所能提供的

983
01:19:24,320 --> 01:19:26,610
最坏情况下 nlgn的运行时间

984
01:19:26,610 --> 01:19:30,710
但是在实践中 如果应用随机化快排

985
01:19:30,710 --> 01:19:34,440
总体上来说它会快出三倍以上

986
01:19:34,600 --> 01:19:38,370
确实需要一些编码技巧来使它达到那样的速度

987
01:19:38,500 --> 01:19:42,280
你确实需要优化基础情况

988
01:19:42,470 --> 01:19:48,810
以及其他的一些技巧 其实大部分好的排序算法

989
01:19:48,810 --> 01:19:53,660
都是基于快速排序的

990
01:19:53,660 --> 01:19:55,850
它很好 另外一个原因就是

991
01:19:55,850 --> 01:19:59,420
它在虚拟内存的缓存中性能比较好

992
01:19:59,420 --> 01:20:02,440
我们不想过多地谈论关于缓存模型的内容

993
01:20:02,780 --> 01:20:07,210
这是现今算法领域很大的课题

994
01:20:07,210 --> 01:20:09,290
但它确实在虚拟内存的缓存中性能很好

995
01:20:09,320 --> 01:20:13,350
这就是它是一个好算法的另一个理由

996
01:20:17,500 --> 01:20:20,160
顺便说下 星期五的习题课

997
01:20:20,160 --> 01:20:24,520
我们将要看另一个nlgn的算法

998
01:20:24,520 --> 01:20:28,230
一个非常重要的算法

