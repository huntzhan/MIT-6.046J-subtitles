1
00:00:08,350 --> 00:00:09,940
早上好

2
00:00:12,960 --> 00:00:17,860
正如我上周提到过的 今天我们要讲的是...

3
00:00:18,810 --> 00:00:21,090
我们最近这一部分课程的内容

4
00:00:22,030 --> 00:00:26,170
将涉及到更多设计上的内容 而不是纯粹的分析

5
00:00:26,330 --> 00:00:27,920
虽然 今天我们还要做分析

6
00:00:28,000 --> 00:00:29,660
但这种分析

7
00:00:29,850 --> 00:00:33,310
会涉及到非常有趣的设计内容

8
00:00:33,460 --> 00:00:36,490
接下来 在周三的课上

9
00:00:36,620 --> 00:00:40,160
我们会运用到今天将要学到的一种方法

10
00:00:41,070 --> 00:00:45,380
来解决一个相当有趣而且实际的问题

11
00:00:45,400 --> 00:00:49,070
那么 今天要讲的是平摊分析

12
00:00:59,360 --> 00:01:04,910
我打算通过提问来引出主题

13
00:01:05,360 --> 00:01:12,730
一个哈希表多大才合适？

14
00:01:20,740 --> 00:01:24,480
一个哈希表多大才合适？有什么建议？

15
00:01:25,340 --> 00:01:27,850
如果要建立一个哈希表 应该设定为多大？

16
00:01:28,810 --> 00:01:30,630
假设要建立一个简单哈希表

17
00:01:30,940 --> 00:01:33,190
用链接法来解决冲突

18
00:01:34,810 --> 00:01:35,830
它要多大才合适？

19
00:01:40,700 --> 00:01:42,160
[学生]：...

20
00:01:43,130 --> 00:01:44,170
[教授]：两倍你所需要大小

21
00:01:44,290 --> 00:01:45,900
那是多大？

22
00:01:46,260 --> 00:01:48,950
[学生]：...

23
00:01:49,350 --> 00:01:51,490
[教授]：举个例子 要元素数量的两倍大

24
00:01:52,240 --> 00:01:56,310
那么 当我增大哈希表时

25
00:01:58,010 --> 00:02:00,890
搜索时间会发生什么变化？

26
00:02:08,080 --> 00:02:10,150
当我增加哈希表的大小时

27
00:02:10,150 --> 00:02:13,750
搜索时间会怎么变化？

28
00:02:14,820 --> 00:02:17,070
对 但通常会怎么变化

29
00:02:17,320 --> 00:02:19,020
会减小 是吧？

30
00:02:19,260 --> 00:02:21,210
哈希表越大...

31
00:02:21,250 --> 00:02:23,430
实际上 如果设为足够大

32
00:02:24,360 --> 00:02:26,750
那就会得到一个直接映射表

33
00:02:26,760 --> 00:02:29,190
在最坏情况下 时间为 O（1）

34
00:02:29,550 --> 00:02:31,460
所以在某种程度上

35
00:02:32,530 --> 00:02:34,310
等下再说说你的答案

36
00:02:36,330 --> 00:02:38,090
我们应该让它越大越好

37
00:02:43,810 --> 00:02:45,650
这样搜索时间就会很少

38
00:02:47,390 --> 00:02:50,290
这样做的缺陷是什么？

39
00:02:52,310 --> 00:02:53,410
这样需要很大的空间

40
00:02:53,420 --> 00:02:55,490
所以哈希表又应该尽可能地小

41
00:03:03,660 --> 00:03:05,640
这样才不至于浪费太多空间

42
00:03:07,220 --> 00:03:09,470
但我又希望它能大一点

43
00:03:09,780 --> 00:03:13,370
正如在分析中讨论过的那样

44
00:03:13,520 --> 00:03:18,830
对于n个项 最好的折中值的是θ(n)

45
00:03:20,450 --> 00:03:32,430
因为如果哈希表的体积超过θ(n)

46
00:03:32,730 --> 00:03:44,440
就不值得为了减少那点搜索时间

47
00:03:44,590 --> 00:03:46,800
去增加额外的空间了

48
00:03:47,140 --> 00:03:49,890
或者至少你能这样理解

49
00:03:50,780 --> 00:03:54,860
然而 还有个问题 那就是如何建立哈希表

50
00:03:55,380 --> 00:04:03,340
如果创建哈希表时 我并不知道...

51
00:04:03,350 --> 00:04:05,860
有多少个元素将要加进来

52
00:04:07,540 --> 00:04:10,450
那哈希表的大小应该设为多少？

53
00:04:14,410 --> 00:04:33,360
如果在不知道n的前提下

54
00:04:33,430 --> 00:04:36,410
如果n是未知的话？

55
00:04:38,550 --> 00:04:44,130
这个问题的解法是这样的

56
00:04:45,170 --> 00:04:49,240
这个策略很优美 它叫做动态表

57
00:04:55,430 --> 00:04:59,060
它的思想是

58
00:04:59,440 --> 00:05:05,400
当哈希表里映射进了太多元素时

59
00:05:06,160 --> 00:05:07,360
被挤爆了

60
00:05:08,580 --> 00:05:12,890
解决方法是

61
00:05:25,180 --> 00:05:28,380
我们称这个表“溢出”了

62
00:05:30,150 --> 00:05:36,870
那么就增大它 把表弄得更大

63
00:05:37,780 --> 00:05:41,740
对于哈希 尽管没有证据表明...

64
00:05:41,750 --> 00:05:45,770
我们并不能断定

65
00:05:46,700 --> 00:05:49,220
哈希表的溢出会导致它失效

66
00:05:49,370 --> 00:05:50,950
至少用链接法时 它不会失效

67
00:05:51,020 --> 00:05:52,130
但也是有这种可能

68
00:05:52,360 --> 00:05:55,430
如果你用的是公开寻址法的话

69
00:05:56,050 --> 00:05:59,930
在使用链接法的情况下 当元素变得太多时

70
00:06:00,380 --> 00:06:05,460
例如 当元素数量等于表的大小时

71
00:06:06,110 --> 00:06:08,110
我们就要增大表的大小

72
00:06:09,070 --> 00:06:12,150
要分配一个更大的表

73
00:06:15,100 --> 00:06:19,350
例如在C语言中 我们用malloc()

74
00:06:19,490 --> 00:06:26,360
或者在Java中 用new来建更大的表

75
00:06:29,120 --> 00:06:30,630
这样 新建一个更大的表

76
00:06:31,260 --> 00:06:43,730
将项从旧的表移到新的表

77
00:06:45,400 --> 00:06:49,870
然后释放旧表的空间

78
00:06:53,180 --> 00:06:54,570
举一个例子

79
00:06:59,900 --> 00:07:07,520
假设在这里有一个大小为1的表

80
00:07:09,100 --> 00:07:11,220
一开始它是空的

81
00:07:12,490 --> 00:07:13,780
我做一个插入操作

82
00:07:15,800 --> 00:07:19,440
把元素放进表里 刚好满了

83
00:07:20,070 --> 00:07:21,870
这里不做具体的哈希过程

84
00:07:21,920 --> 00:07:23,980
直接放进去 就像是我有一个表

85
00:07:24,290 --> 00:07:27,280
然后我把它装满了 把问题抽象化

86
00:07:27,510 --> 00:07:28,600
当然用哈希也行

87
00:07:28,620 --> 00:07:32,900
对于任意固定大小的数据结构而言 都是可行的

88
00:07:33,800 --> 00:07:37,200
我再进行插入 噢 这下不行

89
00:07:37,790 --> 00:07:39,390
它溢出了

90
00:07:41,290 --> 00:07:46,400
这时要新建一个表

91
00:07:46,480 --> 00:07:48,430
实际上 我要画得再紧凑点

92
00:07:52,560 --> 00:07:59,350
我新建一个大小为2的表 两倍于原来的大小

93
00:08:00,170 --> 00:08:03,560
然后将旧的值复制到新表中

94
00:08:04,120 --> 00:08:07,090
再释放旧表的空间 现在我能插入第二项了

95
00:08:12,630 --> 00:08:15,500
再进行插入 又得到一个溢出

96
00:08:19,210 --> 00:08:22,530
现在我新建一个大小为4的表

97
00:08:24,370 --> 00:08:29,310
将这些项复制进去 然后插入第三个数

98
00:08:32,710 --> 00:08:38,980
继续插入到这里 然后是第五项

99
00:08:40,270 --> 00:08:42,380
这里写个“同上”算了

100
00:08:42,400 --> 00:08:43,710
这样会方便很多

101
00:08:43,990 --> 00:08:46,910
噢 我做了什么 又溢出了

102
00:08:51,140 --> 00:08:52,790
再建造一个表大小为8

103
00:09:00,100 --> 00:09:07,580
把这些复制过去 然后就能插入第五项了

104
00:09:08,870 --> 00:09:15,640
同样地 插入第六项 第七项等等

105
00:09:17,450 --> 00:09:20,440
大家都理解了这个基本思路了吗？

106
00:09:20,590 --> 00:09:21,640
一旦发生溢出

107
00:09:22,110 --> 00:09:24,160
新建一个两倍于原大小的表

108
00:09:26,310 --> 00:09:30,100
对这个方法做一个快速的分析

109
00:09:34,100 --> 00:09:41,270
有一个序列 包括n个插入运算

110
00:09:43,070 --> 00:09:54,000
在最坏情况下 一次插入运算的代价是多少？

111
00:09:55,720 --> 00:09:58,970
对于任意项 它的最坏情况是什么？

112
00:10:00,230 --> 00:10:06,170
没错 是θ(n) 无论复制的开销是多少

113
00:10:06,570 --> 00:10:07,740
如果一步复制算为1

114
00:10:08,180 --> 00:10:09,980
这些复制操作的时间是n或者是n+1

115
00:10:10,420 --> 00:10:11,950
因为要把所有项复制过来

116
00:10:11,990 --> 00:10:13,960
所以是θ(n)

117
00:10:16,070 --> 00:10:19,510
因此 如果有n个项

118
00:10:19,960 --> 00:10:25,980
最坏情况下 n个插入运算的代价

119
00:10:27,720 --> 00:10:31,170
为n·θ(n)

120
00:10:32,100 --> 00:10:33,890
也就是θ(n^2)

121
00:10:42,980 --> 00:10:44,190
有什么问题吗？

122
00:10:51,580 --> 00:10:54,200
带感不？

123
00:10:56,560 --> 00:10:57,390
举手示意一下

124
00:11:06,860 --> 00:11:12,480
[学生]：...

125
00:11:13,160 --> 00:11:16,260
[教授]：不是所有的项都是最坏情况 非常好

126
00:11:16,980 --> 00:11:19,510
实际上 这是完全错误的分析

127
00:11:21,280 --> 00:11:23,780
因为一个项在最坏情况下是θ(n)

128
00:11:24,180 --> 00:11:25,880
并不代表n个项都是θ(n)

129
00:11:26,990 --> 00:11:28,390
所以这是个完全错误的分析

130
00:11:28,790 --> 00:11:37,140
实际上在最坏情况下 n个插入花费θ(n)的时间

131
00:11:42,470 --> 00:11:44,910
不是θ(n^2)

132
00:11:45,410 --> 00:11:47,300
这个分析到这一步还是正确的

133
00:11:47,630 --> 00:11:49,840
设最坏情况下 一次插入的时间为θ(n)

134
00:11:50,640 --> 00:11:53,570
所以 出错的是这一步

135
00:11:54,680 --> 00:11:56,430
当你发现证明有错误时

136
00:11:56,790 --> 00:11:58,330
你要知道是在哪一步出错的

137
00:11:58,390 --> 00:12:01,250
这样人家才..才不会...

138
00:12:05,270 --> 00:12:07,210
才不会感到困惑呢

139
00:12:07,790 --> 00:12:10,690
那么 我们做一次正确的分析

140
00:12:11,170 --> 00:12:22,510
设c_i为第i个插入的代价

141
00:12:25,770 --> 00:12:29,210
那么 c_i将等于i

142
00:12:31,100 --> 00:12:38,350
当 i-1 为2的幂时

143
00:12:40,940 --> 00:12:43,610
否则c_i等于1

144
00:12:46,360 --> 00:12:48,160
正如这里讲的一样

145
00:12:49,330 --> 00:12:52,460
只有当插入之前

146
00:12:52,820 --> 00:12:57,040
已经刚好有2的幂个元素

147
00:12:57,370 --> 00:12:58,560
因为这是表的大小

148
00:12:59,010 --> 00:13:00,590
所以我遇到溢出

149
00:13:01,180 --> 00:13:03,020
必须全部进行复制

150
00:13:03,990 --> 00:13:05,800
其余情况下的代价是

151
00:13:06,210 --> 00:13:07,540
比如插入第六项的代价为1

152
00:13:07,690 --> 00:13:08,860
只需插入运算

153
00:13:10,960 --> 00:13:13,210
大家都理解吗？

154
00:13:13,570 --> 00:13:15,240
在这里画一个小列表

155
00:13:16,710 --> 00:13:18,720
这样我们能看得更明白

156
00:13:21,770 --> 00:13:23,650
这里是i

157
00:13:24,740 --> 00:13:27,380
第i步时表的大小

158
00:13:28,170 --> 00:13:29,380
这是第i步的代价

159
00:13:40,460 --> 00:13:43,420
这是第i步表的大小

160
00:13:44,470 --> 00:13:46,570
第1步时表的大小是1

161
00:13:47,660 --> 00:13:48,870
第2步是2

162
00:13:50,890 --> 00:13:52,230
在第3步

163
00:13:52,610 --> 00:13:54,440
当要在表里插入第3项时

164
00:13:56,270 --> 00:14:00,770
必须先将表的大小翻倍

165
00:14:01,030 --> 00:14:03,840
所以这里是4 接下来是第4项 没问题

166
00:14:04,420 --> 00:14:06,010
然后是第5项 表必须增大到8

167
00:14:07,580 --> 00:14:08,700
然后是第6项 大小仍是8

168
00:14:08,810 --> 00:14:10,840
第7项是8 第8项是8

169
00:14:11,020 --> 00:14:14,770
第9项 增加到16 以此类推

170
00:14:16,950 --> 00:14:17,770
这些是表的大小

171
00:14:18,070 --> 00:14:19,740
看一下时间代价是多少

172
00:14:20,560 --> 00:14:22,540
这里代价为1

173
00:14:23,880 --> 00:14:24,850
插入第1项

174
00:14:25,320 --> 00:14:29,890
这里的代价是 要复制1个项

175
00:14:30,020 --> 00:14:31,780
然后再插入1项

176
00:14:31,810 --> 00:14:33,170
所以代价是2

177
00:14:33,720 --> 00:14:36,680
这里 要复制2项再插入1项

178
00:14:37,310 --> 00:14:38,600
所以代价是3

179
00:14:38,950 --> 00:14:40,880
这里只需要插入1项

180
00:14:41,270 --> 00:14:42,490
所以代价是1

181
00:14:43,270 --> 00:14:46,040
这里要复制4项再插入1项

182
00:14:46,060 --> 00:14:47,380
所以代价是5

183
00:14:47,820 --> 00:14:49,680
[学生]：...

184
00:14:49,920 --> 00:14:51,840
[教授]：再说一遍？应该没错

185
00:14:51,990 --> 00:14:54,090
[学生]：...

186
00:14:54,660 --> 00:14:56,040
没错 看 这是i

187
00:14:56,460 --> 00:14:58,080
第5项的代价是i

188
00:14:58,920 --> 00:15:02,410
也就是5 如果之前的大小刚好为2的幂

189
00:15:02,730 --> 00:15:11,130
这些都是1 这一项代价为9 最后又是1

190
00:15:12,440 --> 00:15:13,620
这些是付出的时间代价

191
00:15:14,130 --> 00:15:15,530
这样具体到每一步

192
00:15:15,560 --> 00:15:17,820
时间代价看起来 更加清晰易懂

193
00:15:18,090 --> 00:15:21,010
好 把c_i分成两部分来表示

194
00:15:21,490 --> 00:15:23,160
因为这里总有插入的那一项

195
00:15:24,240 --> 00:15:25,730
所需的时间代价

196
00:15:27,530 --> 00:15:30,050
剩余的这些时间代价

197
00:15:30,190 --> 00:15:31,400
这里花费1

198
00:15:31,610 --> 00:15:33,700
这里要多花费2

199
00:15:33,840 --> 00:15:36,660
加4 加8

200
00:15:36,990 --> 00:15:38,990
这样整个模式看起来更容易理解

201
00:15:39,760 --> 00:15:41,850
这些是复制的时间代价

202
00:15:42,140 --> 00:15:47,080
上面这行只是插入的时间代价

203
00:15:49,060 --> 00:15:51,670
如果你现在在做笔记 在这里留点空间

204
00:15:51,910 --> 00:15:53,990
因为等下还要再回来讲一下这个表

205
00:15:54,560 --> 00:15:55,740
所以 预留一点空间

206
00:15:55,990 --> 00:15:56,850
因为等下还会回来

207
00:15:57,130 --> 00:16:02,100
这里还要再讲多一些东西

208
00:16:03,250 --> 00:16:10,700
将n个插入项的代价加起来

209
00:16:14,890 --> 00:16:19,930
求总和 i从1到n

210
00:16:21,120 --> 00:16:22,090
它等于

211
00:16:22,140 --> 00:16:25,550
由上述分析得到 它等于n...

212
00:16:27,200 --> 00:16:28,750
也就是这些1加起来

213
00:16:30,350 --> 00:16:35,990
再加上 这些2的幂

214
00:16:36,280 --> 00:16:40,240
但它们的上限不超过n

215
00:16:40,250 --> 00:16:43,270
如果我没算错的话

216
00:16:43,420 --> 00:16:47,150
这里是到log(n-1)的整数最小值

217
00:16:48,160 --> 00:16:50,150
2的j次幂的总和

218
00:16:56,700 --> 00:17:01,010
将上限不会超过n的

219
00:17:01,940 --> 00:17:04,410
所有2的幂加起来

220
00:17:06,950 --> 00:17:12,300
这是什么类型的数列

221
00:17:13,830 --> 00:17:14,690
这是几何级数

222
00:17:16,180 --> 00:17:20,410
所以 它的上界被最大项控制

223
00:17:20,550 --> 00:17:24,010
它的最大项是 2的这个上限次幂

224
00:17:25,600 --> 00:17:27,300
它由这个的最大项控制

225
00:17:27,430 --> 00:17:31,030
2的log(n-1)次幂 即最大值为n

226
00:17:33,470 --> 00:17:36,000
然后 其它所有项的上限也是不超过n

227
00:17:36,000 --> 00:17:39,210
所以最后小于或等于3n

228
00:17:41,050 --> 00:17:43,210
也就是θ(n) 如所欲证

229
00:17:50,360 --> 00:17:52,900
这是代数运算

230
00:17:53,560 --> 00:18:05,570
所以每个插入运算的平均代价

231
00:18:08,550 --> 00:18:13,810
等于θ(n)/n 也就是θ(1)

232
00:18:18,260 --> 00:18:21,320
一个插入的平均代价是θ(1)

233
00:18:22,500 --> 00:18:23,990
这是我们想要的结果

234
00:18:24,190 --> 00:18:26,210
特别是当我们在创建哈希表时

235
00:18:28,030 --> 00:18:31,200
尽管有时候要付出比较大的代价

236
00:18:32,270 --> 00:18:35,550
但这个巨大的开销

237
00:18:35,670 --> 00:18:37,840
会被之前的插入平摊掉

238
00:18:38,020 --> 00:18:41,820
因此n个操作的总代价是θ(n)

239
00:18:42,490 --> 00:18:44,850
这就是平摊分析的思想

240
00:18:45,970 --> 00:18:49,620
如果看到一个操作序列

241
00:18:49,990 --> 00:18:53,410
我可以将时间代价平摊到所有操作上

242
00:18:53,520 --> 00:18:56,990
这样平均的代价是θ(n)

243
00:18:57,470 --> 00:19:02,130
总结一下

244
00:19:11,790 --> 00:19:14,990
用平摊分析

245
00:19:15,280 --> 00:19:19,730
来分析一个操作序列

246
00:19:21,870 --> 00:19:32,740
证明每个操作的平均代价很小

247
00:19:36,710 --> 00:19:43,060
尽管一个或多个操作

248
00:19:43,470 --> 00:19:46,000
可能代价很大

249
00:19:54,030 --> 00:19:55,320
这里没有涉及到概率

250
00:19:57,060 --> 00:19:59,040
尽管我们用到了平均

251
00:19:59,370 --> 00:20:00,680
但并没有涉及到概率学

252
00:20:01,700 --> 00:20:02,900
当涉及概率学时

253
00:20:03,220 --> 00:20:05,950
我们会用到期望值 即平均值

254
00:20:07,650 --> 00:20:09,710
但这是另一种平均值

255
00:20:09,970 --> 00:20:11,690
但没有涉及概率学

256
00:20:13,530 --> 00:20:20,540
它是最坏情况下的平均表现

257
00:20:22,570 --> 00:20:24,790
n个操作的代价

258
00:20:25,050 --> 00:20:29,520
在最坏情况下 平均起来每步只是常数

259
00:20:30,320 --> 00:20:31,940
n个操作花费θ(n)的时间

260
00:20:34,420 --> 00:20:36,650
每个操作花费θ(1)的时间

261
00:20:38,820 --> 00:20:41,860
只是平摊到了n个操作上

262
00:20:43,260 --> 00:20:45,570
有问题？

263
00:20:45,790 --> 00:20:49,790
[学生]：...

264
00:20:50,060 --> 00:20:53,550
[教授]：对 没错 可以这样做

265
00:20:55,000 --> 00:20:56,560
但没有必要

266
00:20:58,420 --> 00:21:01,740
重点是 基础的平摊分析

267
00:21:01,850 --> 00:21:04,220
实际上 它能给出非常强的结果

268
00:21:04,320 --> 00:21:06,240
它给出的是最坏情况的代价上限

269
00:21:07,390 --> 00:21:10,020
但这是一整个操作序列的上限

270
00:21:10,020 --> 00:21:13,900
而不是序列里的每一个单独元素的上限

271
00:21:14,250 --> 00:21:19,790
现在有三种类型的平摊方法

272
00:21:20,100 --> 00:21:25,800
都是在文献上出现过的

273
00:21:30,610 --> 00:21:32,050
也可能有更多类型

274
00:21:32,150 --> 00:21:33,740
以前只有两种

275
00:21:33,810 --> 00:21:37,330
后来发明了第三种

276
00:21:37,470 --> 00:21:39,410
所以 可能会有第四种

277
00:21:40,730 --> 00:21:42,340
第一种是聚集

278
00:21:42,380 --> 00:21:44,660
称为聚集分析

279
00:21:47,260 --> 00:21:49,470
也就是我们刚才看到的

280
00:21:53,570 --> 00:21:55,970
基本上就是要你分析

281
00:21:56,070 --> 00:21:58,250
n次操作花费一共花多少时间？

282
00:22:02,730 --> 00:22:06,090
今天要介绍另外两种方法

283
00:22:08,960 --> 00:22:11,580
一种叫做记账方法

284
00:22:12,000 --> 00:22:14,300
另一种叫做势能方法

285
00:22:17,680 --> 00:22:23,830
这两种更精确 因为它们...

286
00:22:25,380 --> 00:22:41,720
它们为每一个操作分配了特定的平摊代价

287
00:22:42,470 --> 00:22:46,040
关于聚集分析 有一点要说明的是

288
00:22:46,640 --> 00:22:50,250
你不能轻易地确定一个单独操作...

289
00:22:50,360 --> 00:22:54,170
它的平摊代价具体是多少

290
00:22:54,560 --> 00:22:55,610
但这种情况可以

291
00:22:55,760 --> 00:22:57,520
你可以说它是θ(1)

292
00:22:59,100 --> 00:23:02,450
但在记账和势能方法里

293
00:23:02,500 --> 00:23:04,880
给出一种更加精确的方法

294
00:23:04,990 --> 00:23:08,600
来表示一个特定操作的平摊代价是多少

295
00:23:09,440 --> 00:23:14,330
我们来看一下

296
00:23:14,400 --> 00:23:16,880
第一个要看的方法是记账方法

297
00:23:17,060 --> 00:23:19,970
用这个方法再走一遍与之前完全相同的例子

298
00:23:20,070 --> 00:23:24,430
在某种程度上 这个例子最简单的分析方案

299
00:23:24,540 --> 00:23:26,270
是聚集分析

300
00:23:27,640 --> 00:23:29,850
也就是说 我们将要用到的另一个方法

301
00:23:29,920 --> 00:23:32,150
从某种程度来看 它更复杂

302
00:23:32,700 --> 00:23:35,970
但实际上 这两种方法其实更加强大

303
00:23:36,040 --> 00:23:38,250
在大部分情况下

304
00:23:38,730 --> 00:23:41,220
所以 我想在一个简单的情况下做一次

305
00:23:41,290 --> 00:23:43,580
这样你就应该意识到

306
00:23:43,680 --> 00:23:46,570
对于任意一个特定的问题

307
00:23:46,670 --> 00:23:48,450
你都能用不同的方法来完成它

308
00:23:51,110 --> 00:23:54,140
好的 记账方法是

309
00:24:04,710 --> 00:24:09,910
设想自己担任了一个财务会计的职位

310
00:24:10,700 --> 00:24:19,060
你要做的就是对第i个操作“收费”

311
00:24:19,160 --> 00:24:29,210
收一个虚构的平摊代价

312
00:24:30,940 --> 00:24:34,570
称之为c^i

313
00:24:35,620 --> 00:24:37,130
将时间代价看作是

314
00:24:37,240 --> 00:24:46,170
每一步运算要花费1美元

315
00:24:46,280 --> 00:24:50,240
因为要花时间来处理数据结构

316
00:24:51,530 --> 00:24:55,900
所以 你要向操作收费

317
00:24:55,970 --> 00:25:02,680
比如这个操作将花费你5美元左右

318
00:25:03,230 --> 00:25:17,690
这份费用是支付给这个操作的

319
00:25:18,800 --> 00:25:21,390
但可能还剩下一些用剩下的

320
00:25:21,570 --> 00:25:25,040
那么 如果还有未用到的余款

321
00:25:27,010 --> 00:25:29,110
它将存放在银行里

322
00:25:35,890 --> 00:25:41,310
用于偿付以后的操作

323
00:25:42,510 --> 00:25:47,250
如果第i次给的费用...

324
00:25:47,350 --> 00:25:49,480
费用c^i

325
00:25:49,580 --> 00:25:54,860
不足以给支付成这些操作

326
00:25:55,620 --> 00:26:00,390
那么就从银行里取出钱来付款

327
00:26:02,720 --> 00:26:05,790
这样你才不会被关小黑屋

328
00:26:05,930 --> 00:26:08,750
你需要多少财产才够呢？

329
00:26:10,200 --> 00:26:12,140
你需要有一些银行存款余额

330
00:26:12,250 --> 00:26:13,580
存款余额要有多少？

331
00:26:14,100 --> 00:26:17,630
银行存款是多少才符合数学逻辑?

332
00:26:19,080 --> 00:26:21,320
这还用说 它应该大于或等于0吧?

333
00:26:21,330 --> 00:26:23,900
大家都懂的

334
00:26:26,080 --> 00:26:38,720
存款余额不能是负数

335
00:26:39,160 --> 00:26:43,420
换句话说 到这一步操作之前

336
00:26:43,560 --> 00:26:46,370
所有的平摊代价减去操作代价的余额

337
00:26:46,410 --> 00:26:47,990
必须总是足够偿付

338
00:26:48,130 --> 00:26:50,860
当前所有操作的花费

339
00:26:50,910 --> 00:26:53,840
否则 你就是在向未来借款了

340
00:26:53,880 --> 00:26:57,240
在平摊分析里 不能向未来借款

341
00:26:57,630 --> 00:27:00,230
至少在这里这个简单的例子里不能

342
00:27:04,000 --> 00:27:12,350
这意味着有这个总和

343
00:27:13,410 --> 00:27:19,230
c_i从1到n求和 这是实际代价

344
00:27:19,790 --> 00:27:24,320
因此 如果存款不会变为负数

345
00:27:24,460 --> 00:27:35,780
则必须小于或等于 n次操作的平摊代价的总和

346
00:27:39,160 --> 00:27:42,380
为了存款余额不会变为负数

347
00:27:42,480 --> 00:27:44,930
如果合计所有实际代价

348
00:27:45,170 --> 00:27:48,780
那么存款总是足以偿付实际代价

349
00:27:48,850 --> 00:27:51,700
如果我要收费的话 这就是我收取的费用

350
00:27:51,910 --> 00:27:54,150
而这个 是实际的花费

351
00:27:55,070 --> 00:27:57,120
所以应该是这种情形

352
00:27:57,220 --> 00:27:58,840
无论实际需要花费多少

353
00:27:58,910 --> 00:28:00,450
来运作这个数据结构

354
00:28:00,510 --> 00:28:02,270
也就是这个实际花费

355
00:28:02,340 --> 00:28:04,580
它应该足以被

356
00:28:05,280 --> 00:28:07,540
我所收取的费用来偿付

357
00:28:07,720 --> 00:28:10,380
也就是之前这个数据结构的使用费

358
00:28:10,520 --> 00:28:12,770
这对于所有的n都是成立的

359
00:28:13,430 --> 00:28:16,460
注意到 现在这种方法

360
00:28:16,570 --> 00:28:20,050
可以给某个特定的操作 收取一定量的费用

361
00:28:21,460 --> 00:28:25,270
所以 总的平摊代价为总的实际代价

362
00:28:25,420 --> 00:28:28,000
提供了一个上限

363
00:28:29,580 --> 00:28:32,190
总的平摊代价是实际代价的上限

364
00:28:32,260 --> 00:28:33,430
对于这个有什么问题吗？

365
00:28:33,570 --> 00:28:36,730
我们会在动态表上用这种方法

366
00:28:36,840 --> 00:28:39,430
来做一个例子

367
00:28:54,050 --> 00:29:01,210
回到动态表

368
00:29:02,670 --> 00:29:05,160
在这个例子里 我们所要做的是

369
00:29:05,270 --> 00:29:13,990
收取3美元的平摊费用

370
00:29:15,850 --> 00:29:21,370
作为所有的第i步操作的费用

371
00:29:23,540 --> 00:29:24,840
收费标准是

372
00:29:24,940 --> 00:29:37,040
1美元付给一个即时插入

373
00:29:40,860 --> 00:29:48,790
还有2美元用于将表翻倍的预存费用

374
00:29:48,860 --> 00:29:52,180
因为表需要扩增

375
00:29:58,570 --> 00:30:10,200
当表的大小增加一倍时

376
00:30:10,310 --> 00:30:18,290
我们就从存款里 取出1美元来移动新项

377
00:30:21,150 --> 00:30:25,330
还有1美元用来移动旧项

378
00:30:30,990 --> 00:30:32,800
我们做个例子

379
00:30:40,900 --> 00:30:45,200
假设我们的情况是

380
00:30:47,820 --> 00:30:50,460
有一个大小为8的表

381
00:30:51,570 --> 00:30:54,190
而且我刚刚才表翻倍

382
00:30:54,430 --> 00:30:56,570
所以表里有4个项

383
00:30:56,710 --> 00:31:02,840
然后这个表里已经没有美元剩下了

384
00:31:06,580 --> 00:31:10,930
接下来要进行第5项的插入操作

385
00:31:12,890 --> 00:31:14,830
为此收取3美元

386
00:31:15,580 --> 00:31:19,730
用1美元 将项插入到表里

387
00:31:20,320 --> 00:31:22,360
还剩下2美元

388
00:31:22,670 --> 00:31:26,440
将这2美元存放在槽里

389
00:31:26,580 --> 00:31:29,680
相对于这个项的所在位置

390
00:31:31,070 --> 00:31:33,160
现在第6项来了

391
00:31:33,270 --> 00:31:35,950
再一次 收取3美元

392
00:31:36,060 --> 00:31:38,430
1美元付给插入运算

393
00:31:38,500 --> 00:31:41,750
还剩2美元 将2美元存起来

394
00:31:42,060 --> 00:31:45,000
将它放在这里 然后继续

395
00:31:45,070 --> 00:31:48,600
下一个又来了 这里是2美元 还剩下2美元

396
00:31:48,670 --> 00:31:51,030
直到第9项来了

397
00:31:51,300 --> 00:31:53,880
我要将表的大小增大为一倍

398
00:32:07,280 --> 00:32:10,490
然后 我要将所有这些项

399
00:32:10,600 --> 00:32:12,480
复制进新表里

400
00:32:12,590 --> 00:32:13,980
会发生什么？

401
00:32:14,080 --> 00:32:16,220
看这里 我有8美元

402
00:32:16,290 --> 00:32:19,460
而我又有8个项需要复制

403
00:32:20,320 --> 00:32:21,460
刚好

404
00:32:22,080 --> 00:32:24,800
所以其中的1美元付给

405
00:32:24,880 --> 00:32:28,640
在最新一轮里插进来的那项

406
00:32:28,710 --> 00:32:30,680
还有1美元付给一个旧的项

407
00:32:31,880 --> 00:32:34,440
将它们复制进来

408
00:32:35,560 --> 00:32:39,810
现在这些槽里都没有存款了

409
00:32:39,920 --> 00:32:43,060
第9项进来了 剩余2美元

410
00:32:44,150 --> 00:32:45,680
然后 继续这些步骤

411
00:32:52,740 --> 00:32:55,620
通过这个方法

412
00:32:56,120 --> 00:32:59,090
如果向每个人收取3美元

413
00:33:00,690 --> 00:33:05,280
我总是能偿付所有表扩增的花费

414
00:33:05,350 --> 00:33:06,980
存款用于表的扩增

415
00:33:07,450 --> 00:33:10,360
因为我维持了一个归纳不变量

416
00:33:10,430 --> 00:33:13,360
在表扩增后 银行存款就归零了

417
00:33:14,480 --> 00:33:15,870
现在再放2美元进去

418
00:33:15,970 --> 00:33:16,950
然后足够偿付了

419
00:33:16,950 --> 00:33:19,420
剩下的情况是一样的

420
00:33:22,540 --> 00:33:26,340
这种情况下 银行存款余额永不为负

421
00:33:26,370 --> 00:33:30,380
所以这是一个相当重要的不变量 我们需要验证一下

422
00:33:39,160 --> 00:33:42,650
因此 实际代价的总和

423
00:33:43,560 --> 00:33:47,570
或者说平摊代价总和 是为实际代价总和的上限

424
00:33:49,160 --> 00:33:52,820
因为平摊代价的总和

425
00:33:52,840 --> 00:33:56,060
这里i是从1到n

426
00:33:57,660 --> 00:34:01,320
这是3n

427
00:34:04,720 --> 00:34:05,930
关键在于

428
00:34:06,070 --> 00:34:10,120
实际代价的上限也就是3n

429
00:34:15,260 --> 00:34:17,060
回到这里这个表

430
00:34:17,200 --> 00:34:19,020
看一下是什么情况

431
00:34:23,800 --> 00:34:30,620
如果加入c^i 还有银行存款余额

432
00:34:35,630 --> 00:34:40,890
第一步要做的插入操作

433
00:34:43,670 --> 00:34:48,680
收取3美元

434
00:34:48,980 --> 00:34:50,560
然后我进行插入

435
00:34:50,940 --> 00:34:52,940
还剩余多少？

436
00:34:57,680 --> 00:34:59,100
剩下2美元

437
00:34:59,230 --> 00:35:01,970
但实际上 我只要收取2美元

438
00:35:02,040 --> 00:35:04,480
然后剩下1美元

439
00:35:06,700 --> 00:35:10,690
实际上 我要给第1项收得便宜些

440
00:35:11,020 --> 00:35:16,210
我会证明 每一项都收取3美元是可行的

441
00:35:16,310 --> 00:35:18,550
除了第一项 收取2美元

442
00:35:19,090 --> 00:35:21,440
实际上 在第1项可以省1美元

443
00:35:24,650 --> 00:35:28,450
接着这一项 我要收取3美元

444
00:35:33,390 --> 00:35:39,110
这样完成后银行存款余额是多少？

445
00:35:39,180 --> 00:35:40,550
我还要复制1项

446
00:35:40,650 --> 00:35:43,300
但这个已经付完了 所以还剩下2美元

447
00:35:48,540 --> 00:35:50,110
大家都明白吗？

448
00:35:50,210 --> 00:35:52,160
下一个 收取3美元

449
00:35:52,230 --> 00:35:54,680
实际上 所有这些项都要收取3美元

450
00:35:58,990 --> 00:36:02,650
到这里我已经有了...

451
00:36:02,760 --> 00:36:04,250
有一个大小为4的表

452
00:36:04,320 --> 00:36:11,120
所以 这里要进行复制

453
00:36:11,230 --> 00:36:14,030
当插入第3项时 必须要复制2个

454
00:36:14,100 --> 00:36:15,150
这部分存款会用掉

455
00:36:15,260 --> 00:36:18,540
所以 在插入第三项后 表里只剩下2美元

456
00:36:20,540 --> 00:36:22,640
现在插入第4项

457
00:36:23,040 --> 00:36:24,520
这一步比较简单

458
00:36:24,590 --> 00:36:28,180
现在这里的存款为4美元

459
00:36:28,750 --> 00:36:32,090
因为不用复制任何项

460
00:36:35,720 --> 00:36:37,180
现在插入第5项

461
00:36:37,280 --> 00:36:38,770
需要复制4项

462
00:36:38,880 --> 00:36:40,810
这样一来存款都要花掉

463
00:36:41,220 --> 00:36:43,710
然后又剩余2美元

464
00:36:45,660 --> 00:36:52,830
然后这里再加2美元 再加...

465
00:36:53,100 --> 00:36:56,120
在这里又全部用掉

466
00:36:56,260 --> 00:37:00,340
又回到2美元 以此类推

467
00:37:11,020 --> 00:37:13,940
你们需要注意的一点是

468
00:37:14,010 --> 00:37:17,000
这里可以收取3美元

469
00:37:17,100 --> 00:37:19,270
然后一直会有多余的1美元

470
00:37:19,380 --> 00:37:21,420
贯穿整个过程 但它不会有影响

471
00:37:21,600 --> 00:37:24,150
上限仍然是3n

472
00:37:25,180 --> 00:37:26,620
这里的想法是

473
00:37:26,730 --> 00:37:32,310
平摊的方案有不同 也是可行的

474
00:37:32,760 --> 00:37:34,760
它们没必要都一样

475
00:37:35,070 --> 00:37:37,360
当你进行平摊分析时

476
00:37:37,430 --> 00:37:39,880
它并不是只有一种可行的方案

477
00:37:40,060 --> 00:37:43,280
我也可以向每一项都收取4美元

478
00:37:43,480 --> 00:37:46,180
这也是可行的 但有一种例外

479
00:37:46,290 --> 00:37:48,550
不能向每一项都收取2美元

480
00:37:48,780 --> 00:37:50,470
如果每一项都收取2美元

481
00:37:50,580 --> 00:37:54,320
存款余额就会变为负的

482
00:37:55,630 --> 00:37:57,320
余额将是负数

483
00:37:57,470 --> 00:38:00,100
但可以收取3美元 这是可行的

484
00:38:00,770 --> 00:38:03,130
同样的也可以收取4，5，6美元

485
00:38:03,200 --> 00:38:05,660
只是会得到一个相对宽松的上限

486
00:38:05,740 --> 00:38:08,030
而不是小于或等于3n

487
00:38:08,100 --> 00:38:10,850
它将是小于或等于4n或5n 或是其它的

488
00:38:11,100 --> 00:38:13,460
但如果试一下2n 会发现是不可行的

489
00:38:15,820 --> 00:38:19,490
因为剩余的存款 不够用来进行复制操作

490
00:38:19,560 --> 00:38:22,790
如果这里只收取1美元 会发生什么情况？

491
00:38:22,900 --> 00:38:25,090
当表需要扩增的时候

492
00:38:25,160 --> 00:38:26,580
我需要复制8项

493
00:38:26,640 --> 00:38:31,090
但我只有4美元的银行存款

494
00:38:32,090 --> 00:38:35,850
抱歉口误了 是如果收取2美元 只剩1美元

495
00:38:37,060 --> 00:38:39,640
所以为了让这些方案可行

496
00:38:39,700 --> 00:38:41,290
你必须多尝试一些

497
00:38:41,930 --> 00:38:44,200
看一下哪些是可行的 哪些是不可行的

498
00:38:44,300 --> 00:38:47,070
不需要算法公式的算法设计

499
00:38:50,870 --> 00:38:55,500
在课本里

500
00:38:56,010 --> 00:38:58,510
你可以学一下表压缩

501
00:38:59,350 --> 00:39:02,810
当删除元素时又会是什么情况？

502
00:39:03,140 --> 00:39:05,080
如果想让表更小一些

503
00:39:05,150 --> 00:39:08,180
你就必须非常小心 因为除非你放...

504
00:39:08,290 --> 00:39:10,870
有谁还记得物理的磁滞现象

505
00:39:11,920 --> 00:39:13,250
大概记得就行 有谁记得吗？

506
00:39:13,290 --> 00:39:15,220
必须考虑一下磁滞现象

507
00:39:15,480 --> 00:39:17,200
如果你不小心

508
00:39:17,270 --> 00:39:22,150
当表小于2的幂时

509
00:39:22,220 --> 00:39:24,630
当进行到一半时 你会发现会系统会颠簸

510
00:39:25,890 --> 00:39:27,410
所以 你要设计成

511
00:39:27,550 --> 00:39:30,660
系统先预留一些内存 在完成一定量的删除操作后

512
00:39:30,730 --> 00:39:33,520
才真正地把内存释放掉

513
00:39:34,390 --> 00:39:35,260
以此类推

514
00:39:35,300 --> 00:39:39,580
课本也有对更普遍情况的分析

515
00:39:40,800 --> 00:39:42,980
对于记帐方法还有什么问题没有？

516
00:39:43,050 --> 00:39:45,490
记帐方法真的很有爱

517
00:39:46,370 --> 00:39:47,670
非常有爱

518
00:39:48,560 --> 00:39:52,270
也是大部分学生比较倾向的一种类型

519
00:39:52,400 --> 00:39:55,120
他们通常讨厌将要学习的东西 直到学会它

520
00:39:55,190 --> 00:39:57,470
一旦学会了 他们会说 酷炫啊

521
00:39:57,960 --> 00:39:59,220
但要开始新的学习

522
00:39:59,290 --> 00:40:05,360
就需要一点点勇气

523
00:40:06,560 --> 00:40:07,460
但它是神奇的

524
00:40:07,530 --> 00:40:12,070
好的势能方法 就像初恋一样难以忘怀

525
00:40:12,210 --> 00:40:14,050
下次课我们就会看到一个

526
00:40:14,150 --> 00:40:15,310
所以你绝对要复习

527
00:40:15,380 --> 00:40:19,070
确保在周三的课前你能理解它

528
00:40:19,170 --> 00:40:20,540
因为在周三的课上 我们会假设

529
00:40:20,610 --> 00:40:23,100
大家都已经掌握了势能方法

530
00:40:26,770 --> 00:40:31,460
开始吧 够多广告了

531
00:40:36,820 --> 00:40:39,070
我认为势能方法是

532
00:40:39,180 --> 00:40:42,630
算法分析里最漂亮的产物之一

533
00:40:43,150 --> 00:40:44,940
漂亮的产物

534
00:40:46,160 --> 00:40:48,110
美妙的技巧集合

535
00:40:51,320 --> 00:40:55,540
让我组织一下语言

536
00:40:55,600 --> 00:40:59,270
你是想数一辈子钱呢  还是做个物理学家去改变世界

537
00:41:02,510 --> 00:41:08,160
那意思就是 我们都不想做银行家

538
00:41:10,510 --> 00:41:14,980
我们都想做物理学家

539
00:41:22,400 --> 00:41:25,800
因此 银行存款帐户 将变成我们要说到的

540
00:41:25,940 --> 00:41:32,950
要分析的动态集的势能

541
00:41:36,810 --> 00:41:38,520
为什么？

542
00:41:38,550 --> 00:41:42,120
打个比方 它就像弹簧一样做功

543
00:41:43,280 --> 00:41:44,990
当你学习势能的时候

544
00:41:45,100 --> 00:41:49,470
或者把某个东西放高 让重力将它拉下来

545
00:41:49,550 --> 00:41:52,390
实际是将动能转为势能

546
00:41:52,460 --> 00:41:54,610
这也正是我们在这里要做的事

547
00:41:54,720 --> 00:41:57,060
它在数学上很相似

548
00:41:57,160 --> 00:41:59,470
只是在这种情况下用的是离散数学

549
00:41:59,520 --> 00:42:01,500
而不是在通常所用的连续数学

550
00:42:02,320 --> 00:42:09,070
好的 这是势能方法的框架

551
00:42:09,210 --> 00:42:20,310
我们由数据结构D_0开始讲起

552
00:42:21,570 --> 00:42:33,020
操作i将D_(i - 1)转化为D_i

553
00:42:34,110 --> 00:42:38,220
把数据结构上的操作看成是一种映射

554
00:42:38,480 --> 00:42:41,170
从一个数据结构映射到另一个数据结构

555
00:42:41,280 --> 00:42:43,390
从之前那个变成之后那个

556
00:42:43,590 --> 00:42:46,890
这已经是很了不起的数学了

557
00:42:48,430 --> 00:42:56,060
当然 操作i的操作代价还是c_i

558
00:43:13,010 --> 00:43:14,840
现在我们要做的是

559
00:43:15,450 --> 00:43:31,120
定义势能函数Φ

560
00:43:31,900 --> 00:43:37,360
将数据结构集映射为实数

561
00:43:41,020 --> 00:43:43,870
这样就把每个数据结构...

562
00:43:43,980 --> 00:43:47,250
跟势关联起来

563
00:43:48,800 --> 00:43:51,830
一种实数值的势

564
00:43:53,880 --> 00:43:55,600
虽然一般势值都是整数

565
00:43:55,740 --> 00:44:04,240
这样Φ(D_0)就等于0

566
00:44:04,520 --> 00:44:06,870
初始的势为0

567
00:44:10,860 --> 00:44:16,410
对于所有i  Φ(D_i)大于或等于0

568
00:44:16,450 --> 00:44:18,540
势能不可能为负值

569
00:44:18,580 --> 00:44:19,930
正如银行存款一样

570
00:44:19,970 --> 00:44:22,490
因为银行存款也可以表示成势

571
00:44:22,560 --> 00:44:27,980
如果你愿意 大可以在记账方法里试下

572
00:44:30,150 --> 00:44:33,310
所以我们要让势总不为负

573
00:44:33,370 --> 00:44:34,390
实际上

574
00:44:34,490 --> 00:44:36,390
当你使用势能函数时

575
00:44:36,490 --> 00:44:38,910
有时会违反这些性质

576
00:44:39,570 --> 00:44:42,110
但有一些相当有意思的势能参数

577
00:44:42,250 --> 00:44:43,300
它们不会违反这些性质的

578
00:44:43,410 --> 00:44:46,670
但像我们在课上用到的这些简单一点的

579
00:44:46,780 --> 00:44:49,100
我们就都假设它们都是成立的

580
00:44:50,100 --> 00:44:52,770
但实际上你会经常看到

581
00:44:52,840 --> 00:44:55,940
Φ(D_0)不等于0 但没关系

582
00:44:56,010 --> 00:44:58,390
因为通常我们都会假设它成立

583
00:44:59,480 --> 00:45:03,220
把这些我们用到的势能参数

584
00:45:03,290 --> 00:45:04,600
假设为符合条件的

585
00:45:04,800 --> 00:45:07,290
我只是想让你们知道 它很广

586
00:45:07,360 --> 00:45:09,340
势能函数参数的选择范围很广

587
00:45:09,430 --> 00:45:11,640
并不只是我这里给出的一两个

588
00:45:12,320 --> 00:45:15,840
然后在这种假设的前提下

589
00:45:16,000 --> 00:45:25,130
定义平摊代价为c^i

590
00:45:26,210 --> 00:45:32,970
对Φ(D_i)有……

591
00:45:33,040 --> 00:45:35,650
这一条公式是

592
00:45:35,790 --> 00:45:38,680
如果你不能记住的话

593
00:45:38,820 --> 00:45:43,670
你就必须记在笔记里 注明期末考点

594
00:45:44,430 --> 00:45:47,850
c^i等于

595
00:45:47,920 --> 00:45:56,720
c_i加上Φ(D_i)减去Φ(D_(i－1))

596
00:45:59,940 --> 00:46:09,600
这部分是势能的改变量

597
00:46:17,060 --> 00:46:21,410
我们将它简称为△Φ_i

598
00:46:26,490 --> 00:46:30,940
让我们看一下这意味着什么——

599
00:46:40,760 --> 00:46:42,580
——在不同的环境变量下

600
00:46:42,650 --> 00:46:55,110
如果△Φ_i大于0

601
00:46:56,710 --> 00:47:00,130
也就是这个大于0

602
00:47:01,250 --> 00:47:06,510
那么c^i和c_i的关系是什么样的？

603
00:47:07,270 --> 00:47:08,940
它大于0

604
00:47:13,760 --> 00:47:15,610
[学生]：...

605
00:47:15,910 --> 00:47:20,650
[教授]:没错 c^i大于c_i

606
00:47:21,470 --> 00:47:26,230
那么c^i大于c_i

607
00:47:27,170 --> 00:47:28,530
这意味着什么

608
00:47:28,590 --> 00:47:31,400
意味着当进行操作i时

609
00:47:32,480 --> 00:47:38,360
我收取的费用 超过了这个操作所需的代价

610
00:47:41,350 --> 00:47:44,360
我多收取的费用

611
00:47:45,010 --> 00:47:50,380
超过实际花费部分会存进银行

612
00:47:51,560 --> 00:47:54,190
变成势能储存起来

613
00:47:54,460 --> 00:48:11,190
操作i储存了后面数据结构所需的功

614
00:48:13,510 --> 00:48:20,680
同样的 如果△Φ_i小于0

615
00:48:22,330 --> 00:48:25,140
那么c^i小于c_i

616
00:48:27,270 --> 00:48:37,790
数据结构要转化出一部分功

617
00:48:50,530 --> 00:48:57,070
——来帮助支付操作i

618
00:48:59,460 --> 00:49:01,100
付给操作i

619
00:49:01,490 --> 00:49:03,370
如果它小于0

620
00:49:03,690 --> 00:49:06,560
那意味着势能的改变

621
00:49:06,670 --> 00:49:12,430
意味着银行存款余额变少

622
00:49:12,490 --> 00:49:20,020
因此 这种情况下

623
00:49:20,090 --> 00:49:24,020
数据结构会提供功来完成操作

624
00:49:24,130 --> 00:49:27,320
因为实际代价大于平摊代价

625
00:49:28,070 --> 00:49:29,560
好 你试想一下

626
00:49:29,640 --> 00:49:32,390
两种方法的差异是

627
00:49:32,760 --> 00:49:34,820
从势能法的角度

628
00:49:34,830 --> 00:49:37,300
跟从记帐法的角度比较

629
00:49:37,440 --> 00:49:38,980
用记帐方法来看

630
00:49:39,050 --> 00:49:42,220
你就会先决定一个平摊代价

631
00:49:42,520 --> 00:49:48,480
然后再分析一下银行存款

632
00:49:48,550 --> 00:49:50,370
确保它不为负值

633
00:49:50,780 --> 00:49:52,460
在某种程度上 在势能法里

634
00:49:52,530 --> 00:49:55,850
你就会说 我的银行存款是这样子的

635
00:49:56,550 --> 00:50:00,210
然后再分析一下 哪个平摊代价才适合

636
00:50:02,810 --> 00:50:04,530
这是两种方法的不同之处

637
00:50:04,600 --> 00:50:07,400
一种考虑的是银行存款

638
00:50:07,470 --> 00:50:10,280
另一种考虑的是平摊代价

639
00:50:13,550 --> 00:50:16,660
那我们来看一下

640
00:50:21,410 --> 00:50:30,710
为什么这是一种合理的操作方式

641
00:50:30,770 --> 00:50:40,370
看一下n个操作的总的平摊代价

642
00:50:42,490 --> 00:50:44,700
这是个求和运算

643
00:50:45,060 --> 00:50:49,320
对c^i从1到n求和

644
00:50:50,820 --> 00:50:53,200
这是总平摊代价

645
00:50:55,740 --> 00:50:59,070
它等于 替换一下

646
00:51:00,340 --> 00:51:03,590
将c^i替换成这条公式

647
00:51:06,790 --> 00:51:18,730
等于c_i加上Φ(D_i)减去Φ(D_(i-1))

648
00:51:24,290 --> 00:51:30,840
等于∑(i=1到n) c_i

649
00:51:31,800 --> 00:51:34,830
然后 把这些项加起来会得到什么？

650
00:51:39,350 --> 00:51:41,030
把这些项加起来会怎样？

651
00:51:41,100 --> 00:51:45,700
用数学术语是怎么说的？

652
00:51:46,900 --> 00:51:48,400
它是可缩进的

653
00:51:49,540 --> 00:51:51,840
左边的每个项

654
00:51:52,310 --> 00:51:54,320
当作为第i项时 会加进来一个

655
00:51:54,460 --> 00:51:58,610
作为第i-1项时 会减去一个

656
00:51:58,720 --> 00:52:01,410
除了第一项和最后一项

657
00:52:03,080 --> 00:52:07,550
第n项只有加 （但不会减掉）

658
00:52:10,500 --> 00:52:13,990
第0项只有减 （没有加进来）

659
00:52:16,670 --> 00:52:18,480
因为这是可缩进的

660
00:52:25,470 --> 00:52:27,850
所以这一项是多少？

661
00:52:30,010 --> 00:52:32,100
它具有什么已知性质？

662
00:52:33,140 --> 00:52:35,010
它大于或等于0

663
00:52:35,310 --> 00:52:38,660
这个等于0

664
00:52:39,250 --> 00:52:50,970
因此这个大于或等于c_i的总和

665
00:52:53,040 --> 00:52:56,240
这样一来 平摊代价

666
00:52:56,690 --> 00:53:00,080
是实际代价的一个上限 这正是我们想要的

667
00:53:00,150 --> 00:53:01,480
平摊代价的总和

668
00:53:01,490 --> 00:53:04,430
是实际代价总和的上限

669
00:53:06,520 --> 00:53:10,010
但这里定义平摊代价的方式

670
00:53:10,080 --> 00:53:13,270
是先定义势能函数

671
00:53:14,540 --> 00:53:17,540
所以势能函数就是  正如我所说的

672
00:53:17,540 --> 00:53:21,040
记帐方法和势能方法的区别是

673
00:53:21,110 --> 00:53:22,930
你考虑的是银行存款

674
00:53:23,000 --> 00:53:25,250
还是平摊代价？

675
00:53:25,870 --> 00:53:27,970
你针对的是任意点的势能

676
00:53:28,040 --> 00:53:30,890
还是在任意点的代价？

677
00:53:33,860 --> 00:53:35,710
但无论哪种情况 你都能得到

678
00:53:36,290 --> 00:53:40,190
这个上限 而同时这是漂亮的数学过程

679
00:53:40,290 --> 00:53:42,010
缩进什么的最喜欢了

680
00:53:43,480 --> 00:53:46,930
所以 平摊代价是实际代价的上限

681
00:53:48,060 --> 00:53:50,630
好的 做一下表扩增

682
00:53:54,120 --> 00:53:55,100
在这里

683
00:54:18,830 --> 00:54:22,880
要分析这个 先要定义势

684
00:54:27,710 --> 00:54:30,630
有谁的第一反应能猜出这是什么

685
00:54:30,680 --> 00:54:32,220
那他就比我还要聪明

686
00:54:33,970 --> 00:54:37,200
你看 我都已经聪明绝顶了

687
00:54:38,060 --> 00:54:41,720
但还要花几个小时才做出来

688
00:54:42,500 --> 00:54:44,300
可能因为我的顶太绝了

689
00:54:50,010 --> 00:54:53,060
这是所要用到的势能函数

690
00:54:53,620 --> 00:54:59,000
2i减去2的log i的上取整次方

691
00:55:00,580 --> 00:55:05,620
接下来 我们要假设

692
00:55:05,700 --> 00:55:10,610
2^┌log 0┐= 0

693
00:55:10,680 --> 00:55:14,720
因为它的极限就是这样

694
00:55:14,790 --> 00:55:18,700
对于log 0 等于负无穷

695
00:55:18,770 --> 00:55:20,960
所以2的负无穷次方等于0

696
00:55:21,120 --> 00:55:24,360
这仅仅是为了数学计算上的方便

697
00:55:24,470 --> 00:55:33,610
假设是这样 我是怎么推出这条式的？

698
00:55:33,720 --> 00:55:34,600
我做了很多尝试

699
00:55:34,670 --> 00:55:38,690
我观察了刚擦掉的那个序列

700
00:55:38,880 --> 00:55:40,540
然后通过逆运算

701
00:55:40,650 --> 00:55:41,880
其实现在问题是

702
00:55:41,950 --> 00:55:44,280
定义一个势能函数并不难

703
00:55:44,650 --> 00:55:47,310
但是定义其平摊代价就很难了

704
00:55:47,950 --> 00:55:49,620
或者定义存款

705
00:55:49,720 --> 00:55:52,710
所以说 对于这个例子 记账方法

706
00:55:52,780 --> 00:55:54,950
是相对容易的一种方法

707
00:55:55,020 --> 00:55:56,010
但我将证明给你看

708
00:55:56,050 --> 00:55:57,600
你仍能用势能方法来做

709
00:55:57,600 --> 00:56:00,090
如果你一开始使用了对的势

710
00:56:00,840 --> 00:56:03,130
直觉上 这也是

711
00:56:03,200 --> 00:56:06,250
第i步操作时剩余的银行存款

712
00:56:06,350 --> 00:56:09,260
因为我把这些2i 存进了银行

713
00:56:09,370 --> 00:56:11,350
并且 我又减去这些东西

714
00:56:11,430 --> 00:56:13,760
本质上 它们是用于表扩增的开销

715
00:56:14,800 --> 00:56:17,400
大概是那个意思

716
00:56:18,230 --> 00:56:25,650
首先要观察Φ(D_0)是多少？

717
00:56:32,860 --> 00:56:34,140
0

718
00:56:34,500 --> 00:56:36,060
非常好

719
00:56:36,170 --> 00:56:42,200
Φ(D_i)大于或等于0

720
00:56:42,200 --> 00:56:43,660
为什么会这样？

721
00:56:57,040 --> 00:56:58,660
为什么？

722
00:57:09,040 --> 00:57:15,950
┌log i┐最大可能是多少？

723
00:57:20,240 --> 00:57:23,230
┌log i┐或者等于log i

724
00:57:25,540 --> 00:57:30,320
或者等于log i的值加上1

725
00:57:30,750 --> 00:57:33,760
所以最大值是log i + 1

726
00:57:33,830 --> 00:57:35,990
如果是log i + 1

727
00:57:36,060 --> 00:57:41,540
2的log i + 1次方 就是2i

728
00:57:41,640 --> 00:57:45,590
这是它的最大值 对哇？

729
00:57:45,630 --> 00:57:53,200
2的（log i + 1）次方

730
00:57:57,030 --> 00:57:59,970
换一种算法 就是i乘以2

731
00:58:03,450 --> 00:58:05,820
i是这一部分 2是这一部分

732
00:58:07,000 --> 00:58:09,210
这是它的最大值了

733
00:58:09,950 --> 00:58:13,000
或者只是log i

734
00:58:13,070 --> 00:58:23,130
所以这里或者等于2i-i 或者等于2i-2i

735
00:58:23,170 --> 00:58:27,090
这两种情况都大于0

736
00:58:29,380 --> 00:58:31,470
所以这两个性质是我需要的

737
00:58:31,470 --> 00:58:34,310
用来定义好的势能函数的性质

738
00:58:34,880 --> 00:58:36,310
但现在 这还不能说明

739
00:58:36,380 --> 00:58:39,300
这个平摊代价将保证...

740
00:58:39,480 --> 00:58:45,130
保证总操作的代价会比较低

741
00:58:46,530 --> 00:58:48,820
并不意味着我只要做做分析

742
00:58:48,890 --> 00:58:50,470
然后就能得到 我要的上限

743
00:58:50,540 --> 00:58:52,790
但它至少给出了

744
00:58:52,930 --> 00:58:57,110
一个合适的势能函数的规则

745
00:58:57,990 --> 00:59:00,220
举一个简单的例子

746
00:59:01,800 --> 00:59:03,760
看一下这些表示着什么

747
00:59:03,830 --> 00:59:08,440
假设在这种情况下有8个

748
00:59:12,870 --> 00:59:14,550
我画对了没有？

749
00:59:14,690 --> 00:59:19,220
没错 有8个槽 其中有6个是满的

750
00:59:21,730 --> 00:59:26,530
那么这个的势能函数值等于 2i

751
00:59:26,570 --> 00:59:31,750
也就是 2乘以6减去 2的2i次方

752
00:59:32,200 --> 00:59:37,320
那是多少？不是 是减去2^┌log i┐

753
00:59:37,320 --> 00:59:45,940
i等于6 log i就是log 6

754
00:59:46,030 --> 00:59:48,510
上取整等于3

755
00:59:48,580 --> 00:59:54,370
所以这是减去2^3 也就是8

756
00:59:54,380 --> 00:59:57,590
这样12减去8 得到4

757
01:00:00,420 --> 01:00:03,380
如果你用记帐方法想一下

758
01:00:03,490 --> 01:00:07,650
这些槽都是0 这些槽是2

759
01:00:08,640 --> 01:00:11,850
如果用记帐方法来分析的话

760
01:00:11,850 --> 01:00:14,180
因为这个刚进行到一半

761
01:00:14,250 --> 01:00:16,630
所以这些都是0 然后这些槽都加2

762
01:00:16,700 --> 01:00:22,130
实际上这个函数 告诉了我们实际代价是多少

763
01:00:23,610 --> 01:00:26,150
大家都明白吗？

764
01:00:26,660 --> 01:00:30,570
这就是这个特殊的势能函数的含义

765
01:00:32,100 --> 01:00:36,410
现在将第i个插入操作的平摊代价加起来

766
01:01:08,010 --> 01:01:11,500
这是第i个操作的平摊代价

767
01:01:11,540 --> 01:01:12,890
由定义可知

768
01:01:15,320 --> 01:01:18,780
现在它等于... c_i是多少？

769
01:01:18,820 --> 01:01:20,730
结果还在黑板上吗？

770
01:01:20,760 --> 01:01:22,340
还是被我们擦掉了？

771
01:01:26,610 --> 01:01:29,190
应该被擦掉了

772
01:01:30,480 --> 01:01:33,070
我们可以再写一遍

773
01:01:33,240 --> 01:01:40,230
它等于i 如果i-1刚好是2的幂

774
01:01:44,330 --> 01:01:49,890
否则它为1 这是c_i

775
01:01:51,310 --> 01:01:57,250
就是这一项 再加上Φ(D_i)

776
01:01:57,580 --> 01:01:59,200
它是多少？

777
01:02:01,710 --> 01:02:05,260
Φ(D_i)等于这个

778
01:02:06,440 --> 01:02:18,180
2i 减去 2^┌log i┐ 再减去

779
01:02:19,820 --> 01:02:27,480
2(i-1)减去2^┌log(i-1)┐

780
01:02:36,000 --> 01:02:37,210
这就是平摊代价了

781
01:02:37,280 --> 01:02:40,490
很工整 很漂亮的公式

782
01:02:42,030 --> 01:02:44,240
再把它简化一下

783
01:02:47,690 --> 01:02:49,440
它等于

784
01:02:52,080 --> 01:02:58,280
这里是i和1 如果 这里省略

785
01:02:59,030 --> 01:03:02,150
就是上面的那坨 再加上

786
01:03:02,790 --> 01:03:05,490
这里有一些可以抵消的

787
01:03:05,850 --> 01:03:08,560
尤其是这一项 可以抵消掉

788
01:03:09,190 --> 01:03:13,190
所以这里是2i减去2i

789
01:03:13,510 --> 01:03:14,850
抵消掉

790
01:03:15,000 --> 01:03:20,920
这里剩下的是负的负2

791
01:03:21,030 --> 01:03:22,980
负负得正 变成加2

792
01:03:24,880 --> 01:03:36,680
然后再减去这一项 再加上这一项

793
01:03:42,830 --> 01:03:44,530
这样漂亮多了

794
01:03:46,910 --> 01:03:48,180
但还是很乱

795
01:03:48,550 --> 01:03:49,930
然后我们要分步讨论

796
01:03:50,000 --> 01:03:52,810
为什么要分步讨论？

797
01:03:52,950 --> 01:03:54,400
因为爱情

798
01:03:55,780 --> 01:03:58,880
那么做一下分步讨论吧

799
01:04:09,260 --> 01:04:21,720
对于情形1 i-1刚好是2的幂值

800
01:04:22,990 --> 01:04:30,890
那么 c^i等于... 这里c_i是i

801
01:04:30,920 --> 01:04:33,490
在这种情况下 然后写上剩余的公式

802
01:04:33,600 --> 01:04:37,900
加上2减去2^┌log i┐

803
01:04:38,100 --> 01:04:42,590
减去2^┌log（i-1）┐

804
01:04:46,630 --> 01:04:51,230
等于i + 2

805
01:04:52,670 --> 01:04:54,820
看一下

806
01:04:55,760 --> 01:04:59,900
如果i-1刚好是2的幂 这一项是多少？

807
01:05:05,000 --> 01:05:07,800
i-1刚好是2的幂

808
01:05:13,830 --> 01:05:19,120
这里是加 不好意思

809
01:05:31,540 --> 01:05:33,200
有学生真好

810
01:05:33,270 --> 01:05:38,960
因为我的数学太渣了

811
01:05:39,780 --> 01:05:44,390
这也是为什么我会成为一个的理论家

812
01:05:44,450 --> 01:05:48,720
因为我连自己写下来的东西都不相信

813
01:05:48,970 --> 01:05:51,890
所以 我把它写下来 只是为了可以验证它

814
01:05:52,030 --> 01:05:54,400
因为我不够聪明

815
01:05:54,470 --> 01:05:57,070
如果一行里摆了五条算式

816
01:05:57,210 --> 01:06:01,330
那结果肯定是必有我失

817
01:06:03,900 --> 01:06:05,140
把它写下来

818
01:06:05,220 --> 01:06:07,210
我习惯把它写下来 这样才能够验证它

819
01:06:07,250 --> 01:06:09,900
而且这样做还有个被动技能

820
01:06:09,940 --> 01:06:12,530
就是别人也能理解我所写的内容

821
01:06:15,060 --> 01:06:17,240
那么 这一项是多少？

822
01:06:19,950 --> 01:06:23,110
它是2^┌log（i-1）┐

823
01:06:23,730 --> 01:06:25,150
因为是往上取整

824
01:06:25,260 --> 01:06:34,640
如果它刚好是2的幂

825
01:06:35,880 --> 01:06:40,600
那么log（i-1）上取整就是log（i-1）

826
01:06:40,670 --> 01:06:42,560
所以等于2^log（i-1）

827
01:06:42,640 --> 01:06:46,530
就是i-1

828
01:06:50,710 --> 01:06:54,510
这里很不可思议

829
01:06:55,320 --> 01:06:57,820
没有掌声很不可思议

830
01:06:58,350 --> 01:07:02,720
如果它刚好是2的幂 那么log的结果就是整数

831
01:07:04,620 --> 01:07:07,300
所以往上取整并没有影响

832
01:07:07,370 --> 01:07:08,740
去掉上限符号

833
01:07:08,780 --> 01:07:12,040
但这一项 并不是2的幂

834
01:07:13,380 --> 01:07:14,760
但它是多少？

835
01:07:16,970 --> 01:07:19,510
它只是比这个大1

836
01:07:21,360 --> 01:07:24,200
已知i-1不是2的幂

837
01:07:24,210 --> 01:07:27,040
那么它就是下一个整数

838
01:07:28,600 --> 01:07:30,370
这意味着这是多少

839
01:07:41,400 --> 01:07:47,710
它就是 这两个比较一下

840
01:07:51,140 --> 01:07:53,480
这个比这个大多少？

841
01:07:54,230 --> 01:07:55,860
是它大小的两倍

842
01:07:56,000 --> 01:07:57,830
已知这个值

843
01:08:01,910 --> 01:08:04,260
用基本原理也可以推导出

844
01:08:04,400 --> 01:08:09,540
这个是log（i-1）+1

845
01:08:11,990 --> 01:08:15,340
这样可以推导出这个

846
01:08:17,060 --> 01:08:19,760
你们回去要想想 上取整和下取整

847
01:08:19,810 --> 01:08:22,470
它就像是四舍五入

848
01:08:23,200 --> 01:08:25,410
现在就可以简化了

849
01:08:26,540 --> 01:08:29,320
这里能得出什么？ 我们有...

850
01:08:32,030 --> 01:08:35,440
如果将这些乘出来

851
01:08:35,450 --> 01:08:46,320
得出i+2-2i+2+i-1

852
01:08:47,900 --> 01:08:52,640
我就知道 你们可能有90%的人会跳过这一步

853
01:08:53,190 --> 01:08:55,880
你会直接从这一步跳到最后一步

854
01:08:55,890 --> 01:08:58,980
而这其中又有30%的人

855
01:08:59,090 --> 01:09:01,710
或多或少会算错

856
01:09:01,820 --> 01:09:05,270
所以我建议你们都算这一步

857
01:09:05,370 --> 01:09:10,810
如果你们慢一点 你们就更容易发现错误

858
01:09:10,870 --> 01:09:14,110
实际上 慢工出细活

859
01:09:14,180 --> 01:09:18,210
你们还是很傻很天真

860
01:09:18,980 --> 01:09:21,120
又很不熟练

861
01:09:21,220 --> 01:09:23,880
悠着点

862
01:09:23,910 --> 01:09:26,120
耐心地 慢慢地来做 把它做对了

863
01:09:27,100 --> 01:09:28,570
这样其实更快

864
01:09:29,230 --> 01:09:31,380
大家都知道乌龟和兔子的故事吧

865
01:09:31,380 --> 01:09:34,970
爷爷也~~不相信

866
01:09:36,400 --> 01:09:40,620
好的 现在这里是2i

867
01:09:43,590 --> 01:09:48,760
剩下2+2-1 等于3

868
01:09:50,080 --> 01:09:55,310
威武霸气

869
01:09:55,710 --> 01:09:58,270
平摊代价是3

870
01:09:58,380 --> 01:10:01,420
这是i-1刚好是2的幂的情况

871
01:10:04,050 --> 01:10:06,930
第二种情况

872
01:10:28,710 --> 01:10:32,310
i-1不是2的幂

873
01:10:32,900 --> 01:10:37,230
那么c^i等于

874
01:10:37,290 --> 01:10:41,350
现在不是i 而是1 加上

875
01:10:41,360 --> 01:10:47,040
然后加上2减去2^┌logi┐

876
01:10:48,150 --> 01:10:53,650
加上2^┌log(i-1)┐

877
01:10:55,130 --> 01:10:57,640
现在有人能告诉我这两项是多少吗

878
01:10:57,640 --> 01:11:02,040
在i-1不是2的幂的情况下

879
01:11:04,730 --> 01:11:07,120
这两个是多少？相等

880
01:11:07,210 --> 01:11:09,220
为什么?

881
01:11:12,430 --> 01:11:13,490
[学生]：……

882
01:11:13,670 --> 01:11:16,730
[教授]:没有 上取整对这两项效果一样

883
01:11:16,810 --> 01:11:18,910
取为相当的整数

884
01:11:19,650 --> 01:11:21,660
所以这两项相等

885
01:11:25,060 --> 01:11:31,180
意味着它等于3

886
01:11:37,090 --> 01:11:43,140
因此 n个插入

887
01:11:45,080 --> 01:11:48,900
现在我知道了 平摊代价是3

888
01:11:48,900 --> 01:11:52,590
对于每个操作 每个插入都是3

889
01:11:52,660 --> 01:11:58,200
因此 n个插入花费

890
01:11:58,280 --> 01:12:02,430
每一个的平摊代价是3

891
01:12:02,910 --> 01:12:06,300
有n个 所以平摊代价是3n

892
01:12:06,390 --> 01:12:10,780
这也是最坏情况下实际代价的上限

893
01:12:10,850 --> 01:12:16,790
所以n个插入在最坏情况下代价为θ(n)

894
01:12:22,300 --> 01:12:25,220
但这个分析里有一个漏洞

895
01:12:26,510 --> 01:12:27,470
一个很小的错误

896
01:12:27,490 --> 01:12:29,610
我在之前指出来过

897
01:12:29,880 --> 01:12:33,720
第一个插入的平摊代价是2 不是3

898
01:12:34,030 --> 01:12:37,740
实际上 我从没仔细地研究过这个问题

899
01:12:37,800 --> 01:12:40,860
这是一个练习 你们回去研究一下

900
01:12:40,860 --> 01:12:43,320
为什么会这样 你要如何证明

901
01:12:43,390 --> 01:12:46,610
实际上 第一项的平摊代价是2

902
01:12:47,050 --> 01:12:48,690
表现出来是这样

903
01:12:50,160 --> 01:12:57,210
总结一下 最后在这里总结一下

904
01:12:57,550 --> 01:13:01,520
平摊分析的结论

905
01:13:15,640 --> 01:13:25,370
平摊分析为数据结构的性能

906
01:13:29,260 --> 01:13:37,760
提供了一个简洁的抽象概念

907
01:13:40,930 --> 01:13:43,730
我能告诉人们

908
01:13:43,730 --> 01:13:47,210
假设我建立一个动态表 打个比方

909
01:13:48,420 --> 01:13:51,520
你很容易就能看出来

910
01:13:51,900 --> 01:13:54,490
根据你自己的性能模型

911
01:13:55,960 --> 01:14:00,090
每个插入都花费一定量的时间

912
01:14:01,400 --> 01:14:04,350
只要你不关注实时表现

913
01:14:04,360 --> 01:14:06,880
只关注聚集行为

914
01:14:07,260 --> 01:14:10,070
这是一个相当好的性能抽象概念

915
01:14:10,830 --> 01:14:14,110
虽然某些地方可能会比较复杂

916
01:14:14,110 --> 01:14:16,530
即有时候代价会很大

917
01:14:16,600 --> 01:14:18,550
你要怎么解释？

918
01:14:19,160 --> 01:14:22,890
但你还是能说 每个操作都花费θ(1)

919
01:14:23,770 --> 01:14:24,990
其实很简单

920
01:14:25,690 --> 01:14:26,880
但你要他们理解

921
01:14:26,880 --> 01:14:31,070
这是从平摊的角度来说的θ(1)

922
01:14:31,330 --> 01:14:34,390
如果他们给你一个实时代价的限制

923
01:14:34,440 --> 01:14:37,260
平摊分析就没辙了

924
01:14:37,840 --> 01:14:41,180
但对于很多问题 这方法都是非常好用的

925
01:14:41,600 --> 01:14:44,780
能够相当简单地进行解释

926
01:14:45,480 --> 01:14:49,410
你会看到另外一些拥有平摊代价的数据结构

927
01:14:49,450 --> 01:14:53,090
而且不同的操作会有不同的平摊代价

928
01:14:53,320 --> 01:14:56,450
好消息是 你只要把它们加起来就行了

929
01:14:56,510 --> 01:14:58,990
所有不同操作的代价是多少?

930
01:15:00,080 --> 01:15:02,820
每个操作的代价不同在哪里？

931
01:15:02,900 --> 01:15:05,890
有一些是log n 有一些是θ(1) 或是其它的

932
01:15:06,000 --> 01:15:09,720
全部加起来 就是实际代价的上限了

933
01:15:10,800 --> 01:15:14,810
极大地简化了那些复杂数据结构的

934
01:15:14,820 --> 01:15:17,350
抽象化和合理化

935
01:15:19,720 --> 01:15:24,110
这个很可能 这其实说得很大

936
01:15:24,230 --> 01:15:26,640
抽象化 对于计算机科学

937
01:15:26,670 --> 01:15:29,800
在四年的大学生活里教给你的

938
01:15:29,820 --> 01:15:32,040
如果你读工程硕士的话还会多一年

939
01:15:32,080 --> 01:15:34,260
如果你再读博士 可能又要15年

940
01:15:34,280 --> 01:15:36,240
反正很多很多年 直到你博士毕业

941
01:15:36,630 --> 01:15:39,310
你所学的所有东西都是抽象化

942
01:15:39,350 --> 01:15:41,870
抽象化 抽象化 抽象化

943
01:15:41,980 --> 01:15:47,230
所以这就是一个强大的抽象概念 非常好

944
01:15:47,230 --> 01:15:49,410
今天我们学习了三种方法

945
01:15:50,700 --> 01:15:52,610
通常情况下 每一种都可用

946
01:15:52,680 --> 01:15:54,570
你能从其中一个转换到另外一个

947
01:16:01,960 --> 01:16:06,340
但每一个都有特定的情况

948
01:16:11,090 --> 01:16:24,850
使得它是最简单的或是最精确的

949
01:16:26,120 --> 01:16:28,160
所以 任意一种方法都可用

950
01:16:28,170 --> 01:16:31,440
无论如何 你要学会所有方法

951
01:16:31,580 --> 01:16:37,420
因为有些情况 你会需要到其中某一个

952
01:16:37,490 --> 01:16:39,840
用这个做可能不错 用另一个做会更好

953
01:16:39,850 --> 01:16:40,830
如果你读一下文献

954
01:16:40,850 --> 01:16:43,710
你想要知道怎样用不同的方法解决问题

955
01:16:43,910 --> 01:16:45,770
这也意味着 即使你

956
01:16:45,910 --> 01:16:48,540
可能用记帐方法用得更顺手

957
01:16:50,150 --> 01:16:53,770
在考试中 或其他场合

958
01:16:53,950 --> 01:16:56,770
要用势能函数方法来解决问题

959
01:16:58,870 --> 01:17:02,450
那么 最好就是所有方法你都得心应手

960
01:17:04,970 --> 01:17:08,720
最后一点是

961
01:17:08,860 --> 01:17:12,390
实际上 不同的势能函数

962
01:17:19,950 --> 01:17:28,850
或不同的记帐代价可能产生不同的上限

963
01:17:35,700 --> 01:17:38,270
所以当你在做平摊分析时

964
01:17:38,310 --> 01:17:40,190
没有这个代价

965
01:17:40,250 --> 01:17:41,870
会比另个一个好

966
01:17:42,250 --> 01:17:44,110
只是举个例子

967
01:17:44,820 --> 01:17:48,740
通常任意数据结构都支持删除操作

968
01:17:48,890 --> 01:17:52,880
我可以用插入 跟删除进行平摊

969
01:17:54,760 --> 01:17:58,680
通常来说 我都假设删除是免费的

970
01:17:59,790 --> 01:18:03,770
然后 对每个插入都收取两倍的代价

971
01:18:05,180 --> 01:18:06,900
插入时 收取足够多的代价

972
01:18:07,000 --> 01:18:08,970
然后 平摊给删除操作

973
01:18:09,040 --> 01:18:10,850
可以用记帐方法来试一下

974
01:18:10,960 --> 01:18:14,450
你也可以用势能方法

975
01:18:14,990 --> 01:18:17,260
而这个势能 实际上就是

976
01:18:17,280 --> 01:18:21,280
数据结构里的元素数量 乘以

977
01:18:21,360 --> 01:18:24,130
每一项删除的代价

978
01:18:25,700 --> 01:18:29,100
关键是 我能用不同的方法来分摊代价

979
01:18:29,170 --> 01:18:30,730
或者说 平摊的代价

980
01:18:30,790 --> 01:18:32,690
它们加起来和实际代价相等

981
01:18:33,070 --> 01:18:35,830
所有 有很多种不同的方法来分配平摊代价

982
01:18:35,830 --> 01:18:38,750
不止一种方法

983
01:18:38,830 --> 01:18:41,960
选择不同的方法 可能会得到不同的上限

984
01:18:42,120 --> 01:18:44,650
可能不会 但也可能有不同的上限

985
01:18:45,490 --> 01:18:48,010
通常都会得出不同的上限

986
01:18:48,110 --> 01:18:53,040
下节课会讲到势能函数的一种神奇的用法

987
01:18:53,180 --> 01:18:56,960
这节课很精彩 但我要剧透下

988
01:18:57,070 --> 01:18:59,280
周三的课 亮瞎了

989
01:18:59,340 --> 01:19:02,720
那将是见证奇迹的时刻

