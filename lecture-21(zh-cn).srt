1
00:00:05,000 --> 00:00:09,580
早上好  今天我们要

2
00:00:09,610 --> 00:00:15,330
继续对多线程算法进行探索

3
00:00:15,360 --> 00:00:19,500
上一节课 我们介绍了一些线程调度方面的内容

4
00:00:19,520 --> 00:00:23,630
还讲了一点术语

5
00:00:23,630 --> 00:00:28,070
来描述多线程竞争

6
00:00:28,110 --> 00:00:29,450
今天 我们要

7
00:00:29,460 --> 00:00:31,190
实际接触一些算法

8
00:00:45,730 --> 00:00:48,130
我们由一个非常简单的例子开始

9
00:00:48,160 --> 00:00:50,330
实际上 有意思的是

10
00:00:50,360 --> 00:00:52,390
今天要教给你们的全部内容

11
00:00:52,420 --> 00:00:56,020
在第二周讲也是可以的

12
00:00:56,060 --> 00:00:58,380
因为它基本上

13
00:00:58,420 --> 00:01:01,910
就是在用名为"分治法"的神器

14
00:01:01,950 --> 00:01:05,520
来刷掉一个又一个问题

15
00:01:05,550 --> 00:01:11,960
而实际上 下星期关于缓存的课

16
00:01:11,980 --> 00:01:14,320
也是差不多的

17
00:01:14,360 --> 00:01:18,920
所以每个人都要钻研一下它的主定理

18
00:01:18,960 --> 00:01:24,950
以及代入实际问题的方法等等

19
00:01:24,990 --> 00:01:24,800
因为这就是我们将要做的

20
00:01:24,820 --> 00:01:28,160
当然 所有这些内容期末都会考

21
00:01:28,240 --> 00:01:31,480
我们先从矩阵相乘开始

22
00:01:38,290 --> 00:01:40,020
以n×n矩阵为例

23
00:01:40,050 --> 00:01:47,980
问题是计算C=A*B

24
00:01:48,020 --> 00:01:49,780
我们使用的方法

25
00:01:49,800 --> 00:01:55,190
是正如之前所见的分治法

26
00:01:55,210 --> 00:01:59,600
不过 我们不打算使用Strassen演算法

27
00:01:59,620 --> 00:02:03,040
只使用普通的方法

28
00:02:03,070 --> 00:02:06,460
Strassen演算法将留作练习

29
00:02:06,480 --> 00:02:11,300
我们的做法是

30
00:02:11,320 --> 00:02:15,560
把n×n矩阵的乘法

31
00:02:15,580 --> 00:02:17,650
看成是n/2×n/2的矩阵的乘法

32
00:02:17,680 --> 00:02:21,500
我将C划分成四个区

33
00:02:26,060 --> 00:02:27,610
A和B也进行同样的分区

34
00:02:47,990 --> 00:02:51,140
将这些乘出来

35
00:02:51,160 --> 00:02:56,540
会得出下列结果

36
00:03:00,440 --> 00:03:02,290
确保所有的下标都无误

37
00:03:37,230 --> 00:03:42,020
得到这两个n×n矩阵的和

38
00:03:42,050 --> 00:03:45,290
举个例子

39
00:03:45,330 --> 00:03:48,480
用第一行乘以第一列

40
00:03:48,500 --> 00:03:50,150
第一项是

41
00:03:50,170 --> 00:03:54,550
矩阵里的A_11乘以B_11 第二个是

42
00:03:54,570 --> 00:04:00,630
A_12乘以B_21放在这里

43
00:04:00,650 --> 00:04:03,000
依此类推 将它们加起来

44
00:04:03,020 --> 00:04:04,950
其它项都这样操作 全部加起来

45
00:04:04,970 --> 00:04:07,650
我就能得到结果

46
00:04:07,680 --> 00:04:11,230
所以 我们可以把这个写成

47
00:04:11,260 --> 00:04:18,350
看一下 我不确定

48
00:04:18,370 --> 00:04:21,570
能不能在一个板面里写完

49
00:04:21,600 --> 00:04:22,750
应该能够写完

50
00:04:22,780 --> 00:04:26,580
我们可以把它写成一个多线程程序

51
00:04:26,610 --> 00:04:32,700
我们将会看到

52
00:04:32,720 --> 00:04:40,190
为简单起见 n恰好是2的幂

53
00:04:41,880 --> 00:04:46,960
因为我们要对两个矩阵相加

54
00:04:47,030 --> 00:04:52,930
那我们先把其中一个存进输出矩阵C里

55
00:04:52,950 --> 00:04:54,270
也就是第一个矩阵

56
00:04:54,280 --> 00:05:02,670
然后还要用到一个临时矩阵T

57
00:05:02,700 --> 00:05:04,990
大小也是n×n

58
00:05:10,650 --> 00:05:13,430
它的代码是这样的

59
00:05:13,450 --> 00:05:27,740
当n=1时 C[1,1]等于A[1,1]

60
00:05:27,760 --> 00:05:33,820
乘以B[1,1]

61
00:05:33,850 --> 00:05:45,890
其它情况下 我们对矩阵进行划分

62
00:05:45,910 --> 00:05:51,670
将它们分成几块

63
00:05:51,680 --> 00:05:56,820
划分矩阵需要花费多少时间？

64
00:05:56,840 --> 00:05:59,640
如果我是合格的程序猿的话

65
00:06:03,400 --> 00:06:08,830
哈？ 不花时间 或者它实际上

66
00:06:08,860 --> 00:06:11,810
花费极少的时间 是O(1)的时间

67
00:06:11,830 --> 00:06:14,400
没错 因为所有这些

68
00:06:14,410 --> 00:06:15,870
都只是下标运算

69
00:06:15,890 --> 00:06:17,680
你还要做改变下标的运算

70
00:06:17,710 --> 00:06:20,910
你现在传参是 C[1,1] A[1,1] 这些

71
00:06:20,940 --> 00:06:23,170
而不仅仅是A B C

72
00:06:23,200 --> 00:06:25,190
所以传参和整理的操作

73
00:06:25,200 --> 00:06:26,770
就会多了一定的开销

74
00:06:26,780 --> 00:06:28,700
但基本上是O(1)的时间

75
00:06:28,720 --> 00:06:35,590
大致是O(1)的时间

76
00:06:35,610 --> 00:06:38,310
这是划分矩阵的时间复杂度

77
00:06:38,330 --> 00:06:39,940
因为只是做下标运算

78
00:06:39,960 --> 00:06:43,160
我们要做的就是 在这过程中

79
00:06:43,170 --> 00:06:44,890
要注意跟踪下标的变化

80
00:06:44,910 --> 00:06:48,770
明白吧？ 有什么问题吗？

81
00:06:48,800 --> 00:06:54,730
跟得上吧？ 很好 这是个很标准的程序

82
00:06:54,750 --> 00:07:07,700
然后 我们递归地衍生出乘法

83
00:07:07,720 --> 00:07:20,700
衍生相乘这些子矩阵

84
00:07:34,740 --> 00:07:38,830
——继续 C_21 A_21……

85
00:07:38,860 --> 00:07:51,850
B_11 n/2 然后是C_22 A_21……

86
00:07:51,870 --> 00:07:57,880
跨过楚河汉界继续写

87
00:07:57,900 --> 00:08:02,990
我要确认下 保证段首的缩进一致

88
00:08:03,010 --> 00:08:06,830
这是段首缩进线

89
00:08:06,850 --> 00:08:08,700
我这边接着缩进线写

90
00:08:17,200 --> 00:08:32,780
现在我把结果放在T里 然后

91
00:08:55,640 --> 00:09:00,410
好的 我把那些衍生递归乘法都写全了

92
00:09:00,430 --> 00:09:01,870
那意味着 当我做衍生时

93
00:09:01,890 --> 00:09:04,300
当我衍生出一条语句

94
00:09:04,330 --> 00:09:06,160
我就可以接着衍生下一条语句

95
00:09:06,180 --> 00:09:09,490
并执行它 即使上一条仍在执行中

96
00:09:09,510 --> 00:09:13,160
这就是多线程编程的概念所在

97
00:09:13,190 --> 00:09:15,570
我这里衍生出8条语句

98
00:09:15,600 --> 00:09:22,640
然后做什么？ 代码的下一步应该是什么？

99
00:09:22,660 --> 00:09:25,920
同步

100
00:09:25,940 --> 00:09:28,490
没错 我必须等它们跑完

101
00:09:28,520 --> 00:09:29,900
才能用到它们的结果

102
00:09:29,930 --> 00:09:37,150
所以这里进行一个同步 等待所有

103
00:09:37,170 --> 00:09:40,020
衍生的结果完成 然后呢？

104
00:09:40,070 --> 00:09:48,070
对 需要让T和C相加

105
00:09:48,080 --> 00:09:57,240
调用一个子程序

106
00:09:57,240 --> 00:09:59,460
子程序运行结束后 返回一个值

107
00:09:59,480 --> 00:10:06,180
写一下加法的代码 因为如果可以的话

108
00:10:06,210 --> 00:10:10,500
我们也用并行处理来做加法

109
00:10:10,530 --> 00:10:20,350
这里要做的是用C加T来赋值C

110
00:10:20,380 --> 00:10:27,160
把T加入到C里

111
00:10:27,190 --> 00:10:31,200
要先给基础情形写一段代码

112
00:10:31,210 --> 00:10:38,870
然后再写划分的代码  因为我们打算

113
00:10:38,890 --> 00:10:40,970
跟之前一样 也用分治法来做

114
00:10:40,990 --> 00:10:43,050
而这个 实际上简单很多

115
00:10:43,070 --> 00:10:49,430
我们只需要衍生 加上C_11

116
00:10:49,450 --> 00:10:56,300
T_11  n/2  C_12  T_12

117
00:10:56,320 --> 00:11:03,590
n/2  C_21  T_21  n/2

118
00:11:03,610 --> 00:11:11,470
C_22  T_22  n/2 然后是同步

119
00:11:13,540 --> 00:11:21,710
然后返回结果 我们这里所做的

120
00:11:21,730 --> 00:11:24,920
只是将其分成四个区 然后衍生下去

121
00:11:24,940 --> 00:11:28,500
就是这样 等它们全部完成时

122
00:11:28,520 --> 00:11:29,840
再返回结果

123
00:11:29,860 --> 00:11:38,270
关于这些代码的执行 还有没有问题？

124
00:11:38,300 --> 00:11:40,160
那么 记住在这里

125
00:11:40,180 --> 00:11:41,820
底层有一个调度程序

126
00:11:41,840 --> 00:11:43,510
它负责调度这些运算给处理器

127
00:11:43,540 --> 00:11:46,220
而我们需要考虑的是

128
00:11:46,240 --> 00:11:47,890
调度程序的性能如何

129
00:11:47,910 --> 00:11:50,280
在上一节课

130
00:11:50,300 --> 00:11:52,920
我们学习了两种重要的度量方法

131
00:11:52,940 --> 00:11:57,830
它们就是用来

132
00:11:57,850 --> 00:12:00,930
预测任意数目的处理器性能的

133
00:12:00,950 --> 00:12:03,140
是哪两个度量方法？

134
00:12:06,710 --> 00:12:09,540
对了 T_1和T无穷 它们还有个名字

135
00:12:09,560 --> 00:12:13,780
T_1是功

136
00:12:13,800 --> 00:12:19,560
很好 T无穷是关键路径长度

137
00:12:19,600 --> 00:12:22,650
你要在关键路径长度上做功

138
00:12:22,680 --> 00:12:24,630
如果知道关键路径长度上做的功

139
00:12:24,650 --> 00:12:27,190
我们就可以知道

140
00:12:27,220 --> 00:12:34,290
程序的并行度如何

141
00:12:34,310 --> 00:12:36,490
然后我们就能知道要用多少处理器

142
00:12:36,520 --> 00:12:38,310
来运行这个程序才合适

143
00:12:38,330 --> 00:12:42,730
我们来做一下分析

144
00:12:46,720 --> 00:12:52,510
设Mp(n)做为

145
00:12:52,530 --> 00:13:03,250
p个处理器执行矩阵相乘代码的时间

146
00:13:03,270 --> 00:13:09,710
同理 Ap(n)则为

147
00:13:09,740 --> 00:13:13,310
执行矩阵相加代码的时间

148
00:13:13,330 --> 00:13:17,880
我们首先要分析的是功

149
00:13:17,900 --> 00:13:20,670
我们理想的功的多少?

150
00:13:24,170 --> 00:13:29,760
当分析功的时候 我们希望它是多少？

151
00:13:36,970 --> 00:13:38,710
我们当然希望它越小越好

152
00:13:38,740 --> 00:13:44,570
用我的头发担保 那要相对什么基准才算小？

153
00:13:48,660 --> 00:13:51,050
如果我们只是写一些

154
00:13:51,070 --> 00:13:52,590
没有并行运算的代码

155
00:13:52,610 --> 00:13:56,900
当只有一个处理器时 我们希望并行代码

156
00:13:56,970 --> 00:14:01,640
能够和串行代码一样快

157
00:14:01,710 --> 00:14:03,020
跟一般解决这个问题的代码一样快

158
00:14:04,560 --> 00:14:06,680
一般来说

159
00:14:06,700 --> 00:14:09,640
我们希望做到这样 对吧？

160
00:14:09,670 --> 00:14:17,010
那么 一般的矩阵运算是怎样的？

161
00:14:17,080 --> 00:14:19,660
没错 是n^3 当然 使用施特拉森演算法

162
00:14:19,680 --> 00:14:24,830
或者其它比n^3更快的算法

163
00:14:24,870 --> 00:14:26,550
但对于这个问题

164
00:14:26,570 --> 00:14:28,870
我们只需要关注n^3

165
00:14:28,890 --> 00:14:31,830
我打算让你们用施特拉森演算法进行练习

166
00:14:31,860 --> 00:14:33,250
分析一下功

167
00:14:33,270 --> 00:14:37,220
因为我们有一个做加法的子程序

168
00:14:37,240 --> 00:14:41,500
在乘法代码里面会用到

169
00:14:41,520 --> 00:14:45,430
那么 我们就从加法开始分析

170
00:14:45,450 --> 00:14:49,950
A_1(n)等于

171
00:14:49,970 --> 00:14:54,770
这一块 有谁能给出一个递归式吗？

172
00:14:54,790 --> 00:14:58,570
有没有一条递归式能帮助我们

173
00:14:58,590 --> 00:15:00,430
求出这些代码的运行时间

174
00:15:08,820 --> 00:15:12,430
这基本上是第二周的内容

175
00:15:12,460 --> 00:15:14,580
实际上 第一节课就讲了

176
00:15:14,600 --> 00:15:18,440
这好像在第二节课 最多第三节课的内容

177
00:15:20,700 --> 00:15:23,670
A_1(n)等于……

178
00:15:32,720 --> 00:15:34,210
加上θ(1) 是的

179
00:15:34,230 --> 00:15:41,680
没错 那么我们就有四个

180
00:15:41,700 --> 00:15:43,550
大小为n/2的问题需要解决

181
00:15:43,570 --> 00:15:48,120
要理解这个 你甚至不需要知道

182
00:15:48,140 --> 00:15:49,320
我们是在搞并行运算

183
00:15:49,340 --> 00:15:52,110
因为这是在一台串行机器上执行的

184
00:15:52,130 --> 00:15:56,520
它基本也是这样的

185
00:15:56,540 --> 00:15:59,120
所以我们有四个大小为n/2的问题

186
00:15:59,160 --> 00:16:01,310
再加上θ(1)即为工作总量

187
00:16:01,330 --> 00:16:03,140
对于这个递归式的推导 还有什么问题吗？

188
00:16:03,160 --> 00:16:06,970
是不是非常直观？

189
00:16:06,990 --> 00:16:09,190
有不懂直说喔亲

190
00:16:09,220 --> 00:16:12,160
那么这个递归式的解是什么？

191
00:16:12,180 --> 00:16:16,910
对了 θ(n^2)

192
00:16:16,930 --> 00:16:21,390
怎么知道的？没错 主方法

193
00:16:21,410 --> 00:16:26,650
n的log4(以2为底)次幂 正好是n^2

194
00:16:26,670 --> 00:16:30,190
与θ(1)比较一下

195
00:16:30,210 --> 00:16:32,660
这块毫无疑问占了主导地位

196
00:16:32,690 --> 00:16:34,570
所以这就是答案

197
00:16:34,590 --> 00:16:37,890
n的log4(以2为底)次幂 即n^2

198
00:16:37,920 --> 00:16:39,850
大家都记得吧？

199
00:16:39,870 --> 00:16:41,120
所以 大家都得抓紧学习了

200
00:16:41,140 --> 00:16:43,890
因为这里都是递归

201
00:16:43,910 --> 00:16:45,090
以及分治法等的内容

202
00:16:45,110 --> 00:16:46,500
期末肯定会考

203
00:16:46,520 --> 00:16:50,190
即使我们已经好几个月没有接触过

204
00:16:50,220 --> 00:16:52,500
这个结果很好

205
00:16:52,530 --> 00:16:53,740
它与串行运算是一样的

206
00:16:53,760 --> 00:16:55,510
如果要相加两个n×n的矩阵

207
00:16:55,530 --> 00:16:58,780
需要花费多少时间？n^2的时间

208
00:16:58,810 --> 00:17:00,640
因为输入的矩阵大小为n^2

209
00:17:00,660 --> 00:17:03,690
那你不可能比这个大小还小

210
00:17:03,710 --> 00:17:07,920
你必须关注输入的每个细节

211
00:17:07,940 --> 00:17:18,130
现在继续分析矩阵相乘的功

212
00:17:18,150 --> 00:17:21,040
那么再一次 我们要求这里的递归式

213
00:17:28,840 --> 00:17:31,560
这里的递归式是什么？

214
00:17:35,070 --> 00:17:43,280
多少？不对

215
00:17:43,310 --> 00:17:48,080
8 是的 很好

216
00:17:48,110 --> 00:17:53,080
8 M_1(n/2)加上

217
00:17:57,670 --> 00:18:01,960
没错 另外还有θ(n^2)

218
00:18:02,000 --> 00:18:04,580
还有额外的一个θ(1)

219
00:18:04,600 --> 00:18:08,710
我们把它算进θ(n^2)里

220
00:18:08,730 --> 00:18:15,170
上下不是惊人地相似吗？ 非常好

221
00:18:15,190 --> 00:18:19,340
那么这一个的解是多少？

222
00:18:26,310 --> 00:18:29,940
θ(n^3) 为什么？

223
00:18:29,960 --> 00:18:34,760
童鞋们 动动你们的生锈的脑袋吧

224
00:18:34,770 --> 00:18:36,650
我都听到它们氧化的声音了

225
00:18:36,680 --> 00:18:38,610
为什么是这个？

226
00:18:38,630 --> 00:18:41,350
对 要用主方法 因为我们观察到…

227
00:18:41,370 --> 00:18:42,430
我们参照的是什么？

228
00:18:42,470 --> 00:18:46,690
对 n的log²8次幂 即n^3相对于n^2

229
00:18:46,710 --> 00:18:49,290
这部分决定了是θ(n^3)

230
00:18:49,310 --> 00:18:52,640
所以 这与串行结果是一样

231
00:18:52,660 --> 00:18:54,130
与串行计算的时间度相同

232
00:18:54,150 --> 00:18:55,400
与串行计算一样

233
00:18:55,420 --> 00:18:57,380
很好 我们知道

234
00:18:57,400 --> 00:18:59,960
我们的并行代码在单处理器上

235
00:18:59,980 --> 00:19:05,380
与它所基于的串行代码

236
00:19:05,400 --> 00:19:08,800
所执行的结果一样

237
00:19:08,820 --> 00:19:10,990
也就是说 我们可以做到这一点

238
00:19:11,010 --> 00:19:13,840
如果去掉所有的衍生和同步函数

239
00:19:13,860 --> 00:19:15,980
这就是一个

240
00:19:16,010 --> 00:19:18,690
非常完美的伪代码

241
00:19:18,710 --> 00:19:22,500
描述了算法的运行时间

242
00:19:22,530 --> 00:19:24,960
说错了 是描述了串行算法

243
00:19:24,980 --> 00:19:29,760
它们的运行时间也是一样的

244
00:19:29,790 --> 00:19:31,680
喜闻乐见 对吧？

245
00:19:31,710 --> 00:19:37,890
现在看一下新的内容 关键路径长度

246
00:19:45,570 --> 00:19:49,120
这里有一个A_∞(n)

247
00:19:52,420 --> 00:19:56,050
呼 我们这里要加上

248
00:19:56,110 --> 00:19:58,640
这段代码的关键路径

249
00:19:58,670 --> 00:20:02,800
嗯 我们要如何

250
00:20:02,820 --> 00:20:06,450
计算代码段的关键路径？

251
00:20:23,630 --> 00:20:26,630
好吧 要把它拓展到一个DAG图里

252
00:20:26,650 --> 00:20:29,310
DAG图看起来是怎么样的？

253
00:20:29,330 --> 00:20:31,610
我的目的是什么？

254
00:20:31,640 --> 00:20:33,500
实际上 如果不想DAG图的话还会更简单点

255
00:20:33,520 --> 00:20:37,350
只需要想想代码里做了些什么

256
00:20:37,370 --> 00:20:39,160
你说？

257
00:20:43,280 --> 00:20:44,800
没错 因为它基本上

258
00:20:44,820 --> 00:20:50,110
因为四个衍生操作所衍生出的结果都一样

259
00:20:50,130 --> 00:20:53,460
而且它们是并行运作的

260
00:20:53,480 --> 00:20:56,480
那只需要看一个就好

261
00:20:56,520 --> 00:20:59,460
或者通常来说 如果衍生出好几个

262
00:20:59,480 --> 00:21:00,940
我就看在衍生出来的东西里

263
00:21:00,960 --> 00:21:03,530
拥有最大关键路径的

264
00:21:03,550 --> 00:21:08,010
那一个衍生支

265
00:21:08,030 --> 00:21:09,730
所以计算的时候

266
00:21:09,750 --> 00:21:15,150
乘法子程序的功是相加的

267
00:21:15,160 --> 00:21:18,940
而求关键路径时 则是取最大值

268
00:21:18,960 --> 00:21:20,790
我们求的是最大值

269
00:21:20,810 --> 00:21:23,820
所有子程序中的最大关键路径

270
00:21:23,840 --> 00:21:26,260
在这里它们是相等的

271
00:21:26,280 --> 00:21:28,240
那这次又是什么递归式？

272
00:21:40,140 --> 00:21:42,670
这里我们能得到什么递归式？

273
00:21:45,300 --> 00:21:52,990
对  A_∞(n/2)再加上常量

274
00:21:54,830 --> 00:21:56,530
因为这就是

275
00:21:56,560 --> 00:21:58,760
那四个里任意一个的最坏情况

276
00:21:58,780 --> 00:22:00,540
因为它们都是一样的

277
00:22:00,560 --> 00:22:02,170
它们都是同一种情况

278
00:22:02,200 --> 00:22:08,570
都要取决于一半大小的关键路径

279
00:22:08,590 --> 00:22:11,610
取决于大小为一半的情况

280
00:22:11,640 --> 00:22:17,670
大家都明白？那么它的解是多少？

281
00:22:21,270 --> 00:22:22,510
没错 θ(log n)

282
00:22:22,530 --> 00:22:28,420
这只是再一次使用公式法 第二次了

283
00:22:28,460 --> 00:22:31,470
因为这个的解是

284
00:22:31,490 --> 00:22:35,170
n的log1(以2为底)次幂

285
00:22:35,190 --> 00:22:43,010
也就是n的0次幂 所以在这边是1

286
00:22:43,030 --> 00:22:45,280
在这里 拿它和1作对比

287
00:22:45,310 --> 00:22:46,620
它们是一样的

288
00:22:46,640 --> 00:22:49,910
因此乘上一个额外的log n

289
00:22:49,930 --> 00:22:53,860
额外的一个log n

290
00:22:53,880 --> 00:22:56,930
主方法的第二种情况

291
00:22:56,950 --> 00:22:59,450
非常好

292
00:22:59,470 --> 00:23:02,050
答案非常好

293
00:23:02,080 --> 00:23:04,160
因为关键路径很短

294
00:23:04,180 --> 00:23:05,960
log n相对于功n^2

295
00:23:05,980 --> 00:23:10,380
那么 我们来...

296
00:23:10,400 --> 00:23:15,040
这个会更有意思一点

297
00:23:15,060 --> 00:23:19,200
但又不会更难  这个等于多少？

298
00:23:19,220 --> 00:23:23,020
递归式是多少？

299
00:23:23,040 --> 00:23:29,830
乘积的关键路径？

300
00:23:35,140 --> 00:23:37,590
再一次 它会是

301
00:23:37,610 --> 00:23:40,200
并行衍生出的子程序的最大值

302
00:23:40,210 --> 00:23:44,650
也就是 由对称可知 它们每一个都相同

303
00:23:44,670 --> 00:23:51,430
所以这里得出什么？M_∞(n/2)

304
00:23:51,450 --> 00:23:57,540
加上θ(log n) 这个θ(log n)是怎么来的？

305
00:23:57,560 --> 00:24:00,280
对 从相加函数里得来的

306
00:24:00,300 --> 00:24:04,490
它是相加函数里的关键路径

307
00:24:04,510 --> 00:24:11,670
怪了 为什么不是这些衍生操作的最大值？

308
00:24:12,160 --> 00:24:13,930
你会说 当衍生出一些运算时

309
00:24:13,950 --> 00:24:14,990
你都应该要先做...

310
00:24:15,010 --> 00:24:20,260
没错 你要先进行同步

311
00:24:20,300 --> 00:24:24,240
同步意味着 要等所有运算都完成

312
00:24:24,260 --> 00:24:25,600
所以 这一块你只能取最大值

313
00:24:25,620 --> 00:24:28,220
等同步完了 你要做的是相加

314
00:24:28,240 --> 00:24:30,750
相加是在同步之后

315
00:24:30,770 --> 00:24:34,000
等所有并行的衍生处理完成 再相加

316
00:24:34,020 --> 00:24:35,750
这就是要取最大值的原因

317
00:24:35,770 --> 00:24:38,450
一旦进行同步

318
00:24:38,470 --> 00:24:40,540
意味着并行的结束

319
00:24:40,560 --> 00:24:41,970
你必须等待所有工作的完成

320
00:24:41,990 --> 00:24:43,560
加法跟前面的运算不是并行的

321
00:24:43,580 --> 00:24:45,220
而是在并行处理之后进行的

322
00:24:45,240 --> 00:24:46,970
所以无论这里的关键路径是什么

323
00:24:46,990 --> 00:24:50,670
即使我有无限个处理器

324
00:24:50,690 --> 00:24:52,740
在这里 我还是要等前面都做完

325
00:24:52,770 --> 00:24:55,060
因此这就使得

326
00:24:55,130 --> 00:25:00,420
接下来的程序执行...

327
00:25:00,530 --> 00:25:01,620
无论加法这块的关键路径是多少

328
00:25:01,640 --> 00:25:03,370
都要等到同步完成才开始

329
00:25:03,390 --> 00:25:04,800
大家都清楚了吗？

330
00:25:04,820 --> 00:25:08,670
所以得到这个递归

331
00:25:08,680 --> 00:25:11,480
最后的解是多少？

332
00:25:11,500 --> 00:25:23,860
对 θ(log²n) 再一次

333
00:25:23,870 --> 00:25:28,490
由主方法的第二种情况

334
00:25:28,560 --> 00:25:31,050
因为这是常数 这是log n

335
00:25:31,080 --> 00:25:35,740
它们微分后不是多项式数

336
00:25:35,760 --> 00:25:38,420
也不是一个log因子

337
00:25:38,440 --> 00:25:40,820
在这种情况下我们要做的是

338
00:25:40,840 --> 00:25:42,480
乘上一个额外的系数

339
00:25:42,520 --> 00:25:46,530
正如我说的 复习下主方法是有帮助的

340
00:25:46,550 --> 00:25:49,580
非常好

341
00:25:49,600 --> 00:26:01,690
现在看一下得到的并行度

342
00:26:01,710 --> 00:26:11,920
我们在这边写乘法的并行度吧

343
00:26:11,940 --> 00:26:19,220
对于乘法的并行度是多少？

344
00:26:19,240 --> 00:26:20,900
并行度的公式是什么？

345
00:26:20,910 --> 00:26:31,520
对这个问题 我们用P帽来表示并行度

346
00:26:35,940 --> 00:26:38,610
并行度是多少？

347
00:26:38,630 --> 00:26:39,750
我取的比值是多少？

348
00:26:39,790 --> 00:26:49,800
对 它是M_1(n)/M_∞(n)

349
00:26:49,820 --> 00:26:54,840
等于 上面是n^3

350
00:26:54,860 --> 00:27:03,470
下面是n^2  啊 是log²n 不好意思

351
00:27:03,490 --> 00:27:09,190
这就是并行度

352
00:27:09,210 --> 00:27:12,610
这表示 可以在这么多的处理器上运行

353
00:27:12,630 --> 00:27:14,600
而且会得到线性的加速

354
00:27:14,620 --> 00:27:18,250
如果运行的处理器数量多于并行度

355
00:27:18,270 --> 00:27:21,100
就不再期望能得到线性的加速了

356
00:27:21,120 --> 00:27:25,320
因为会到达极限 我们期望的是

357
00:27:25,340 --> 00:27:27,790
运行时间能跟关键路径长度成正比

358
00:27:27,800 --> 00:27:29,770
但投入过多的处理器

359
00:27:29,790 --> 00:27:31,710
并不能带来很大的帮助

360
00:27:31,730 --> 00:27:35,290
懂吗？看一下这个

361
00:27:35,310 --> 00:27:37,330
感觉一下 这到底是怎么回事

362
00:27:37,360 --> 00:27:40,830
让我们设想一下 常数的大小不是很重要

363
00:27:40,860 --> 00:27:43,500
比如有1000乘以1000大小的矩阵

364
00:27:43,520 --> 00:27:49,160
在这种情况下

365
00:27:49,190 --> 00:28:06,010
并行度就是1000^3/(log 1000)^2

366
00:28:06,030 --> 00:28:13,140
log 1000是多少？近似等于10

367
00:28:13,160 --> 00:28:16,010
以2为底的log 1000大概是10

368
00:28:16,030 --> 00:28:21,420
所以这是10^2 所以并行度大概是10^7

369
00:28:21,440 --> 00:28:22,960
10^7是多大？

370
00:28:22,980 --> 00:28:25,780
一千万个处理器

371
00:28:25,800 --> 00:28:32,000
谁知道有什么机器有一千万个处理器吗？

372
00:28:32,020 --> 00:28:36,390
你们所知道的最多处理器有多少？

373
00:28:40,390 --> 00:28:41,900
好吧 差不多

374
00:28:41,920 --> 00:28:46,650
IBM的“蓝色牛仔裤”有超多处理器

375
00:28:46,670 --> 00:28:51,640
超过一万个

376
00:28:51,660 --> 00:28:55,090
但那是一位处理器

377
00:28:55,110 --> 00:29:02,170
所以这实际上是非常大的数

378
00:29:02,190 --> 00:29:15,550
因此并行度也远远大于

379
00:29:15,570 --> 00:29:19,200
典型、实际的处理器数量

380
00:29:19,220 --> 00:29:22,580
所以 我们就能期望

381
00:29:22,600 --> 00:29:24,410
并行能起效 而且效果不错

382
00:29:24,430 --> 00:29:29,890
因为我们从来不会

383
00:29:29,910 --> 00:29:32,970
因为算法的限制而降低性能

384
00:29:33,000 --> 00:29:34,960
然而 确实有一些技巧能提升性能

385
00:29:34,980 --> 00:29:37,180
其中一个是 在这段代码里

386
00:29:37,190 --> 00:29:40,040
实际上有一些开销

387
00:29:40,060 --> 00:29:42,070
没有表示出来

388
00:29:42,090 --> 00:29:44,300
因为没有实际运行给你们看

389
00:29:44,320 --> 00:29:45,410
虽然可以跑一下

390
00:29:45,430 --> 00:29:50,560
那就是这个临时矩阵T

391
00:29:50,570 --> 00:29:56,430
如果查看程序的执行堆栈

392
00:29:56,450 --> 00:30:00,160
我们总是在分配T 然后又释放掉

393
00:30:00,190 --> 00:30:01,220
我要说的是

394
00:30:01,240 --> 00:30:04,320
当你实际查看真实代码的性能时

395
00:30:04,340 --> 00:30:06,510
就像现在 你有一定算法知识背景

396
00:30:06,540 --> 00:30:09,120
当你准备好去做一个彻底的调查时

397
00:30:09,140 --> 00:30:11,040
当然 你关心的

398
00:30:11,060 --> 00:30:15,870
将不仅仅是算法的渐近界限

399
00:30:15,890 --> 00:30:17,000
你更关心的是

400
00:30:17,020 --> 00:30:19,930
得到实际的性能参数的信息

401
00:30:19,950 --> 00:30:22,170
那么 你就会自然地关注一些常量

402
00:30:22,190 --> 00:30:23,770
你可能会发现

403
00:30:23,790 --> 00:30:26,060
如果有一个大型临时变量

404
00:30:26,080 --> 00:30:28,500
它实际上会花费很多开销

405
00:30:28,530 --> 00:30:30,920
而实际上 有种很常见情形是——

406
00:30:30,940 --> 00:30:32,770
当你看到现实中的代码

407
00:30:32,790 --> 00:30:34,110
如果你能优化存储空间

408
00:30:34,130 --> 00:30:36,520
那你同时也能优化时间

409
00:30:36,550 --> 00:30:38,310
如果你的代码占用更少的空间

410
00:30:38,330 --> 00:30:42,690
实际上 它也会花费更少的时间

411
00:30:42,700 --> 00:30:45,490
大致有一个常量级的优势

412
00:30:45,510 --> 00:30:47,620
但这些常量优势是可叠加的

413
00:30:47,640 --> 00:30:50,300
并造成较大影响

414
00:30:50,320 --> 00:30:52,090
最终决定 是别人的代码更快

415
00:30:52,110 --> 00:30:53,410
还是你的更快

416
00:30:53,430 --> 00:30:55,530
如果你们的基本算法都是一样的话

417
00:30:55,540 --> 00:30:58,590
所以在这种情况下 思路就是

418
00:30:58,610 --> 00:31:02,060
通过并行化 来去除隐藏开销

419
00:31:02,090 --> 00:31:05,180
因为我们有

420
00:31:05,200 --> 00:31:09,110
很多的并行运算来提高空间效率

421
00:31:14,110 --> 00:31:17,120
好的 我们的目的是去除T

422
00:31:21,870 --> 00:31:26,050
好的 乾坤大挪移

423
00:31:32,160 --> 00:31:35,070
谁知道是在这里如何去掉T的？

424
00:31:42,980 --> 00:31:44,680
怎么甩掉这个临时矩阵？

425
00:31:57,330 --> 00:31:58,580
啥?

426
00:32:11,660 --> 00:32:14,640
如果只是把它加到C里

427
00:32:14,680 --> 00:32:16,390
但问题是 如果这样做

428
00:32:16,420 --> 00:32:17,610
如果大家都加到C里

429
00:32:17,630 --> 00:32:21,630
那两个子运算之间会产生干扰

430
00:32:21,640 --> 00:32:23,960
现在 有很多方法都是可行的

431
00:32:23,980 --> 00:32:25,460
但你必须考虑一下

432
00:32:25,480 --> 00:32:26,650
一些我们不会细说的问题

433
00:32:26,670 --> 00:32:28,020
比如互斥之类的

434
00:32:28,030 --> 00:32:29,930
来保证比如当你做更新时

435
00:32:29,950 --> 00:32:31,030
其他人是更新不了的

436
00:32:31,050 --> 00:32:32,440
不会出现竞争的情况

437
00:32:32,470 --> 00:32:34,260
但实际上你可以这样做

438
00:32:34,280 --> 00:32:35,830
因为这里没有竞争的情况

439
00:32:40,730 --> 00:32:44,660
对 没错 是这样的

440
00:32:44,680 --> 00:32:49,190
方法就是将其衍生成四步

441
00:32:49,210 --> 00:32:52,930
全部都更新原来的C

442
00:32:52,950 --> 00:32:57,290
然后再衍生四个新的再把它们的值加起来

443
00:32:57,310 --> 00:33:01,870
所以这部分代码又称为“乘加”

444
00:33:10,730 --> 00:33:16,670
用来计算C=C+A*B

445
00:33:16,700 --> 00:33:21,170
所以最后要加进来

446
00:33:21,190 --> 00:33:23,300
一开始要把C归零

447
00:33:23,320 --> 00:33:25,950
但这个的代码就跟之前

448
00:33:25,970 --> 00:33:31,320
θ(n^2)的加法代码很像

449
00:33:31,340 --> 00:33:33,920
还有θ(log n)关键路径的代码

450
00:33:33,940 --> 00:33:35,560
所以这不是

451
00:33:35,580 --> 00:33:37,840
我们必须要重点应付的部分

452
00:33:37,860 --> 00:33:43,820
这是代码 再一次

453
00:33:43,840 --> 00:33:46,060
分析基础情况 以及划分部分

454
00:33:48,870 --> 00:33:50,760
这些就不再详细地写出代码了

455
00:33:50,780 --> 00:34:07,210
然后为(C_11, A_11, B_11, n/2)衍生一个乘加函数

456
00:34:07,230 --> 00:34:12,620
然后在做几步 直到第四步

457
00:34:23,720 --> 00:34:30,500
然后做一步同步 然后再做另外四步——

458
00:34:59,420 --> 00:35:02,270
——最后完成时 再进行同步

459
00:35:09,330 --> 00:35:13,540
大家都理解这些代码吗?

460
00:35:13,550 --> 00:35:17,450
可以看出 基本上都在进行相同的计算

461
00:35:17,460 --> 00:35:19,710
实际上 不需要再调用相加函数了

462
00:35:19,740 --> 00:35:21,150
因为我们已经把它

463
00:35:21,170 --> 00:35:24,660
归为乘法的一部分了 因为它包括了相加运算

464
00:35:24,680 --> 00:35:25,840
但必须要先初始化

465
00:35:25,860 --> 00:35:30,110
在这种情况下 要对矩阵进行初始化

466
00:35:30,140 --> 00:35:34,420
那么 这是另一个阶段

467
00:35:34,450 --> 00:35:38,790
大家理解这段代码的语义吧？

468
00:35:38,810 --> 00:35:40,260
我们来分析一下

469
00:35:45,580 --> 00:35:51,560
对于n的乘加的功是多少？

470
00:35:58,910 --> 00:36:03,730
基本是一样的 对不对？

471
00:36:03,750 --> 00:36:09,040
是θ(n^3) 因为这里的串行代码

472
00:36:09,060 --> 00:36:11,260
几乎与上面的串行代码是一模一样的

473
00:36:11,280 --> 00:36:13,370
虽然不全等

474
00:36:13,390 --> 00:36:16,590
但基本是相同的递归

475
00:36:16,600 --> 00:36:17,900
除了没有相加函数

476
00:36:17,920 --> 00:36:20,450
得到的是相同的递归

477
00:36:20,480 --> 00:36:24,700
但这里有θ(1) 噢不对 θ(1)是在上面

478
00:36:24,720 --> 00:36:30,130
所以 还是同样的解θ(n^3)

479
00:36:30,150 --> 00:36:36,740
好的 我想这并不难理解

480
00:36:36,760 --> 00:36:42,130
至于关键路径长度

481
00:36:42,150 --> 00:36:47,200
写在这里  所以n的乘加运算

482
00:36:47,230 --> 00:36:50,160
这段代码的递归式是什么？

483
00:37:00,690 --> 00:37:12,200
没错 2MA_∞(n/2) 差不多了

484
00:37:12,220 --> 00:37:16,210
还有θ(1) 加上θ(1)

485
00:37:16,240 --> 00:37:20,040
所以重点是

486
00:37:20,060 --> 00:37:21,840
对于关键路径 我们有

487
00:37:21,860 --> 00:37:24,620
我们衍生出这四步

488
00:37:24,640 --> 00:37:26,740
取其中最大值 无论这些是多少

489
00:37:26,760 --> 00:37:29,440
因为其中任意一个都是对称的

490
00:37:29,460 --> 00:37:33,470
然后我需要等它做完

491
00:37:33,490 --> 00:37:35,600
然后再做一次

492
00:37:35,630 --> 00:37:37,530
所以这里的同步 再一次

493
00:37:37,550 --> 00:37:39,630
在分析中 我们可以看做是

494
00:37:39,640 --> 00:37:42,260
关键路径的相加

495
00:37:42,280 --> 00:37:44,960
也等同于在并行衍生中

496
00:37:44,980 --> 00:37:49,270
取最大值的操作 大家明白了没?

497
00:37:49,290 --> 00:37:51,000
所以得到这个递归

498
00:37:51,020 --> 00:37:55,730
2MA_∞(n/2)+θ(1)

499
00:37:55,750 --> 00:37:57,510
它的解是多少？

500
00:38:00,700 --> 00:38:01,890
等于θ(n)

501
00:38:01,910 --> 00:38:08,850
因为n的log 2(以2为底)次幂等于n

502
00:38:08,870 --> 00:38:12,220
它比1大 所以是θ(n)

503
00:38:16,260 --> 00:38:28,480
那么 并行度P帽

504
00:38:28,500 --> 00:38:38,080
等于MA_1(n)/MA_∞(n)

505
00:38:38,100 --> 00:38:43,920
在这个情况下 n^3/n 即θ(n^2)

506
00:38:43,950 --> 00:38:49,820
举个例子 对于1000乘1000的矩阵

507
00:38:49,830 --> 00:38:54,140
顺便说一下 现在1000乘1000被认为只是一个小矩阵

508
00:38:54,170 --> 00:39:00,630
因为只有100万个元

509
00:39:00,660 --> 00:39:03,470
你可以毫无压力地放到你的笔记本里

510
00:39:03,490 --> 00:39:09,060
但对于1000乘1000矩阵

511
00:39:09,080 --> 00:39:15,650
并行度大概是10^6

512
00:39:15,670 --> 00:39:19,730
所以再一次

513
00:39:19,750 --> 00:39:25,060
在现在 并行度都足够让我们跑程序的

514
00:39:25,080 --> 00:39:28,440
而实际应用中 它的运行效率更快

515
00:39:36,740 --> 00:39:44,080
——因为使用了较少的空间

516
00:39:44,080 --> 00:39:46,510
所以这就是博弈

517
00:39:46,530 --> 00:39:52,320
你会经常在学术论文中见到博弈论

518
00:39:52,330 --> 00:39:53,680
如果你查阅研究论文 你会发现

519
00:39:53,700 --> 00:39:56,010
人们经常努力去争取最大的并行度

520
00:39:56,040 --> 00:39:59,200
这是一个不错的博弈

521
00:39:59,220 --> 00:40:01,950
但不是必要的唯一博弈

522
00:40:01,960 --> 00:40:03,660
特别是 当你有很大的并行度时

523
00:40:03,690 --> 00:40:05,220
你还可以很容易地做一件事

524
00:40:05,250 --> 00:40:06,470
就是放弃一部分并行度

525
00:40:06,490 --> 00:40:09,420
从而让你的代码去获得其他方面的性能

526
00:40:09,450 --> 00:40:11,820
这就是一个很好的例子

527
00:40:11,840 --> 00:40:15,360
事实上 这是课后的练习

528
00:40:15,380 --> 00:40:18,910
你其实能取得n^3的功

529
00:40:18,940 --> 00:40:23,630
θ(n^3)的功 还有log n的关键路径

530
00:40:23,650 --> 00:40:27,410
所以说 甚至比之前那两个算法更好

531
00:40:27,430 --> 00:40:28,580
从并行度来看的话

532
00:40:28,600 --> 00:40:33,000
所以 它给出了n^3/log n的并行度

533
00:40:33,030 --> 00:40:34,040
这是课后习题

534
00:40:34,060 --> 00:40:37,040
然后 我还提到了另一个不错的课后练习

535
00:40:37,070 --> 00:40:38,840
就是把施特拉森算法并行化

536
00:40:38,870 --> 00:40:42,070
用施特拉森算法进行同样的编程

537
00:40:42,090 --> 00:40:43,990
然后分析 施特拉森代码的关键路径

538
00:40:44,010 --> 00:40:48,120
还有并行度是多少？

539
00:40:48,140 --> 00:40:53,050
对于矩阵乘法有什么疑问吗？

540
00:40:53,070 --> 00:40:56,440
说吧？

541
00:41:00,920 --> 00:41:03,090
对了 它就会给...

542
00:41:03,110 --> 00:41:06,070
给关键路径加上一个log n

543
00:41:06,090 --> 00:41:08,370
和n相比就不算什么了

544
00:41:08,400 --> 00:41:11,010
听不清

545
00:41:11,030 --> 00:41:15,240
要先保证C一开始归零

546
00:41:15,260 --> 00:41:19,530
即必须把所有元设为0

547
00:41:19,550 --> 00:41:23,900
这样才能给你n^2的功

548
00:41:23,930 --> 00:41:25,450
和这里的n^3的功相比

549
00:41:25,470 --> 00:41:26,870
又不算什么了

550
00:41:26,880 --> 00:41:31,600
它在关键路径上有额外的log n的开销

551
00:41:31,510 --> 00:41:32,810
和所之前的θ(n)相比

552
00:41:32,840 --> 00:41:34,090
又不算什么了

553
00:41:36,260 --> 00:41:40,340
对于矩阵乘法还有其它问题吗？

554
00:41:40,360 --> 00:41:47,660
我都说了 这些都是第二周的内容

555
00:41:47,680 --> 00:41:49,030
课堂上讲过的内容

556
00:41:49,050 --> 00:41:59,090
听说你想发表意见？ 是的 可以

557
00:41:59,110 --> 00:42:01,060
你可以这样

558
00:42:01,080 --> 00:42:04,580
实际去研究下的话 你会发现这很有趣

559
00:42:04,610 --> 00:42:06,380
其实等下我就会讲到

560
00:42:06,410 --> 00:42:09,110
我们会在课后写一篇研究论文

561
00:42:09,130 --> 00:42:11,520
因为实际上

562
00:42:11,550 --> 00:42:12,930
这些是很有意思的开放性话题

563
00:42:12,950 --> 00:42:25,040
我们继续介绍一些

564
00:42:25,060 --> 00:42:28,030
你们认为在几周前就摆脱了的东西

565
00:42:28,050 --> 00:42:34,450
那就是排序的话题

566
00:42:34,470 --> 00:42:43,580
回到排序 我们想要实现并行排序

567
00:42:43,610 --> 00:42:47,530
这是非常重要的问题

568
00:42:47,550 --> 00:42:53,340
让我们看一下 如果我要选一种排序算法

569
00:42:53,350 --> 00:42:55,270
最适合拿来并行化的话

570
00:42:55,290 --> 00:42:57,170
哪一种排序算法最适合并行化?

571
00:42:57,190 --> 00:43:01,130
快速排序

572
00:43:01,150 --> 00:43:03,640
很好的一种排序算法 快速排序

573
00:43:03,660 --> 00:43:05,700
非常适合拿来并行化和做分析

574
00:43:05,720 --> 00:43:07,080
但要记得 快速排序相比其它排序法

575
00:43:07,100 --> 00:43:09,300
分析起来会比较复杂一点

576
00:43:09,320 --> 00:43:11,340
还有没有其他的算法

577
00:43:11,360 --> 00:43:12,660
会比较容易进行并行化？

578
00:43:12,680 --> 00:43:14,730
归并排序

579
00:43:14,760 --> 00:43:19,860
什么时候学的归并排序？第一天

580
00:43:19,890 --> 00:43:22,630
好 那就归并排序

581
00:43:22,650 --> 00:43:24,360
因为它更容易分析

582
00:43:24,380 --> 00:43:26,030
用快速排序同样也可以

583
00:43:26,060 --> 00:43:32,470
这里是归并排序

584
00:43:32,490 --> 00:43:39,980
为A[p…r]排序

585
00:43:40,010 --> 00:43:44,870
如果p小于r

586
00:43:44,890 --> 00:43:51,630
则取中间的元素

587
00:43:51,650 --> 00:44:01,340
然后进行衍生 因为我们要... 好好回想下吧

588
00:44:01,350 --> 00:44:03,550
当进行归并排序时 首先要递归地

589
00:44:03,570 --> 00:44:05,190
为两个子数组排序

590
00:44:05,210 --> 00:44:07,120
所以没理由不并行化

591
00:44:07,140 --> 00:44:08,860
并行地跑下来

592
00:44:08,890 --> 00:44:14,710
衍生出(A,p,q)的归并排序

593
00:44:14,740 --> 00:44:26,340
还有然后衍生出来的(A,q+1,r)

594
00:44:26,360 --> 00:44:36,920
然后等这它们运算完

595
00:44:36,950 --> 00:44:39,380
别忘了同步

596
00:44:39,400 --> 00:44:42,980
穷路同步 从不同富

597
00:44:43,000 --> 00:44:47,580
然后在完成这些之后做什么？

598
00:44:47,600 --> 00:44:52,240
是的 归并

599
00:44:52,260 --> 00:45:00,530
归并(A,p,q,r)

600
00:45:00,550 --> 00:45:19,790
也就是归并A(p…q)与A(q+1…r)

601
00:45:19,810 --> 00:45:24,470
一旦归并结束 排序就完成了

602
00:45:24,490 --> 00:45:30,750
这跟之前第一天看的代码是一样的

603
00:45:30,770 --> 00:45:32,910
除了这同步里多了几步衍生运算

604
00:45:32,930 --> 00:45:54,300
分析一下 这里T_1(n)表示功

605
00:45:54,320 --> 00:45:57,450
这个的递归式是什么？

606
00:45:57,470 --> 00:46:04,770
这真的在第一天讲过 是吧？

607
00:46:04,800 --> 00:46:07,660
实际上在第一天做过这分析

608
00:46:07,690 --> 00:46:12,730
递归式是什么？

609
00:46:12,760 --> 00:46:21,940
是2T_1(n/2)+θ(n)

610
00:46:21,960 --> 00:46:25,950
归并花费θ(n)时间的操作

611
00:46:25,970 --> 00:46:30,910
得出一个解是θ(n log n)

612
00:46:30,930 --> 00:46:33,600
即使你不知道怎么解的

613
00:46:33,630 --> 00:46:34,910
也应该知道这答案

614
00:46:34,930 --> 00:46:38,040
和串行代码的结论是一样的

615
00:46:38,060 --> 00:46:40,300
不奇怪 这正是想要的

616
00:46:40,310 --> 00:46:48,520
关键路径长度 T_∞(n)等于

617
00:46:48,550 --> 00:47:05,860
好 T_∞(n/2)又是加上θ(n)

618
00:47:05,880 --> 00:47:13,450
这等于θ(n)

619
00:47:13,470 --> 00:47:14,880
所以并行度是

620
00:47:14,920 --> 00:47:27,680
P帽等于T_1(n)/T_∞(n)

621
00:47:27,700 --> 00:47:34,860
等于θ(log n)

622
00:47:34,880 --> 00:47:41,430
这并行度是不是很多？

623
00:47:41,450 --> 00:47:46,260
不是 有一个专业点的叫法 称之为“微小”

624
00:47:46,280 --> 00:47:53,030
这是“微小”的并行度 log n

625
00:47:53,070 --> 00:47:58,320
这实际上可能是一个相当好的算法

626
00:47:58,350 --> 00:48:02,380
对于一些小规模的处理器来说

627
00:48:02,410 --> 00:48:04,140
尤其是多核处理器

628
00:48:04,170 --> 00:48:06,560
从市场上能买到的

629
00:48:06,600 --> 00:48:11,120
还有对于一些SMP：对称多处理器

630
00:48:11,140 --> 00:48:12,470
都是有用的

631
00:48:12,480 --> 00:48:14,450
它们有四个或八个处理器

632
00:48:14,470 --> 00:48:17,040
这算法可能可行 并行度不是很多

633
00:48:17,060 --> 00:48:24,330
对于百万个元 log n大概是20

634
00:48:24,350 --> 00:48:28,050
因为还有一些常数阶的开销

635
00:48:28,070 --> 00:48:30,790
所以这个不是相当并行化

636
00:48:30,810 --> 00:48:31,870
有问题吗？

637
00:48:37,780 --> 00:48:47,160
如何才能做得更好？我是说 就像是

638
00:48:47,170 --> 00:48:51,370
归并算法那样 花费θ(n)

639
00:48:51,390 --> 00:48:54,520
如果想要更好的性能 应该怎么做？

640
00:48:54,540 --> 00:49:01,200
说？原位排序

641
00:49:01,220 --> 00:49:03,830
例如你用快速排序 要划分数组

642
00:49:03,840 --> 00:49:07,130
你仍要用线性时间来做划分

643
00:49:07,150 --> 00:49:10,750
所以情况还是一样的

644
00:49:10,770 --> 00:49:19,480
但这里能怎么做？并行归并

645
00:49:19,510 --> 00:49:22,990
然我们并行地进行归并

646
00:49:23,010 --> 00:49:26,060
那是关系到关键路径的部分

647
00:49:26,080 --> 00:49:30,920
我们试着写一个新的归并程序

648
00:49:30,940 --> 00:49:33,820
并令其有一条超短的关键路径

649
00:49:33,870 --> 00:49:45,670
必须将归并操作并行化 非常好

650
00:49:45,690 --> 00:49:52,570
我表示相当感动 像这样的课程 学到最后

651
00:49:52,580 --> 00:49:57,000
你们能拥有一种直觉

652
00:49:57,020 --> 00:49:58,570
通过表面看透其本质

653
00:49:58,600 --> 00:50:00,390
知道哪里才是关键所在

654
00:50:00,410 --> 00:50:02,760
关于算法的认识之一是

655
00:50:02,790 --> 00:50:04,750
它不会在你编程时

656
00:50:04,770 --> 00:50:08,420
妨碍你设计一个程序

657
00:50:08,440 --> 00:50:10,140
编程要编得好 有很多工作要做

658
00:50:10,160 --> 00:50:12,410
而不仅仅是算法

659
00:50:12,430 --> 00:50:14,140
就像我们在第一天说的那样

660
00:50:14,160 --> 00:50:16,570
还有一些工作比如 模块化

661
00:50:16,590 --> 00:50:18,330
使其具有可维护性

662
00:50:18,370 --> 00:50:20,610
还有诸如此类的一大堆事

663
00:50:20,630 --> 00:50:21,830
但有一件事就是

664
00:50:21,870 --> 00:50:23,320
算法会告诉你

665
00:50:23,340 --> 00:50:24,480
哪里才是你要关注的地方

666
00:50:24,500 --> 00:50:27,280
好吧 就不会是在...

667
00:50:27,300 --> 00:50:28,540
比如说 就像是

668
00:50:28,560 --> 00:50:30,850
我这里衍生出

669
00:50:30,870 --> 00:50:33,280
四个大小为n/4的运算

670
00:50:33,300 --> 00:50:37,510
我希望得到... 我是说像这些

671
00:50:37,530 --> 00:50:39,140
这不是重点所在

672
00:50:39,160 --> 00:50:41,380
需要把重点放在归并

673
00:50:41,410 --> 00:50:44,680
因为这才是关键的瓶颈

674
00:50:44,700 --> 00:50:47,120
这也是算法的精秒之处

675
00:50:47,140 --> 00:50:48,920
让你迅速找到重点

676
00:50:48,940 --> 00:50:50,270
让你有的放矢

677
00:50:50,280 --> 00:50:56,250
让你在做算法设计的工程实践时更得心应手

678
00:50:56,320 --> 00:50:58,070
你肯定要把归并并行化

679
00:51:07,480 --> 00:51:10,270
关注的是归并

680
00:51:10,290 --> 00:51:11,910
下面是我们的基本思路

681
00:51:11,940 --> 00:51:17,090
通常 当进行归并时

682
00:51:17,120 --> 00:51:18,730
当做递归合并时

683
00:51:18,760 --> 00:51:20,000
我们会用到两个数组

684
00:51:20,030 --> 00:51:22,420
称之为A和B

685
00:51:22,440 --> 00:51:24,680
那边已经有一个A了

686
00:51:24,720 --> 00:51:25,870
可能不应该再用A来表示

687
00:51:25,890 --> 00:51:28,200
应该把它叫做其它的

688
00:51:28,220 --> 00:51:29,420
但教案上就是这么写的

689
00:51:29,450 --> 00:51:30,490
还是继续用这个名字吧

690
00:51:30,530 --> 00:51:33,380
这里留多点空间

691
00:51:33,410 --> 00:51:36,260
看看要怎么做

692
00:51:39,760 --> 00:51:41,880
有两个数组 称之为A和B

693
00:51:41,900 --> 00:51:48,910
我们打算做的是

694
00:51:48,930 --> 00:51:50,130
这些是已经排序好的

695
00:51:50,160 --> 00:51:53,930
我们的工作是将它们归并到一起

696
00:51:53,950 --> 00:51:57,500
要做的是取A中间那个元素

697
00:51:57,520 --> 00:52:02,650
这个假设是从1到l

698
00:52:02,680 --> 00:52:07,200
这个是从1到m

699
00:52:07,230 --> 00:52:11,640
取中间的元素

700
00:52:11,660 --> 00:52:14,070
假设是l/2

701
00:52:14,090 --> 00:52:23,390
我们要做的是 用二分法检索来出

702
00:52:23,400 --> 00:52:26,200
它在数组B中的位置

703
00:52:26,220 --> 00:52:28,750
这个元素在哪？

704
00:52:28,770 --> 00:52:31,670
在这里某个位置

705
00:52:31,680 --> 00:52:36,490
这里是j 还有这里是j+1

706
00:52:36,510 --> 00:52:41,380
因为数组已经排序好

707
00:52:41,400 --> 00:52:42,740
所有这些元素

708
00:52:42,760 --> 00:52:45,330
都小于或等于A[l/2]

709
00:52:45,350 --> 00:52:48,750
还有所有这些元素

710
00:52:48,760 --> 00:52:50,630
都大于或等于A[l/2]

711
00:52:52,080 --> 00:52:56,070
同样的 因为这个元素在这里

712
00:52:56,090 --> 00:52:59,490
所有这些都小于或等于A[l/2]

713
00:52:59,520 --> 00:53:02,100
还有所有这些都将

714
00:53:02,120 --> 00:53:04,160
大于或等于A[l/2]

715
00:53:11,660 --> 00:53:14,510
现在我们能做的是

716
00:53:14,530 --> 00:53:16,240
一旦算出这个元素的位置

717
00:53:16,260 --> 00:53:20,850
我就能递归地将这段数组和这段归并起来

718
00:53:20,870 --> 00:53:24,130
还有这段和这段数组

719
00:53:24,150 --> 00:53:30,480
然后就能够将它们连结到一起

720
00:53:30,500 --> 00:53:37,400
我就得到归并好的数组 写一下代码

721
00:53:37,420 --> 00:53:41,960
每个同学都理解这个过程的主旨吗

722
00:53:41,980 --> 00:53:43,900
它是如何进行并行化归并的？

723
00:53:43,920 --> 00:53:46,070
当然你会觉得 这有一点混乱

724
00:53:46,090 --> 00:53:49,700
因为j可能在任意地方

725
00:53:53,560 --> 00:53:56,000
这是代码 并行归并

726
00:54:06,110 --> 00:54:12,320
我们会把结果放进C[1…n]

727
00:54:12,340 --> 00:54:14,630
所以有n个元素

728
00:54:14,640 --> 00:54:25,030
所以这个函数是将A和B归并到C

729
00:54:25,050 --> 00:54:29,000
这里n=l+m

730
00:54:31,810 --> 00:54:34,070
我们是将两个数组

731
00:54:34,120 --> 00:54:37,900
归并到第三个数组里

732
00:54:37,920 --> 00:54:45,560
为了使其具有一般性

733
00:54:45,580 --> 00:54:49,790
我要假设l大于m 正如这里表示的

734
00:54:49,810 --> 00:54:51,620
因为如果不是这样 那该怎么做？

735
00:54:51,630 --> 00:54:54,380
只要数组位置反过来做就行了 是吧

736
00:54:54,400 --> 00:54:58,130
我要先搞清楚哪一个比较大

737
00:54:58,150 --> 00:55:00,310
那仅需要θ(1)的时间就能测出来

738
00:55:00,330 --> 00:55:03,200
然后 分析基本情况

739
00:55:03,210 --> 00:55:08,360
比如 如果两个数组是空的或是其它怎样

740
00:55:08,380 --> 00:55:10,480
当然 在实际工程中

741
00:55:10,520 --> 00:55:13,670
如果数组足够小 你只需要串行归并

742
00:55:13,680 --> 00:55:16,880
如果它们足够小的话

743
00:55:16,900 --> 00:55:18,990
我也不期望能得到多大的并行度

744
00:55:19,020 --> 00:55:20,300
因为做的功不多

745
00:55:20,320 --> 00:55:21,950
你也同样可以用串行归并实现

746
00:55:21,960 --> 00:55:24,270
可能还更有效率

747
00:55:24,290 --> 00:55:25,810
好的 分析基本情况

748
00:55:25,830 --> 00:55:32,800
然后所要做的是找出j

749
00:55:32,820 --> 00:55:39,240
使得B[j]小于或等于A[l/2]

750
00:55:39,260 --> 00:55:43,690
小于或等于B[j+1]

751
00:55:43,710 --> 00:55:48,820
用二分法检索可得

752
00:55:53,850 --> 00:55:55,190
什么时候学的二分法检索？

753
00:55:55,210 --> 00:55:58,370
没错 第一周

754
00:55:58,390 --> 00:56:00,920
好像是在第一堂复习课上

755
00:56:00,940 --> 00:56:04,030
对 它非常神奇

756
00:56:04,050 --> 00:56:06,840
现在要做的是

757
00:56:06,860 --> 00:56:25,000
衍生出新的归并 A[1…l/2]与B[1…j]

758
00:56:25,030 --> 00:56:33,040
然后把结果归并到C[1…l/2+j]

759
00:56:38,530 --> 00:56:52,970
然后同样地 衍生另一个归并

760
00:56:53,000 --> 00:57:10,480
A[l/2+1…l]与B[j+1…m]

761
00:57:10,500 --> 00:57:20,160
归并到C[l/2+j+1…n]

762
00:57:20,170 --> 00:57:23,320
然后进行同步

763
00:57:23,350 --> 00:57:32,290
代码非常直观

764
00:57:32,310 --> 00:57:35,160
也就是我刚刚在这演示的内容

765
00:57:35,180 --> 00:57:43,130
它的分析 呀咩 会有一点点混乱喔

766
00:57:43,150 --> 00:57:51,180
那在进行分析前

767
00:57:51,200 --> 00:57:52,490
我们先尝试理解一下

768
00:57:52,510 --> 00:57:57,060
为什么我要选择

769
00:57:57,080 --> 00:58:03,030
大数组里的中位元素 而不是小数组里面的？

770
00:58:03,030 --> 00:58:09,310
给个奶油我？

771
00:58:09,310 --> 00:58:11,570
这实际上是关键部分

772
00:58:11,590 --> 00:58:19,530
是分析过程的关键部分 啊哈？

773
00:58:32,480 --> 00:58:33,770
对了 就例如 设想数组B

774
00:58:33,790 --> 00:58:40,700
它里面只有一个元素 或者只有极少量元素

775
00:58:40,770 --> 00:58:43,160
那B的中位元素在A中的位置

776
00:58:43,260 --> 00:58:46,930
就很可能靠近A的开头部分

777
00:58:46,950 --> 00:58:55,040
这就会使得之后的子数组变得非常大

778
00:58:55,900 --> 00:58:58,000
相对于这里 正如你所说的

779
00:58:58,020 --> 00:59:03,690
如果从这里开始 元素的总数是n

780
00:59:03,690 --> 00:59:11,050
那这里递归出的数组长度最小是多少？

781
00:59:11,050 --> 00:59:13,910
最小可能是n/4

782
00:59:15,880 --> 00:59:22,270
因为它至少是总元素的四分之一

783
00:59:22,340 --> 00:59:25,570
无论是A的左边也好 右边也好

784
00:59:25,640 --> 00:59:28,260
如果反过来 则之后递归出的数组的大小

785
00:59:28,290 --> 00:59:32,110
可能跟n差不多大

786
00:59:32,130 --> 00:59:34,600
那就变成... 再一次

787
00:59:34,620 --> 00:59:35,740
这之间的差别就像

788
00:59:35,760 --> 00:59:38,460
当我们分析快排时

789
00:59:38,480 --> 00:59:43,580
看看是否能得到一个不错的分割元素那样

790
00:59:43,600 --> 00:59:46,030
如果分割元素在中间位置附近

791
00:59:46,050 --> 00:59:49,150
那结果就非常好 但如果总在一端上

792
00:59:49,170 --> 00:59:51,440
那效率可能都没有插入排序好

793
00:59:51,440 --> 00:59:54,140
在使用分治法时 你总希望分割时

794
00:59:54,140 --> 00:59:56,400
能有一个固定的比例

795
00:59:56,430 --> 00:59:57,850
从而得到对数时间的复杂度

796
00:59:57,870 --> 01:00:01,440
我们会在接下来的分析中看到

797
01:00:01,460 --> 01:00:02,960
但这里关键的因素是

798
01:00:02,980 --> 01:00:06,620
当进行递归操作时

799
01:00:06,650 --> 01:00:09,470
我们至少有四分之一的元素

800
01:00:09,490 --> 01:00:11,200
在无论哪一个小数组里

801
01:00:11,220 --> 01:00:15,800
让我们开始..

802
01:00:15,830 --> 01:00:17,650
看来功的分析是这部分的难点

803
01:00:17,670 --> 01:00:19,540
那我们先从关键路径长度开始

804
01:00:19,560 --> 01:00:24,230
看一下关键路径长度

805
01:00:24,250 --> 01:00:36,590
好的 在并行归并中 PM_∞(n)将会

806
01:00:36,610 --> 01:00:44,810
小于等于 如果最小的部分至少是四分之一

807
01:00:44,830 --> 01:00:46,340
那这两个递归数组中

808
01:00:46,360 --> 01:00:50,370
大一点那个最大有多大？

809
01:00:56,850 --> 01:00:59,780
我们现又衍生了两个子问题

810
01:00:59,800 --> 01:01:02,900
现在我们取的是最大值

811
01:01:02,930 --> 01:01:04,380
因为它们不是对称的

812
01:01:04,400 --> 01:01:05,760
最大那个能有多大？

813
01:01:05,780 --> 01:01:16,180
它最多可能占了四分之三的元素

814
01:01:16,200 --> 01:01:27,560
小于等于PM_∞(3n/4) 再加上

815
01:01:27,590 --> 01:01:33,730
所以 这两个递归数组的最大那个

816
01:01:33,750 --> 01:01:36,950
会占了四分之三的元素 再加上多少？

817
01:01:36,970 --> 01:01:47,280
加上log n  这个log n是什么？

818
01:01:47,300 --> 01:01:54,980
二分法检索 这条式的解是

819
01:01:54,990 --> 01:02:09,140
这个最后等于n的多少次幂？

820
01:02:13,930 --> 01:02:15,500
n的零次幂 没错

821
01:02:15,530 --> 01:02:20,660
它是n的log1(以3/4为底)次幂

822
01:02:20,680 --> 01:02:25,080
无论底是多少 log 1都为0

823
01:02:25,100 --> 01:02:26,150
所以它是n的0次方

824
01:02:26,180 --> 01:02:27,890
所以这是1和log n的比较

825
01:02:27,910 --> 01:02:31,460
要附加log 所以是θ(log²n)

826
01:02:31,480 --> 01:02:37,370
所以关键路径为log²n

827
01:02:37,400 --> 01:02:38,420
这是个好消息

828
01:02:38,440 --> 01:02:40,370
现在我们祈祷

829
01:02:40,400 --> 01:02:42,650
求出来的功不会大到爆炸

830
01:02:46,190 --> 01:02:56,060
好的 功PM_1(n)等于

831
01:02:56,080 --> 01:02:58,890
因为我们不知道分割点在哪

832
01:02:58,910 --> 01:03:05,420
所以设分割比例为α 所以一边就是α·n

833
01:03:12,000 --> 01:03:13,570
然后另一边的功就是

834
01:03:13,590 --> 01:03:19,870
PM_1((1-α)·n) 然后再加上

835
01:03:19,900 --> 01:03:22,420
还是二分法检索的θ(log n)

836
01:03:22,440 --> 01:03:29,070
这里正如我们说过的

837
01:03:29,100 --> 01:03:32,780
α将落在

838
01:03:32,810 --> 01:03:34,730
1/4与3/4之间

839
01:03:44,440 --> 01:03:46,740
怎么解这样的一个递归式？

840
01:03:51,720 --> 01:03:53,800
这一类递归的专业叫法是什么？

841
01:03:58,060 --> 01:04:02,330
毛烦 毛烦递归

842
01:04:02,350 --> 01:04:03,630
怎么解毛烦递归

843
01:04:03,660 --> 01:04:07,050
替换法 很好

844
01:04:07,070 --> 01:04:20,700
替换法 那么我们假设

845
01:04:20,730 --> 01:04:23,570
PM_1(k)小于或等于

846
01:04:23,590 --> 01:04:28,810
这里要来一个大胆的猜想

847
01:04:28,830 --> 01:04:31,310
因为我已经被它搞好毛烦了

848
01:04:31,350 --> 01:04:33,110
我猜它是线性的

849
01:04:33,130 --> 01:04:36,810
那么它就有一个线性系数 a·k减去

850
01:04:36,830 --> 01:04:39,900
然后减去b·log k

851
01:04:39,930 --> 01:04:41,820
这是减去一个低阶项的技巧

852
01:04:41,830 --> 01:04:46,350
还记得吗？ 这样可以使得替换法更强大

853
01:04:46,370 --> 01:04:47,850
如果只有a·k 那是没有用的

854
01:04:47,860 --> 01:04:49,680
因为这边求出来就是n

855
01:04:49,700 --> 01:04:51,560
然后这边一替换

856
01:04:51,580 --> 01:04:55,080
就会得到一个a·α·n

857
01:04:55,110 --> 01:04:58,740
后面这个就是a·(1-α)n 这两项加起来

858
01:04:58,760 --> 01:05:01,090
就恰好是等号左边这一项

859
01:05:01,110 --> 01:05:03,640
因为后面还有一个θ(log n) 这样一来

860
01:05:03,660 --> 01:05:05,020
式子就不成立了

861
01:05:05,040 --> 01:05:06,780
所以我们要在这两项中

862
01:05:06,790 --> 01:05:09,940
减去一部分来抵消掉这一项

863
01:05:09,980 --> 01:05:14,120
懂吗？ 我就跳过中间的步骤了

864
01:05:14,150 --> 01:05:19,130
因为第二节课就已经讲过了类似的内容

865
01:05:19,160 --> 01:05:23,030
这就是要猜想的部分

866
01:05:23,050 --> 01:05:28,320
这里a与b都大于0

867
01:05:28,350 --> 01:05:31,990
我们来代入一下

868
01:05:43,430 --> 01:05:50,410
PM_1(n)小于或等于

869
01:05:50,440 --> 01:05:56,180
好的 我们把这个归纳的假设

870
01:05:56,200 --> 01:05:58,290
代入到这两项中去

871
01:05:58,310 --> 01:06:07,580
得出一个a·(α*n)-b·log(α·n)

872
01:06:07,650 --> 01:06:13,590
加上a·((1-α)n)

873
01:06:13,660 --> 01:06:21,880
减去b·log((1-α)n)

874
01:06:21,950 --> 01:06:22,690
这里还有一个括号

875
01:06:22,760 --> 01:06:25,360
(1-α)n

876
01:06:25,760 --> 01:06:27,840
虽然已经预留了很多位置了（但还是不够）

877
01:06:27,910 --> 01:06:30,560
加上...把这个写到这边

878
01:06:30,630 --> 01:06:32,710
这样才不至于占用太多地方

879
01:06:32,740 --> 01:06:37,490
好的 b·log((1-α)n)

880
01:06:37,520 --> 01:06:46,070
加上θ(log n) 如何?

881
01:06:46,090 --> 01:06:55,760
明白吗？这只是进行代入而已

882
01:06:55,780 --> 01:06:58,370
我们做一下代数运算

883
01:06:58,400 --> 01:07:04,750
它等于把a乘以α·n 再乘以(1-α)n

884
01:07:04,780 --> 01:07:08,930
那就等于a·n 再减去

885
01:07:08,960 --> 01:07:11,200
b那项就没那么简单了

886
01:07:11,230 --> 01:07:13,160
取出系数b

887
01:07:13,180 --> 01:07:15,520
现在后面有一大堆的式子

888
01:07:15,560 --> 01:07:19,060
我有log(α·n)

889
01:07:19,080 --> 01:07:25,170
然后是这个log((1-α)n)

890
01:07:25,190 --> 01:07:35,500
(1-α)n 然后加上θ(log n)

891
01:07:35,520 --> 01:07:42,680
做得对不对？看起来没错吧？

892
01:07:42,700 --> 01:07:50,630
接下来要看

893
01:07:50,650 --> 01:07:55,980
现在把一些参数乘出来

894
01:07:56,000 --> 01:08:00,460
得出a·n减去b乘以

895
01:08:00,490 --> 01:08:05,570
log(α·n)等于logα加上log n

896
01:08:05,590 --> 01:08:12,640
然后加上log(1-α)加上log n 最后加上θ(log n)

897
01:08:12,670 --> 01:08:20,520
加上θ(logn) 这变得更代数化了

898
01:08:20,540 --> 01:08:24,830
用的是log的运算法则

899
01:08:24,850 --> 01:08:27,860
我把它比作是

900
01:08:27,890 --> 01:08:34,150
实际的解减去预期的解再减去一个残差

901
01:08:34,160 --> 01:08:43,860
a·n减去b·log n 减去

902
01:08:43,880 --> 01:08:48,750
这个是这些b·log n中的一个 这一个

903
01:08:48,770 --> 01:08:51,190
还有其它的最后会在这里

904
01:08:51,210 --> 01:09:03,330
b·log n加上

905
01:09:03,350 --> 01:09:09,890
log(α(1-α))减去 哎呀 写得太复杂了

906
01:09:09,910 --> 01:09:11,460
右括号的数量没错吧

907
01:09:11,480 --> 01:09:14,880
闭合那个 闭合那个 没错

908
01:09:14,900 --> 01:09:29,660
减去θ(log n) 这里两个右括号

909
01:09:29,680 --> 01:09:35,950
我的板书真是有失身份 写得对不对？

910
01:09:35,990 --> 01:09:37,150
括号都没错吧？

911
01:09:37,180 --> 01:09:39,970
对应这个 对应这个

912
01:09:39,990 --> 01:09:41,380
全部对应 很好

913
01:09:41,410 --> 01:09:44,170
然后b在那里 没错 很好

914
01:09:44,190 --> 01:09:48,670
我宣称这个小于或等于

915
01:09:48,700 --> 01:09:59,140
a·n-b·logn  如果选择的b足够大的话

916
01:09:59,160 --> 01:10:09,980
这团乱糟糟的要大于这个

917
01:10:10,000 --> 01:10:13,610
因为这个基本上是一个log n

918
01:10:13,640 --> 01:10:16,680
还有这个本质上是一个常量

919
01:10:16,700 --> 01:10:20,620
如果增大b

920
01:10:20,650 --> 01:10:29,010
乘以log n 能够远大于这个θ(log n)

921
01:10:29,030 --> 01:10:31,030
无论这个被渐近符隐藏的

922
01:10:31,050 --> 01:10:36,390
常数因子有多大

923
01:10:36,410 --> 01:10:51,980
这样b·log n加上

924
01:10:52,000 --> 01:10:59,610
log(α(1-α))大于θ(log n)

925
01:10:59,630 --> 01:11:04,810
而且我还可以选择

926
01:11:04,830 --> 01:11:07,950
基础的条件 使其大到足以

927
01:11:07,970 --> 01:11:09,280
应付初始条件

928
01:11:09,300 --> 01:11:10,930
不管条件是什么

929
01:11:10,960 --> 01:11:28,840
选择a 让它大到足以——

930
01:11:46,590 --> 01:11:48,050
——满足归纳的基本情形

931
01:11:48,070 --> 01:12:00,900
因此PM_1(n)等于θ(n)

932
01:12:00,920 --> 01:12:05,850
虽然我只证明了O(n) 但实际上

933
01:12:05,870 --> 01:12:10,680
下限Ω(n)的证明会更直观一点

934
01:12:10,710 --> 01:12:11,750
因为递归会容易一些

935
01:12:11,770 --> 01:12:13,540
因为我可以做同样的替换

936
01:12:13,560 --> 01:12:18,040
只是不需要减去低阶的那一项

937
01:12:18,060 --> 01:12:20,760
所以实际上用的是θ 而不是O

938
01:12:20,790 --> 01:12:28,870
所以这给出……

939
01:12:28,890 --> 01:12:31,170
我们说关键路径是多少？

940
01:12:31,200 --> 01:12:34,420
并行归并的关键路径是log²n

941
01:12:34,440 --> 01:12:40,740
那就用这个来做归并排序的分析

942
01:12:46,000 --> 01:12:50,910
所以 做的功是 我们都知道了

943
01:12:50,930 --> 01:12:55,380
T_1(n)=θ(n log n)

944
01:12:55,390 --> 01:12:59,310
因为刚才分析过功是θ(n)

945
01:12:59,330 --> 01:13:02,190
与串行算法相同

946
01:13:02,210 --> 01:13:04,510
而关键路径是

947
01:13:04,530 --> 01:13:10,560
T_∞(n)等于

948
01:13:10,590 --> 01:13:14,230
在一般的归并排序里

949
01:13:14,260 --> 01:13:19,050
取数组大小的一半 T(n/2) 加上

950
01:13:19,060 --> 01:13:24,320
现在 归并的关键路径

951
01:13:24,350 --> 01:13:26,780
不再是之前的θ(n)

952
01:13:26,800 --> 01:13:33,700
取代它的就在这里

953
01:13:33,730 --> 01:13:40,180
θ(log²n） 就是它

954
01:13:40,210 --> 01:13:55,050
所以得出θ(log³n）

955
01:13:55,070 --> 01:14:08,800
所以并行度是θ(n/log³n）

956
01:14:08,830 --> 01:14:18,100
实际上 已知最好的

957
01:14:18,120 --> 01:14:24,180
不好意思 是log²n 你是对的

958
01:14:24,200 --> 01:14:31,660
log²n  因为它是n(log n)/log³n

959
01:14:31,690 --> 01:14:33,900
这个是n/log²n

960
01:14:33,930 --> 01:14:39,690
所以最好的是 我不确信这里教案是不是打错了

961
01:14:39,710 --> 01:14:42,200
已有的最好并行度是

962
01:14:42,210 --> 01:14:48,240
p帽等于θ(n/log n）没错吧？

963
01:14:48,270 --> 01:14:57,430
是这样的 对 那是目前最好的

964
01:14:57,450 --> 01:15:07,550
是目前最有效的 应该是由Occoli发明的

965
01:15:07,570 --> 01:15:12,050
是他增加了你们的期末考题

966
01:15:13,720 --> 01:15:17,680
所以最终能够得到一个相当不错的并行度

967
01:15:17,760 --> 01:15:20,580
但事实上 你很难给排序并行化

968
01:15:20,640 --> 01:15:23,040
因为你很难凑到一些很好的参数

969
01:15:23,110 --> 01:15:24,630
让每个并行部分都一致

970
01:15:24,660 --> 01:15:25,850
而矩阵相乘

971
01:15:25,870 --> 01:15:28,330
你可以让它并行运行 并得到

972
01:15:28,350 --> 01:15:31,470
直观 坚实的方法 让它随着处理器的数量线性加速

973
01:15:31,500 --> 01:15:33,230
它有很大量的并行度

974
01:15:33,250 --> 01:15:35,140
可以在更多的处理器上运行

975
01:15:35,160 --> 01:15:38,100
每个处理器都满负载 但对于排序

976
01:15:38,120 --> 01:15:41,550
你一般会丧失... 具体不清楚

977
01:15:41,590 --> 01:15:48,030
我的经验大概是20%的并行度 还要顾及别的问题

978
01:15:48,090 --> 01:15:51,000
因为你必须花很多功夫

979
01:15:51,040 --> 01:15:54,600
才能使归这种归并算法的常量阶

980
01:15:54,610 --> 01:15:57,990
小于普通归并的常量阶

981
01:15:58,020 --> 01:15:59,590
我说这 是一个非常不错的算法

982
01:15:59,620 --> 01:16:01,410
它跑起来嘚嘞嘚嘞嘚嘞的

983
01:16:01,410 --> 01:16:05,770
取两个链表然后 像这样归并到一起

984
01:16:05,790 --> 01:16:10,590
这是一个很有意思的问题

985
01:16:10,610 --> 01:16:13,460
很多人在排序上努力钻研

986
01:16:13,480 --> 01:16:14,910
因为它是一个非常重要的问题

987
01:16:14,930 --> 01:16:17,820
要如何让常量阶变小

988
01:16:17,840 --> 01:16:19,580
同时仍然保证

989
01:16:19,610 --> 01:16:22,960
它能按处理器的数量成比例递减

990
01:16:22,980 --> 01:16:29,250
这只是并行苦海边的小贝壳

991
01:16:29,280 --> 01:16:34,060
另外 下周我们讲介绍缓存

992
01:16:34,080 --> 01:16:40,140
那是另一个非常重要的算法领域

993
01:16:40,160 --> 01:16:43,070
对于通常的编程也很重要

