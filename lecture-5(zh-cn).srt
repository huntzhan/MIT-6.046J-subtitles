1
00:00:05,590 --> 00:00:08,200
今天我们讨论排序

2
00:00:08,200 --> 00:00:10,630
这对大家来说也许并不意外

3
00:00:11,630 --> 00:00:12,600
因为我们已经研究排序好一阵子了

4
00:00:14,220 --> 00:00:16,880
但今天我们将会更加深入地探讨一下

5
00:00:16,880 --> 00:00:18,520
并对我们先前作出的有些假设

6
00:00:18,520 --> 00:00:21,360
提出一些疑问

7
00:00:25,470 --> 00:00:28,280
现在我有一个问题 排序最快可以多快

8
00:00:30,810 --> 00:00:31,720
一个很自然的问题

9
00:00:32,760 --> 00:00:34,190
你们可能认为自己知道答案

10
00:00:34,830 --> 00:00:35,480
也许你们知道

11
00:00:37,180 --> 00:00:40,690
谁知道这答案是多少

12
00:00:41,010 --> 00:00:42,120
答案不是唯一的

13
00:00:42,600 --> 00:00:44,110
很多答案都会在一定程度上正确

14
00:00:44,810 --> 00:00:51,320
所以 请大家畅所欲言吧

15
00:00:51,330 --> 00:00:57,230
让大脑从早晨的迷糊中逐渐清醒过来

16
00:00:57,230 --> 00:00:58,170
什么

17
00:00:58,170 --> 00:00:59,360
Θ(nlgn)

18
00:00:59,360 --> 00:01:01,290
这个答案不错

19
00:01:01,460 --> 00:01:03,560
也是比较容易想到的答案

20
00:01:04,520 --> 00:01:05,140
还有其他答案吗

21
00:01:06,300 --> 00:01:07,630
n的平方

22
00:01:08,160 --> 00:01:13,030
只允许进行相邻数字交换时这个答案正确

23
00:01:13,390 --> 00:01:13,640
不错

24
00:01:15,060 --> 00:01:15,510
这答案也不错

25
00:01:15,510 --> 00:01:17,430
看看我能不能给出所有答案成立的条件

26
00:01:18,830 --> 00:01:22,280
通常只在特定条件下n的平方才会是正解

27
00:01:22,280 --> 00:01:23,620
请说

28
00:01:24,110 --> 00:01:25,950
Θ(n)同样只在特定条件下才成立

29
00:01:26,780 --> 00:01:28,740
所以 真正的答案要“看情况”

30
00:01:29,620 --> 00:01:32,110
这就是今天的观点

31
00:01:36,560 --> 00:01:39,870
它取决于你使用的计算模型里

32
00:01:39,870 --> 00:01:41,620
哪些操作是被允许的

33
00:01:42,420 --> 00:01:43,950
当然 这里是指 就排序来说

34
00:01:43,950 --> 00:01:47,000
我们关心的是元素的排列顺序

35
00:01:47,310 --> 00:01:49,400
我们可以如何对元素操作

36
00:01:49,400 --> 00:01:52,190
在排序过程中 哪些操作是被允许的

37
00:01:55,380 --> 00:02:01,260
模型简单来说就是那些你被允许的操作

38
00:02:12,960 --> 00:02:16,660
至今为止我们已经学过好几种排序算法

39
00:02:16,660 --> 00:02:18,910
能大声地说出来有哪些吗

40
00:02:18,910 --> 00:02:23,890
我记得的有4种 但你们可能知道更多

41
00:02:23,890 --> 00:02:25,600
快速排序

42
00:02:26,080 --> 00:02:27,980
继续

43
00:02:28,770 --> 00:02:30,330
堆排序

44
00:02:35,020 --> 00:02:35,610
归并排序

45
00:02:36,380 --> 00:02:39,300
你们还记得第一讲的内容

46
00:02:39,300 --> 00:02:40,690
还有吗

47
00:02:40,690 --> 00:02:41,810
插入排序

48
00:02:41,810 --> 00:02:42,520
好的

49
00:02:42,520 --> 00:02:44,500
你们对这些算法都很熟悉

50
00:02:46,160 --> 00:02:50,220
我不知道为什么这两个算法只有一个单词

51
00:02:50,220 --> 00:02:51,620
而下面两个算法要用两个单词表示

52
00:02:53,100 --> 00:02:53,710
但风格就是这样

53
00:02:55,540 --> 00:02:59,270
快速排序的运行时间是多少

54
00:02:59,270 --> 00:03:01,530
看起来这个问题有点难

55
00:03:02,760 --> 00:03:06,340
平均情况下运行时间是nlgn

56
00:03:06,860 --> 00:03:08,810
或者说 如果我们随机化快速排序

57
00:03:08,810 --> 00:03:13,150
随机化的快速排序运行时间为nlgn

58
00:03:15,530 --> 00:03:18,640
所以说在被随机化时是nlgn

59
00:03:19,290 --> 00:03:20,520
前面带个Θ

60
00:03:21,130 --> 00:03:24,440
而最初的朴素快速排序的最差情况是

61
00:03:24,450 --> 00:03:28,410
在取第一个元素作为分块元素时发生

62
00:03:28,410 --> 00:03:30,880
运行时间是n的平方

63
00:03:33,920 --> 00:03:35,380
堆排序呢 运行时间是多少

64
00:03:37,670 --> 00:03:39,020
永远是nlgn

65
00:03:41,080 --> 00:03:46,080
归并排序 希望你们还记得 也是nlgn

66
00:03:46,520 --> 00:03:48,310
插入排序呢 n的平方

67
00:03:51,220 --> 00:03:54,420
这些算法运行时间都没有小于nlgn的

68
00:03:54,420 --> 00:03:57,430
于是我想问 运行时间可能小于nlgn吗

69
00:04:10,020 --> 00:04:12,260
事实上这个问题答案 在一定程度上说

70
00:04:12,260 --> 00:04:14,560
亦是亦非

71
00:04:15,000 --> 00:04:17,720
以上算法在规范操作的模型中

72
00:04:17,720 --> 00:04:20,110
都存在一些共同点

73
00:04:21,070 --> 00:04:23,990
大家对这个模型有什么猜想吗

74
00:04:27,110 --> 00:04:31,760
请说 你只能对2个元素进行比较 没错

75
00:04:32,860 --> 00:04:36,810
这就是四个算法共用的模型

76
00:04:38,030 --> 00:04:42,010
在这个模型中 nlgn是最快的

77
00:04:42,430 --> 00:04:49,120
现在来看一下叫做比较排序的算法模型

78
00:04:49,120 --> 00:04:51,060
或者直接说比较排序

79
00:04:53,110 --> 00:04:58,510
这是解决排序问题的一个模型

80
00:05:01,080 --> 00:05:06,940
在模型中 你只能做比较操作: 小于

81
00:05:06,940 --> 00:05:08,850
大于 小于等于 大于等于和等于

82
00:05:08,850 --> 00:05:15,280
来决定元素的相对顺序

83
00:05:23,390 --> 00:05:25,190
这是这个算法的局限

84
00:05:26,180 --> 00:05:29,940
在某种意义上也说明了要处理的元素类型

85
00:05:30,220 --> 00:05:31,380
这些元素是可以进行比较操作的

86
00:05:32,060 --> 00:05:34,990
它们最终会有一个顺序 有小有大

87
00:05:37,080 --> 00:05:39,530
但也对算法本身产生了约束

88
00:05:40,080 --> 00:05:41,940
举个例子来说 我对整数进行排序

89
00:05:41,940 --> 00:05:44,420
但我只能进行比较的操作

90
00:05:44,660 --> 00:05:46,970
我不能进行整数相乘或者其他奇怪的操作

91
00:05:47,570 --> 00:05:50,280
这就是比较排序模型

92
00:05:50,810 --> 00:05:53,380
一定程度上来说 这一讲会遵循

93
00:05:53,380 --> 00:05:58,900
标准数学逻辑方式 当你想到一个定理

94
00:05:59,190 --> 00:06:01,060
你要先证明这个定理 然后寻找反例

95
00:06:01,640 --> 00:06:03,110
在涉及数学的课上这样做不失为一件好事

96
00:06:03,560 --> 00:06:05,750
接下来就要证明我们的这个定理:

97
00:06:05,750 --> 00:06:11,870
比较排序的算法运算速度不会快于nlgn

98
00:06:11,870 --> 00:06:13,740
比较排序

99
00:06:14,800 --> 00:06:16,300
提出定理 证明它

100
00:06:16,300 --> 00:06:18,800
然后再举个反例

101
00:06:18,800 --> 00:06:22,220
在不用比较排序时运算速度可以快于nlgn

102
00:06:22,890 --> 00:06:25,830
在某些条件下你甚至可以得到n 快于nlgn

103
00:06:26,520 --> 00:06:28,880
所以 这就是我们今天要做的事

104
00:06:30,860 --> 00:06:33,170
首先 我们来看一下这个比较模型

105
00:06:33,170 --> 00:06:34,070
并进而理解为什么

106
00:06:34,540 --> 00:06:38,060
在只允许比较操作时最少需要nlgn次操作

107
00:06:38,840 --> 00:06:42,170
先看一个被叫做

108
00:06:42,170 --> 00:06:43,830
决策树的东西

109
00:06:43,830 --> 00:06:47,440
可以说它是算法里另一个

110
00:06:47,440 --> 00:06:49,770
规定你可以进行哪些操作的模型

111
00:06:50,530 --> 00:06:53,770
但这比比较模型适用范围更广

112
00:06:55,880 --> 00:07:03,780
我们举个例子让它更加直观

113
00:07:05,210 --> 00:07:09,020
假设需要对3个元素进行排序

114
00:07:10,250 --> 00:07:11,870
这并不是很有挑战性

115
00:07:11,870 --> 00:07:14,040
但这里我们将通过绘制决策树的方法

116
00:07:14,040 --> 00:07:16,360
来实现对3个元素排序

117
00:07:16,700 --> 00:07:19,500
下面是我的一种解法

118
00:07:40,390 --> 00:07:44,350
这也可以被看做是一种算法

119
00:07:44,350 --> 00:07:47,990
只不过不是用伪代码而是用决策树来实现

120
00:08:15,160 --> 00:08:19,640
树上的每一个节点表示一次比较操作

121
00:08:20,110 --> 00:08:22,220
这里是比较a₁和a₂

122
00:08:22,680 --> 00:08:25,270
如果a₁<a₂ 走这条路

123
00:08:25,280 --> 00:08:28,980
如果a₁>a₂ 走这条路 然后继续前进

124
00:08:29,280 --> 00:08:31,310
当你抵达一个叶节点 就得到了一个答案

125
00:08:31,310 --> 00:08:33,240
记住 排序问题是需要你

126
00:08:33,240 --> 00:08:36,970
找到一个对输入序列实现排序输出的方法

127
00:08:37,490 --> 00:08:46,610
我们用一组序列来试一下: 9 4 6

128
00:08:49,070 --> 00:08:51,900
对9 4 6进行排序

129
00:08:51,900 --> 00:08:54,520
首先 比较a₁和a₂的大小

130
00:08:54,860 --> 00:08:57,730
9比4大 我们选择这边的路径

131
00:08:58,660 --> 00:09:01,380
然后 比较a₁和a₃的大小

132
00:09:01,380 --> 00:09:02,220
9与6比较

133
00:09:02,220 --> 00:09:05,470
9大于6 所以往这边走

134
00:09:06,270 --> 00:09:08,280
之后 我们比较a₂和a₃的大小

135
00:09:08,280 --> 00:09:12,090
4小于6 往这边走

136
00:09:12,400 --> 00:09:15,070
于是说 这就是元素的正确排序

137
00:09:15,350 --> 00:09:17,820
第一个是a₂ 值是4 第二个是a₃

138
00:09:17,820 --> 00:09:21,770
值是6 之后是a₁ 值是9 算法有效

139
00:09:22,030 --> 00:09:24,200
如果我没有抄错的话

140
00:09:24,200 --> 00:09:27,930
这就是决策树模型下的排序算法

141
00:09:28,230 --> 00:09:33,140
一般地 游戏规则是这样的

142
00:09:36,420 --> 00:09:39,030
通常 会有n个元素需要排序

143
00:09:41,090 --> 00:09:44,680
这里只是做了n=3的情况

144
00:09:44,680 --> 00:09:50,010
这是因为决策树会成长得很快

145
00:09:52,360 --> 00:09:55,660
每一个内节点 即每一个非叶节点

146
00:09:55,660 --> 00:10:08,470
都会有一个下标i:j i和j分别在1到n之间

147
00:10:14,110 --> 00:10:20,770
这表示我们要比较ai和aj的大小

148
00:10:27,550 --> 00:10:31,070
每个内节点下会分出2棵子树

149
00:10:31,320 --> 00:10:38,230
左边的子树说明ai<aj的情况下

150
00:10:38,510 --> 00:10:45,620
算法要做什么 后续会进行哪些比较

151
00:10:52,610 --> 00:10:54,020
这里我们需要留心

152
00:10:54,020 --> 00:10:55,370
两数比较结果可能会是相等

153
00:10:55,860 --> 00:10:59,110
所以 左边的子树对应小于等于条件

154
00:11:00,270 --> 00:11:04,260
右边的子树对应大于的情况

155
00:11:16,250 --> 00:11:18,640
因此 这里会比刚才的例子更严谨

156
00:11:18,640 --> 00:11:21,880
这里的数是不等的 所以没有出现问题

157
00:11:22,470 --> 00:11:27,680
但为了更通用 必须考虑相等的情况

158
00:11:28,900 --> 00:11:30,490
好的 这就是内节点的设定

159
00:11:30,490 --> 00:11:33,880
而每一个叶节点代表一个排序

160
00:11:42,930 --> 00:11:45,720
若某个排序是正解

161
00:11:45,720 --> 00:11:50,140
则这个排序更好地表达了数的特定排列

162
00:11:50,410 --> 00:11:54,910
也就是在第一讲里我们对排序问题的定义

163
00:11:56,290 --> 00:12:02,580
排列使得aπ(1)小于等于

164
00:12:02,580 --> 00:12:06,970
aπ(2) 依此类推

165
00:12:14,030 --> 00:12:17,200
那么 这就是决策树的定义

166
00:12:17,590 --> 00:12:22,750
任何与之相似的二分树都满足这些特征

167
00:12:23,270 --> 00:12:25,100
这可以说是一种排序算法

168
00:12:25,350 --> 00:12:27,590
在决策树模型下的排序算法

169
00:12:28,690 --> 00:12:30,600
正如你们可能想到的

170
00:12:30,600 --> 00:12:34,920
决策树模型和比较模型其实相差不大

171
00:12:35,380 --> 00:12:37,740
如果给你一个比较排序算法

172
00:12:37,980 --> 00:12:40,840
快排 堆排序 归并排序或者插入排序

173
00:12:41,400 --> 00:12:44,820
这4种都可以被转换成决策树模型的方式

174
00:12:45,370 --> 00:12:49,440
这是算法的一种图形表示

175
00:12:49,860 --> 00:12:53,580
但在写算法的时候这种表达不是非常有用

176
00:12:53,890 --> 00:12:55,410
猜猜看为什么

177
00:12:55,410 --> 00:13:02,580
为什么不能通过绘制图形的方式定义快排

178
00:13:02,580 --> 00:13:04,470
或者定义归并排序呢

179
00:13:07,680 --> 00:13:10,040
因为它取决于输入的大小 不错的观点

180
00:13:10,320 --> 00:13:14,110
这棵树因n的数值而有不同的大小

181
00:13:14,110 --> 00:13:16,340
所以某种意义上来说 不具有一般性

182
00:13:16,580 --> 00:13:18,270
接下来 我们将尝试写一个

183
00:13:18,270 --> 00:13:20,090
表示任意n值的决策树

184
00:13:22,620 --> 00:13:24,410
它会是一个对任意n都成立的

185
00:13:24,410 --> 00:13:25,540
真正的算法

186
00:13:26,460 --> 00:13:30,240
即便如此 这仍不是一个很方便的表达

187
00:13:30,240 --> 00:13:32,040
在用于记录一个算法方面

188
00:13:35,770 --> 00:13:38,430
现在 我将把比较排序的一个算法

189
00:13:38,430 --> 00:13:42,700
转换成决策树形式的算法表达

190
00:13:42,700 --> 00:13:44,830
之后 也许你就会知道为什么了

191
00:13:46,310 --> 00:13:47,770
但这不是一个无用的模型

192
00:13:47,770 --> 00:13:50,150
这显然不是无用的 我永远不会这么说

193
00:13:50,410 --> 00:13:52,110
无论如何它在证明我们找不到

194
00:13:52,110 --> 00:13:53,860
快于nlgn的算法时显得十分有效

195
00:13:54,480 --> 00:13:56,250
但在记录一个算法时 如果想要

196
00:13:56,250 --> 00:13:59,860
某些功能 这棵树就不是很有用

197
00:14:00,990 --> 00:14:04,520
即使专门用一台计算机来处理决策树也一样

198
00:14:08,160 --> 00:14:10,460
那么 让我们用决策树的表达方式

199
00:14:10,460 --> 00:14:14,550
构建比较排序算法

200
00:14:16,690 --> 00:14:19,700
或者直接叫做比较排序

201
00:14:26,030 --> 00:14:29,050
下面是转换的过程

202
00:14:30,860 --> 00:14:34,370
我们将会为每一个n值绘制一棵决策树

203
00:14:35,290 --> 00:14:38,240
因为决策树和n值有关

204
00:14:39,010 --> 00:14:41,870
虽然与n有关 但我们希望这个算法

205
00:14:41,870 --> 00:14:43,950
对所有的n都有效

206
00:14:44,460 --> 00:14:53,530
进行比较时 我们把树分成两个分支

207
00:14:53,780 --> 00:14:58,350
左子树和右子树

208
00:15:05,840 --> 00:15:07,700
如果使用归并排序算法

209
00:15:10,570 --> 00:15:12,340
需要进行很多操作

210
00:15:12,340 --> 00:15:15,050
比如算数平均 还有递归等等

211
00:15:15,270 --> 00:15:17,210
但终归要进行比较 所以我们可以说

212
00:15:17,210 --> 00:15:20,200
我们把算法分成了两部分

213
00:15:20,410 --> 00:15:22,350
当比较结果是小于等于时

214
00:15:22,350 --> 00:15:24,920
算法会做哪些操作

215
00:15:24,920 --> 00:15:28,700
当结果为大于等于时 算法又会做什么

216
00:15:30,200 --> 00:15:33,380
所以 你可以用这种方式构建这棵树

217
00:15:33,990 --> 00:15:39,900
可以说 决策树就是把算法中这些比较的

218
00:15:39,900 --> 00:15:42,300
所有可能的结果

219
00:15:42,760 --> 00:15:46,290
分别列出来

220
00:15:57,750 --> 00:16:02,780
也可以说决策树指出了所有可能的路线

221
00:16:03,800 --> 00:16:08,760
如果你把算法的执行过程画出来

222
00:16:09,640 --> 00:16:15,470
包括算法的输入 从a₁到an

223
00:16:15,910 --> 00:16:19,070
还有比较过程

224
00:16:19,070 --> 00:16:23,070
最后就得到一个决策树

225
00:16:23,540 --> 00:16:29,720
那么 猜一猜这个决策树到底有多大呢

226
00:16:41,580 --> 00:16:42,370
是n的一个函数

227
00:16:46,370 --> 00:16:54,830
请说 很好

228
00:16:55,180 --> 00:16:58,460
如果算法对长度为n的任意序列都能排序

229
00:16:59,530 --> 00:17:03,260
叶节点就是这些元素所有可能的顺序

230
00:17:04,260 --> 00:17:05,550
这个值会很大

231
00:17:05,880 --> 00:17:07,630
n个元素的所有排列是很大的值

232
00:17:07,870 --> 00:17:09,000
这个值等于n的阶乘

233
00:17:09,890 --> 00:17:13,030
n的阶乘是指数级 的确很大

234
00:17:13,580 --> 00:17:15,450
所以 这个决策树也很大

235
00:17:15,690 --> 00:17:17,680
输入规模为n 结果就是指数级

236
00:17:17,980 --> 00:17:21,990
这就是为什么一般不用决策树来描述算法

237
00:17:21,990 --> 00:17:24,280
即使我们能将决策树画出来

238
00:17:24,680 --> 00:17:27,840
这不是一种简洁的表达方式

239
00:17:28,080 --> 00:17:30,760
用伪代码描述算法

240
00:17:30,760 --> 00:17:32,070
一个好处就是长度固定

241
00:17:32,680 --> 00:17:35,240
伪代码是一种非常简洁的算法描述方式

242
00:17:35,460 --> 00:17:37,010
伪代码的长度只跟n有关

243
00:17:37,010 --> 00:17:38,320
而决策树跟n的阶乘有关

244
00:17:38,600 --> 00:17:42,040
用决策树来描述算法显然很不方便

245
00:17:42,040 --> 00:17:45,310
因为光画决策树就很费时了

246
00:17:46,060 --> 00:17:46,960
但是 我们也要注意到

247
00:17:46,960 --> 00:17:50,590
决策树分析这些比较排序算法时却很有用

248
00:17:50,590 --> 00:17:51,390
我们现在学到这些算法

249
00:17:51,390 --> 00:17:56,200
每一个都可以转换成决策树的描述方式

250
00:17:56,510 --> 00:17:59,860
现在我们知道在一个决策树中

251
00:17:59,860 --> 00:18:03,100
叶节点的个数是非常多的

252
00:18:04,230 --> 00:18:10,650
我马上就要说到叶节点

253
00:18:14,650 --> 00:18:18,330
在那之前 先了解一下树的深度这个概念

254
00:18:24,270 --> 00:18:27,980
决策树代表算法执行的所有可能

255
00:18:28,230 --> 00:18:30,620
如果我挑出一条特定的算法执行路径

256
00:18:30,620 --> 00:18:34,320
它就对应一条从根节点到叶节点的路径

257
00:18:34,570 --> 00:18:37,430
算法执行路径的运行时间 比较次数

258
00:18:37,430 --> 00:18:39,870
就是对应决策树路径的深度

259
00:18:45,860 --> 00:18:53,540
因此 对于长为n的所有可能输入

260
00:18:53,540 --> 00:19:02,580
最坏情况运行时间等于

261
00:19:02,930 --> 00:19:05,830
n-1吗 可能

262
00:19:06,610 --> 00:19:07,700
这得看决策树是什么样的

263
00:19:08,500 --> 00:19:10,550
和决策树的什么有关呢

264
00:19:13,950 --> 00:19:16,810
最长路径 正确 也就是树的高度

265
00:19:22,840 --> 00:19:24,120
这就是我们要讲的

266
00:19:24,400 --> 00:19:26,850
我们想要证明树的深度

267
00:19:26,850 --> 00:19:29,650
最小值是Ω(nlgn)

268
00:19:30,880 --> 00:19:31,980
这就是我们要证明的

269
00:19:40,790 --> 00:19:43,160
我们唯一能用到的证明条件是

270
00:19:43,160 --> 00:19:46,560
叶节点的数目很大 是n的阶乘

271
00:19:58,670 --> 00:20:06,760
这是决策树排序的下界

272
00:20:19,480 --> 00:20:20,570
下界的意思就是说

273
00:20:20,570 --> 00:20:27,280
如果决策树是针对n个元素排序

274
00:20:29,510 --> 00:20:33,650
那么它的高度至少是nlgn

275
00:20:43,970 --> 00:20:45,620
这是一个定理

276
00:20:45,860 --> 00:20:47,040
下面我们来证明这个定理

277
00:20:54,460 --> 00:21:01,090
用到的条件是 决策树中叶节点

278
00:21:01,090 --> 00:21:04,190
的个数至少是n的阶乘

279
00:21:04,500 --> 00:21:08,180
因为输入值的所有排列个数是n的阶乘

280
00:21:08,440 --> 00:21:09,730
各种排列都可能发生

281
00:21:10,000 --> 00:21:12,680
所以 一个合理的算法

282
00:21:12,680 --> 00:21:16,370
必须以某种方式检测每种排列情况

283
00:21:16,670 --> 00:21:18,440
算法也许能很快的检测所有情况

284
00:21:18,730 --> 00:21:22,190
理想的情况是只比较nlgn次

285
00:21:22,190 --> 00:21:24,140
我们知道这是可能的

286
00:21:26,980 --> 00:21:29,520
树的高度可能不会太深

287
00:21:29,520 --> 00:21:32,940
但它可能有非常多的叶子

288
00:21:33,340 --> 00:21:35,960
决策树必须极力延伸出n的阶乘个叶子

289
00:21:35,960 --> 00:21:39,070
因为它必须针对每种输入都得出正确答案

290
00:21:40,010 --> 00:21:43,750
这个过程也可以看做是

291
00:21:43,750 --> 00:21:45,400
计算所有可能输入序列的数目

292
00:21:49,540 --> 00:21:50,470
这是叶节点个数

293
00:21:50,970 --> 00:21:52,510
我们关心的是树的高度

294
00:21:55,020 --> 00:21:57,170
设树的高度为h

295
00:21:57,730 --> 00:22:01,510
一个高度为h的树的叶节点个数是多少

296
00:22:01,980 --> 00:22:18,850
叶子个数最大是多少 2^h 完全正确

297
00:22:19,110 --> 00:22:20,320
因为这是一个二叉树

298
00:22:20,320 --> 00:22:28,130
基于比较的树都有两个分支

299
00:22:28,130 --> 00:22:31,560
树的高度是h时叶子个数最大就是2^h

300
00:22:34,040 --> 00:22:36,860
现在我们得到一个推导关系

301
00:22:37,200 --> 00:22:40,150
叶子个数大于或等于n的阶乘

302
00:22:40,150 --> 00:22:42,800
并且 叶子个数还小于等于2^h

303
00:22:43,090 --> 00:22:48,750
因此就有 n的阶乘小于或等于2^h

304
00:22:56,670 --> 00:23:00,090
我们关心的是h和n的阶乘之间的关系

305
00:23:00,090 --> 00:23:02,150
可以引入lg运算来解决这个问题

306
00:23:08,630 --> 00:23:10,480
我把两边互换一下

307
00:23:10,950 --> 00:23:12,950
h大于等于

308
00:23:12,950 --> 00:23:16,090
lg(n!) 这里lg的底数为2

309
00:23:16,430 --> 00:23:17,900
这里我用到了一个不等式的性质

310
00:23:17,900 --> 00:23:21,520
它可以从这个不等式推出这个不等式

311
00:23:22,570 --> 00:23:23,640
这不是我们课程要讲的东西

312
00:23:23,640 --> 00:23:26,330
但你必须知道这是一个很重要的性质

313
00:23:39,780 --> 00:23:43,530
基本原则是我有一个不等式

314
00:23:43,850 --> 00:23:45,560
对一个不等式的两边做同样的运算

315
00:23:45,560 --> 00:23:48,060
我们希望 得到的不等式仍然成立

316
00:23:48,240 --> 00:23:50,350
为了得到上面这个结果

317
00:23:50,360 --> 00:23:53,690
我用到了哪个不等式性质

318
00:23:53,760 --> 00:23:58,500
对 是单调变换

319
00:23:58,780 --> 00:24:02,650
这里 lg函数是个单调递增的函数

320
00:24:06,280 --> 00:24:06,790
这很重要

321
00:24:07,380 --> 00:24:11,240
如果不等式两边同时乘以-1 也就是说

322
00:24:11,240 --> 00:24:13,700
递减函数的话 不等关系就应该倒过来

323
00:24:14,010 --> 00:24:16,360
这里不等关系不需要倒过来

324
00:24:16,360 --> 00:24:18,660
因为lg函数是单调递增的

325
00:24:18,660 --> 00:24:20,330
有lg 这关系就对了

326
00:24:22,270 --> 00:24:24,310
这里我们要注意下

327
00:24:24,330 --> 00:24:28,850
现在我们需要知道n的阶乘的近似值

328
00:24:28,850 --> 00:24:30,810
因为要计算它的lg值

329
00:24:31,020 --> 00:24:33,800
有人知道n阶乘的近似值公式吗

330
00:24:34,090 --> 00:24:35,650
知道公式名字也行

331
00:24:36,540 --> 00:24:37,350
斯特林公式

332
00:24:37,350 --> 00:24:37,930
非常好

333
00:24:37,930 --> 00:24:39,910
看样你们都知道斯特林公式

334
00:24:39,910 --> 00:24:50,120
这里只需要斯特林公式的最高阶因子

335
00:24:50,790 --> 00:24:54,770
n阶乘大于等于(n/e)ⁿ

336
00:24:55,740 --> 00:24:57,540
这就是我们要的

337
00:24:57,730 --> 00:25:00,940
现在我可以用lg的性质把n提出来

338
00:25:01,790 --> 00:25:07,130
等于 nlg(n/e)

339
00:25:13,750 --> 00:25:15,960
这里lg(n/e)也可以化简

340
00:25:26,380 --> 00:25:28,680
等于 lgn-lg(e)

341
00:25:30,150 --> 00:25:34,950
这里等于 n(lgn-lg(e))

342
00:25:35,870 --> 00:25:37,480
lg(e) 是个常数

343
00:25:37,480 --> 00:25:42,820
n趋于无穷大时lg(e)可以忽略不计

344
00:25:43,170 --> 00:25:46,100
最后等于Ω(nlgn)

345
00:25:46,330 --> 00:25:48,900
因为我们只关心前面的部分

346
00:25:49,430 --> 00:25:51,280
其实也就是 Θ(nlgn)

347
00:25:51,280 --> 00:25:53,510
但这里是大于等于的关系

348
00:25:53,510 --> 00:25:56,170
我们只用Ω就行了

349
00:25:56,440 --> 00:25:58,250
Θ和Ω在这里差不多

350
00:25:58,430 --> 00:26:01,840
当然 不是所有的排序算法的运行时间都是nlgn

351
00:26:01,840 --> 00:26:03,520
或都做nlgn 次比较

352
00:26:03,520 --> 00:26:05,920
其中一些算法是 另一些要差一点

353
00:26:05,920 --> 00:26:07,620
这个过程证明了所有排序算法

354
00:26:07,620 --> 00:26:09,960
对应的决策树的深度至少是nlgn

355
00:26:10,370 --> 00:26:14,260
如果你能想到叶节点数目的两个关系

356
00:26:14,260 --> 00:26:16,360
还有斯特林公式 你就能完成证明

357
00:26:17,140 --> 00:26:18,420
你们应该记住这个证明

358
00:26:19,160 --> 00:26:21,600
几乎所有的排序问题都至少

359
00:26:21,600 --> 00:26:24,580
需要做nlgn次比较

360
00:26:24,800 --> 00:26:28,000
如果它们能对应上决策树的话

361
00:26:28,390 --> 00:26:29,080
这是一个很重要的性质

362
00:26:29,080 --> 00:26:32,970
一个排序算法必须能够对应一个决策树

363
00:26:33,510 --> 00:26:35,870
我们从这个转换过程知道

364
00:26:35,870 --> 00:26:39,890
基于比较的排序可以转换成决策树

365
00:26:39,890 --> 00:26:41,380
但是有一些排序算法

366
00:26:41,380 --> 00:26:43,110
无法以决策树的形式表现出来

367
00:26:43,680 --> 00:26:46,220
我马上就要讲到这种算法

368
00:26:46,770 --> 00:26:48,900
但在讲这之前

369
00:26:50,900 --> 00:26:54,760
再看下决策树的下界问题

370
00:26:55,100 --> 00:26:58,960
也称为基于比较的排序算法的下界问题

371
00:26:58,960 --> 00:27:00,050
具体来讲 它说明了

372
00:27:00,050 --> 00:27:10,730
归并排序和堆排序算法是渐进最优的

373
00:27:11,060 --> 00:27:14,390
说到渐进 这些算法是依赖于n的

374
00:27:14,390 --> 00:27:16,920
并且忽略常数因子

375
00:27:16,920 --> 00:27:24,280
这些算法随n的递增趋于最优

376
00:27:25,270 --> 00:27:27,430
这仅适用于基于比较的模型

377
00:27:29,170 --> 00:27:32,050
所以 在基于比较的排序算法中

378
00:27:32,050 --> 00:27:35,490
它们都是渐进最优的

379
00:27:35,780 --> 00:27:38,970
它们只比较最少的次数

380
00:27:39,300 --> 00:27:41,300
它们的运行时间主要受

381
00:27:41,300 --> 00:27:42,530
比较次数的影响

382
00:27:42,800 --> 00:27:43,800
比较次数都等于Θ(nlgn)

383
00:27:44,780 --> 00:27:46,090
这是个好消息

384
00:27:47,170 --> 00:27:49,630
我还得说一点

385
00:27:49,630 --> 00:27:51,630
随机算法方面的东西

386
00:27:51,860 --> 00:27:54,380
我要讲的这些仅适用于

387
00:27:54,380 --> 00:27:56,840
确定性的算法

388
00:27:57,240 --> 00:28:01,680
有没有人发现对于随机算法有什么不同

389
00:28:01,690 --> 00:28:03,970
或者我在哪里默认了

390
00:28:03,970 --> 00:28:06,710
我用的是确定性的比较排序

391
00:28:09,400 --> 00:28:10,380
只有一点差别

392
00:28:10,650 --> 00:28:14,510
我也是今早看讲义时发现这点的

393
00:28:26,910 --> 00:28:27,420
给你们点提示

394
00:28:27,790 --> 00:28:31,320
在右边这块的黑板上

395
00:28:50,300 --> 00:28:52,060
一个确定性的算法

396
00:28:52,060 --> 00:28:55,200
它执行的每一步都是完全确定的

397
00:28:55,890 --> 00:29:02,340
只要我能知道所有的比较情况

398
00:29:02,340 --> 00:29:04,460
那么这个算法基本上就是确定的

399
00:29:08,720 --> 00:29:10,660
但对于随机算法

400
00:29:10,660 --> 00:29:13,310
它会受一些随机因素的影响

401
00:29:20,440 --> 00:29:22,590
有没有看出来二者有什么不同

402
00:29:25,750 --> 00:29:28,090
不只一棵树 完全正确

403
00:29:28,450 --> 00:29:31,390
我们已假定对于每个n都只有一棵树

404
00:29:31,580 --> 00:29:35,070
但事实上我们得到是树的概率分布

405
00:29:35,680 --> 00:29:36,890
对于每个n

406
00:29:36,900 --> 00:29:40,550
把算法所有可能的执行情况

407
00:29:40,550 --> 00:29:42,250
所有执行路径

408
00:29:42,570 --> 00:29:45,020
还有比较分支

409
00:29:45,020 --> 00:29:48,110
分支中各种可能的微小变化

410
00:29:48,450 --> 00:29:50,660
以及如何产生随机数等等都考虑进去

411
00:29:50,660 --> 00:29:52,920
最后会得到1到n之间的一个值

412
00:29:53,830 --> 00:29:56,150
我们得到了一个树的概率分布

413
00:29:56,400 --> 00:29:58,380
这个下界仍然适用

414
00:29:58,870 --> 00:30:02,030
不管得到一个什么样的树

415
00:30:02,290 --> 00:30:04,500
对于每个n至少会产生一棵树

416
00:30:04,830 --> 00:30:07,510
而这个证明适用于各种树

417
00:30:07,800 --> 00:30:09,600
所以不管什么样的树

418
00:30:09,600 --> 00:30:11,330
只要是正确的

419
00:30:11,330 --> 00:30:15,390
它的高度就是Ω(nlgn)

420
00:30:15,800 --> 00:30:18,670
这个下界同时也适用于随机算法

421
00:30:18,920 --> 00:30:20,470
你不可能比nlgn还好

422
00:30:20,470 --> 00:30:22,500
因为不管什么样的树

423
00:30:22,770 --> 00:30:25,430
发生什么样的变化

424
00:30:25,430 --> 00:30:29,420
这个下界定理始终适用

425
00:30:29,780 --> 00:30:33,800
每个树都是这样

426
00:30:33,800 --> 00:30:37,180
这里是说至少一棵树

427
00:30:40,940 --> 00:30:42,710
我们现在知道了这个定理

428
00:30:42,980 --> 00:30:44,840
我们还知道随机快速排序

429
00:30:44,840 --> 00:30:52,260
在理想的情况下是渐进最优的

430
00:31:03,210 --> 00:31:06,810
为了证明它是渐进最优的

431
00:31:07,300 --> 00:31:10,780
我们必须了解

432
00:31:10,780 --> 00:31:14,200
所有随机算法都要Ω(nlgn)次比较

433
00:31:14,480 --> 00:31:16,450
这块讲的差不多了

434
00:31:17,320 --> 00:31:19,420
这就是基于比较的模型

435
00:31:19,760 --> 00:31:25,660
还有什么问题么 好 我们继续

436
00:31:27,240 --> 00:31:32,740
下面要讲的是对比较模型的一个突破

437
00:31:32,740 --> 00:31:36,580
我们要尽量在线性时间内完成排序

438
00:31:41,550 --> 00:31:43,230
我们知道

439
00:31:43,230 --> 00:31:46,170
如果不用并行算法

440
00:31:46,170 --> 00:31:47,490
或是什么超能力

441
00:31:47,930 --> 00:31:49,740
你不可能比线性时间更快完成排序

442
00:31:49,740 --> 00:31:51,720
因为你得去遍历这些数据

443
00:31:51,960 --> 00:31:53,800
无论你对这些数据做什么

444
00:31:53,800 --> 00:31:56,720
你必须遍历 否则你无法对其正确排序

445
00:31:57,220 --> 00:31:58,930
因此线性时间是我们能期望的最好结果

446
00:31:59,180 --> 00:32:00,060
nlgn相当接近了

447
00:32:00,620 --> 00:32:02,820
我们如何在线性时间内排序

448
00:32:03,210 --> 00:32:05,690
我们需要一些更有效的设想

449
00:32:06,090 --> 00:32:07,090
这是一个计数实例

450
00:32:07,540 --> 00:32:10,200
我们将要不再用比较的方式

451
00:32:10,200 --> 00:32:12,070
而是对元素做一些其他操作

452
00:32:12,740 --> 00:32:15,900
我们要做的是假设

453
00:32:15,900 --> 00:32:18,830
它们是在特定范围内的整数

454
00:32:19,220 --> 00:32:21,780
我们会利用这点来在线性时间内排序

455
00:32:22,500 --> 00:32:27,790
我们现在看两种比nlgn快的排序算法

456
00:32:28,210 --> 00:32:29,510
第一种很简单

457
00:32:29,510 --> 00:32:32,110
并且我们第二种也中会用到它

458
00:32:32,460 --> 00:32:34,130
它被成为计数排序

459
00:32:37,450 --> 00:32:40,210
通常计数排序的输入是一个数列

460
00:32:40,870 --> 00:32:44,560
但我们会设定这些数列元素的范围

461
00:32:46,670 --> 00:32:52,440
每个A[i]是一个在1到k范围的整数

462
00:32:53,390 --> 00:32:55,260
这是一个很强的假设

463
00:32:55,610 --> 00:32:58,040
实际上运行时间也会依赖于k

464
00:32:58,280 --> 00:32:59,890
如果k很小这将是个很好的算法

465
00:33:00,330 --> 00:33:04,690
如果k很大这会是个比nlgn差的算法

466
00:33:07,920 --> 00:33:09,120
我们的目标是

467
00:33:09,120 --> 00:33:11,720
输出这个数列的某个排序序列

468
00:33:15,820 --> 00:33:19,060
我们称其为A排序

469
00:33:21,470 --> 00:33:23,760
直接写出输出序列

470
00:33:23,760 --> 00:33:27,700
要比写出算法的排列更方便

471
00:33:28,680 --> 00:33:31,220
因而我们需要一些辅助存储序列

472
00:33:31,890 --> 00:33:33,870
我接下来要写下伪代码

473
00:33:33,870 --> 00:33:37,810
因此我在声明所有变量

474
00:33:39,180 --> 00:33:42,750
以及写下长度为k的辅助存储序列

475
00:33:42,750 --> 00:33:45,840
这其实就是输入序列的范围长度

476
00:33:47,060 --> 00:33:49,890
我们来看算法

477
00:34:05,600 --> 00:34:07,280
这就是计数排序

478
00:34:16,060 --> 00:34:18,200
这需要一些时间写下

479
00:34:18,200 --> 00:34:20,570
但确实很容易明白

480
00:34:27,050 --> 00:34:29,090
首先我们做一些初始化

481
00:34:32,860 --> 00:34:34,370
然后我们计数

482
00:35:02,790 --> 00:35:04,480
然后我们求和

483
00:35:48,700 --> 00:35:51,760
然后我们就能写出输出序列了

484
00:36:26,090 --> 00:36:27,340
所有人都明白这个算法了吗

485
00:36:28,730 --> 00:36:30,080
没人 好吧

486
00:36:30,870 --> 00:36:33,600
这说明了伪代码会令人费解到何种程度

487
00:36:34,100 --> 00:36:35,430
当你们在解决自己的算法问题时

488
00:36:35,430 --> 00:36:36,320
你们应当记住

489
00:36:36,320 --> 00:36:38,090
要理解一个仅给出类似伪代码的

490
00:36:38,090 --> 00:36:40,070
算法是多么困难

491
00:36:40,480 --> 00:36:43,820
你需要某种自然语言描述当前情形

492
00:36:44,380 --> 00:36:47,400
因为除此以外当你想搞清楚这些问题

493
00:36:47,400 --> 00:36:49,360
你可能要耗费半个到一个小时

494
00:36:50,080 --> 00:36:52,420
而这不是种自我表达的好方法

495
00:36:53,490 --> 00:36:55,600
因此我现在要告诉你们的就是英语描述

496
00:36:55,950 --> 00:36:59,160
但我们会回顾伪代码来理解

497
00:37:00,840 --> 00:37:01,680
某种程度上

498
00:37:01,680 --> 00:37:04,340
这就是我们算法该做什么的圣经

499
00:37:05,610 --> 00:37:07,220
我来简短回顾下

500
00:37:07,550 --> 00:37:09,010
第一步是某些初始化

501
00:37:09,360 --> 00:37:14,240
C[i]用来记录某些数值出现的频率

502
00:37:14,590 --> 00:37:16,150
因此将它们初始化为0

503
00:37:16,460 --> 00:37:18,620
然后对于每个A[j]的值

504
00:37:18,620 --> 00:37:22,140
我们会递增代表A[j]的计数器的值

505
00:37:23,430 --> 00:37:29,410
最后C[i]会给出

506
00:37:29,410 --> 00:37:31,930
等于数值i的元素的数量

507
00:37:32,320 --> 00:37:34,540
然后我会对前缀做加法

508
00:37:34,540 --> 00:37:38,400
这使得C[i]表示

509
00:37:38,640 --> 00:37:41,060
小于或等于i的元素数目

510
00:37:41,060 --> 00:37:42,740
而不是等于i的数目

511
00:37:42,970 --> 00:37:43,810
最后我们获得了足够的信息

512
00:37:43,810 --> 00:37:46,900
可以把所有元素放到正确的地方

513
00:37:47,150 --> 00:37:49,470
我把这称为分配

514
00:37:50,200 --> 00:37:54,110
这是分配的步骤

515
00:37:54,400 --> 00:37:57,390
这很可能是所有步骤中最令人迷糊的

516
00:37:57,940 --> 00:37:59,440
我们来做一个实例

517
00:37:59,440 --> 00:38:01,690
更清楚的观察它的运作

518
00:38:10,340 --> 00:38:25,520
取一个数组A=[4,1,3,4,3]

519
00:38:30,840 --> 00:38:34,760
然后我取一个数组C

520
00:38:38,680 --> 00:38:41,530
我在这加一些下标

521
00:38:41,530 --> 00:38:45,760
使得我们能看到算法实际上在做什么

522
00:38:48,690 --> 00:38:51,370
显然所有元素在1到4的范围内

523
00:38:51,370 --> 00:38:52,790
因此k=4

524
00:38:53,390 --> 00:38:55,940
C数组有四个值

525
00:38:56,300 --> 00:38:58,270
开始我设它们均为0

526
00:38:58,550 --> 00:38:59,090
这很简单

527
00:39:00,800 --> 00:39:02,690
现在我要计算所有元素

528
00:39:03,530 --> 00:39:05,560
我不会在这里作弊

529
00:39:07,620 --> 00:39:11,250
我在第二个步骤 打个比方

530
00:39:11,870 --> 00:39:13,570
我要依次遍历各个元素

531
00:39:14,080 --> 00:39:16,020
对应每个C[i]的值

532
00:39:16,270 --> 00:39:18,380
第一个元素是4 因此我看C[4]

533
00:39:18,650 --> 00:39:19,530
那是0

534
00:39:19,740 --> 00:39:20,880
我将它加为1

535
00:39:21,180 --> 00:39:23,900
然后我看到元素1

536
00:39:24,260 --> 00:39:24,800
那是0

537
00:39:25,050 --> 00:39:26,240
我将它加为1

538
00:39:26,550 --> 00:39:28,840
然后我看到元素3 在这

539
00:39:29,490 --> 00:39:30,580
它也是0

540
00:39:30,910 --> 00:39:31,490
我将它加为1

541
00:39:31,770 --> 00:39:32,500
目前这并不值得兴奋

542
00:39:32,760 --> 00:39:33,510
现在我看到4 这我之前看到过

543
00:39:33,510 --> 00:39:34,800
很兴奋啊

544
00:39:35,240 --> 00:39:38,890
这里值是1 我将它加为2

545
00:39:39,410 --> 00:39:41,490
然后我看到3 也有一个值1

546
00:39:41,490 --> 00:39:42,710
我将它加为2

547
00:39:42,710 --> 00:39:47,990
结果是[1,0,2,2]

548
00:39:48,230 --> 00:39:56,360
这时C数组看上去就是这样

549
00:39:58,140 --> 00:40:02,900
现在我加上前缀 做个简单的改变

550
00:40:03,460 --> 00:40:05,800
我想知道的不是这些单独的值

551
00:40:05,800 --> 00:40:06,820
而是这些前缀数的和

552
00:40:06,830 --> 00:40:07,960
这些这些还有这些

553
00:40:07,960 --> 00:40:10,210
以此类推

554
00:40:10,950 --> 00:40:12,660
我这个数组为C'

555
00:40:12,660 --> 00:40:15,710
我们就不会混淆

556
00:40:17,340 --> 00:40:18,690
这是1

557
00:40:19,160 --> 00:40:20,350
1加0是1

558
00:40:20,640 --> 00:40:22,770
1加2是3

559
00:40:23,430 --> 00:40:25,280
3加2是5

560
00:40:25,790 --> 00:40:28,340
因此某种程度上这些是流动的总数

561
00:40:28,720 --> 00:40:30,100
总共有五个数

562
00:40:30,100 --> 00:40:32,320
小于或等于3的有三个元素

563
00:40:32,600 --> 00:40:34,550
小于或等于2的有一个元素 等等

564
00:40:35,770 --> 00:40:38,760
现在有意思的环节来了 分配

565
00:40:39,280 --> 00:40:41,750
这是得到B数列的地方

566
00:40:43,840 --> 00:40:45,580
B最好有相同大小

567
00:40:45,580 --> 00:40:48,170
每个元素会在某处出现

568
00:40:48,170 --> 00:40:50,640
它们会以排好的序列出现

569
00:40:51,270 --> 00:40:52,810
我们来运行算法

570
00:40:53,150 --> 00:40:55,340
j会从数组尾部开始

571
00:40:55,340 --> 00:40:58,090
递减至数组头部1

572
00:40:59,500 --> 00:41:07,460
我们做的就是取出A的最后元素A[n]

573
00:41:08,510 --> 00:41:11,650
我们看计数器

574
00:41:11,950 --> 00:41:14,070
在C数组中找到相应值

575
00:41:14,320 --> 00:41:20,270
这里值是3 第三列 因此3在那

576
00:41:22,360 --> 00:41:24,400
而这说明了这个元素在B中的位置

577
00:41:24,890 --> 00:41:30,100
你取出3放到数列B中下标为3的地方

578
00:41:31,110 --> 00:41:33,180
然后减去计数器

579
00:41:33,460 --> 00:41:37,070
在这用2代替3

580
00:41:38,010 --> 00:41:44,730
这个想法其实是这些数会告诉你值该放哪

581
00:41:45,380 --> 00:41:47,680
任何值为1的元素应该到位置1

582
00:41:48,020 --> 00:41:51,760
任何值为3的元素应该到位置3或更靠前

583
00:41:52,080 --> 00:41:55,550
这是元素3该去的最靠后的位置

584
00:41:56,320 --> 00:42:01,140
任何值为4的元素应该到位置5或更靠前

585
00:42:01,140 --> 00:42:04,790
到了数组最末 因为4是最大的值

586
00:42:05,400 --> 00:42:08,250
这个计数器会完美的运转

587
00:42:08,250 --> 00:42:13,320
因为在数组各部分都留下了足够的空间

588
00:42:13,570 --> 00:42:16,750
事实上这部分留给元素1

589
00:42:16,750 --> 00:42:20,500
没有2 这部分留给元素3

590
00:42:20,920 --> 00:42:22,700
这部分留给元素4

591
00:42:23,410 --> 00:42:25,780
你可以检查这个数列到底意味着什么

592
00:42:26,160 --> 00:42:27,540
我们结束运行这个算法

593
00:42:27,750 --> 00:42:29,620
这是最后一个元素

594
00:42:29,840 --> 00:42:32,190
我不会划掉它 但我们确实那样做了

595
00:42:32,490 --> 00:42:34,850
现在我看最后一个元素的相邻元素

596
00:42:35,060 --> 00:42:35,630
一个4

597
00:42:36,040 --> 00:42:38,000
4该去位置5

598
00:42:38,000 --> 00:42:41,500
因此我把这个4放在位置5并减去计数器

599
00:42:41,930 --> 00:42:43,550
接下来看到另一个3

600
00:42:44,130 --> 00:42:48,040
现在3该去位置2 因此去那

601
00:42:48,650 --> 00:42:50,190
减去计数器

602
00:42:50,460 --> 00:42:51,900
实际上我不会再用到计数器

603
00:42:52,090 --> 00:42:54,400
但还是减去它 因为算法规定如此

604
00:42:54,710 --> 00:42:55,900
我看到前面的元素

605
00:42:55,900 --> 00:42:56,590
一个1

606
00:42:56,990 --> 00:43:03,230
1该去位置1 放到那并减去计数器

607
00:43:03,660 --> 00:43:05,040
最终我碰到另一个4

608
00:43:05,440 --> 00:43:10,000
4该去位置4 在这

609
00:43:10,010 --> 00:43:12,550
减去计数器

610
00:43:15,040 --> 00:43:16,780
这就是计数排序

611
00:43:17,110 --> 00:43:21,360
你会发现所有的元素出现并已排好序

612
00:43:21,360 --> 00:43:22,750
这就是这个算法

613
00:43:22,990 --> 00:43:25,400
现在计数排序的运行时间是多少

614
00:43:28,090 --> 00:43:30,130
kn是一个上限

615
00:43:30,690 --> 00:43:31,890
这个算法比kn要好些

616
00:43:32,510 --> 00:43:33,660
事实上好了很多

617
00:43:38,430 --> 00:43:41,820
这需要一些加法

618
00:43:43,200 --> 00:43:46,500
回到算法开始

619
00:43:47,730 --> 00:43:52,850
这步需要多少时间 k

620
00:43:53,770 --> 00:43:59,060
这步呢 n

621
00:44:01,010 --> 00:44:08,420
这步呢 k

622
00:44:09,710 --> 00:44:12,640
每项for循环中的操作耗费固定时间

623
00:44:12,640 --> 00:44:17,820
这由for中的循环次数决定

624
00:44:19,320 --> 00:44:25,070
最终这步需要n

625
00:44:26,600 --> 00:44:35,740
因此计数排序总的运行时间是k+n

626
00:44:41,340 --> 00:44:44,030
如果k相对较小则此算法极好

627
00:44:44,030 --> 00:44:45,950
比如k最大为n

628
00:44:46,680 --> 00:44:50,850
如果k较大像n²或2ⁿ或任何其他

629
00:44:50,850 --> 00:44:52,650
这不是那么好

630
00:44:52,650 --> 00:44:57,460
但如果k=O(n)这极好

631
00:45:01,790 --> 00:45:04,730
我们得到了线性时间的排序算法

632
00:45:05,040 --> 00:45:08,130
我们不仅需要假设这些数是整数

633
00:45:08,400 --> 00:45:11,010
还需要确保这些整数的范围很小

634
00:45:11,010 --> 00:45:12,210
算法在此基础上运行

635
00:45:12,460 --> 00:45:15,740
如果所有的数在1和n之间

636
00:45:15,740 --> 00:45:18,360
那么我们就得到了一个线性时间算法

637
00:45:18,610 --> 00:45:21,210
但只要他们小于nlgn我们就该满意了

638
00:45:21,420 --> 00:45:22,660
如果回到nlgn的排序

639
00:45:23,090 --> 00:45:23,750
就不那么好

640
00:45:24,430 --> 00:45:26,960
因此你可以写一个混合算法

641
00:45:26,960 --> 00:45:31,460
如果k比nlgn大那么我就用归并排序

642
00:45:31,810 --> 00:45:33,960
如果它比nlgn小我会用计数排序

643
00:45:34,470 --> 00:45:37,310
这可行 但我们可以做的更好

644
00:45:42,170 --> 00:45:43,130
时间怎么办

645
00:45:46,420 --> 00:45:50,500
应该注意到我们越过了界限

646
00:45:50,500 --> 00:45:53,000
但只需假设我们在比较模型之外

647
00:45:53,260 --> 00:45:55,250
实际上我们还没有与原来的定理发生矛盾

648
00:45:55,250 --> 00:45:56,440
只是改变了模型

649
00:45:56,940 --> 00:45:58,100
提出质疑总是好的

650
00:45:58,100 --> 00:46:02,910
对于任何题目场景中你允许做的

651
00:46:03,530 --> 00:46:05,520
某个实用的场景

652
00:46:05,520 --> 00:46:08,640
如果你在处理的数字长度为1字节

653
00:46:08,640 --> 00:46:09,890
这就很好

654
00:46:10,420 --> 00:46:13,810
k仅为2⁸ 这是256

655
00:46:14,040 --> 00:46:17,850
你需要的辅助数列长度为256

656
00:46:17,850 --> 00:46:18,870
这很快

657
00:46:19,100 --> 00:46:20,100
256+n

658
00:46:20,100 --> 00:46:22,420
无论n多大这是n的线性时间

659
00:46:22,610 --> 00:46:24,040
如果你知道数字小这会很好

660
00:46:24,300 --> 00:46:26,310
但如果数字更大

661
00:46:26,310 --> 00:46:28,230
即使你知道它们仍是整数

662
00:46:28,230 --> 00:46:30,510
但它们是类似于32位的双字

663
00:46:30,510 --> 00:46:31,980
就不那么简单了

664
00:46:32,220 --> 00:46:35,400
因为k是2³²

665
00:46:35,400 --> 00:46:41,360
这是42亿或此类相当大的数

666
00:46:42,130 --> 00:46:45,770
你所需的辅助序列就要有42亿个字

667
00:46:45,770 --> 00:46:47,890
这大概是16G

668
00:46:48,270 --> 00:46:51,570
因此初始化数组都很困难

669
00:46:51,570 --> 00:46:55,090
除非n比40亿大很多很多

670
00:46:55,090 --> 00:46:59,340
而且你有16G的存储空间来纯粹挥霍

671
00:46:59,340 --> 00:47:04,180
而我还没有一台机器的RAM有16G

672
00:47:04,180 --> 00:47:06,860
显然这不是一个好的算法

673
00:47:07,290 --> 00:47:09,700
如果数确实小 仅凭感觉它就是好的

674
00:47:10,270 --> 00:47:13,810
接下来我们要接触一个更有趣的算法

675
00:47:13,810 --> 00:47:15,550
这个算法会利用计数排序

676
00:47:15,550 --> 00:47:17,300
作为小数据规模的子程序

677
00:47:17,300 --> 00:47:23,180
结合这个算法去处理更大规模的数字

678
00:47:25,180 --> 00:47:26,970
这个算法叫做基数排序算法

679
00:47:27,680 --> 00:47:31,820
不过现在要讲计数排序一个重要性质

680
00:47:31,820 --> 00:47:33,650
在进一步之前

681
00:47:40,800 --> 00:47:42,760
这个重要性质是稳定性

682
00:47:48,980 --> 00:47:59,700
一个稳定性算法保证了相等元素的顺序

683
00:47:59,700 --> 00:48:02,950
这个叫相对顺序

684
00:48:17,600 --> 00:48:20,840
这个有点儿微妙因为通常元素就是数字

685
00:48:21,330 --> 00:48:23,580
现在有一对3然后还有一对4

686
00:48:23,910 --> 00:48:27,010
结果是你要是看一下那些3的顺序

687
00:48:27,020 --> 00:48:29,950
还有4的顺序 他们保持了原来的顺序

688
00:48:30,140 --> 00:48:32,740
把最后的3拿出来放在这里

689
00:48:33,140 --> 00:48:34,520
然后拿挨着的下一个3

690
00:48:34,520 --> 00:48:35,850
然后把它放在这个左面

691
00:48:35,850 --> 00:48:37,650
计数器减0

692
00:48:37,650 --> 00:48:41,990
然后从数组结尾挪到数组的开头

693
00:48:42,370 --> 00:48:46,690
不管怎么操作那些3的顺序都不变

694
00:48:46,920 --> 00:48:47,940
那些4的顺序也不变

695
00:48:48,390 --> 00:48:50,500
这个相对看起来挺简单的

696
00:48:50,510 --> 00:48:53,450
不过看一下我们讲过的其他四种排序算法

697
00:48:53,730 --> 00:48:55,480
不是所有都稳定

698
00:48:56,190 --> 00:48:57,700
一个课堂练习

699
00:49:05,040 --> 00:49:09,080
找出讲过的其他排序算法

700
00:49:09,080 --> 00:49:12,450
哪些稳定哪些不是

701
00:49:19,590 --> 00:49:20,790
我强烈建议你做出来

702
00:49:20,790 --> 00:49:22,940
因为这种问题会在小测中出现

703
00:49:24,900 --> 00:49:29,220
不过现在知道计数排序是稳定的就够了

704
00:49:30,620 --> 00:49:34,500
我不证明了不过从算法看来很显然

705
00:49:36,080 --> 00:49:38,920
现在开始基数排序

706
00:49:54,380 --> 00:49:55,600
基数排序是用来在

707
00:49:55,600 --> 00:49:59,250
线性时间内处理大范围数据的

708
00:50:01,610 --> 00:50:04,440
现在还是要假设这个数据有多大

709
00:50:04,440 --> 00:50:07,880
不过肯定是很宽松的假设

710
00:50:08,250 --> 00:50:11,160
现在再留点儿悬念

711
00:50:11,160 --> 00:50:13,470
我准备讲一下基数排序的历史

712
00:50:13,680 --> 00:50:15,640
这是最古老排序方法之一

713
00:50:15,950 --> 00:50:19,670
很可能是最古老实现的算法了

714
00:50:19,930 --> 00:50:22,860
大约出现在1890年

715
00:50:23,800 --> 00:50:28,110
这是Herman Hollerith

716
00:50:30,470 --> 00:50:32,020
大约1890

717
00:50:35,570 --> 00:50:37,960
有人以前听说过Herman Hollerith么

718
00:50:38,780 --> 00:50:39,730
两个

719
00:50:40,480 --> 00:50:41,310
不多啊

720
00:50:41,800 --> 00:50:42,880
他是个很重要的人物

721
00:50:43,070 --> 00:50:44,530
他曾经是MIT的讲师

722
00:50:45,000 --> 00:50:52,190
他发明了最早版本的打孔卡片

723
00:50:52,450 --> 00:50:53,090
打孔卡片技术

724
00:50:53,440 --> 00:50:55,650
我也没用过 所以看了讲义才想起来

725
00:50:55,940 --> 00:50:56,840
它们叫打孔卡片

726
00:50:57,160 --> 00:50:58,510
你们可能也见过

727
00:50:58,860 --> 00:51:01,900
如果你们没见过 看一下ppt课件

728
00:51:02,320 --> 00:51:03,380
这是个大网格

729
00:51:03,880 --> 00:51:14,160
如果你最近用过现代打孔卡片的话

730
00:51:14,160 --> 00:51:19,030
他们是80字符宽 我不知道

731
00:51:19,030 --> 00:51:23,160
好像是16吧 记不清了

732
00:51:23,470 --> 00:51:26,620
然后在这里打小孔

733
00:51:26,950 --> 00:51:28,330
用这个神奇的机器

734
00:51:28,510 --> 00:51:29,480
像一个打字机

735
00:51:29,650 --> 00:51:32,720
你按下一个键对应一个字母

736
00:51:32,910 --> 00:51:35,960
可能会在这里打一个洞

737
00:51:36,470 --> 00:51:39,730
想深入了解的话可以上网看一下

738
00:51:39,730 --> 00:51:42,110
它具体工作方式和历史原因

739
00:51:42,330 --> 00:51:46,370
你也不用了解太多 不过这个确实是

740
00:51:46,650 --> 00:51:51,810
大部分终端是80字符宽的原因

741
00:51:52,080 --> 00:51:57,100
不能确切的说Hollerith发明了这种打孔卡片

742
00:51:57,100 --> 00:51:59,440
虽然确实是他发明了打孔卡片

743
00:51:59,660 --> 00:52:03,110
早在1890年 人口普查很困难

744
00:52:03,600 --> 00:52:06,520
如果你看新闻的话 我想应该一两年前

745
00:52:06,520 --> 00:52:08,080
人口普查很困难

746
00:52:08,310 --> 00:52:11,090
因为从每个人那里收集数据确实很庞大

747
00:52:11,360 --> 00:52:13,880
宪法说你必须收集

748
00:52:13,890 --> 00:52:15,360
关于每个人每十年的数据

749
00:52:15,790 --> 00:52:17,050
而且越来越困难

750
00:52:17,340 --> 00:52:20,530
特别是 那是1880年 人口普查

751
00:52:20,800 --> 00:52:23,870
可能要耗费将近十年时间才能完成

752
00:52:24,160 --> 00:52:25,650
人口持续增长

753
00:52:25,650 --> 00:52:27,880
用10年时间做一次十年普查

754
00:52:28,130 --> 00:52:30,820
当两次普查时间重叠时 代价变得很高

755
00:52:31,100 --> 00:52:33,840
所以1890年他们想要做点儿特别的事情

756
00:52:34,150 --> 00:52:35,000
然后Hollerith说了

757
00:52:35,000 --> 00:52:39,420
好吧 我准备建一个能输入数据的机器

758
00:52:39,750 --> 00:52:41,660
这个就是一个修改过的打孔卡片

759
00:52:41,660 --> 00:52:48,880
根据你的状态标记相应的方块

760
00:52:49,220 --> 00:52:51,000
你是未婚啊还是已婚啊或者什么的

761
00:52:51,230 --> 00:52:53,710
所有普查时需要知道的数据

762
00:52:53,710 --> 00:52:55,880
他们在卡片上编码成二进制

763
00:52:56,160 --> 00:52:57,240
然后Hollerith就做了一个机器

764
00:52:57,240 --> 00:53:00,020
可以对那些卡片进行分类以便进行统计

765
00:53:00,570 --> 00:53:03,580
某种感觉上 这些都是数字

766
00:53:03,620 --> 00:53:05,460
这些数字不是太大

767
00:53:05,460 --> 00:53:08,690
但又确实大到足以让计数排序算法失效

768
00:53:08,910 --> 00:53:10,960
我是说如果这里有100个数字

769
00:53:10,960 --> 00:53:15,000
2¹⁰⁰实在太猛了 所以不能用计数排序

770
00:53:15,940 --> 00:53:20,470
首先 我的想法一开始就是错误的

771
00:53:21,060 --> 00:53:26,520
我准备把它们当成数字

772
00:53:27,120 --> 00:53:30,900
每一列是一个数字

773
00:53:31,470 --> 00:53:34,520
就是对这个最高位在这里

774
00:53:34,520 --> 00:53:36,330
和最低位在这里的数字排序

775
00:53:36,330 --> 00:53:41,150
第一个想法是先对最高位排序

776
00:53:48,870 --> 00:53:51,640
这个不是一个好的算法

777
00:53:51,870 --> 00:53:53,600
因为如果对最高位排序

778
00:53:53,600 --> 00:53:57,910
会得到一堆卡片在一堆桶里面

779
00:53:58,130 --> 00:53:59,720
而且这个是物理设备

780
00:53:59,900 --> 00:54:02,220
不是电子计算机

781
00:54:02,520 --> 00:54:05,840
需要交给一些人来读

782
00:54:06,070 --> 00:54:09,530
他会看第一列哪个洞被打上了

783
00:54:09,760 --> 00:54:12,140
然后他打开一个箱子

784
00:54:12,140 --> 00:54:16,030
把这个卡片扔进去

785
00:54:16,030 --> 00:54:17,480
然后这个卡片就被放在正确的箱子里了

786
00:54:17,830 --> 00:54:19,380
这是半自动的

787
00:54:19,380 --> 00:54:23,010
计算机是人加上机器 不过没关系

788
00:54:23,290 --> 00:54:24,260
就是这个过程

789
00:54:24,260 --> 00:54:25,170
你把它们放在箱子里面排序

790
00:54:25,170 --> 00:54:28,440
然后还得对每个箱子的卡片按第二位排序

791
00:54:28,730 --> 00:54:31,210
很快箱子数目变得非常多

792
00:54:31,500 --> 00:54:33,890
如果不想要这么多位 也可以

793
00:54:33,890 --> 00:54:35,570
不过这本来就不是正确的方案

794
00:54:36,270 --> 00:54:43,340
Hollerith后来提出 正确的做法是

795
00:54:43,340 --> 00:54:48,670
先对最后一位排序

796
00:54:58,100 --> 00:55:01,940
这里你必须使用一种稳定的排序算法

797
00:55:02,400 --> 00:55:05,170
当时Hollerith可能不会叫它稳定排序

798
00:55:05,170 --> 00:55:07,830
不过我们可以

799
00:55:09,570 --> 00:55:12,000
这个算法让Hollerith赚了很多钱

800
00:55:12,230 --> 00:55:15,730
它在1911年发明了这个制表机

801
00:55:15,980 --> 00:55:19,030
然后在1924年吞并了几个公司

802
00:55:19,030 --> 00:55:21,670
组成了叫做IBM的新公司

803
00:55:22,150 --> 00:55:25,760
这个可能是你听说过Hollerith的原因

804
00:55:25,760 --> 00:55:27,980
也可能你之前做过打孔卡片

805
00:55:28,860 --> 00:55:32,380
整体思想就是 按位排序

806
00:55:33,270 --> 00:55:34,490
我一开始就说IBM的话你们就知道了

807
00:55:35,820 --> 00:55:39,280
我们从最低位开始到最高位

808
00:55:40,040 --> 00:55:40,870
结果这个算法很有用

809
00:55:41,750 --> 00:55:43,440
来看一个例子

810
00:55:43,780 --> 00:55:48,050
我想我可能需要两块黑板才够

811
00:55:53,770 --> 00:55:54,710
首先我们来看一个例子

812
00:55:54,960 --> 00:55:55,950
然后我们将证明这个方法

813
00:55:56,210 --> 00:55:59,290
证明实际上非常简单

814
00:55:59,660 --> 00:56:03,420
尽管如此 这个算法确实不容易想到

815
00:56:03,420 --> 00:56:04,410
如果你以前没见过的话

816
00:56:06,030 --> 00:56:10,620
当然 我第一次见到的时候也很惊讶

817
00:56:12,650 --> 00:56:14,900
最出色的地方在于这个算法没有箱子

818
00:56:14,900 --> 00:56:16,700
始终都是一个大箱子

819
00:56:17,450 --> 00:56:18,350
我们取一些数字

820
00:56:20,610 --> 00:56:21,990
329

821
00:56:22,240 --> 00:56:23,300
这是一个三位数

822
00:56:24,040 --> 00:56:26,630
我在数字中间留空 以便看清楚每一位

823
00:56:27,110 --> 00:56:29,360
457

824
00:56:29,360 --> 00:56:42,340
657 839 436 720和355

825
00:56:42,560 --> 00:56:44,910
我假设这是十进制的

826
00:56:45,140 --> 00:56:45,560
没什么不好

827
00:56:49,460 --> 00:56:50,810
希望它们还是乱序

828
00:56:50,810 --> 00:56:51,930
因为我们就是要为它们排序

829
00:56:52,920 --> 00:56:56,740
首先取出最低位

830
00:56:56,740 --> 00:56:59,170
按照最低位排序

831
00:56:59,860 --> 00:57:02,600
遇到相等的数 比如这两个9

832
00:57:02,600 --> 00:57:04,230
我们保持它们的顺序

833
00:57:04,470 --> 00:57:06,880
所以329仍然要在839的前面

834
00:57:07,330 --> 00:57:10,830
这没关系 因为现在才是第一遍

835
00:57:10,830 --> 00:57:14,560
不过通常我们总是选择稳定排序算法

836
00:57:14,900 --> 00:57:20,290
根据这一列排序 首先是0对应的数

837
00:57:20,290 --> 00:57:29,330
也就是这个720 然后是5 355

838
00:57:29,630 --> 00:57:33,720
然后是6 436

839
00:57:33,920 --> 00:57:34,930
出错的话打断我一下

840
00:57:35,360 --> 00:57:38,890
然后是这些7 保持它们原来的顺序

841
00:57:39,430 --> 00:57:41,200
这里顺序恰好已经正确

842
00:57:41,200 --> 00:57:42,670
不过最后可能不是这样

843
00:57:42,930 --> 00:57:45,240
我们甚至还没看其它位呢

844
00:57:45,520 --> 00:57:53,390
然后是9 2个9 329和839

845
00:57:54,560 --> 00:57:56,590
目前为止没问题吧

846
00:57:57,630 --> 00:57:57,940
好的

847
00:57:59,440 --> 00:58:04,090
现在按中间位排序 也就是倒数第二位

848
00:58:04,800 --> 00:58:07,740
看起来2是最小的

849
00:58:07,940 --> 00:58:10,050
上面有一个2在这 下面一个2在这

850
00:58:13,080 --> 00:58:17,060
当然 先写第一个2 720然后329

851
00:58:17,400 --> 00:58:25,830
然后是3 得到436和839

852
00:58:28,630 --> 00:58:31,740
然后看起来是一堆5

853
00:58:32,420 --> 00:58:33,920
目前为止没漏掉哪个数吧

854
00:58:34,230 --> 00:58:35,240
没有 好的

855
00:58:35,830 --> 00:58:45,080
有3个5 355 457和657

856
00:58:45,600 --> 00:58:48,280
我来检查一下有没有漏掉

857
00:58:48,510 --> 00:58:51,690
这里7个 这里7个 这里也是7个

858
00:58:51,990 --> 00:58:52,350
好的

859
00:58:52,720 --> 00:58:54,950
最后 我们对剩下的这一位排序

860
00:58:55,240 --> 00:58:58,280
请注意 在我们按这一位排序之前

861
00:58:58,480 --> 00:59:00,810
这些数字看起来一点也不像排过序的

862
00:59:01,100 --> 00:59:04,290
但是如果不去看没有排序过的这一位

863
00:59:04,530 --> 00:59:06,840
这两位 很好 是有序的

864
00:59:06,840 --> 00:59:11,140
20 29 36 39 55 57 57

865
00:59:11,460 --> 00:59:12,210
很好

866
00:59:12,270 --> 00:59:16,420
把这个做完

867
00:59:16,680 --> 00:59:18,510
对第一位稳定排序

868
00:59:18,810 --> 00:59:28,840
最小的是3 得到329 然后355

869
00:59:30,970 --> 00:59:37,650
然后是4 436和457

870
00:59:37,650 --> 00:59:54,560
然后是6 656 然后一个7一个8

871
00:59:56,300 --> 00:59:57,810
检查一下

872
00:59:57,810 --> 00:59:58,980
还是7个数

873
00:59:58,980 --> 01:00:00,260
好的 没丢啥

874
01:00:00,260 --> 01:00:01,960
确实 它们现在已经排好序了

875
01:00:02,310 --> 01:00:03,820
你可以想一想为什么这样做能行

876
01:00:04,030 --> 01:00:06,750
当有相同元素时 后缀数字已经排好了

877
01:00:07,340 --> 01:00:09,000
接下来是证明过程

878
01:00:12,510 --> 01:00:18,390
好的部分是我们不用分成一个一个箱子了

879
01:00:18,640 --> 01:00:21,360
而是始终把它们放在一整个大桶里面

880
01:00:21,950 --> 01:00:24,100
我们只是多次遍历

881
01:00:24,430 --> 01:00:26,760
通常 排序总是需要多次遍历

882
01:00:26,760 --> 01:00:28,010
只希望次数不要太多

883
01:00:31,540 --> 01:00:33,300
先证明正确性

884
01:00:33,860 --> 01:00:37,100
分析运行时间有点儿小技巧

885
01:00:37,100 --> 01:00:39,930
因为这个取决于你怎么分割位

886
01:00:40,900 --> 01:00:42,310
正确性证明很简单

887
01:00:42,890 --> 01:00:49,330
只要对已经排序的部分数字位进行归纳

888
01:00:49,330 --> 01:00:51,480
这里记作t

889
01:00:51,980 --> 01:00:57,450
通过归纳假设在t之前的位已经排序

890
01:00:57,870 --> 01:01:02,560
这是归纳假设

891
01:01:04,840 --> 01:01:12,230
假设我们已经对较低的t-1位排好序了

892
01:01:17,280 --> 01:01:21,560
接下来做的就是对第t位排序

893
01:01:24,770 --> 01:01:26,320
然后检查先后顺序对不对

894
01:01:26,540 --> 01:01:29,860
我们用t-1的表达式来计算t

895
01:01:30,390 --> 01:01:34,410
对第t位排序有两种情况

896
01:01:34,610 --> 01:01:36,250
检查任意两个元素 我们想知道

897
01:01:36,260 --> 01:01:37,590
这两个元素的相对顺序是否正确

898
01:01:37,590 --> 01:01:44,000
如果这两个元素是相同的

899
01:01:44,290 --> 01:01:52,410
就是说它们有相同的第t位数字

900
01:01:52,410 --> 01:01:58,210
这就是用到一点技巧的地方

901
01:01:58,420 --> 01:02:03,220
第t位数字相同意味着不应交换顺序

902
01:02:03,400 --> 01:02:09,040
基于稳定性原则 可知它们保持原顺序

903
01:02:13,510 --> 01:02:15,540
因为被排序元素具有相同的键值时

904
01:02:15,540 --> 01:02:17,720
稳定性意味着保持元素位置不变

905
01:02:18,290 --> 01:02:20,260
然后 根据归纳假设

906
01:02:20,750 --> 01:02:23,970
我们可以知道它们仍然保持有序

907
01:02:23,970 --> 01:02:28,420
因为根据归纳假设它们已经排过序

908
01:02:28,680 --> 01:02:31,420
加上现在这个第t位数字

909
01:02:31,420 --> 01:02:33,470
还是有序的 因为没有改变任何东西

910
01:02:33,470 --> 01:02:34,760
所以它们仍然是有序的

911
01:02:35,160 --> 01:02:41,610
如果它们有不同的第t位数字

912
01:02:53,280 --> 01:02:56,570
那么排序过程将把它们调整为正确的顺序

913
01:02:59,470 --> 01:03:01,140
因为那就是排序的本职工作

914
01:03:02,760 --> 01:03:04,170
这是最高位

915
01:03:04,170 --> 01:03:06,570
所以我们可以根据第t位对它们排序

916
01:03:06,830 --> 01:03:07,590
其余的无关紧要

917
01:03:08,140 --> 01:03:13,160
所以如果知道算法 正确性很容易证明

918
01:03:15,850 --> 01:03:17,790
现在 有什么问题吗

919
01:03:22,710 --> 01:03:23,090
很好

920
01:03:25,260 --> 01:03:26,700
下面我们将使用计数排序

921
01:03:28,980 --> 01:03:33,230
对一位数字 我们可以使用任何排序算法

922
01:03:33,230 --> 01:03:35,610
但是目前我们所知的算法里

923
01:03:35,610 --> 01:03:39,060
运行时间少于nlgn的只有计数排序

924
01:03:39,290 --> 01:03:42,350
所以 我们最好还是用它做辅助算法

925
01:03:42,360 --> 01:03:45,550
这样才能实现更快更一般的算法

926
01:03:49,940 --> 01:03:51,980
我刚刚擦掉了运行时间

927
01:03:52,210 --> 01:03:59,540
计数排序运行时间为(n+k)阶

928
01:04:00,630 --> 01:04:01,660
我们需要牢记这一点

929
01:04:02,300 --> 01:04:06,360
数字的范围是1到k或者0到(k-1)

930
01:04:07,860 --> 01:04:10,460
当我们仅对一位数字排序时

931
01:04:10,460 --> 01:04:13,250
不应该使用nlgn的算法

932
01:04:13,250 --> 01:04:16,040
因为这将在每一轮花费nlgn时间

933
01:04:16,040 --> 01:04:17,450
而我们必然会运行很多轮

934
01:04:17,450 --> 01:04:18,790
结果将比nlgn糟糕

935
01:04:18,790 --> 01:04:23,060
因此我们将在每一轮使用计数排序

936
01:04:31,450 --> 01:04:35,090
对每一位上的数字使用计数排序

937
01:04:38,500 --> 01:04:43,580
已知基数排序的运行时间是(k+n)

938
01:04:45,860 --> 01:04:50,660
但我不想按照每一个数字位来依次排序

939
01:04:50,910 --> 01:04:53,580
那样将会丧失太多灵活性

940
01:04:53,580 --> 01:04:56,980
因为数可以用任意形式来表示

941
01:04:56,980 --> 01:04:58,240
比如用二进制表示的数

942
01:04:58,240 --> 01:05:02,000
可以把几个比特放在一起当做一位来处理

943
01:05:02,250 --> 01:05:04,010
假设我们的数是二进制数

944
01:05:04,430 --> 01:05:07,280
有n个整数

945
01:05:09,720 --> 01:05:10,750
它们都在相同的范围内

946
01:05:10,950 --> 01:05:12,990
而我们希望知道它们的取值范围

947
01:05:15,450 --> 01:05:20,270
从实践角度来考虑

948
01:05:20,280 --> 01:05:26,610
我们知道 二进制整数设为b比特长

949
01:05:26,920 --> 01:05:34,130
那么取值范围就在0到(2^b-1)之间

950
01:05:34,340 --> 01:05:36,370
假定所有的数都非负

951
01:05:36,370 --> 01:05:38,350
有负数的话情况也没有太大不同

952
01:05:40,340 --> 01:05:42,650
我希望知道我们可以处理多大的b

953
01:05:42,650 --> 01:05:51,480
但是我不想把数字拆分成比特

954
01:05:51,480 --> 01:05:54,330
因为虽然我得到了b个数字

955
01:05:54,330 --> 01:05:57,350
但是我需要重复b轮这个算法

956
01:05:57,350 --> 01:06:00,950
重复的轮数就是数的位数

957
01:06:01,150 --> 01:06:04,200
比较好的情况下 每次要花费线性时间

958
01:06:04,610 --> 01:06:08,830
而实际上如果只是1比特 那么k=2

959
01:06:09,120 --> 01:06:10,450
所以这是n阶的

960
01:06:10,760 --> 01:06:14,320
但是每轮的运行时间都是n阶的

961
01:06:14,580 --> 01:06:16,220
一共有b位数字

962
01:06:16,220 --> 01:06:19,760
如果按比特切分 则有n乘b阶的时间

963
01:06:19,980 --> 01:06:23,130
即使b是很小的值 比如lgn

964
01:06:23,140 --> 01:06:25,190
如果我们有lgn比特

965
01:06:25,470 --> 01:06:27,970
则这些数在0到(n-1)之间

966
01:06:28,200 --> 01:06:29,830
我已经知道怎样在线性时间内

967
01:06:29,830 --> 01:06:31,600
对0到(n-1)之间的数排序

968
01:06:31,870 --> 01:06:35,120
这里花费了nlgn时间 这不好

969
01:06:35,760 --> 01:06:36,380
相反地

970
01:06:36,380 --> 01:06:39,380
我们要做的是把连续的比特看做一位

971
01:06:39,380 --> 01:06:42,690
我们可以用计数排序一次处理的最多比特

972
01:06:44,580 --> 01:06:53,230
算法是 把每个整数拆分为b/r位数字

973
01:06:57,780 --> 01:06:59,480
每个数字是r比特长

974
01:07:03,620 --> 01:07:07,650
换句话说 基于2^r进制来表示这个数

975
01:07:10,440 --> 01:07:12,240
我只是碰巧用二进制形式将它们写下来

976
01:07:12,460 --> 01:07:14,950
但是我把r比特放在一起

977
01:07:14,950 --> 01:07:17,240
实际是基于2^r进制得到了一些数字

978
01:07:18,390 --> 01:07:20,250
然后我们一共有b/r位数字

979
01:07:20,480 --> 01:07:23,620
b/r是我们需要运算的轮数

980
01:07:26,340 --> 01:07:30,850
而这个基数 就是每一位数字的最大值

981
01:07:31,100 --> 01:07:32,670
就是说每位数字的范围在0到2^r之间

982
01:07:32,880 --> 01:07:38,880
某种意义上说 它就是计数排序中的k

983
01:07:45,300 --> 01:07:49,950
那么 总的运行时间怎么算呢

984
01:07:49,950 --> 01:07:52,390
我们一共有b/r轮

985
01:07:54,950 --> 01:07:58,600
那么是b/r乘以每轮运行所需时间

986
01:07:58,960 --> 01:08:03,500
我们有n个数字 k值为2^r

987
01:08:04,310 --> 01:08:09,870
计数排序的运行时间是(n+k)

988
01:08:09,870 --> 01:08:18,650
这是轮数 最终结果为(b/r)*(n+2^r)

989
01:08:21,240 --> 01:08:23,970
而我们可以任意挑选r

990
01:08:25,750 --> 01:08:31,750
目的是通过选择r来尽量减少运行时间

991
01:08:33,470 --> 01:08:34,770
有没有什么建议呢

992
01:08:34,770 --> 01:08:39,120
怎样挑选r可以使运行时间最小呢

993
01:08:40,000 --> 01:08:42,620
方法就可以 不必说出完整的过程

994
01:08:51,590 --> 01:08:54,500
我们一下子想不到是因为它是隐式的

995
01:08:54,500 --> 01:08:56,100
但是如果忽略这里的大O的话

996
01:08:56,380 --> 01:08:59,320
怎样求一个一元函数的最小值呢

997
01:09:00,240 --> 01:09:01,370
对 求导

998
01:09:01,720 --> 01:09:05,770
我们对这个函数关于r求导

999
01:09:05,770 --> 01:09:08,810
对r求导 求导数为零时的解

1000
01:09:08,810 --> 01:09:10,800
就可以得到函数的驻点

1001
01:09:10,800 --> 01:09:13,130
实际上这个函数在r上是单模的

1002
01:09:13,130 --> 01:09:14,920
因此总可以找到最小值

1003
01:09:15,210 --> 01:09:16,630
我们可以算出来

1004
01:09:17,160 --> 01:09:19,790
我不具体写出来了 这会花费一些时间

1005
01:09:20,010 --> 01:09:20,930
你下课以后可以写一下

1006
01:09:21,180 --> 01:09:24,870
这里 我们可以得到具体的最小值

1007
01:09:24,870 --> 01:09:29,790
如果你知道了这个常数是多少

1008
01:09:30,300 --> 01:09:38,920
对r求导 求导数等于零时的解

1009
01:09:41,590 --> 01:09:43,970
我将会采用某种更直觉的方法

1010
01:09:43,970 --> 01:09:45,420
换句话说 不那么精确的方法

1011
01:09:45,760 --> 01:09:46,660
但我们还是可以得到正确的结果

1012
01:09:46,870 --> 01:09:48,460
准确的说是上界

1013
01:09:48,460 --> 01:09:50,200
因为r是任意选择的

1014
01:09:50,510 --> 01:09:51,730
所以这个结果总是正确的

1015
01:09:52,100 --> 01:09:54,430
让我们考虑关于r的增长过程

1016
01:09:54,970 --> 01:09:57,110
这里有两个包含r的项

1017
01:09:57,370 --> 01:10:00,600
我们有(b/r)*(n)和(b/r)*(2^r)

1018
01:10:00,990 --> 01:10:04,250
对于(b/r)*(n)这项 r越大越好

1019
01:10:04,490 --> 01:10:06,450
r越大轮数越少

1020
01:10:06,980 --> 01:10:12,280
n前面的这个数 这个系数变小

1021
01:10:12,540 --> 01:10:14,000
所以我希望r尽可能大

1022
01:10:14,410 --> 01:10:21,070
所以 (b/r)*(n)希望r尽可能大

1023
01:10:21,460 --> 01:10:23,720
然而 r不能太大

1024
01:10:23,970 --> 01:10:26,880
因为那意味着一个数用很长的比特来表示

1025
01:10:27,130 --> 01:10:29,710
它不可以太大 因为这里有2^r项

1026
01:10:30,090 --> 01:10:32,510
如果这个值恰好比n大

1027
01:10:32,510 --> 01:10:35,750
这一项将决定多项式随r的增长而增大

1028
01:10:35,980 --> 01:10:38,950
结果将是b*(2^r)/r

1029
01:10:39,200 --> 01:10:41,070
2^r远远大于r

1030
01:10:41,070 --> 01:10:43,540
增长速度远比我们想象得快

1031
01:10:43,950 --> 01:10:47,650
因此根据这一项可知 r不能太大

1032
01:10:47,920 --> 01:10:56,770
所以 b/r*(2^r)希望r比较小

1033
01:10:58,700 --> 01:11:04,500
注意到这一项大于等于这一项

1034
01:11:04,500 --> 01:11:08,340
则由这一项可知 r可以取较大的值

1035
01:11:08,570 --> 01:11:11,900
我们要的是让n决定整个多项式的大小

1036
01:11:12,300 --> 01:11:16,140
在这样的前提下我才可以任意设定r的值

1037
01:11:16,380 --> 01:11:33,010
所以不妨选择r为这种情况下的最大值

1038
01:11:33,010 --> 01:11:35,580
也就是满足n大于等于2^r

1039
01:11:36,580 --> 01:11:39,310
这是2^r的上界 就得到r的上界

1040
01:11:39,640 --> 01:11:44,830
换句话说 r最大可以取lgn

1041
01:11:44,830 --> 01:11:50,470
在现有条件下 这个结果是对的

1042
01:11:51,290 --> 01:11:53,990
继续

1043
01:11:54,210 --> 01:11:56,850
选择r=lgn就可以得到

1044
01:11:56,850 --> 01:11:58,320
运行时间的上界

1045
01:11:59,490 --> 01:12:01,160
因为我可以任意选择

1046
01:12:01,920 --> 01:12:04,680
如果你用求导的方法 结果是一样的

1047
01:12:08,990 --> 01:12:12,880
这并不是严格的解答 但是结果很接近

1048
01:12:12,880 --> 01:12:16,940
因为大O记号只关心谁增长最快

1049
01:12:18,350 --> 01:12:28,520
代入r=lgn 就得到(b*n)/lgn

1050
01:12:28,520 --> 01:12:32,030
n等于2^r

1051
01:12:32,030 --> 01:12:34,820
它是2的倍数 2乘以n 没有太大关系

1052
01:12:34,820 --> 01:12:35,870
经过大O记号之后

1053
01:12:36,280 --> 01:12:39,980
我们得到了(b*n)/lgn 其中lgn=r

1054
01:12:42,330 --> 01:12:44,940
我们需要考虑这是什么

1055
01:12:44,940 --> 01:12:47,760
并且把它转换成数的范围

1056
01:12:48,010 --> 01:12:50,500
b是数的比特位数

1057
01:12:50,500 --> 01:12:53,310
对应于数的取值范围

1058
01:12:54,370 --> 01:13:02,560
原来我总共提早20分下课 所以今天我打算拖堂20分

1059
01:13:03,310 --> 01:13:04,210
不是啦 我开玩笑的

1060
01:13:04,650 --> 01:13:05,400
马上就下课

1061
01:13:05,980 --> 01:13:14,790
注意到待排序数列都是某个范围内的整数

1062
01:13:14,790 --> 01:13:27,600
这个范围是0到2^b 或者说0到n^d

1063
01:13:28,010 --> 01:13:28,720
这里应该有一个-1

1064
01:13:29,040 --> 01:13:35,000
如果数的范围在0到n^d-1

1065
01:13:35,000 --> 01:13:40,470
这里的d是常数 也就是参数

1066
01:13:40,770 --> 01:13:43,730
那么这就是n的多项式

1067
01:13:43,730 --> 01:13:45,700
计算一下运行时间

1068
01:13:46,070 --> 01:13:50,640
是(n*d)阶的

1069
01:13:51,150 --> 01:13:52,460
就是这样来考虑

1070
01:13:52,460 --> 01:13:54,150
现在我们可以和计数排序比较

1071
01:13:54,470 --> 01:13:56,680
计数排序可以用线性时间

1072
01:13:56,680 --> 01:13:59,890
处理0到某个常数乘以d范围内的数

1073
01:14:00,150 --> 01:14:03,020
现在我们可以在线性时间内处理

1074
01:14:03,020 --> 01:14:06,100
0到n的某个常数次方范围内的数

1075
01:14:07,360 --> 01:14:12,330
如果d=O(1) 这就是一个线性时间的算法

1076
01:14:12,960 --> 01:14:17,000
而且只要d小于等于lgn就可以

1077
01:14:17,230 --> 01:14:19,950
只要数的范围在nlgn以内

1078
01:14:19,950 --> 01:14:23,990
我们就可以击败原来的nlgn算法

1079
01:14:24,250 --> 01:14:25,890
这样很好

1080
01:14:26,250 --> 01:14:28,440
只要我们知道

1081
01:14:28,440 --> 01:14:32,010
我们的数字是lgn比特长 我们就很高兴

1082
01:14:32,010 --> 01:14:34,890
我们做了一些实际情况的权衡

1083
01:14:35,150 --> 01:14:39,250
比如 如果我们有32位的数

1084
01:14:39,250 --> 01:14:43,340
我们把它们拆分为 比如8位的段

1085
01:14:43,340 --> 01:14:46,240
我们仅仅需要做四轮线性时间的运算

1086
01:14:46,240 --> 01:14:49,280
只需要256位辅助空间

1087
01:14:49,610 --> 01:14:52,680
32位数需要4轮

1088
01:14:52,930 --> 01:14:54,420
如果使用nlgn算法

1089
01:14:54,420 --> 01:14:57,540
你需要做lgn次运算

1090
01:14:57,870 --> 01:15:02,800
n差不多是2000 那么至少是11轮

1091
01:15:03,030 --> 01:15:06,670
你会认为这个算法对于小的数字

1092
01:15:06,670 --> 01:15:08,090
会运行得更快

1093
01:15:08,320 --> 01:15:10,850
不幸的是 计数排序在缓存上要求更多

1094
01:15:11,100 --> 01:15:15,910
在实践中 计数排序并不那么快

1095
01:15:15,910 --> 01:15:17,740
除非你的数都很小

1096
01:15:18,140 --> 01:15:20,180
快速排序之类的会做得更好

1097
01:15:20,550 --> 01:15:23,840
有点遗憾 在理论上这个算法真的很美

1098
01:15:24,100 --> 01:15:25,210
但是需要在正确的情境下

1099
01:15:25,210 --> 01:15:27,630
才适合使用这种方式来排序

1100
01:15:27,860 --> 01:15:31,410
最后提一下 如果是对任意整数排序

1101
01:15:31,410 --> 01:15:33,210
并且每个数都是一个字长

1102
01:15:33,740 --> 01:15:36,260
这里我们假设每个字有b比特

1103
01:15:36,260 --> 01:15:41,230
这里我们间接地有些依赖b

1104
01:15:41,520 --> 01:15:42,640
但是 一般来说

1105
01:15:42,640 --> 01:15:46,910
如果你有一些一个字长的数

1106
01:15:46,910 --> 01:15:48,960
而且可以在常数时间内操作一个字的话

1107
01:15:49,320 --> 01:15:54,380
目前已知的最好的排序算法

1108
01:15:54,380 --> 01:16:04,060
期望运行时间是n乘根号下lg(lgn)

1109
01:16:04,340 --> 01:16:05,750
这是一个随机算法

1110
01:16:06,710 --> 01:16:08,490
我们在本课程内不会涉及它

1111
01:16:08,770 --> 01:16:10,200
它非常复杂

1112
01:16:10,200 --> 01:16:14,480
甚至我教的高级算法也不会讲

1113
01:16:14,480 --> 01:16:16,740
如果你想要某种简单一些的算法

1114
01:16:16,740 --> 01:16:21,210
有一个最坏情况n乘lg(lgn)的算法

1115
01:16:21,550 --> 01:16:22,960
那篇论文还是可以看懂的

1116
01:16:23,410 --> 01:16:24,920
我在高级算法里讲了那个算法

1117
01:16:25,160 --> 01:16:27,320
如果你对这些感兴趣

1118
01:16:27,320 --> 01:16:29,040
下学期可以选修高级算法

1119
01:16:30,120 --> 01:16:32,180
那是本课程的后继课程

1120
01:16:32,530 --> 01:16:34,280
有很多非常复杂的算法

1121
01:16:34,280 --> 01:16:36,190
但是它们可以给你某种信息

1122
01:16:36,430 --> 01:16:38,460
你可以打破对b的依赖

1123
01:16:38,460 --> 01:16:40,410
只要你知道b最多是一个字长

1124
01:16:40,930 --> 01:16:44,240
没有问题的话就到这里

1125
01:16:44,960 --> 01:16:46,610
下周三再见

