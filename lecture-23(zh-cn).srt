1
00:00:06,430 --> 00:00:10,070
6.046到了尾声~~o(≧v≦)o~

2
00:00:10,080 --> 00:00:28,670
我们今天再讲讲缓存参数无关算法

3
00:00:28,690 --> 00:00:32,180
上节课我们见识了几种算法

4
00:00:32,200 --> 00:00:34,760
不过那些算法没什么难度

5
00:00:34,770 --> 00:00:38,440
今天我们来看看两个难一点的算法

6
00:00:38,460 --> 00:00:39,850
这两个更高端

7
00:00:39,860 --> 00:00:44,050
我想既然是最后一节课 那就来点高端的东西

8
00:00:44,060 --> 00:00:46,500
来个一发入魂

9
00:00:46,510 --> 00:00:54,220
闲话少说 开始干活

10
00:00:54,230 --> 00:00:58,920
上节课我们讲了二分法

11
00:00:58,930 --> 00:01:01,500
或者说 分析了二分法

12
00:01:01,510 --> 00:01:04,270
而且我们知道 二分法在缓参无关时

13
00:01:04,280 --> 00:01:07,080
表现得不是很好

14
00:01:07,090 --> 00:01:08,790
下课后有些人来问我

15
00:01:08,790 --> 00:01:12,110
缓参无关的二分法能不能再给力点？

16
00:01:12,110 --> 00:01:15,760
当然可以 我们用静态搜索树就可以做到

17
00:01:15,770 --> 00:01:19,280
实际上 它也是二分法

18
00:01:19,290 --> 00:01:25,720
说得抽象点 就是给你N个有序的元素

19
00:01:25,740 --> 00:01:27,790
建立某种静态的数据结构

20
00:01:27,800 --> 00:01:32,580
使你能够快速搜索这N个元素

21
00:01:32,590 --> 00:01:35,970
我说的快速 是指以B为底的log N

22
00:01:35,980 --> 00:01:37,810
我们知道 对于B树

23
00:01:37,810 --> 00:01:40,590
我们的目标是以B为底的log N

24
00:01:40,600 --> 00:01:45,280
如果B是已知的 那我们已经可以做到了

25
00:01:45,290 --> 00:01:48,110
我们希望就算不知道B也能做到

26
00:01:48,130 --> 00:01:54,080
而这正是缓参无关静态搜索树能够做到的事

27
00:01:54,090 --> 00:01:55,990
下面是具体做法

28
00:01:56,000 --> 00:02:03,280
你们可能猜到了 我们要用一个树

29
00:02:03,290 --> 00:02:09,000
我们先把N个元素放在一个完全二叉树中

30
00:02:09,010 --> 00:02:12,310
我们用不了B树 因为B还是未知的

31
00:02:12,330 --> 00:02:15,330
那么我们就用一个二叉树

32
00:02:15,340 --> 00:02:18,800
关键就是我们如何构造这个二叉树

33
00:02:18,820 --> 00:02:21,950
这个二叉树有N个节点

34
00:02:21,970 --> 00:02:23,690
或者你可以把数据放在叶子节点上

35
00:02:23,700 --> 00:02:26,390
这些都不是重点

36
00:02:26,390 --> 00:02:31,040
那么这就是我们的树了

37
00:02:31,060 --> 00:02:33,820
里面有N个节点

38
00:02:33,820 --> 00:02:35,520
现在 我们要存储数据

39
00:02:35,520 --> 00:02:40,330
忘了说 是有序地存储

40
00:02:40,340 --> 00:02:43,600
按照一般的方法 有序存储在二叉树里

41
00:02:43,610 --> 00:02:45,160
这样它就是一个二叉搜索树

42
00:02:45,170 --> 00:02:46,900
这样我们就可以在树里做查找

43
00:02:46,920 --> 00:02:48,270
从根节点开始查找

44
00:02:48,290 --> 00:02:51,640
沿某条路径直到叶子节点

45
00:02:51,650 --> 00:02:54,410
在每个节点处 你都知道要向左走还是向右走

46
00:02:54,420 --> 00:02:55,570
因为这些都是有序的

47
00:02:55,580 --> 00:03:00,170
那么 我们假设这是一个有序元素的集合

48
00:03:00,190 --> 00:03:03,080
这就很明显了 我们知道搜索要花费log N的时间

49
00:03:03,100 --> 00:03:05,190
问题是存储的传输量有多少？

50
00:03:05,200 --> 00:03:08,050
我们想把根节点周围的许多节点

51
00:03:08,060 --> 00:03:10,920
都集中到一个内存块中

52
00:03:10,930 --> 00:03:12,890
不过我们不知道这个块的大小

53
00:03:12,900 --> 00:03:20,430
所以我们要做的是 将这颗树从中间进行分割

54
00:03:20,440 --> 00:03:26,050
用分治法来设计这个树的内存布局

55
00:03:26,060 --> 00:03:29,420
设计节点在内存里是分布形式

56
00:03:29,430 --> 00:03:33,630
这个分治法就是把树从中间切开

57
00:03:33,650 --> 00:03:35,710
有点诡异

58
00:03:35,720 --> 00:03:37,480
这可不是一般的分治法

59
00:03:37,490 --> 00:03:41,990
但今天我们会反复提及到它

60
00:03:42,010 --> 00:03:43,870
那么 我们给中间来了一刀

61
00:03:43,890 --> 00:03:50,400
如果树原本的高度是log N

62
00:03:50,420 --> 00:03:54,530
或者是log N加上常数 但大致就是log N

63
00:03:54,540 --> 00:03:59,210
那么 上半部分的高度就是log N/2

64
00:03:59,220 --> 00:04:04,030
下半部分也是log N/2

65
00:04:04,050 --> 00:04:09,990
那上半部分有多少个节点？

66
00:04:10,000 --> 00:04:14,730
N/2？ 不太对吧

67
00:04:14,740 --> 00:04:19,370
2的logN/2次方 解出来就是√n

68
00:04:19,380 --> 00:04:21,900
所以这里就有√n个节点

69
00:04:21,910 --> 00:04:25,520
因此 这下面就大约有√n个子树

70
00:04:25,520 --> 00:04:29,500
一个叶节点对于一个或多个子树

71
00:04:29,510 --> 00:04:34,200
然后 这些子树也都有√n个节点

72
00:04:34,210 --> 00:04:39,690
大约一共有√n个子树

73
00:04:39,710 --> 00:04:42,640
我们就这样把树分割开来

74
00:04:42,650 --> 00:04:45,360
现在 我们要递归地分割下去

75
00:04:45,370 --> 00:04:50,820
这个图得稍微改改

76
00:04:50,830 --> 00:04:52,370
这样能更明了些

77
00:04:52,390 --> 00:04:55,570
这些三角形都是树

78
00:04:55,580 --> 00:05:01,000
它们通过一些边跟上面这棵树相连

79
00:05:01,010 --> 00:05:02,820
我们所做的就是

80
00:05:02,830 --> 00:05:07,930
把树中部的这些边切断

81
00:05:07,940 --> 00:05:12,480
如果N不是2的整数幂

82
00:05:12,500 --> 00:05:15,160
这条边的位置可能要上下浮动

83
00:05:15,170 --> 00:05:17,360
不过大体位置是在中间

84
00:05:17,370 --> 00:05:21,080
这里有很多条边

85
00:05:21,080 --> 00:05:23,690
你往这里来上一刀

86
00:05:23,700 --> 00:05:26,800
树就分成了顶部树和底部树

87
00:05:26,810 --> 00:05:30,460
而底部树有很多个 它们的大小都为√N

88
00:05:30,480 --> 00:05:41,040
然后我们递归地分割

89
00:05:41,060 --> 00:05:53,980
这√N+1棵子树 然后把他们连接在一起

90
00:05:53,990 --> 00:05:55,860
这就是递归分布的思想

91
00:05:55,870 --> 00:05:58,910
上一次我们是用递归分布来处理矩阵

92
00:05:58,920 --> 00:06:00,620
这次只是将处理的对象换成了树

93
00:06:00,630 --> 00:06:03,910
我现在要对顶部树进行递归分布

94
00:06:03,920 --> 00:06:06,150
这是我们的顶部树

95
00:06:06,160 --> 00:06:08,960
想象一下它被压扁了

96
00:06:08,970 --> 00:06:12,940
变成了一个线性序列

97
00:06:12,960 --> 00:06:18,030
然后 我对这些底部树也做同样的事

98
00:06:18,050 --> 00:06:23,530
这些是底部树

99
00:06:23,550 --> 00:06:26,850
我把它们每个都压成线性序列

100
00:06:26,870 --> 00:06:29,110
然后把这些线性序列都连接起来

101
00:06:29,120 --> 00:06:32,150
这就是这个树的线性序列了

102
00:06:32,160 --> 00:06:33,230
当然需要有一个基准情形

103
00:06:33,250 --> 00:06:34,920
基准情形就是只有一个节点

104
00:06:34,930 --> 00:06:38,040
它的线性序列就是它本身

105
00:06:38,050 --> 00:06:42,140
这就是一个二叉搜索树的递归分布

106
00:06:42,160 --> 00:06:46,140
你会发现这很有用

107
00:06:46,150 --> 00:06:49,490
我们来举一些简单的例子

108
00:06:49,510 --> 00:06:52,100
来把这种分布方式搞清楚

109
00:06:52,110 --> 00:06:59,890
因为如果你们以前没学过的话 会感觉很诡异

110
00:06:59,900 --> 00:07:13,000
画这个是我的拿手好戏

111
00:07:13,010 --> 00:07:16,750
树的高度是四或者三 这取决于你的计算方式

112
00:07:16,760 --> 00:07:22,230
我们在树中部做分割 那么上面的就是顶部树

113
00:07:22,240 --> 00:07:27,160
下面这些是底部树

114
00:07:27,170 --> 00:07:29,150
这里有四个底部树

115
00:07:29,160 --> 00:07:33,810
也就是说顶部树下面连着四个子树

116
00:07:33,820 --> 00:07:35,640
这里它们的大小都一样

117
00:07:35,660 --> 00:07:37,740
通常它们都是差不多大的

118
00:07:37,750 --> 00:07:39,720
然后我们对顶部树进行分布

119
00:07:39,740 --> 00:07:41,440
先在中部进行分割

120
00:07:41,450 --> 00:07:43,210
那好 最上面的就是1

121
00:07:43,280 --> 00:07:47,100
接下来底部的子树就是2和3

122
00:07:47,110 --> 00:07:48,380
我写的这个顺序

123
00:07:48,400 --> 00:07:51,260
就是它们在数组里面的顺序

124
00:07:51,270 --> 00:07:54,530
然后我们到这个子树 得到4、5、6

125
00:07:54,550 --> 00:07:58,290
然后到这个子树 得到7、8、9

126
00:07:58,300 --> 00:08:06,960
然后下一个 10、11、12 再然后是最后一个子树

127
00:08:06,970 --> 00:08:10,680
这就是这15个节点的存储顺序

128
00:08:10,690 --> 00:08:13,570
你可以通过递归来进行构造

129
00:08:13,580 --> 00:08:16,620
这个结构其实很简单

130
00:08:16,640 --> 00:08:18,900
就是我们喜闻乐见的二分结构

131
00:08:18,920 --> 00:08:20,600
不过存储方式很非主流

132
00:08:20,610 --> 00:08:24,070
这不是深度优先遍历和层次遍历

133
00:08:24,080 --> 00:08:25,600
并不是那些常用的方式

134
00:08:25,620 --> 00:08:28,490
那些方式在缓参无关环境下都无效

135
00:08:28,500 --> 00:08:31,030
这可以说是唯一有效的选择

136
00:08:31,040 --> 00:08:32,260
而直观上来看

137
00:08:32,280 --> 00:08:36,160
我们想要我们的树适用于所有类型的B树

138
00:08:36,170 --> 00:08:38,420
如果你想要一个二叉树

139
00:08:38,420 --> 00:08:39,550
那好 这本来就是二叉树

140
00:08:39,560 --> 00:08:41,260
你想用什么方式来存储都行

141
00:08:41,270 --> 00:08:44,930
如果你想要一个分支是4的树

142
00:08:44,940 --> 00:08:45,900
这个就是了

143
00:08:45,910 --> 00:08:48,630
这四个块就是你要的四个分支

144
00:08:48,640 --> 00:08:49,960
如果下面有更多的叶节点

145
00:08:49,970 --> 00:08:53,780
那么 这下面又会有四个子树

146
00:08:53,790 --> 00:08:56,430
而在同一块里的数据 都是连续地存储在内存中

147
00:08:56,450 --> 00:08:58,930
如果你的内存块大小是3

148
00:08:58,940 --> 00:09:02,390
那这就是一个内存块为3的完美的解决方案

149
00:09:02,400 --> 00:09:08,350
如果你的块大小是15

150
00:09:08,360 --> 00:09:11,870
那我们来数一数

151
00:09:11,890 --> 00:09:13,740
这一整块的节点数就是15

152
00:09:13,750 --> 00:09:15,870
如果你的块大小是15

153
00:09:15,880 --> 00:09:20,950
那么这种分配也可以完美地给你大小为15的块

154
00:09:20,970 --> 00:09:26,390
实际上 它适用于块大小为2^2^K-1的情况

155
00:09:26,400 --> 00:09:30,210
2的平方的K次方 好 这是直观的阐述

156
00:09:30,250 --> 00:09:37,380
下面给出更系统、清楚的分析

157
00:09:37,400 --> 00:09:49,090
我们已知有O(log_B(N))的存储传输量

158
00:09:49,100 --> 00:09:53,600
我们想证明的它对于任意B都成立

159
00:09:53,620 --> 00:09:55,450
下面就是我们要做的

160
00:09:55,460 --> 00:09:58,940
好好回想一下 上次我们分析分治法的时候

161
00:09:58,950 --> 00:10:02,110
在递归循环中 基准情形是关键

162
00:10:02,110 --> 00:10:03,560
某种意义上 我们关注的

163
00:10:03,570 --> 00:10:05,580
其实只有基准情形而已

164
00:10:05,590 --> 00:10:08,470
你用不着去跟着递归一步一步走

165
00:10:08,490 --> 00:10:10,920
算法会自己找到一条根到叶子的路径

166
00:10:10,940 --> 00:10:13,830
递归过程仅仅出现于存储分布的定义里

167
00:10:13,840 --> 00:10:16,910
所以 我们的想法可以更灵活一些

168
00:10:16,920 --> 00:10:19,220
你用不着去盯着递归看

169
00:10:19,230 --> 00:10:21,040
只要考虑基准情形就可以了

170
00:10:21,050 --> 00:10:24,560
想象一下 你从这个大三角形开始

171
00:10:24,570 --> 00:10:27,280
然后你在中间来了一刀 得到了更小的三角形

172
00:10:27,300 --> 00:10:30,330
然后你一直这样切下去

173
00:10:30,350 --> 00:10:31,380
想象一下这个过程

174
00:10:31,390 --> 00:10:34,160
大三角形每次都会被拦腰斩断

175
00:10:34,180 --> 00:10:35,530
然后 三角形越变越小

176
00:10:35,540 --> 00:10:42,110
直到三角形的大小正好符合内存块的大小为止

177
00:10:42,130 --> 00:10:44,440
我们要看的就是这个时候

178
00:10:44,450 --> 00:10:46,170
当然了 每一步都需要递归分割

179
00:10:46,190 --> 00:10:48,480
但是在分析里 我们需要考虑则只有

180
00:10:48,490 --> 00:10:52,970
当三角形和内存块大小吻合的时候

181
00:10:52,980 --> 00:10:56,330
也就是框起来的节点数与块大小一致的时候

182
00:10:56,340 --> 00:11:01,010
我们把每一层递归称为递归层级

183
00:11:01,020 --> 00:11:09,150
想象一下 我们把一层层的递归平行地展开来

184
00:11:09,160 --> 00:11:10,460
这是一种表示细节的层级

185
00:11:10,460 --> 00:11:15,960
或者说表示树被细分的程度

186
00:11:15,970 --> 00:11:22,200
我们要考虑的是 当三角形的大小

187
00:11:22,220 --> 00:11:23,200
换句话说

188
00:11:23,210 --> 00:11:27,280
当三角形中的节点数 小于等于B的时候

189
00:11:27,290 --> 00:11:35,050
我来画上一笔

190
00:11:35,060 --> 00:11:38,500
我想要画的和这幅图的差不多 不过我不用节点

191
00:11:38,520 --> 00:11:41,490
而是用三角形 它们大小最大是B

192
00:11:41,510 --> 00:11:44,830
我们的图大概会是这样

193
00:11:44,830 --> 00:11:47,210
我们有一个小三角形 最大是B

194
00:11:47,220 --> 00:11:52,580
它下面有一些子树

195
00:11:52,590 --> 00:11:55,170
它们的大小也同样是B

196
00:11:55,180 --> 00:12:00,470
这些是一组 然后还有其他的组

197
00:12:00,480 --> 00:12:08,540
和上面的基本一样

198
00:12:27,610 --> 00:12:29,400
我就不一一画全了

199
00:12:29,410 --> 00:12:33,580
其实中间还有很多子树  数量在B到B^2之间

200
00:12:33,590 --> 00:12:38,090
呃 是子树大小的平方才对

201
00:12:38,100 --> 00:12:40,440
我要先对整个树在中间进行了细分

202
00:12:40,450 --> 00:12:44,270
然后再对这些子树的这里 和这里 进行细分

203
00:12:44,280 --> 00:12:47,590
经过了这两级递归 我们发现

204
00:12:47,600 --> 00:12:49,540
这些三角形就和内存块大小一样了

205
00:12:49,580 --> 00:12:50,560
每个三角形大小都一样

206
00:12:50,570 --> 00:12:53,280
到某个时候它们就和内存块大小一样了

207
00:12:53,300 --> 00:12:56,760
不过也有可能它们会比内存块要小一些

208
00:12:56,780 --> 00:13:01,670
到底有多小？

209
00:13:01,670 --> 00:13:03,200
我所做的其实就是

210
00:13:03,210 --> 00:13:07,590
每次把树对半分割

211
00:13:07,610 --> 00:13:12,670
一直到这些树的高度

212
00:13:12,680 --> 00:13:18,630
小于等于log B时候 我才停止分割

213
00:13:18,640 --> 00:13:24,190
因为这时子树的节点数大约为B

214
00:13:24,210 --> 00:13:27,080
那么高度最小是多少？

215
00:13:27,090 --> 00:13:35,940
我一直不停地分割下去 一直到树高≤ B为止

216
00:13:35,950 --> 00:13:37,200
最小是log B/2

217
00:13:37,210 --> 00:13:41,770
所以高度最大是log B 最小是log B/2

218
00:13:41,780 --> 00:13:42,480
所以子树的节点数

219
00:13:42,490 --> 00:13:45,140
可能是√B到B之间

220
00:13:45,160 --> 00:13:47,750
所以 子树的节点数可能会远小于

221
00:13:47,760 --> 00:13:49,770
一个块的的大小 不过这无关紧要

222
00:13:49,790 --> 00:13:51,960
都是可以的 它的大小可能是√B

223
00:13:51,970 --> 00:13:54,070
我甚至都不想把它可能是√B写出来

224
00:13:54,080 --> 00:13:56,100
因为在分析里它是打酱油的

225
00:13:56,110 --> 00:13:58,270
这是个隐患 不过可以接受

226
00:13:58,280 --> 00:14:02,440
本质上因为我们的定界只跟以B为底的log有关

227
00:14:02,460 --> 00:14:05,630
而不是和B有关

228
00:14:05,640 --> 00:14:08,400
回过来总结一下

229
00:14:08,410 --> 00:14:13,760
我们知道对于这些节点数≤B的三角形

230
00:14:13,770 --> 00:14:19,950
它们的高度大于等于log B/2

231
00:14:19,960 --> 00:14:28,460
因此 如果你观察一条搜索路径

232
00:14:28,470 --> 00:14:30,300
当我们在树里进行搜索时

233
00:14:30,300 --> 00:14:32,130
我们应该从这里开始

234
00:14:32,140 --> 00:14:34,030
我又开始毁图了

235
00:14:34,040 --> 00:14:36,300
我们沿着某一条路径

236
00:14:36,320 --> 00:14:39,220
或许应该是往这边走

237
00:14:39,240 --> 00:14:41,590
我们访问了这些三角形

238
00:14:41,600 --> 00:14:43,680
不过实际上这是一条根到节点的路径

239
00:14:43,690 --> 00:14:45,880
那么我们一共访问了多少三角形？

240
00:14:45,890 --> 00:14:47,720
答案是 树的高度——

241
00:14:47,730 --> 00:14:50,100
除以三角形的高度

242
00:14:50,110 --> 00:15:03,310
访问的三角形个数最多是log N / (½ log B)

243
00:15:03,320 --> 00:15:05,390
哎哟 不错喔 这就是以B为底的log N

244
00:15:05,400 --> 00:15:06,750
当然前面还有个2

245
00:15:06,760 --> 00:15:14,310
现在 我们想知道一个三角形要占用几个块？

246
00:15:14,320 --> 00:15:20,400
某些三角形应该正好只占用一个内存块  但是呢

247
00:15:20,420 --> 00:15:22,000
我们知道在递归分布中

248
00:15:22,010 --> 00:15:24,980
这是三角形是储存在一段连续的内存区域里的

249
00:15:24,990 --> 00:15:27,880
那么 三角形最多可能占用几个块？

250
00:15:27,890 --> 00:15:29,430
两个 因为在数据对齐时

251
00:15:29,440 --> 00:15:32,440
某个三角形可能正好落在块的边界上

252
00:15:32,460 --> 00:15:34,230
不过最多也只有一个边界

253
00:15:34,240 --> 00:15:36,820
所以 两个块能妥妥地装下

254
00:15:36,830 --> 00:15:42,160
每个三角形都能装在一个块里

255
00:15:42,160 --> 00:15:46,870
不过有时候会占用到两个块

256
00:15:46,880 --> 00:15:50,350
两个内存块 大小是B 取决于数据对齐的情况

257
00:15:50,360 --> 00:15:54,090
所以传输的内存量 换而言之

258
00:15:54,100 --> 00:15:55,650
也就是读取的块的个数——

259
00:15:55,660 --> 00:15:59,450
因为搜索实际就是在读取

260
00:15:59,460 --> 00:16:01,900
——每个三角形最多占用两个块

261
00:16:01,910 --> 00:16:03,250
算上这么多三角形的

262
00:16:03,270 --> 00:16:07,870
最多是4 log_B(N)

263
00:16:07,890 --> 00:16:10,320
也就是O(log_B(n))

264
00:16:10,340 --> 00:16:14,010
有些论文专门研究如何把降低这个常数4

265
00:16:14,020 --> 00:16:15,710
用的是更复杂的数据结构

266
00:16:15,730 --> 00:16:18,800
我觉得起码能降低得比2要小

267
00:16:18,820 --> 00:16:21,480
但就这样了 这个其实并没有B树那么好

268
00:16:21,490 --> 00:16:24,150
因为有这个常数 不过已经不错了

269
00:16:24,160 --> 00:16:25,440
而这个数据结构的精妙之处在于

270
00:16:25,450 --> 00:16:27,800
对于所有B值都有效

271
00:16:27,810 --> 00:16:30,010
这个分析对于所有的B都成立

272
00:16:30,020 --> 00:16:35,540
所以 我们可以轻松应对多层内存结构

273
00:16:35,550 --> 00:16:36,920
对于这个数据结构还有什么问题？

274
00:16:36,940 --> 00:16:38,620
这货的难度已经是困难了

275
00:16:38,630 --> 00:16:41,610
不过接下来的会是噩梦级别的

276
00:16:41,620 --> 00:16:49,160
很好 大家都很淡定

277
00:16:49,180 --> 00:16:54,080
你们是都无压力 还是已经GG？  我看是不明觉厉

278
00:16:54,090 --> 00:16:58,640
有时我自己会思想斗争

279
00:16:58,650 --> 00:17:01,510
来决定我们下面要讲什么

280
00:17:01,520 --> 00:17:02,980
有两个东西都很有必要讲

281
00:17:02,990 --> 00:17:04,540
但两个都挺复杂的

282
00:17:04,550 --> 00:17:08,690
我在缓参无关算法中地第一个成果

283
00:17:08,700 --> 00:17:11,190
就是让这个数据结构动态化

284
00:17:11,200 --> 00:17:15,050
所以 有一种动态的B树 是缓参无关的

285
00:17:15,070 --> 00:17:16,540
而且它对所有的B值适用

286
00:17:16,550 --> 00:17:21,840
而且插入删除和搜索的花费都是log_B(N)

287
00:17:21,850 --> 00:17:24,480
我们前面说的只是用log_B(N)的搜索

288
00:17:24,480 --> 00:17:28,070
我们第一篇论文的数据结构超级复杂

289
00:17:28,070 --> 00:17:29,110
后来简化了一些

290
00:17:29,130 --> 00:17:30,660
现在就没那么难了

291
00:17:30,670 --> 00:17:34,450
不过依然需要很多节高级算法课才能讲清楚

292
00:17:34,460 --> 00:17:37,430
所以这里我就不为难你们了

293
00:17:37,440 --> 00:17:40,810
但这算法是确实存在的

294
00:17:40,820 --> 00:17:47,930
而我们要讲的是大家喜闻乐见的排序

295
00:17:47,940 --> 00:17:49,330
在缓存无关的环境下的排序

296
00:17:49,340 --> 00:17:53,360
这其实相当复杂 比你们想象的难

297
00:17:53,380 --> 00:17:55,160
甚至比在多线程环境下

298
00:17:55,170 --> 00:18:01,560
更难做出正确的分析

299
00:18:01,570 --> 00:18:02,980
虽说在多线程环境下

300
00:18:03,000 --> 00:18:04,980
要得出最佳的分析也挺难的

301
00:18:04,990 --> 00:18:08,490
不过我们上周做的那个就很简单

302
00:18:08,500 --> 00:18:10,150
在我们讲缓存无关排序之前

303
00:18:10,160 --> 00:18:12,000
我们先来讲讲缓存相关排序

304
00:18:12,010 --> 00:18:20,300
因为我们需要知道 我们的优化边界是什么

305
00:18:20,320 --> 00:18:21,120
我先声明一点

306
00:18:21,140 --> 00:18:23,550
我不会对整个缓存无关排序

307
00:18:23,560 --> 00:18:25,150
做完整的分析

308
00:18:25,160 --> 00:18:26,060
但我想给你们讲解

309
00:18:26,080 --> 00:18:28,530
它内在的思想 因为它实在太酷炫了

310
00:18:28,540 --> 00:18:30,350
蕴含了很多想法

311
00:18:30,350 --> 00:18:34,530
那么 你们是怎么排序的？

312
00:18:34,540 --> 00:18:37,520
在缓存相关环境下 假设我们能做任何事

313
00:18:37,530 --> 00:18:39,340
也就是说 我们有B树

314
00:18:39,350 --> 00:18:41,620
这是我们手上唯一的数据结构

315
00:18:41,640 --> 00:18:44,340
如果你只有B树

316
00:18:44,350 --> 00:18:52,050
你要怎么对N个数排序？

317
00:18:52,060 --> 00:18:54,240
没错 就是把他们都插入到B树中

318
00:18:54,250 --> 00:18:55,660
然后按中序遍历

319
00:18:55,670 --> 00:18:58,410
这是一种不错的排序方式 非常合理

320
00:18:58,420 --> 00:19:09,740
我们称之为 B树反复插入

321
00:19:09,750 --> 00:19:15,710
我们知道 在通常情况下 比如BST排序

322
00:19:15,720 --> 00:19:17,360
它用的是平衡二叉搜索树

323
00:19:17,370 --> 00:19:21,130
像红黑树什么的 总排序时间为N log N 每步花费log N

324
00:19:21,140 --> 00:19:23,650
这在比较型排序算法里是最优情况了

325
00:19:23,660 --> 00:19:26,200
这里我们只考虑比较型排序算法

326
00:19:26,220 --> 00:19:33,770
那么 这种数据结构有多少内存传输？

327
00:19:33,780 --> 00:19:43,860
说错了 是这种排序算法有多少内存传输？

328
00:19:43,870 --> 00:19:47,560
内存传输MT是一个关于N和B的函数

329
00:19:47,570 --> 00:19:57,180
那MT是多少？

330
00:19:57,180 --> 00:20:01,490
其实挺简单的

331
00:20:06,960 --> 00:20:09,110
有N次插入 你得联想一下N阶的遍历

332
00:20:09,130 --> 00:20:13,470
再回想一下对B树的分析

333
00:20:13,480 --> 00:20:16,930
但这并不难

334
00:20:16,940 --> 00:20:24,410
N次插入要多久？

335
00:20:24,420 --> 00:20:30,100
N log_B(N)

336
00:20:30,110 --> 00:20:33,530
那遍历要多久？ 比这更少

337
00:20:33,540 --> 00:20:37,070
仔细想想的话 我们其实只需要N/B次内存传输

338
00:20:37,080 --> 00:20:38,380
所以要比这个小

339
00:20:38,390 --> 00:20:45,990
而这个比N要大 所以它弱爆了

340
00:20:46,000 --> 00:20:49,530
内存传输量为N的算法 就相当于在做随机访问

341
00:20:49,540 --> 00:20:51,750
按随机的顺序访问每个元素

342
00:20:51,770 --> 00:20:53,930
这个比它还差 后面还挂着个log因子

343
00:20:53,940 --> 00:20:57,570
虽然log_B(N)会随着B的增加而减小

344
00:20:57,580 --> 00:21:00,650
但这也是一个相当糟糕的边界

345
00:21:00,670 --> 00:21:02,530
和普通算法不一样的是

346
00:21:02,540 --> 00:21:05,460
一般来说 用搜索树来排序是个好方法

347
00:21:05,480 --> 00:21:10,770
但是在考虑到缓存的时候 它就很糟糕了

348
00:21:10,790 --> 00:21:14,200
还有什么值得一试的算法吗？

349
00:21:14,210 --> 00:21:18,660
在我们已知的排序算法里？

350
00:21:18,660 --> 00:21:21,210
即使是缓存无关的也行

351
00:21:21,220 --> 00:21:24,160
其实我们学过的算法都是缓存无关的

352
00:21:24,180 --> 00:21:29,940
哪个值得一试？ 归并排序

353
00:21:29,950 --> 00:21:33,310
我们在多线程里讲过归并排序

354
00:21:33,320 --> 00:21:37,230
那我们就来试试归并排序 分治法的典范

355
00:21:37,240 --> 00:21:39,320
我把它称为二分归并排序

356
00:21:39,330 --> 00:21:45,400
因为这里我们把数组分成两半

357
00:21:45,420 --> 00:21:47,540
然后再递归地分割这两半数组

358
00:21:47,560 --> 00:21:50,200
于是 你就得到了一个二分递归树

359
00:21:50,210 --> 00:21:52,600
我们来分析一下

360
00:21:52,610 --> 00:21:56,260
那么 N个元素所需的内存传输量

361
00:21:56,270 --> 00:21:58,910
这个结构的递归分布已经很不错了 是吧？

362
00:21:58,920 --> 00:22:01,190
因为我们分割数组的时候

363
00:22:01,200 --> 00:22:05,140
得到的两个子数组在内存里是连续的

364
00:22:05,160 --> 00:22:07,080
然后再对这边递归 对这边递归

365
00:22:07,090 --> 00:22:10,070
所以 这是个很好的缓参无关分布

366
00:22:10,080 --> 00:22:11,900
即使在缓存相关时

367
00:22:11,910 --> 00:22:12,820
这依然是很好的算法

368
00:22:12,830 --> 00:22:14,990
比这个要强多了 后面会说到

369
00:22:15,000 --> 00:22:22,940
那它的递归式是什么？

370
00:22:22,950 --> 00:22:27,390
这里我们就得回头看看上一课

371
00:22:27,400 --> 00:22:39,070
好好回想下缓参无关算法的递归式

372
00:22:45,100 --> 00:22:50,870
第一步应该无压力吧

373
00:22:50,880 --> 00:22:55,340
有个"O"？ 啊 好吧 我们最后再说"O"

374
00:22:55,350 --> 00:22:57,590
最后再考虑分治的部分

375
00:22:57,600 --> 00:23:05,530
而这里的递归式则是 2MT(N/2) 很好

376
00:23:05,540 --> 00:23:08,290
就像归并排序的递归式一样

377
00:23:08,300 --> 00:23:10,910
然后就是你们说的附加项了

378
00:23:10,930 --> 00:23:15,930
一般来说 我们要加一个线性的附加项

379
00:23:15,940 --> 00:23:19,030
阶是N 因为归并的时间是N阶的

380
00:23:19,040 --> 00:23:23,200
现在我们来做归并 这会有三个并行的扫描

381
00:23:23,210 --> 00:23:24,880
两个输入用 一个输出用

382
00:23:24,890 --> 00:23:27,320
它们不是一般的并行交错地扫描

383
00:23:27,330 --> 00:23:28,750
而是以一个奇怪的方式交错扫描

384
00:23:28,760 --> 00:23:32,100
但只要你的缓存能放得下三个块

385
00:23:32,110 --> 00:23:35,540
在这里的花费就会是线性的时间

386
00:23:35,550 --> 00:23:38,680
也就是说 对于每个块 访问次数都是固定的

387
00:23:38,690 --> 00:23:39,920
这就是递归式了

388
00:23:39,930 --> 00:23:42,080
当然我们还需要一个基准情形

389
00:23:42,090 --> 00:23:46,180
我们见过两个基准情形 一个是MT(B)

390
00:23:46,200 --> 00:23:50,310
另一个就是能匹配缓存大小的MT

391
00:23:50,330 --> 00:23:53,750
这里我们考虑后一个 因为它更好

392
00:23:53,770 --> 00:23:56,640
假设我有一个大小为M的数组 对于某常数c

393
00:23:56,650 --> 00:24:00,300
cM与缓存大小相匹配 这个c也可能是1

394
00:24:00,310 --> 00:24:01,650
不过我还是严谨一点

395
00:24:01,650 --> 00:24:04,760
对于某常数c来说 cM和缓存大小匹配

396
00:24:04,760 --> 00:24:07,530
当问题分割到跟缓存大小匹配时

397
00:24:07,540 --> 00:24:11,820
它的内存传输量是多少？ 有谁记得？

398
00:24:11,840 --> 00:24:19,290
我们已经不止一次讨论过这个基准情形了

399
00:24:28,240 --> 00:24:30,790
听说你记得？

400
00:24:30,800 --> 00:24:33,280
什么？ cM/B

401
00:24:33,290 --> 00:24:38,210
因为这是大O记号 所以是O(M/B)

402
00:24:38,230 --> 00:24:41,960
O(M/B)可以理解为 M是数据的大小

403
00:24:41,970 --> 00:24:44,280
而把所有数据读入缓存要M/B次

404
00:24:44,280 --> 00:24:45,560
一旦数据读入缓存以后

405
00:24:45,560 --> 00:24:48,270
只要把每cM的数据 存储在线性的空间中

406
00:24:48,270 --> 00:24:50,170
那我做什么都不会有额外的花费

407
00:24:50,180 --> 00:24:52,200
只要算法是线性地使用缓存空间

408
00:24:52,210 --> 00:24:54,010
那就可以把数据留在缓存里 也因此

409
00:24:54,020 --> 00:24:56,210
直到数据处理完毕 我都不需要写回

410
00:24:56,220 --> 00:24:58,750
最终我花费M/B来写回

411
00:24:58,760 --> 00:25:00,950
所以无论我用的是什么算法

412
00:25:00,960 --> 00:25:04,110
我用的内存传输都不会大于M/B

413
00:25:04,120 --> 00:25:05,920
只要算法是线性地使用缓存空间

414
00:25:05,930 --> 00:25:09,170
这个基准情形对大多数算法都是有用的

415
00:25:09,190 --> 00:25:10,680
那么 这就是递归式了

416
00:25:10,690 --> 00:25:13,860
现在我们来解它

417
00:25:13,870 --> 00:25:24,790
好的 我们就来看看二分归并到底有多威武

418
00:25:24,800 --> 00:25:30,540
我重申 这里我只会直观地讲一下

419
00:25:30,550 --> 00:25:32,200
这个递归式解法的内在思想

420
00:25:32,220 --> 00:25:36,220
我不会给出用代入法的正式证明

421
00:25:36,240 --> 00:25:38,460
不过这个其实挺简单的

422
00:25:38,470 --> 00:25:42,720
在第一层递归里——我还是写在这边吧

423
00:25:42,730 --> 00:25:44,410
不然我都快看不着了

424
00:25:44,430 --> 00:25:46,880
所以在第一层递归时

425
00:25:46,890 --> 00:25:48,960
我们的花费是N/B

426
00:25:48,970 --> 00:25:50,240
常数什么的就不管了

427
00:25:50,250 --> 00:25:53,150
后面可能还有一个1 不过先无视它

428
00:25:53,160 --> 00:25:55,910
然后我们把它分成两个子问题

429
00:25:55,920 --> 00:26:01,460
所以 每个子问题大小都是 ½ N/B

430
00:26:01,470 --> 00:26:04,370
在以前 这里是N 然后这两个是N/2

431
00:26:04,390 --> 00:26:06,380
第一节课的式子就是这样的

432
00:26:06,390 --> 00:26:09,320
所以这一层的和是N/B

433
00:26:09,340 --> 00:26:11,570
这层的和也一样是N/B

434
00:26:11,580 --> 00:26:13,100
你可以用归纳法证明

435
00:26:13,110 --> 00:26:15,080
每一层都是N/B

436
00:26:15,090 --> 00:26:16,790
问题是一共有多少层？

437
00:26:16,800 --> 00:26:19,980
那在最底层 点 点 点

438
00:26:19,990 --> 00:26:22,330
我们直接看递归树的最底层

439
00:26:22,340 --> 00:26:25,740
数据的大小应该是M

440
00:26:25,750 --> 00:26:27,700
然后它的传输花费是M/B

441
00:26:27,760 --> 00:26:29,850
就像这里写的 花费是M/B

442
00:26:29,860 --> 00:26:33,030
他们应该是相互匹配的

443
00:26:33,040 --> 00:26:36,200
所以 这些叶子节点的大小都是M/B

444
00:26:36,210 --> 00:26:44,460
你也可以算出来 这些叶节点的个数是N/M

445
00:26:44,470 --> 00:26:47,940
为了确保没算错 你就要检查叶子层的花费和

446
00:26:47,950 --> 00:26:49,190
这是个好习惯

447
00:26:49,210 --> 00:26:53,550
我们有N/M个节点 每个花费都是M/B

448
00:26:53,560 --> 00:26:58,130
这个M消掉 所以 这层的花费还是N/B

449
00:26:58,150 --> 00:27:01,390
所以每一层的内存传输量都是N/B

450
00:27:01,400 --> 00:27:11,520
那么层数是多少呢？ 1？ N/B？

451
00:27:11,530 --> 00:27:16,550
log(N/B) 这才是正确答案

452
00:27:16,560 --> 00:27:17,930
刚刚应该是我听错了

453
00:27:17,950 --> 00:27:19,190
一开始 数据大小为N

454
00:27:19,210 --> 00:27:20,610
到最后分割成大小为M

455
00:27:20,630 --> 00:27:24,260
你可以理解为 整个二叉树的高度是log N

456
00:27:24,280 --> 00:27:27,230
减去最下面子树的高度log M

457
00:27:27,250 --> 00:27:30,900
结果就是log(N/M)

458
00:27:30,900 --> 00:27:33,880
你还可以有别的理解方式

459
00:27:33,900 --> 00:27:35,860
关键是这个log是以2为底的

460
00:27:35,870 --> 00:27:38,040
就是这个地方还不够给力

461
00:27:38,050 --> 00:27:40,890
不过这个算法已经很不错了

462
00:27:40,900 --> 00:27:44,980
我们来写一遍过程

463
00:27:44,990 --> 00:27:47,290
所以 N个元素的内存传输量应该是...

464
00:27:47,300 --> 00:27:50,160
层数乘以每层的花费

465
00:27:50,170 --> 00:27:57,990
所以就是N/B乘以log_2(N/M)

466
00:27:58,000 --> 00:28:03,070
这就比对B树的反复插入要好得多

467
00:28:03,090 --> 00:28:11,240
这里我们得到的是N*log N/log B

468
00:28:11,250 --> 00:28:12,970
对于这个N*log N/log B

469
00:28:12,980 --> 00:28:17,220
即使它有个分母log B 但也说明不了什么

470
00:28:17,240 --> 00:28:21,590
而这条式的分母是B 所以是N*log N/B

471
00:28:21,610 --> 00:28:24,930
而且后面的log(N/M)比log N还要小一点呢

472
00:28:24,950 --> 00:28:26,710
当然这不是重点

473
00:28:26,720 --> 00:28:30,080
重点是分母还是个大(牛)B

474
00:28:30,090 --> 00:28:32,110
好了 我们很接近最优解了

475
00:28:32,120 --> 00:28:34,570
这已经差不多是个最优算法了

476
00:28:34,580 --> 00:28:36,240
而且它还是缓参无关的 好感度+10

477
00:28:36,260 --> 00:28:38,820
再努力一点点

478
00:28:38,830 --> 00:28:42,210
你就能得到一个log B因子的性能提升

479
00:28:42,220 --> 00:28:43,690
我要结合这两个算法

480
00:28:43,700 --> 00:28:47,180
我既想保留这个优化分母B

481
00:28:47,200 --> 00:28:50,940
我同时还想保留这个优化分母log B

482
00:28:50,960 --> 00:28:52,990
兼得鱼与熊掌

483
00:28:53,000 --> 00:28:55,730
在我们把它做成缓参无关之前

484
00:28:55,740 --> 00:28:58,610
我们先来看看缓存相关的情况

485
00:28:58,630 --> 00:29:01,810
这已经是第三个缓存相关算法了

486
00:29:01,830 --> 00:29:06,940
而这个算法(归并排序)同时也是缓参无关的

487
00:29:06,950 --> 00:29:13,670
那么 我们如何改进归并排序呢？

488
00:29:13,680 --> 00:29:16,220
我的意思是 这个log是以2为底的

489
00:29:16,230 --> 00:29:20,910
我大致是想要以B为底的

490
00:29:20,930 --> 00:29:24,220
那么 我们怎么改进归并排序？

491
00:29:24,240 --> 00:29:28,880
请说？分成B份

492
00:29:28,900 --> 00:29:31,960
没错 原来我们做的是二分归并

493
00:29:31,970 --> 00:29:33,420
我之前也说明过

494
00:29:33,440 --> 00:29:34,970
我们之前是把数据分成两份

495
00:29:34,980 --> 00:29:37,270
之后递归地分下去 然后再把它们归并

496
00:29:37,290 --> 00:29:40,790
其实 我们可以试试分成更多份

497
00:29:40,800 --> 00:29:45,300
好吧 于是我们要用到缓存了

498
00:29:45,320 --> 00:29:46,590
分成B份是一个思路

499
00:29:46,600 --> 00:29:48,400
但不是最优的选择

500
00:29:48,410 --> 00:29:49,770
尽管分成B份也行

501
00:29:49,790 --> 00:29:51,790
因为我一直在埋伏笔说要一个log B

502
00:29:51,800 --> 00:29:55,030
但其实这不是log B啦 而是log(M/B)

503
00:29:55,040 --> 00:30:00,380
我们一步步看 那么 我们最多能分成几份？

504
00:30:00,390 --> 00:30:03,910
好吧 我大可以分成N份

505
00:30:03,920 --> 00:30:06,260
这不是省力更省心？ 一次递归就完事了

506
00:30:06,280 --> 00:30:10,370
事实上我不能这么干 原因呢？

507
00:30:10,390 --> 00:30:13,570
要是分成了N份会有什么后果？

508
00:30:13,590 --> 00:30:24,820
感觉这才是它的完全体啊？

509
00:30:24,830 --> 00:30:26,840
因为你归并不了 就是这样

510
00:30:26,860 --> 00:30:30,780
如果有N份 那归并就无法在缓存中进行

511
00:30:30,800 --> 00:30:32,980
因为如果归并要在缓存内进行

512
00:30:32,990 --> 00:30:36,720
我就必须从每一个归并队列里

513
00:30:36,730 --> 00:30:38,860
都取出一个完整的数据块存入缓存里

514
00:30:38,870 --> 00:30:42,100
如果每一个队列都有一个完整的块在缓存里

515
00:30:42,120 --> 00:30:45,920
那么就能进行并行扫描了

516
00:30:45,930 --> 00:30:48,830
这就像是在测试并行扫描技术的极限

517
00:30:48,850 --> 00:30:51,820
如果你有K个并行的扫描

518
00:30:51,840 --> 00:30:54,720
并且缓存里有K个对应的块

519
00:30:54,730 --> 00:30:57,630
那就万事大吉了 因为这样你就可以

520
00:30:57,700 --> 00:30:59,850
并行地扫描K个数组 而对于每个数组

521
00:30:59,920 --> 00:31:03,120
每次都有一个数据块在缓存里

522
00:31:03,130 --> 00:31:05,770
所以 这就是原因了

523
00:31:05,790 --> 00:31:07,840
那么 我能在缓存里装多少块？

524
00:31:07,850 --> 00:31:12,000
M/B 不能再多了

525
00:31:12,010 --> 00:31:13,470
所以这也决定了归并排序

526
00:31:13,480 --> 00:31:16,480
它的最佳运行时间

527
00:31:16,500 --> 00:31:22,980
这就是M/B路的归并排序

528
00:31:23,000 --> 00:31:28,110
现在 我们得到的是一个更好的递归

529
00:31:28,130 --> 00:31:32,800
我们把它拆分成M/B个子问题

530
00:31:32,810 --> 00:31:37,540
毫无疑问 每个大小都是N/(M/B)

531
00:31:37,550 --> 00:31:41,880
而且归并的时间依然是线性的

532
00:31:41,890 --> 00:31:45,930
因为缓存刚好够用

533
00:31:45,950 --> 00:31:48,450
我觉得应该把这个算法描述一遍

534
00:31:48,460 --> 00:31:52,420
我们先分解 因为我们没真正做过多路归并排序

535
00:31:52,430 --> 00:32:00,800
把数据拆分为M/B个等大的子队列 而不是两个

536
00:32:00,810 --> 00:32:04,380
显然这是一个缓存相关的算法

537
00:32:04,400 --> 00:32:07,850
假设M/B是已知的

538
00:32:07,860 --> 00:32:18,000
然后 我们递归地对每个子序列排序

539
00:32:18,010 --> 00:32:23,430
然后再做归并

540
00:32:23,450 --> 00:32:25,460
我们之所以能够归并

541
00:32:25,470 --> 00:32:31,320
是因为我们能保证 在缓存里面

542
00:32:31,330 --> 00:32:39,730
一个子序列至少有一个缓存块

543
00:32:39,740 --> 00:32:42,420
而且如果你细心的话 你会发现

544
00:32:42,440 --> 00:32:45,310
你还需要一个缓存块来存放输出结果

545
00:32:45,320 --> 00:32:47,330
所以应该是M/B-1

546
00:32:47,340 --> 00:32:51,340
不过现在先不考虑这个常数项

547
00:32:51,350 --> 00:32:53,970
那么 这就是我们得到的递归式

548
00:32:53,990 --> 00:33:00,640
基准情形是一样的 那改进在什么地方呢？

549
00:33:00,650 --> 00:33:03,440
因为每层的花费没变

550
00:33:03,450 --> 00:33:06,410
在顶层 我们的数据大小是N/B

551
00:33:06,420 --> 00:33:11,370
这和以前一样 然后我们把它分成了M/B个子问题

552
00:33:11,380 --> 00:33:20,860
每个子问题的花费都是1/(M/B)*N/B

553
00:33:20,880 --> 00:33:22,330
把它们加在一起

554
00:33:22,350 --> 00:33:26,200
你得到的还是N/B 因为我们并没有减少数据

555
00:33:26,210 --> 00:33:27,870
我们只是把它分割开

556
00:33:27,880 --> 00:33:29,230
现在有M/B个子问题

557
00:33:29,260 --> 00:33:32,380
每个的大小都是M/B

558
00:33:32,390 --> 00:33:35,580
就像前面讲过的 每层的花费总和都是N/B

559
00:33:35,590 --> 00:33:38,260
发生变化的是层的个数

560
00:33:38,270 --> 00:33:40,230
因为分支的数量增加了

561
00:33:40,230 --> 00:33:41,890
这次的log不是以2为底

562
00:33:41,910 --> 00:33:44,560
而是以分支数为底

563
00:33:44,570 --> 00:33:57,050
那么这个树的高度就是log_(M/B)(N/M)

564
00:33:57,130 --> 00:34:02,770
应该是这样 我使用道具[小抄]确认一下

565
00:34:02,840 --> 00:34:09,910
就是这样喵~

566
00:34:11,630 --> 00:34:14,810
细心的你可能会发现

567
00:34:14,830 --> 00:34:17,370
这其实不是准确的层数

568
00:34:17,380 --> 00:34:20,890
而是层数减1(因为还有最顶层)

569
00:34:20,910 --> 00:34:24,250
所以我再加上1

570
00:34:24,260 --> 00:34:27,330
但这个并不是我理想的边界 原因是...

571
00:34:27,400 --> 00:34:29,700
我改写一下这条式子

572
00:34:29,770 --> 00:34:35,150
首先 我们有log以M/B为底——

573
00:34:35,160 --> 00:34:37,960
我这么做的真正的目标 是得到N/B

574
00:34:37,970 --> 00:34:53,040
这里的等号是成立的 因为我后面还要减一项

575
00:34:53,050 --> 00:34:58,570
嗯 很好

576
00:34:58,680 --> 00:35:00,920
这有点神来之笔的感觉

577
00:35:00,990 --> 00:35:03,480
但其实是因为我非常熟悉排序的边界

578
00:35:03,500 --> 00:35:05,950
所以 算一算就看出来了

579
00:35:05,960 --> 00:35:09,510
我把这个log_(M/B)(N/M)

580
00:35:09,530 --> 00:35:10,880
保持它底不变

581
00:35:10,890 --> 00:35:12,570
看这里 N/M

582
00:35:12,580 --> 00:35:17,670
它可以化成N/B除以M/B  因为B可以消掉

583
00:35:17,690 --> 00:35:19,660
M就被分离出来

584
00:35:19,670 --> 00:35:21,130
再对它们取对数

585
00:35:21,140 --> 00:35:24,130
就变成了log(N/B)-log(M/B)

586
00:35:24,150 --> 00:35:26,260
这里的除法变减法

587
00:35:26,280 --> 00:35:29,730
而log_(M/B)(M/B)又等于1

588
00:35:29,740 --> 00:35:34,550
所以后面两个消掉了 我就得到了log_(M/B)(N/B)

589
00:35:34,560 --> 00:35:38,030
这正是我想要的

590
00:35:38,050 --> 00:35:41,610
为什么？ 因为这就是正常情况下的边界值

591
00:35:41,620 --> 00:35:45,530
我们想在缓参无关的条件下取得这个界

592
00:35:45,540 --> 00:35:47,910
那么 我们知道了树的高度

593
00:35:47,920 --> 00:35:53,170
又知道每层的内存传输都是N/B

594
00:35:53,180 --> 00:35:58,020
所以 总的内存传输量就是

595
00:35:58,030 --> 00:36:12,540
这个M/B分归并算法的复杂度的边界

596
00:36:12,550 --> 00:36:20,970
我把它框起来 这就是算法的复杂度的边界

597
00:36:20,980 --> 00:36:24,310
它的特殊之处在于 在缓存相关的条件下

598
00:36:24,320 --> 00:36:28,400
这是N元排序算法复杂度最优的边界了

599
00:36:28,420 --> 00:36:33,840
这是在1983年提出来的

600
00:36:33,860 --> 00:36:35,000
这是我们能做到的最好结果了

601
00:36:35,010 --> 00:36:36,630
这个边界看起来很奇怪

602
00:36:36,650 --> 00:36:38,890
不过如果你无视掉这些分母B

603
00:36:38,900 --> 00:36:45,500
它就变成了N*log_M(N)

604
00:36:45,510 --> 00:36:46,740
这看起来就科学多了

605
00:36:46,750 --> 00:36:48,570
不过实际的式子里有很多B

606
00:36:48,580 --> 00:36:50,190
输入的块的数量 乘以

607
00:36:50,200 --> 00:36:53,060
以缓存的块数为底的

608
00:36:53,080 --> 00:36:56,140
输入的块数量的对数

609
00:36:56,150 --> 00:36:57,720
这样解释更直观一些

610
00:36:57,730 --> 00:37:01,210
这个就是我们想要的边界

611
00:37:01,230 --> 00:37:02,560
这算法的关键在于

612
00:37:02,580 --> 00:37:05,970
这是在我们已知M/B的前提下

613
00:37:05,990 --> 00:37:10,100
现在我们要试着做做不知道M/B的情况

614
00:37:10,120 --> 00:37:11,160
也就是缓存无关

615
00:37:11,180 --> 00:37:18,350
这个结果是前几年才做出来的

616
00:37:18,360 --> 00:37:20,670
准备好了吗？

617
00:37:20,680 --> 00:37:25,270
没问题吧？ 这还是很好理解的

618
00:37:25,280 --> 00:37:30,630
我们想要模仿它的原理 然后做一个新的归并排序

619
00:37:30,640 --> 00:37:32,980
不过这次不是M/B路了 因为M/B是未知的

620
00:37:32,990 --> 00:37:35,670
我们要做的是

621
00:37:35,690 --> 00:37:38,110
√N路的归并排序

622
00:37:38,130 --> 00:37:41,760
你瞎蒙也能蒙出这个数

623
00:37:41,770 --> 00:37:45,200
不过问题在于 你很难同时归并√N路数据

624
00:37:45,210 --> 00:37:50,740
因为这样就不好高效地利用缓存了

625
00:37:50,760 --> 00:37:53,230
我们刚才讲过 如果√N大于M/B的话

626
00:37:53,250 --> 00:37:56,150
你要直接同时归并√N路就是在找抽

627
00:37:56,160 --> 00:37:57,640
所以 我们需要巧妙地归并

628
00:37:57,650 --> 00:37:59,350
我们要分而治之地归并

629
00:37:59,360 --> 00:38:02,630
就像上周做的多线程算法一样

630
00:38:02,640 --> 00:38:04,020
我们尝试一种分治型归并

631
00:38:04,030 --> 00:38:05,630
不管归并队列有多少个

632
00:38:05,640 --> 00:38:07,640
只要少于√N个 准确来说是³√N个

633
00:38:07,650 --> 00:38:11,910
我们都可以高效地利用缓存完成归并

634
00:38:11,920 --> 00:38:20,630
好的 我们首先需要一些前提条件

635
00:38:20,640 --> 00:38:23,990
而我们的方向就是缓参无关的排序

636
00:38:24,000 --> 00:38:33,930
然后 我们想得到这一个排序复杂度的边界

637
00:38:33,950 --> 00:38:39,030
你会发现 在做缓参无关排序时

638
00:38:39,050 --> 00:38:45,650
你需要估计一下缓存的大小

639
00:38:45,660 --> 00:38:47,370
这点相当哲学 因为我们一边说

640
00:38:47,390 --> 00:38:48,890
既然是缓存无关算法

641
00:38:48,900 --> 00:38:51,520
那就应该对所有缓存参数B和M都好使

642
00:38:51,530 --> 00:38:54,250
但其实你还必须有一个额外的参数估计

643
00:38:54,260 --> 00:38:56,520
才能在缓参无关的条件下得到这个边界

644
00:38:56,540 --> 00:38:59,810
这个结果应该是去年由Garrett Brodel提出来的

645
00:38:59,830 --> 00:39:06,040
这个估计就是——这个估计其实很弱

646
00:39:06,050 --> 00:39:12,990
这是个好消息

647
00:39:13,010 --> 00:39:14,920
我们以前也做过几次估计

648
00:39:14,940 --> 00:39:18,100
比如说 假设缓存至少可以存下三个块

649
00:39:18,120 --> 00:39:20,390
或者四个块

650
00:39:20,400 --> 00:39:23,820
如果说缓存至少能放进四个块或者某常数个块

651
00:39:23,840 --> 00:39:25,610
这也算是说得过去的

652
00:39:25,660 --> 00:39:28,970
这条式子就是说 缓存里能容纳的块数

653
00:39:28,980 --> 00:39:31,510
至少是B的ε次方

654
00:39:31,520 --> 00:39:34,750
意思就是你的缓存不是细而短

655
00:39:34,760 --> 00:39:36,580
而是粗又壮的

656
00:39:36,600 --> 00:39:38,260
这样我们就可以舒服多了

657
00:39:38,280 --> 00:39:40,960
我们可以用这个公式的简化版

658
00:39:40,970 --> 00:39:43,320
假设M大于等于B^2

659
00:39:43,330 --> 00:39:47,470
这个很好理解 就是说你的缓存

660
00:39:47,490 --> 00:39:52,640
高度至少跟宽度一样大 这些一条条的就是块

661
00:39:52,650 --> 00:39:55,680
也就是说块的数量大于等于块的大小

662
00:39:55,690 --> 00:39:57,160
这个假设很合理

663
00:39:57,180 --> 00:40:01,060
现今我们用的缓存都符合这一点

664
00:40:01,070 --> 00:40:03,250
至少对某个ε成立 而且绝大数情况下

665
00:40:03,260 --> 00:40:08,540
M至少应该是B^2  事实上

666
00:40:08,560 --> 00:40:13,330
如果你还记得上次我说过的光速限制理论

667
00:40:13,340 --> 00:40:16,510
B^2或者说B^3是有道理的

668
00:40:16,520 --> 00:40:18,550
因为在三维空间中

669
00:40:18,560 --> 00:40:23,000
B^2就是球形的表面

670
00:40:23,020 --> 00:40:27,230
这就可以理解为 给定一个距离

671
00:40:27,240 --> 00:40:29,760
对应的球形的面积(体积)是多少

672
00:40:29,770 --> 00:40:31,950
假设我们住在一个常数维的空间中

673
00:40:31,960 --> 00:40:33,500
这个假设就是成立的

674
00:40:33,520 --> 00:40:36,190
这个结论甚至适用于42维的空间

675
00:40:36,210 --> 00:40:40,760
所以这个假设还很合理 很好

676
00:40:40,770 --> 00:40:43,240
现在 我们要去取得这个边界

677
00:40:43,250 --> 00:40:48,520
我们要做的就是

678
00:40:48,530 --> 00:40:54,910
使用一个N^ε路的归并排序

679
00:40:54,920 --> 00:40:57,980
如果M大于等于B^2

680
00:40:58,000 --> 00:41:01,640
那ε就是三分之一

681
00:41:01,650 --> 00:41:07,550
我们要做的就是³√N分的归并排序

682
00:41:07,570 --> 00:41:15,550
我们从排序算法的分析入手

683
00:41:15,560 --> 00:41:20,440
先假设我们知道 如何在特定的复杂度边界内做归并

684
00:41:20,450 --> 00:41:21,570
然后 我再来说怎么做归并

685
00:41:21,580 --> 00:41:31,040
而归并才是关键部分

686
00:41:31,050 --> 00:41:33,620
我先给出一个归并的黑盒

687
00:41:33,630 --> 00:41:36,020
归并是干什么的？

688
00:41:36,030 --> 00:41:39,020
K路归并又叫做K漏斗

689
00:41:39,030 --> 00:41:41,240
因为它的作用就像一个漏斗 等会儿就知道了

690
00:41:41,260 --> 00:41:45,170
K漏斗是一种数据结构 或者说是算法

691
00:41:45,180 --> 00:41:47,330
因为它看起来像是数据结构

692
00:41:47,340 --> 00:41:50,290
它把K个有序的序列归并到一起

693
00:41:50,300 --> 00:41:53,880
假设你有K个有序序列

694
00:41:53,900 --> 00:41:57,390
而且它们都是很长的序列

695
00:41:57,400 --> 00:42:03,040
那使用这个黑盒就需要一些附加条件

696
00:42:03,050 --> 00:42:05,360
这些条件在排序时就会获得

697
00:42:05,380 --> 00:42:08,410
我们需要这些序列的总大小

698
00:42:08,430 --> 00:42:09,380
假设把所有序列里的所有元素加起来

699
00:42:09,400 --> 00:42:16,150
总大小应该至少有K^3这么多

700
00:42:16,170 --> 00:42:24,980
那么 这些序列的归并花费就是这个排序的界

701
00:42:24,990 --> 00:42:28,790
这里应该是Θ(K^3)

702
00:42:28,800 --> 00:42:32,120
我也不希望它比K^3大太多

703
00:42:32,140 --> 00:42:40,950
失误了

704
00:42:44,970 --> 00:42:54,340
所以 这个归并漏斗的内存传输量就是

705
00:42:54,360 --> 00:42:58,220
K^3个元素对应的排序边界

706
00:42:58,240 --> 00:43:02,330
就是(K^3/B)*log_(M/B)(K^3/B) + K

707
00:43:02,340 --> 00:43:04,270
后面的这个K很好理解

708
00:43:04,280 --> 00:43:06,490
一开始 每个序列你都要读取一个块

709
00:43:06,510 --> 00:43:10,000
所以每个序列都要花一次内存传输

710
00:43:10,010 --> 00:43:14,160
那么 去掉这个K就是一个分支任务了

711
00:43:14,180 --> 00:43:16,210
而这就是我们做归并的速度了

712
00:43:16,220 --> 00:43:18,190
我们后面再讲

713
00:43:18,190 --> 00:43:19,770
现在 先假设这个是已知的

714
00:43:19,780 --> 00:43:21,860
我们来讲讲怎么排序

715
00:43:21,870 --> 00:43:27,540
它有一个很贴切的名字 漏斗排序

716
00:43:27,560 --> 00:43:34,090
不过实际上它就是³√N路的归并排序

717
00:43:34,100 --> 00:43:37,990
但分析时 我们会用这个名字

718
00:43:38,010 --> 00:43:42,540
漏斗排序 就是定义K=N^(1/3)

719
00:43:42,560 --> 00:43:46,520
然后代入到这个归并中

720
00:43:46,530 --> 00:43:51,960
那我们要做什么？ 就像这里

721
00:43:51,980 --> 00:44:03,180
我们把序列分成N^(1/3)份

722
00:44:03,190 --> 00:44:06,820
这些子序列应该都是连续的

723
00:44:06,830 --> 00:44:09,780
我把它们称作序列片段

724
00:44:09,790 --> 00:44:11,660
对于缓参无关来说

725
00:44:11,670 --> 00:44:13,700
这些东西的内存分布形式至关重要

726
00:44:13,710 --> 00:44:16,460
我们把连续的数组着切成几段

727
00:44:16,470 --> 00:44:18,330
一共有N^(1/3)段

728
00:44:18,350 --> 00:44:21,200
然后对它们进行递归排序

729
00:44:21,220 --> 00:44:25,220
然后再归并

730
00:44:34,260 --> 00:44:37,930
我用K漏斗来做归并

731
00:44:37,940 --> 00:44:42,040
N^(1/3)路漏斗

732
00:44:42,040 --> 00:44:47,490
那么 为什么是1/3？

733
00:44:47,500 --> 00:44:49,120
因为这里是3

734
00:44:49,130 --> 00:44:51,580
为了能使用这N^(1/3)路漏斗

735
00:44:51,590 --> 00:44:53,890
我需要确保元素的个数

736
00:44:53,900 --> 00:44:58,030
是K的立方 K^3

737
00:44:58,040 --> 00:44:59,480
然后K^3等于N

738
00:44:59,490 --> 00:45:02,550
这正是我们的元素总数

739
00:45:02,560 --> 00:45:04,860
而我正是要这样子来使用漏斗

740
00:45:04,870 --> 00:45:07,810
它要求我至少有K^3个元素

741
00:45:07,820 --> 00:45:10,930
这样我才能够用N^(1/3)路漏斗

742
00:45:10,940 --> 00:45:12,500
我的意思是 如果没有这个条件

743
00:45:12,520 --> 00:45:15,730
我甚至可以说 我有N个大小为1的序列

744
00:45:15,750 --> 00:45:19,470
但那对于我们的归并显然行不通

745
00:45:19,480 --> 00:45:23,030
因为很明显 这个+K会害死你的

746
00:45:23,050 --> 00:45:26,400
因为它会变成+N 那就太大了

747
00:45:26,410 --> 00:45:28,320
我们用N^(1/3)路漏斗就好了

748
00:45:28,330 --> 00:45:30,240
这样就能排序了

749
00:45:30,260 --> 00:45:35,240
那么 来分析一下这个算法吧

750
00:45:35,260 --> 00:45:37,900
顺利的话 它会得到那个排序的边界

751
00:45:37,910 --> 00:45:44,820
如果我没有失误的话

752
00:45:49,760 --> 00:45:51,420
其实别的都好办

753
00:45:51,430 --> 00:45:53,080
只有一件事很费劲

754
00:45:53,100 --> 00:45:55,940
就是重复写这个排序边界很累啊

755
00:45:55,960 --> 00:45:59,380
这是归并的花费

756
00:45:59,390 --> 00:46:01,320
这是根节点的花费

757
00:46:01,340 --> 00:46:03,720
而K^3在这里就是N

758
00:46:03,740 --> 00:46:05,860
所以在递归的根节点上

759
00:46:05,880 --> 00:46:08,350
我先把递归式写一下 不好意思

760
00:46:08,360 --> 00:46:16,260
N个元素对应的内存传输量就是N^(1/3)

761
00:46:16,280 --> 00:46:17,850
看一眼

762
00:46:17,870 --> 00:46:25,280
N^(1/3)乘以MT(N^(2/3))

763
00:46:25,290 --> 00:46:32,670
加上——这里K^3等于N

764
00:46:32,690 --> 00:46:41,900
所以这就是(N/B)log_(M/B)(N/B)

765
00:46:41,910 --> 00:46:46,160
加上N^(1/3)

766
00:46:46,170 --> 00:46:48,710
就是那个K

767
00:46:48,730 --> 00:46:50,390
这个就是递归式了

768
00:46:50,400 --> 00:46:53,220
基准情形和以前一样

769
00:46:53,240 --> 00:46:57,490
MT(cM)=O(M/B)（c为常数）

770
00:46:57,510 --> 00:47:01,650
那写到这一步 我们应该知道...

771
00:47:01,670 --> 00:47:03,200
呃 也不全是啦

772
00:47:03,220 --> 00:47:05,840
在以前的递归式里面

773
00:47:05,850 --> 00:47:08,250
我们每层的花费都是一样的

774
00:47:08,260 --> 00:47:10,250
这就是我们log项的由来

775
00:47:10,260 --> 00:47:12,930
现在我们已经有了一个log项

776
00:47:12,930 --> 00:47:15,490
所以 最好不要再来log项了

777
00:47:15,500 --> 00:47:18,400
这就是我们想要得到的边界

778
00:47:18,410 --> 00:47:31,370
我来偷看下秘籍

779
00:47:31,380 --> 00:47:35,650
嘿嘿 找到了 你们可能会想

780
00:47:35,660 --> 00:47:38,320
N^(1/3)看起来很大啊

781
00:47:38,330 --> 00:47:41,380
如果它比前面这项还大 我们就摊上大事了

782
00:47:41,390 --> 00:47:43,330
递归一两步就悲剧了

783
00:47:43,350 --> 00:47:46,130
所以我说 大丈夫 萌大奶

784
00:47:46,140 --> 00:47:48,870
我们来看看这个N^(1/3)

785
00:47:48,890 --> 00:47:53,400
这个基准情形涵盖了所有的可能的N值

786
00:47:53,410 --> 00:47:55,500
N最大不超过常数倍的M

787
00:47:55,510 --> 00:48:00,070
那么在基准情形下 我知道N的值

788
00:48:00,080 --> 00:48:03,800
至少和缓存M一样大 取决于常数c的选择

789
00:48:03,810 --> 00:48:08,110
现在 我们设缓存的大小至少是B^2

790
00:48:08,120 --> 00:48:09,120
如果你想更严谨一些

791
00:48:09,130 --> 00:48:11,430
你也可以写成B^(1+ε)

792
00:48:11,440 --> 00:48:16,240
那么N至少是B^2

793
00:48:16,260 --> 00:48:19,250
呃 我老是把自己说懵了

794
00:48:19,270 --> 00:48:26,510
这就是说N/B等于Ω(√N)

795
00:48:26,520 --> 00:48:28,030
不管你信不信

796
00:48:28,050 --> 00:48:32,900
反正真相只有一个 那么为什么是这样？

797
00:48:32,910 --> 00:48:37,430
这是说√N大于等于B

798
00:48:37,440 --> 00:48:41,680
那么N/B大于等于N/√N

799
00:48:41,690 --> 00:48:45,170
这就等于√N

800
00:48:45,190 --> 00:48:46,970
我速度把这个式子算一遍

801
00:48:46,990 --> 00:48:50,080
因为这很简单 但又不可或缺

802
00:48:50,100 --> 00:48:55,840
√N显然是大于³√N的

803
00:48:55,850 --> 00:48:57,740
这就是说N/B

804
00:48:57,750 --> 00:49:00,350
严格大于N^(1/3)

805
00:49:00,370 --> 00:49:03,100
而这里 我们用N/B乘以一个大于1的东西

806
00:49:03,120 --> 00:49:07,400
所以这项严格大于后面的这项

807
00:49:07,410 --> 00:49:09,380
只要我还没算到基本情况

808
00:49:09,390 --> 00:49:11,190
我就知道N至少是M阶的

809
00:49:11,200 --> 00:49:15,160
所以 这一项就从我的递归中消失了

810
00:49:15,180 --> 00:49:18,290
呼~ 好了 就快算出来了

811
00:49:18,300 --> 00:49:21,670
我们想要在全局获得这个运行时间

812
00:49:21,690 --> 00:49:25,980
所以递归的花费最好小一点

813
00:49:25,990 --> 00:49:30,140
最好比这一项的常数倍要小

814
00:49:30,160 --> 00:49:34,460
现在来把递归画一下

815
00:49:34,470 --> 00:49:42,040
在根节点 数据大小是(N/B)*log_(M/B)(N/B)

816
00:49:42,050 --> 00:49:47,170
然后分成很多个子问题

817
00:49:47,190 --> 00:49:50,830
一共N^(1/3)个子问题

818
00:49:50,840 --> 00:49:54,360
每个的花费都是上面这个

819
00:49:54,380 --> 00:49:57,900
d但要把其中的N变成N^(2/3)

820
00:49:57,910 --> 00:50:03,840
这就是(N^(2/3)/B)*log_(M/B)(N^(2/3)/B)

821
00:50:03,850 --> 00:50:05,840
这里忘记除B了

822
00:50:05,850 --> 00:50:09,480
就是(N^(2/3)/B)log(M/B)(N^(2/3)/B)

823
00:50:09,490 --> 00:50:11,980
这就是一个节点的花费 而这里有一行节点

824
00:50:11,990 --> 00:50:16,650
一共是N^(1/3)个节点 它们的和是多少？

825
00:50:16,660 --> 00:50:18,760
数量是N^(1/3)

826
00:50:18,780 --> 00:50:21,360
这里还有一个N^(2/3) 乘在一起就是N

827
00:50:21,370 --> 00:50:24,300
我们就得到了N/B——这看起来不妙啊

828
00:50:24,320 --> 00:50:25,510
还是那熊样啊

829
00:50:25,520 --> 00:50:29,230
我可不想再失去一个log项了

830
00:50:29,240 --> 00:50:33,430
不过好在我们这个指数是2/3

831
00:50:33,450 --> 00:50:36,330
这就是我们在这一层得到的和

832
00:50:36,340 --> 00:50:38,070
看起来跟排序的边界差不多

833
00:50:38,080 --> 00:50:40,820
不过在log项里还有一个2/3

834
00:50:40,830 --> 00:50:43,800
log项里的2/3指数项

835
00:50:43,810 --> 00:50:46,590
可以提到前面来

836
00:50:46,600 --> 00:50:49,560
所以这就是2/3乘以N/B

837
00:50:49,570 --> 00:50:54,080
乘以log_(M/B)(N/B) 也就是排序边界

838
00:50:54,090 --> 00:50:56,310
所以这就是排序边界的2/3

839
00:50:56,320 --> 00:50:59,040
而在根节点是1乘以排序边界

840
00:50:59,050 --> 00:51:02,670
所以这是从几何级数上变少了 哦也~~

841
00:51:02,690 --> 00:51:05,840
我是不想证明它了 反正它就是对的

842
00:51:05,850 --> 00:51:07,440
这一层乘了一个2/3

843
00:51:07,460 --> 00:51:10,610
下一层又乘了一个2/3 以此类推

844
00:51:10,630 --> 00:51:12,270
所以如果你在一层证明了

845
00:51:12,290 --> 00:51:15,160
那在所有层就都是这样

846
00:51:15,180 --> 00:51:17,730
具体细节我就先跳过

847
00:51:17,740 --> 00:51:20,710
我们可以检查一下叶节点 只是为了确定一下

848
00:51:20,720 --> 00:51:23,970
这是个明智的选择

849
00:51:23,990 --> 00:51:28,820
在叶节点上 我们的花费是M/B

850
00:51:28,830 --> 00:51:30,810
叶子节点有多少个？

851
00:51:30,820 --> 00:51:37,890
就像以前一样 我们有N/M个叶子

852
00:51:37,910 --> 00:51:43,380
所以最底层的花费应该是N/B

853
00:51:43,390 --> 00:51:46,140
而且这就是你得到的

854
00:51:46,160 --> 00:51:49,200
看起来挺有意思

855
00:51:49,220 --> 00:51:50,630
因为你可能会以为

856
00:51:50,640 --> 00:51:54,230
这个会比下面这个小 感觉上是这样

857
00:51:54,250 --> 00:51:56,710
其实不是 事实是

858
00:51:56,720 --> 00:51:59,770
在这里是N/B乘以这个log项

859
00:51:59,780 --> 00:52:01,590
不管log后面是什么了 那不重要

860
00:52:01,600 --> 00:52:03,380
就叫它log好了

861
00:52:03,400 --> 00:52:08,590
我们在下一层就是用2/3乘以这个log

862
00:52:08,600 --> 00:52:12,780
再下一层 就是4/9乘以log 以此类推

863
00:52:12,800 --> 00:52:17,470
这个log项不断减小 直到log项减小到1

864
00:52:17,480 --> 00:52:18,800
然后就停止递归

865
00:52:18,810 --> 00:52:21,580
这就是为什么这个N/B后面没有log

866
00:52:21,600 --> 00:52:23,000
所以你做的其实只是减小log项

867
00:52:23,010 --> 00:52:25,100
而N/B岿然不动

868
00:52:25,110 --> 00:52:27,290
2/3应该是在指数位置上

869
00:52:27,300 --> 00:52:30,450
这个树的层数应该是log(log N)

870
00:52:30,460 --> 00:52:35,460
这是你把这个log项用3/2除到1

871
00:52:35,470 --> 00:52:39,070
所需要的次数

872
00:52:39,080 --> 00:52:40,740
我们用不着那个

873
00:52:40,750 --> 00:52:41,920
我们不关心到底有多少层

874
00:52:41,930 --> 00:52:43,230
因为它是几何级数减少的

875
00:52:43,240 --> 00:52:45,100
它还可能有无限层呢

876
00:52:45,110 --> 00:52:51,760
反正是几何级数减少 而这个就是我们得到的运行时间

877
00:52:51,770 --> 00:53:02,920
MT(N)等于漏斗排序边界

878
00:53:02,930 --> 00:53:03,970
这个太帅了

879
00:53:03,980 --> 00:53:07,010
只要我们能找到一个能够快速归并的漏斗

880
00:53:07,030 --> 00:53:10,470
我们就能找到一个尽可能快的算法来排序

881
00:53:10,480 --> 00:53:17,550
我虽然没写出来 但这是目前黑板上的一个渐进最优解了

882
00:53:17,560 --> 00:53:20,710
即使你知道B和M是多少

883
00:53:20,720 --> 00:53:25,120
这也是你所能取得的最优解了

884
00:53:25,130 --> 00:53:31,330
而我们现在做的 就是B和M无关的算法

885
00:53:31,350 --> 00:53:33,670
准备迎接漏斗的洗礼吧

886
00:53:33,680 --> 00:53:38,050
漏斗就是另一个递归了

887
00:53:38,070 --> 00:53:40,450
所以 这是递归中的递归

888
00:53:40,460 --> 00:53:41,990
是另一种分治法

889
00:53:42,000 --> 00:53:44,120
有点像是静态搜索树

890
00:53:44,130 --> 00:53:45,810
就是我们这门课一开始讲的

891
00:53:45,820 --> 00:53:51,320
它们都是互相关联的

892
00:54:01,740 --> 00:54:08,140
好的 K漏斗 之所以叫K漏斗

893
00:54:08,150 --> 00:54:10,920
因为我想从广义的递归层面来考虑它

894
00:54:10,940 --> 00:54:12,870
而不只是N^(1/3)路递归

895
00:54:12,880 --> 00:54:15,140
但实际上 我们是打算

896
00:54:15,150 --> 00:54:18,010
递归地使用√K漏斗

897
00:54:18,020 --> 00:54:22,400
我们的目的是取得那个复杂度边界

898
00:54:22,410 --> 00:54:25,270
这个递归就像是静态搜索树

899
00:54:25,280 --> 00:54:27,120
画在黑板上可能有些困难

900
00:54:27,130 --> 00:54:28,380
但还是来一发吧

901
00:54:28,390 --> 00:54:32,140
这就是我们的√K漏斗

902
00:54:32,150 --> 00:54:36,410
这上面有一个缓冲区

903
00:54:36,420 --> 00:54:44,840
叫做输出缓冲区

904
00:54:44,860 --> 00:54:49,120
大小是K^3 为了显得真实一些

905
00:54:49,130 --> 00:54:53,080
我们假设它里面已经装进了一些奇怪的东西

906
00:54:53,100 --> 00:55:01,220
然后 下面是更多的缓冲区

907
00:55:01,230 --> 00:55:06,610
假设它们都被装进了一些不同数量的东西

908
00:55:06,620 --> 00:55:14,790
每个的大小都是K^(3/2)

909
00:55:14,800 --> 00:55:17,960
这些都叫缓冲区

910
00:55:17,970 --> 00:55:22,390
或者叫中间缓冲区 它们下面挂着的是

911
00:55:22,410 --> 00:55:29,730
更多的漏斗 这有一个√K漏斗

912
00:55:29,740 --> 00:55:35,300
这也有一个√K漏斗

913
00:55:35,310 --> 00:55:36,520
每个缓冲区都有一个

914
00:55:36,520 --> 00:55:46,390
每个都是上面这个漏斗的子漏斗

915
00:55:46,410 --> 00:56:03,500
然后在这些漏斗下面是输入序列

916
00:56:05,500 --> 00:56:09,040
我可没傻到把K个全画出来

917
00:56:09,060 --> 00:56:13,140
不过这里的确有K个输入序列

918
00:56:13,150 --> 00:56:18,140
输入的数组 它们在最底层

919
00:56:18,150 --> 00:56:21,810
我们要做的就是自底向上做归并

920
00:56:21,830 --> 00:56:23,070
我们从K个输入序列开始

921
00:56:23,080 --> 00:56:25,230
它们总的大小至少是K^3

922
00:56:25,240 --> 00:56:28,690
这是我们上面提到的前提假设

923
00:56:28,700 --> 00:56:33,250
我们把这些序列分成√K大小的组

924
00:56:33,260 --> 00:56:34,780
这样每个组有√K个序列

925
00:56:34,790 --> 00:56:36,660
每个序列把数据输入它所在的√k漏斗中

926
00:56:36,680 --> 00:56:39,990
然后递归地归并这些序列

927
00:56:40,000 --> 00:56:42,260
这些漏斗的输出放在一个缓冲区里

928
00:56:42,270 --> 00:56:46,770
输出结果会暂时积累在缓冲区里

929
00:56:46,790 --> 00:56:51,350
这些缓冲区大小恰好为K^(3/2)

930
00:56:51,360 --> 00:56:55,390
虽然这可能不是最好的选择 这是因为...

931
00:56:55,410 --> 00:56:57,660
平均来说 这下面每个漏斗对应K^(3/2)个元素

932
00:56:57,680 --> 00:56:59,320
因为总数是K^3

933
00:56:59,460 --> 00:57:01,260
组的个数是√K个

934
00:57:01,270 --> 00:57:03,290
所以应该是K^3除以√K

935
00:57:03,300 --> 00:57:06,240
所以平均来说 应该每个都是K^(3/2)

936
00:57:06,260 --> 00:57:07,250
但有些缓冲区会比较大

937
00:57:07,270 --> 00:57:09,250
有些小一点 我在这画出来了

938
00:57:09,260 --> 00:57:12,880
有些缓冲区空出了一部分 这取决于你是怎么归并的

939
00:57:12,890 --> 00:57:16,980
但平均来说 中间的缓冲区应该是同时装满的

940
00:57:16,990 --> 00:57:19,810
然后 我们把它们放进这一个√K漏斗里

941
00:57:19,820 --> 00:57:21,880
然后我们就得到了大小为K^3的输出

942
00:57:21,890 --> 00:57:26,370
那么 大概就是这么个情况

943
00:57:26,440 --> 00:57:28,920
事实上 有的缓冲区已被填充

944
00:57:28,930 --> 00:57:31,030
我们就需要做一些归并来腾出地方

945
00:57:31,050 --> 00:57:33,870
为下面的数据做准备

946
00:57:33,940 --> 00:57:36,980
这个图就说这么多

947
00:57:36,990 --> 00:57:38,900
在我讲这个算法之前

948
00:57:38,910 --> 00:57:40,430
或者说分析算法之前

949
00:57:40,440 --> 00:57:42,390
我们先来考虑一下空间问题

950
00:57:42,400 --> 00:57:45,660
一个很简单的热身分析

951
00:57:45,680 --> 00:57:51,890
我们先不考虑输入输出

952
00:57:51,900 --> 00:57:58,000
不管那些缓冲大小

953
00:57:58,020 --> 00:58:01,020
为什么我要忽略输入输出的缓冲大小呢？

954
00:58:01,030 --> 00:58:05,430
因为每个缓冲区我只算一次

955
00:58:05,450 --> 00:58:08,560
而这个缓冲区既是上面这个漏斗的输入

956
00:58:08,570 --> 00:58:10,490
也是下面这个漏斗的输出

957
00:58:10,510 --> 00:58:15,420
为了要递归地计算缓冲大小 而且每个缓冲区只算一遍

958
00:58:15,480 --> 00:58:17,470
我就只算中间的缓冲区就好了

959
00:58:17,490 --> 00:58:18,370
除此之外

960
00:58:18,380 --> 00:58:20,800
我还必须计算总的输入、输出

961
00:58:20,810 --> 00:58:21,840
不过它们算是已知的了

962
00:58:21,850 --> 00:58:23,630
输出是K^3

963
00:58:23,640 --> 00:58:26,930
输入也是K^3 所以 还是忽略它们吧

964
00:58:26,950 --> 00:58:28,510
因为如果我用递归地计算中间的缓冲区

965
00:58:28,520 --> 00:58:31,010
我就得到总的缓冲大小了

966
00:58:31,020 --> 00:58:36,330
那么 我们得出一条简单的空间递归式

967
00:58:36,340 --> 00:58:39,470
S(K)就等于(√K+1)

968
00:58:39,480 --> 00:58:47,030
乘以S(√K) 再加上O(K^2)

969
00:58:47,040 --> 00:58:50,680
K^2是因为我们在中间有√K个缓冲区

970
00:58:50,690 --> 00:58:53,010
每个大小都是K^(3/2)

971
00:58:53,020 --> 00:58:57,670
算一下 嗯？ 我好像刚刚说错了什么

972
00:58:57,680 --> 00:59:00,930
听起来像是K^3 有种不祥的感觉啊…

973
00:59:00,950 --> 00:59:04,650
不管了 反正翻译会修正的

974
00:59:04,660 --> 00:59:07,890
就是K^(3/2)乘以√K

975
00:59:07,900 --> 00:59:11,750
就是K^(3/2+1/2)

976
00:59:11,770 --> 00:59:14,040
K^(4/2) 也就是K^2

977
00:59:14,050 --> 00:59:15,260
很好喵

978
00:59:15,270 --> 00:59:17,340
我的数学没学好

979
00:59:17,350 --> 00:59:19,430
所以中间的缓冲大小为K^2

980
00:59:19,440 --> 00:59:22,580
然后你再把递归每一层的大小加起来

981
00:59:22,600 --> 00:59:26,280
这里+1是指上面的漏斗

982
00:59:26,300 --> 00:59:30,920
√K是指它下面的漏斗 所以递归项里是√K+1个

983
00:59:30,930 --> 00:59:34,270
好吧 我还是画一下递归树

984
00:59:34,280 --> 00:59:36,230
我们可以用很多方法来解这个递归式

985
00:59:36,250 --> 00:59:38,840
你可以不用K来算

986
00:59:38,850 --> 00:59:43,190
你可以算log K 这样这里就变½ log K了

987
00:59:43,200 --> 00:59:45,750
我只要画一下递归树

988
00:59:45,760 --> 00:59:47,280
你们就明白了

989
00:59:47,290 --> 00:59:49,190
不过如果你要解这条式

990
00:59:49,210 --> 00:59:53,000
你可以取个log 用log项的替代法

991
00:59:53,020 --> 00:59:57,530
所以我们的分支数是√K+1

992
00:59:57,540 --> 00:59:59,300
然后分支大小是√K

993
00:59:59,310 --> 01:00:03,950
所以每个分支的花费就是O(K)了

994
01:00:03,970 --> 01:00:07,840
也就是O(√(K^2))

995
01:00:07,860 --> 01:00:09,700
然后继续

996
01:00:09,720 --> 01:00:14,350
我不管递归最底层的情况

997
01:00:14,360 --> 01:00:16,610
但因为最顶层我们有K^2

998
01:00:16,620 --> 01:00:22,800
而它的下一层的花费是K(√K+1)

999
01:00:22,820 --> 01:00:28,590
也就是K^(3/2)+K

1000
01:00:28,600 --> 01:00:31,460
我们从K^2降到了K^(3/2)+K

1001
01:00:31,480 --> 01:00:33,280
这比几何级数还多

1002
01:00:33,290 --> 01:00:36,030
差不多是指数级别的下降

1003
01:00:36,040 --> 01:00:40,880
它的下降的速度相当快 所以总的来说是K^2阶

1004
01:00:40,890 --> 01:00:49,220
这是个令人愉悦的消息

1005
01:00:49,230 --> 01:00:53,320
那么缓存的花费基本都集中在最顶层

1006
01:00:53,340 --> 01:00:54,800
我是说总的花费

1007
01:00:54,810 --> 01:00:56,200
我们会用到这个式子

1008
01:00:56,210 --> 01:00:57,540
其实应该是Θ(K^2)

1009
01:00:57,550 --> 01:01:01,190
因为上面就是Θ(K^2)

1010
01:01:01,210 --> 01:01:04,700
分析时间复杂度的时候会用到这个

1011
01:01:04,710 --> 01:01:06,070
这就是我讲这个的原因

1012
01:01:06,080 --> 01:01:09,200
它的意义不只是说“哎哟不错喔 空间用不多”

1013
01:01:09,210 --> 01:01:11,710
实际上 这个漏斗的大小远小于输入的大小

1014
01:01:11,720 --> 01:01:16,030
输入的大小可是K^3 不过这不是最关键的

1015
01:01:16,040 --> 01:01:19,020
关键是这个K^2 我们在分析中会用到

1016
01:01:19,040 --> 01:01:21,500
那么 整个漏斗就是这么递归地分布的

1017
01:01:21,510 --> 01:01:24,930
你递归地储存这些漏斗

1018
01:01:24,940 --> 01:01:26,980
比如这里 你把所有的缓冲区

1019
01:01:27,050 --> 01:01:29,500
存储成一个连续的数组

1020
01:01:29,540 --> 01:01:30,830
这里还没有递归

1021
01:01:30,830 --> 01:01:32,940
就是一个接一个输出就好了

1022
01:01:32,950 --> 01:01:34,170
别让它们重叠了

1023
01:01:34,190 --> 01:01:35,360
按顺序把他们放好

1024
01:01:35,380 --> 01:01:39,270
然后你再递归地存储这些漏斗

1025
01:01:39,290 --> 01:01:40,980
下面这层漏斗

1026
01:01:40,990 --> 01:01:42,090
不管你用什么方法递归

1027
01:01:42,100 --> 01:01:44,540
只要每个漏斗用的是一块连续的内存

1028
01:01:44,560 --> 01:01:46,980
只要每个缓冲区用的是一块连续的内存

1029
01:01:46,990 --> 01:01:57,000
我们下面要做的时间分析就会派上用场

1030
01:02:13,080 --> 01:02:17,270
我还是把要分析的算法写出来吧

1031
01:02:17,290 --> 01:02:22,760
为了让这个漏斗能够运作 我们要做的是

1032
01:02:22,780 --> 01:02:25,890
在初始化时 这些缓冲区都清空

1033
01:02:25,900 --> 01:02:27,750
所有输入序列都在底下

1034
01:02:27,760 --> 01:02:30,460
而我们的目标是 填满根部的缓冲区（输出缓冲）

1035
01:02:30,470 --> 01:02:33,180
把它填满 而这又是另一个递归算法了

1036
01:02:33,190 --> 01:02:35,750
我马上就会讲要怎么填满缓冲区

1037
01:02:35,760 --> 01:02:38,120
一旦它被填满 就意味着所有的东西都输出了

1038
01:02:38,130 --> 01:02:39,720
归并就完成了

1039
01:02:39,730 --> 01:02:44,200
这就是我们的第一步

1040
01:02:44,220 --> 01:02:55,260
归并就是要填满最上面的缓冲区

1041
01:02:55,270 --> 01:02:57,820
顶端输出缓冲区

1042
01:02:57,830 --> 01:03:05,150
然后我们来讲怎么填满一个缓冲区

1043
01:03:05,160 --> 01:03:09,850
一般来说 如果你把这个递归过程全部展开

1044
01:03:09,870 --> 01:03:13,770
在底层的实现里 其实有一个细节 这里是有个节点的

1045
01:03:13,780 --> 01:03:16,490
也就是说 你在这个图里

1046
01:03:16,510 --> 01:03:19,270
任意取一个缓冲区

1047
01:03:19,280 --> 01:03:22,920
这个缓冲区是空的 你要填满它

1048
01:03:22,970 --> 01:03:27,240
而它下面会有一个节点 这个节点连着两个子缓冲

1049
01:03:27,250 --> 01:03:33,290
另外两个缓冲区 就像这样连着

1050
01:03:33,310 --> 01:03:37,600
你只知道它们一样大 但不知道究竟有多大

1051
01:03:37,620 --> 01:03:39,200
它可能比上面的小很多

1052
01:03:39,210 --> 01:03:41,940
或者大很多 我们都不知道

1053
01:03:41,950 --> 01:03:44,840
不过在最底层 你得到的是一个二分的结构

1054
01:03:44,860 --> 01:03:52,050
就像我们最开始讲过的二分搜索树一样

1055
01:03:52,060 --> 01:03:53,910
那么我们如何填充缓冲区？

1056
01:03:53,930 --> 01:04:01,620
我们只要对这两个子缓冲区做归并就可以了

1057
01:04:01,640 --> 01:04:09,880
那么 只要两个子缓冲非空

1058
01:04:09,890 --> 01:04:13,090
我们就把它们归并起来

1059
01:04:13,100 --> 01:04:16,320
所以 有一件事是不变的

1060
01:04:16,330 --> 01:04:20,440
我还是写一下吧

1061
01:04:20,450 --> 01:04:22,790
只要有一个缓冲区是非空的

1062
01:04:22,800 --> 01:04:26,350
或者说 缓冲区里还有没用到的东西

1063
01:04:26,430 --> 01:04:31,960
那些东西就是在这个缓冲下面的子树的归并输出

1064
01:04:31,980 --> 01:04:37,280
这个缓冲区里装的是它下面的子树的归并结果

1065
01:04:37,300 --> 01:04:39,630
这个缓冲区里也是它下面的归并结果

1066
01:04:39,650 --> 01:04:43,000
我可以从顶部开始归并这俩缓冲的元素

1067
01:04:43,010 --> 01:04:45,260
得到的输出就放在上面的缓冲区

1068
01:04:45,270 --> 01:04:47,410
直到有一个缓冲区被清空了

1069
01:04:47,420 --> 01:04:49,350
我们也不知道哪个会先清空

1070
01:04:49,360 --> 01:04:52,300
因为这和实际数据的顺序有关

1071
01:04:52,310 --> 01:04:56,570
当其中一个被清空了 我们就递归地将其填满

1072
01:04:56,590 --> 01:05:01,330
就是这样了 这就是算法

1073
01:05:01,340 --> 01:05:14,270
当有一个缓冲区被清空了——

1074
01:05:14,280 --> 01:05:17,600
就开始递归地填充

1075
01:05:17,620 --> 01:05:20,770
基准情形里 就是在叶节点里

1076
01:05:20,790 --> 01:05:22,840
我们不需要做什么别的

1077
01:05:22,860 --> 01:05:37,520
只要把输入的序列读进来缓存就好

1078
01:05:37,530 --> 01:05:39,900
在最下面的地方

1079
01:05:39,910 --> 01:05:41,510
会有一些节点

1080
01:05:41,520 --> 01:05:43,990
它会归并这两个输入序列

1081
01:05:44,000 --> 01:05:46,400
就是两个序列之间的最直接的归并

1082
01:05:46,410 --> 01:05:48,360
我们都知道 它是用两个并行扫描来完成的

1083
01:05:48,380 --> 01:05:50,930
所以 我们可以一步步把整个序列都归并了

1084
01:05:50,940 --> 01:05:52,440
然后扔到缓冲区里

1085
01:05:52,450 --> 01:05:54,400
好吧 这也取决于缓冲区的大小

1086
01:05:54,410 --> 01:05:57,730
我们只能归并到缓冲区满了为止

1087
01:05:57,750 --> 01:05:59,160
一旦缓冲区被填满了

1088
01:05:59,180 --> 01:06:05,350
我们就停下来 把结果递归地向上传

1089
01:06:05,360 --> 01:06:09,200
所以 我们就一直这么做归并

1090
01:06:09,210 --> 01:06:11,260
直到缓冲区填满了为止

1091
01:06:11,270 --> 01:06:13,430
然后停下来 向上一级传结果

1092
01:06:13,450 --> 01:06:19,670
这就是归并的算法了

1093
01:06:19,690 --> 01:06:22,950
现在 我们还需要分析一下这个算法

1094
01:06:22,970 --> 01:06:28,020
这并不是很困难 不过这是个很巧妙的分析

1095
01:06:28,040 --> 01:06:32,000
更重要的是 这是个平摊分析

1096
01:06:32,010 --> 01:06:35,950
这是你们的最爱啊 好的 最后我们来做一次

1097
01:06:35,970 --> 01:06:41,950
关于缓参无关的平摊分析

1098
01:06:41,970 --> 01:06:44,580
这可能有一点点复杂

1099
01:06:44,590 --> 01:06:46,670
我们要把见过的所有东西融会贯通

1100
01:06:46,680 --> 01:06:50,240
这个分析主要的思想是

1101
01:06:50,260 --> 01:06:53,210
我们在递归的构造这个K漏斗

1102
01:06:53,220 --> 01:06:57,590
想象一下 如果我们把K漏斗

1103
01:06:57,600 --> 01:06:59,610
从中间分开

1104
01:06:59,620 --> 01:07:01,510
变成许许多多的√K漏斗

1105
01:07:01,530 --> 01:07:03,990
然后反复 然后我们继续在中间分开

1106
01:07:04,010 --> 01:07:06,400
得到开四次方的K漏斗 然后反复下去

1107
01:07:06,420 --> 01:07:12,370
直到漏斗的大小正好能匹配上缓存

1108
01:07:12,380 --> 01:07:14,500
以前我们会说它跟块匹配

1109
01:07:14,510 --> 01:07:16,250
而现在是分割到一定程度时

1110
01:07:16,260 --> 01:07:18,000
这些漏斗都正好与缓存匹配

1111
01:07:18,010 --> 01:07:21,920
在这一层递归的每一个漏斗都和缓存匹配

1112
01:07:21,940 --> 01:07:24,420
我们就来分析这一层

1113
01:07:24,430 --> 01:07:27,870
我们管它叫J级

1114
01:07:27,880 --> 01:07:41,870
考虑第一个满足以下条件的递归层

1115
01:07:41,880 --> 01:07:53,400
我们称之为J级 这时每个J漏斗都与缓存匹配

1116
01:07:53,420 --> 01:07:56,050
而且不是简单地和缓存相匹配

1117
01:07:56,070 --> 01:07:58,510
而是四个漏斗匹配一个缓存

1118
01:07:58,520 --> 01:08:02,690
也就是一个漏斗匹配四分之一个缓存

1119
01:08:02,700 --> 01:08:06,740
我们还需要给缓存留点地方去做别的事

1120
01:08:06,750 --> 01:08:10,590
不过我想要保证J漏斗跟缓存匹配

1121
01:08:10,600 --> 01:08:13,100
这是什么意思？ 我们已经分析了空间的问题

1122
01:08:13,120 --> 01:08:15,910
我们知道一个J漏斗所占的空间大约是J^2

1123
01:08:15,930 --> 01:08:20,920
某个常数乘以J^2 也就是cJ^2

1124
01:08:20,940 --> 01:08:27,730
这就是说cJ^2 ≤ M/4

1125
01:08:27,740 --> 01:08:31,050
就是四分之一的缓存

1126
01:08:31,060 --> 01:08:34,230
这就是说一个J漏斗的大小应该

1127
01:08:34,230 --> 01:08:37,590
正好能装进四分之一个缓存里

1128
01:08:37,600 --> 01:08:39,910
所以 在递归的某一步

1129
01:08:39,920 --> 01:08:42,550
递归树里会出现符合条件的J漏斗

1130
01:08:42,560 --> 01:08:44,360
它们的缓冲大小不一

1131
01:08:44,370 --> 01:08:46,730
但每个J漏斗都和缓存相匹配

1132
01:08:46,740 --> 01:08:48,650
我们来考虑一下其中的一个J漏斗

1133
01:08:48,660 --> 01:08:50,370
假设J就是√K

1134
01:08:50,380 --> 01:08:54,670
就是用这幅图吧 要不然就就要画一幅更大的了

1135
01:08:54,680 --> 01:08:57,120
假设这就是一个J漏斗

1136
01:08:57,140 --> 01:09:01,570
它有一堆输入缓冲区 还有一个输出缓冲区

1137
01:09:01,580 --> 01:09:05,220
我们要考虑的就是J漏斗的工作方式

1138
01:09:05,230 --> 01:09:08,380
在很长一段时间内 只要这些缓冲区是满的

1139
01:09:08,400 --> 01:09:11,190
它的作用就是一个归并器

1140
01:09:11,200 --> 01:09:14,090
它会做一些递归的步骤 但我们不关心那些

1141
01:09:14,100 --> 01:09:15,900
只要这整个递归器换入到内存里时

1142
01:09:15,910 --> 01:09:19,910
我其实把这一整块都圈起来 就是这个漏斗

1143
01:09:19,920 --> 01:09:22,500
和它的输入输出缓冲区都换入到内存里

1144
01:09:22,510 --> 01:09:24,420
换而言之 所有有关的块都在内存里

1145
01:09:24,440 --> 01:09:27,650
你就可以尽情的进行归并

1146
01:09:27,660 --> 01:09:31,780
直到输入缓冲区空了 或者输出缓冲区满了

1147
01:09:31,790 --> 01:09:32,930
我们就来分析这种情况

1148
01:09:32,950 --> 01:09:35,430
假设所有东西都在内存里 因为我们知道它跟内存匹配

1149
01:09:35,450 --> 01:09:37,020
嗯 我还是得小心一点

1150
01:09:37,030 --> 01:09:41,370
因为输入缓冲区的总大小还挺大的

1151
01:09:41,390 --> 01:09:44,750
因为输入是K^(3/2)

1152
01:09:44,770 --> 01:09:47,650
输出是K^(1/2)

1153
01:09:47,660 --> 01:09:52,980
这个的大小其实是K 我来画一个总体的图

1154
01:09:52,990 --> 01:09:57,030
这是一个J漏斗

1155
01:09:57,040 --> 01:09:59,420
这样算数好算一点

1156
01:09:59,430 --> 01:10:05,550
这是一个J漏斗 大小是CJ^2

1157
01:10:05,560 --> 01:10:06,980
应该是这样

1158
01:10:06,990 --> 01:10:16,950
输入的数量是J 它们的大小都很大

1159
01:10:16,970 --> 01:10:20,250
前面我们是怎么说的？ 这是一个K漏斗

1160
01:10:20,260 --> 01:10:23,740
总输入为K^3

1161
01:10:23,760 --> 01:10:25,750
所以这个输入的大小应该是J^3

1162
01:10:25,760 --> 01:10:27,260
我们不可能把所有东西都放入缓存

1163
01:10:27,280 --> 01:10:28,620
因为它多了J因子

1164
01:10:28,630 --> 01:10:32,270
但我们可以做到每个输入一个块

1165
01:10:32,280 --> 01:10:33,970
对于归并来说 这就足够了

1166
01:10:33,980 --> 01:10:37,570
对于每个输入序列 它的第一个块可以

1167
01:10:37,580 --> 01:10:40,750
跟整个J漏斗一起装进内存里

1168
01:10:40,770 --> 01:10:45,290
在这个过程中 只要这些东西都在缓存里

1169
01:10:45,290 --> 01:10:47,690
这个归并就可以火力全开

1170
01:10:47,690 --> 01:10:50,030
就像我们做并行扫描一样

1171
01:10:50,040 --> 01:10:51,810
把这些块都用光了之后 肯定有一块是空了的

1172
01:10:51,830 --> 01:10:55,440
你就到它对应的输入缓冲里找下一个块

1173
01:10:55,460 --> 01:10:59,340
就像普通的并行归并分析一样

1174
01:10:59,360 --> 01:11:02,040
而这时 我们假设这些东西都能和缓存匹配

1175
01:11:02,050 --> 01:11:06,150
就像以前讲过的一样 当然了

1176
01:11:06,170 --> 01:11:09,730
这其实是递归执行的 但我们就只分析这一层的事

1177
01:11:09,750 --> 01:11:18,300
好的 我要证明你可以容纳每个输入序列存一个块

1178
01:11:18,310 --> 01:11:25,930
这也不难 只是计算量的问题

1179
01:11:25,940 --> 01:11:28,600
而基本上 这漏斗的设计方式

1180
01:11:28,610 --> 01:11:34,020
就是为了能容纳每个输入序列存一个块

1181
01:11:34,040 --> 01:11:35,560
下面就是证明

1182
01:11:35,570 --> 01:11:42,530
我们的目标是证明 缓存可以容纳

1183
01:11:42,540 --> 01:11:55,040
一个输入序列存一个块

1184
01:11:55,050 --> 01:11:57,290
这是说除了要存一个J漏斗外

1185
01:11:57,300 --> 01:12:00,750
你也可以容纳一个输入序列存一个块

1186
01:12:00,760 --> 01:12:04,730
这里对应的是J漏斗

1187
01:12:04,750 --> 01:12:07,750
不是所有漏斗都行 因为大的漏斗太大了

1188
01:12:07,760 --> 01:12:10,400
下面就是证明了

1189
01:12:10,410 --> 01:12:15,180
J^2小于等于(1/4)M

1190
01:12:15,200 --> 01:12:20,430
这就是我们这里说过的 应该说是cJ^2

1191
01:12:20,440 --> 01:12:21,730
我就不在c上多花时间了

1192
01:12:21,750 --> 01:12:25,490
因为这已经够我受的了

1193
01:12:25,500 --> 01:12:27,260
嗯 这已经是个很弱的约束条件了

1194
01:12:27,280 --> 01:12:30,900
我们证明过漏斗大小大约是J^2

1195
01:12:30,920 --> 01:12:33,930
然后它最多是1/4个缓存

1196
01:12:33,940 --> 01:12:38,580
这意味着 如果对两边开平方

1197
01:12:38,590 --> 01:12:42,580
得到J小于等于(1/2)√M

1198
01:12:42,600 --> 01:12:48,280
我们还知道B小于等于√M

1199
01:12:48,300 --> 01:12:50,460
因为M大于等于B^2

1200
01:12:50,470 --> 01:12:53,240
所以我们把它们放在一起

1201
01:12:53,250 --> 01:12:58,440
得到了J*B小于等于(1/2)M

1202
01:12:58,440 --> 01:13:02,160
我们之所以要算J乘B

1203
01:13:02,230 --> 01:13:05,920
是因为在J漏斗里 有J个输入序列

1204
01:13:05,980 --> 01:13:11,280
如果要每个输入存一个块 那每次就要B的空间

1205
01:13:11,290 --> 01:13:15,090
对于每个输入序列 它都有B大小的块

1206
01:13:15,100 --> 01:13:17,980
这条式子说明了 它的总大小跟缓存大小的一半匹配

1207
01:13:17,990 --> 01:13:19,320
之前我们只用了四分之一的缓存

1208
01:13:19,380 --> 01:13:21,190
所以 总计就用了四分之三的缓存

1209
01:13:21,210 --> 01:13:22,660
我就是我们所有的花费

1210
01:13:22,670 --> 01:13:24,020
这听起来不错

1211
01:13:24,030 --> 01:13:26,570
因为我们还能给输出留一个块

1212
01:13:26,590 --> 01:13:27,700
毫无压力

1213
01:13:27,710 --> 01:13:29,980
只要J漏斗还在工作

1214
01:13:29,990 --> 01:13:33,870
只要所有东西都在缓存里 就妥妥的了

1215
01:13:33,890 --> 01:13:41,310
这意味着什么？ 我们先来分析一下

1216
01:13:41,330 --> 01:13:44,500
换入到内存的时间花费是多少

1217
01:13:44,520 --> 01:13:47,370
把整个J漏斗 还有一输入一块都读进来

1218
01:13:47,390 --> 01:13:50,690
需要花费多少时间？

1219
01:13:50,700 --> 01:13:53,710
我们来研究一下

1220
01:13:53,730 --> 01:13:59,890
好的 这是J漏斗的换入操作

1221
01:13:59,890 --> 01:14:05,110
也就是把整个J漏斗

1222
01:14:05,110 --> 01:14:13,320
还有一个输入一个块读入内存

1223
01:14:18,460 --> 01:14:25,350
换入操作的花费很好理解

1224
01:14:25,370 --> 01:14:27,500
就是缓存大小除以B

1225
01:14:27,510 --> 01:14:30,370
因为读入就是线性的扫描

1226
01:14:30,390 --> 01:14:33,600
我们还需要每个输入读一个块

1227
01:14:33,620 --> 01:14:36,600
而输入缓冲的分布很散 因为它们实在太大

1228
01:14:36,610 --> 01:14:40,180
所以我们设在读入一个输入序列的块之前

1229
01:14:40,190 --> 01:14:42,710
我们需要额外一个内存传输

1230
01:14:42,720 --> 01:14:44,510
这就是说

1231
01:14:44,530 --> 01:14:46,160
这里我们要算的东西比较多

1232
01:14:46,170 --> 01:14:50,230
它小于等于J^3/B

1233
01:14:50,240 --> 01:14:55,030
为什么它不超过J^3/B？

1234
01:14:55,040 --> 01:14:59,180
因为它是缓存能装下的第一个层

1235
01:14:59,200 --> 01:15:02,720
这就是说比它大的那层 就是J^2那层

1236
01:15:02,730 --> 01:15:06,610
它的大小是J^4 缓存已经装不下了

1237
01:15:06,620 --> 01:15:08,000
不然我们就在那一层停下了

1238
01:15:08,010 --> 01:15:10,570
这其实就是多算几步

1239
01:15:10,590 --> 01:15:12,690
你可以选择相信我或者是算一下

1240
01:15:12,700 --> 01:15:22,400
我们知道J^4≥M 那这就意味着

1241
01:15:22,410 --> 01:15:26,580
而M≥B^2

1242
01:15:26,590 --> 01:15:30,300
因此 J^2而不是J^4

1243
01:15:30,310 --> 01:15:34,720
我们对等式两边开平方 得到J^2≥B

1244
01:15:34,740 --> 01:15:38,320
那么 J^2/B肯定是小于J^3/B

1245
01:15:38,340 --> 01:15:45,440
我们还能得出J小于等于J^3 因为J^2≥B

1246
01:15:45,450 --> 01:15:49,690
这应该清楚了 这就是算数而已

1247
01:15:49,710 --> 01:15:50,990
我们不会用这个边界

1248
01:15:51,010 --> 01:15:52,100
因为它挺复杂的

1249
01:15:52,110 --> 01:15:53,130
我们只是说

1250
01:15:53,150 --> 01:15:55,880
换入操作的花费就是J^3/B

1251
01:15:55,900 --> 01:15:58,000
为什么J^3/B是个好东西？

1252
01:15:58,010 --> 01:16:03,730
因为我们知道输入的总大小是J^3

1253
01:16:03,740 --> 01:16:07,350
所以 把J漏斗的输入都读进来 花费就是J^3/B

1254
01:16:07,360 --> 01:16:09,620
也就是说 这只是多用了一点线性的花费

1255
01:16:09,630 --> 01:16:12,820
就完成了整个换入操作 不错嘛

1256
01:16:12,830 --> 01:16:16,790
做归并的花费也是J^3/B

1257
01:16:16,800 --> 01:16:18,400
那么 换入操作是J^3/B

1258
01:16:18,470 --> 01:16:19,880
而要归并J^3个元素

1259
01:16:19,950 --> 01:16:22,050
如果它们都在缓存里放好了

1260
01:16:22,080 --> 01:16:25,720
它的花费就是J^3/B 因为如果它们都放好了

1261
01:16:25,740 --> 01:16:27,580
你的归并就是全速前进的

1262
01:16:27,580 --> 01:16:34,070
平均一次传输可以处理B个元素

1263
01:16:34,080 --> 01:16:36,800
问题是你还要换出

1264
01:16:36,810 --> 01:16:38,110
你们可能想到了

1265
01:16:38,130 --> 01:16:40,580
当你的某个输入缓冲区清空了的时候

1266
01:16:40,600 --> 01:16:42,700
比如说这个没剩多少的 如果它空了的话

1267
01:16:42,710 --> 01:16:45,470
你就得把整个漏斗清空

1268
01:16:45,480 --> 01:16:48,230
然后从下面换入新的数据 把这个缓冲区填满

1269
01:16:48,240 --> 01:16:51,720
继续执行归并直到结束

1270
01:16:51,730 --> 01:16:55,060
下面就该平摊分析出场了

1271
01:16:55,070 --> 01:16:56,440
这也是为什么会有log项的原因

1272
01:16:56,450 --> 01:17:00,060
因为我们目前为止只有一点线性的花费

1273
01:17:00,080 --> 01:17:04,240
就快搞定了

1274
01:17:04,250 --> 01:17:13,380
所以我们——啊 还没讲到这里呢

1275
01:17:13,390 --> 01:17:20,600
当一个输入缓冲区空了

1276
01:17:20,610 --> 01:17:31,190
我们执行换出操作

1277
01:17:31,200 --> 01:17:37,340
然后再递归地把那个缓冲区重新填满

1278
01:17:37,360 --> 01:17:39,840
假设我们完全没有重用原来的缓冲

1279
01:17:39,850 --> 01:17:43,160
这个递归把所有的东西都换出了

1280
01:17:43,180 --> 01:17:45,780
我就得从下面的漏斗里重新提取数据

1281
01:17:45,790 --> 01:17:49,290
这样的话 我就得递归地重填下下面的缓冲区

1282
01:17:49,310 --> 01:17:54,830
最后我再回过头来 把新的数据换入进来

1283
01:17:54,840 --> 01:17:58,340
就是说递归重填完毕后 我就执行换入操作

1284
01:17:58,350 --> 01:18:04,600
所以我先递归的填充 然后再换入

1285
01:18:04,620 --> 01:18:13,240
换入的操作花费是J^3/B

1286
01:18:13,260 --> 01:18:18,500
我要把这部分花费平摊到刚刚填充的那部分元素上

1287
01:18:18,520 --> 01:18:29,150
所以这是一个平摊计费的问题

1288
01:18:46,840 --> 01:18:49,390
问题是有多少这样的元素？

1289
01:18:49,400 --> 01:18:51,800
其实这还挺好算的

1290
01:18:51,810 --> 01:18:54,190
比如这里 对于√K漏斗

1291
01:18:54,200 --> 01:18:59,770
每个缓冲区的大小是K^(3/2)

1292
01:18:59,790 --> 01:19:02,740
有点绕啊

1293
01:19:02,750 --> 01:19:07,170
我是说 填充缓冲区的元素个数

1294
01:19:07,180 --> 01:19:18,070
应该是J^3

1295
01:19:18,080 --> 01:19:19,300
所以对于一个J漏斗

1296
01:19:19,310 --> 01:19:22,450
每个输入缓冲区的大小都是J^3

1297
01:19:22,460 --> 01:19:25,510
这是根据前面的证明得出的

1298
01:19:25,520 --> 01:19:30,990
所以 我们对这J^3个元素的计费是J^3/B

1299
01:19:31,000 --> 01:19:32,550
就好像 对每个元素的计费是1/B

1300
01:19:32,570 --> 01:19:36,100
就好像 对每个元素的计费是1/B

1301
01:19:36,110 --> 01:19:38,790
听起来不错 这就是说——

1302
01:19:38,800 --> 01:19:44,300
从头想一想 我有N个元素

1303
01:19:44,320 --> 01:19:47,790
对每个元素的计费是1/B

1304
01:19:47,810 --> 01:19:50,310
听起来好像总运行时间是N/B

1305
01:19:50,320 --> 01:19:52,610
对于排序这也太快了

1306
01:19:52,620 --> 01:19:55,110
我们忘了log项了 那到底是怎么回事？

1307
01:19:55,120 --> 01:19:58,560
我们实际上对每个元素的计费不止一次

1308
01:19:58,580 --> 01:20:01,050
我们一般都不会这么做

1309
01:20:01,070 --> 01:20:03,600
至少以前的课上没这么做过

1310
01:20:03,610 --> 01:20:05,960
不过你可以限制计费的次数

1311
01:20:05,980 --> 01:20:07,880
每当你做计费分析的时候

1312
01:20:07,890 --> 01:20:09,700
你会发现 这个其实不用算那么多次

1313
01:20:09,720 --> 01:20:11,840
因为算这个的同时 那个也算了

1314
01:20:11,850 --> 01:20:15,960
你要证明你计费的对象

1315
01:20:15,970 --> 01:20:21,040
不会被计费太多次

1316
01:20:21,060 --> 01:20:24,420
这里我们就有一个计费的对象：元素

1317
01:20:24,430 --> 01:20:26,040
对于每个换入到缓冲区的元素

1318
01:20:26,050 --> 01:20:27,640
对于每个换入到缓冲区的元素

1319
01:20:27,650 --> 01:20:32,870
我都向它收费1/B

1320
01:20:32,890 --> 01:20:35,750
那对同一个元素我收费了多少次？

1321
01:20:35,770 --> 01:20:39,730
每次它被计费一次 它就移动到一个新的缓冲去

1322
01:20:39,740 --> 01:20:41,590
那么它经过了多少个缓冲区？

1323
01:20:41,600 --> 01:20:44,040
它一直都在从下到上移动

1324
01:20:44,060 --> 01:20:45,150
归并是向上的

1325
01:20:45,160 --> 01:20:47,140
我们从这里开始 到下一个缓冲区

1326
01:20:47,150 --> 01:20:48,290
然后再到下一个

1327
01:20:48,300 --> 01:20:52,600
经过的缓冲区数目就是那个log项

1328
01:20:52,620 --> 01:20:56,270
我也不知道是哪个log了

1329
01:20:56,280 --> 01:21:05,830
每个元素被计费的次数

1330
01:21:05,850 --> 01:21:11,340
就是它访问到的缓冲区数 就是一个log项

1331
01:21:11,350 --> 01:21:13,550
这就是我们为什么运行时间里有log项

1332
01:21:13,560 --> 01:21:19,490
这是要访问的J漏斗的个数

1333
01:21:19,510 --> 01:21:25,370
那就是log K除以log J

1334
01:21:25,380 --> 01:21:31,770
应该没错 就快大功告成了

1335
01:21:31,780 --> 01:21:40,560
用一下上面的黑板

1336
01:21:40,570 --> 01:21:42,600
不幸的是还得算点东西

1337
01:21:42,610 --> 01:21:44,990
那么log K/log J

1338
01:21:45,000 --> 01:21:49,590
J^2和M差不多

1339
01:21:49,610 --> 01:21:53,920
J可能是√M 不过log J和log M差不多

1340
01:21:53,940 --> 01:21:55,170
差的只是常数因子而已

1341
01:21:55,180 --> 01:22:06,480
所以计费的次数就是Θ(log K/log M)

1342
01:22:07,340 --> 01:22:09,920
虽然这个平摊分析里不是肯定会用到

1343
01:22:09,960 --> 01:22:12,680
但现在我们还是需要算出总的计费次数

1344
01:22:12,690 --> 01:22:15,160
所有的操作都要计费

1345
01:22:15,170 --> 01:22:19,200
除了最开始的换入不需要计费

1346
01:22:19,210 --> 01:22:22,990
不过每次执行换入操作 我们就得计费了

1347
01:22:23,010 --> 01:22:24,900
那么所有的计费次数是多少

1348
01:22:24,920 --> 01:22:26,330
有N个元素

1349
01:22:26,340 --> 01:22:28,760
每个元素收费1/B

1350
01:22:28,780 --> 01:22:33,490
计费的次数是log K/log M

1351
01:22:33,500 --> 01:22:42,920
所以总花费就是元素的个数

1352
01:22:42,930 --> 01:22:49,250
乘以1/B乘以这个log项

1353
01:22:49,260 --> 01:22:53,400
其实还有一个+K 我们忘了这个+K

1354
01:22:53,410 --> 01:22:55,520
这是在最开始的第一步的花费

1355
01:22:55,540 --> 01:22:57,590
用来输入所有的序列

1356
01:22:57,610 --> 01:23:05,550
这个平摊分析得出的这个界

1357
01:23:05,570 --> 01:23:08,750
不好意思 这个N是什么

1358
01:23:08,770 --> 01:23:12,700
我假设过 数据是K^3个元素

1359
01:23:12,720 --> 01:23:16,220
最底层的元素个数为Θ(K^3)

1360
01:23:16,230 --> 01:23:19,200
所以我应该用K^3而不是N

1361
01:23:19,210 --> 01:23:24,980
这两个其实差不多 不过不完全一样

1362
01:23:24,990 --> 01:23:32,340
这是log_M(K) 而且如果你算一下

1363
01:23:32,350 --> 01:23:40,380
这就是K^3/B乘以log_(M/B)(K/B)

1364
01:23:40,390 --> 01:23:43,300
再加上K 这就是我想要的

1365
01:23:43,310 --> 01:23:45,560
这个log里应该是K^3

1366
01:23:45,580 --> 01:23:47,040
不过对于log来说 它只是个因子3而已

1367
01:23:47,060 --> 01:23:51,450
接下来 因为我们假设这不是基准情形

1368
01:23:51,460 --> 01:23:57,930
所以 K大于等于M 也就是大于等于B^2

1369
01:23:57,940 --> 01:24:07,570
那么K/B就等于Ω(√K)

1370
01:24:07,580 --> 01:24:12,540
在log里面 K/B是和K差不多的

1371
01:24:12,550 --> 01:24:13,620
这个是以M为底的log

1372
01:24:13,640 --> 01:24:15,940
我把它转为M/B 就更乱了

1373
01:24:15,950 --> 01:24:18,400
不过这都无所谓 现在我有一个log K

1374
01:24:18,410 --> 01:24:19,790
替换成K/B

1375
01:24:19,800 --> 01:24:22,380
而K/B大约是√K

1376
01:24:22,400 --> 01:24:25,620
在log里 这就是一个1/2罢了

1377
01:24:25,630 --> 01:24:29,490
这就是漏斗的分析了

1378
01:24:29,510 --> 01:24:31,270
我们得到了这个犀利的运行时间

1379
01:24:31,290 --> 01:24:33,350
就是排序边界加上了一点

1380
01:24:33,360 --> 01:24:35,620
我们把它用在漏斗排序里 得到了

1381
01:24:35,640 --> 01:24:42,840
最优的缓存无关排序 时间刚刚好

1382
01:24:42,850 --> 01:24:45,510
周二就期末考试了

1383
01:24:45,520 --> 01:24:51,680
期末考试的形式跟小测1差不多 没什么新鲜的

1384
01:24:51,700 --> 01:24:56,000
基本包含了所有知识点

1385
01:24:56,010 --> 01:24:58,920
你不用复习漏斗排序的具体过程

1386
01:24:58,940 --> 01:25:00,860
不过其他的都要看

1387
01:25:00,870 --> 01:25:03,490
就像小测1的豪华增量版

1388
01:25:03,500 --> 01:25:07,910
你们有三个小时 愿算法与你同在

1389
01:25:07,920 --> 01:25:10,450
和你们在一起的时光很开心

1390
01:25:10,470 --> 01:25:14,160
我相信查哥也是这么想的 感谢你们所有人

1391
01:25:14,180 --> 01:25:20,240
学算法真™开心啊

