1
00:00:04,990 --> 00:00:06,670
——宝贵的经验

2
00:00:06,950 --> 00:00:13,300
今天我们要开始介绍

3
00:00:13,360 --> 00:00:16,070
一类叫做算法的特殊算法

4
00:00:16,070 --> 00:00:18,890
但我们会涉及一些图论的知识

5
00:00:18,950 --> 00:00:25,910
所以 我们先回顾一下图的相关内容

6
00:00:26,840 --> 00:00:33,760
大部分内容可以在课本的附录B里找到

7
00:00:34,490 --> 00:00:39,470
如果你最近没有看过附录B

8
00:00:39,580 --> 00:00:41,730
请静下心来 复习附录B

9
00:00:41,800 --> 00:00:46,090
这对你很有帮助 特别是当你做课后小测时

10
00:00:46,260 --> 00:00:50,550
只是提醒一下 一个Digraph

11
00:00:51,070 --> 00:00:53,510
什么是Digraph？

12
00:00:54,370 --> 00:00:56,430
是什么的简称？

13
00:00:56,740 --> 00:00:58,620
有向图(Direct + Graph)

14
00:00:58,970 --> 00:01:02,490
有向图G=(V,E)

15
00:01:03,170 --> 00:01:10,600
有一个顶点集合V

16
00:01:10,990 --> 00:01:18,860
总是有人提醒我 如果只有一个顶点

17
00:01:18,970 --> 00:01:24,020
单数的话是不叫vertice 叫vertex

18
00:01:24,160 --> 00:01:26,420
顶点的复数形式为vertices 单数为vertex

19
00:01:26,490 --> 00:01:30,040
它也算是英语单词中的一朵奇葩了

20
00:01:30,240 --> 00:01:33,920
原来可能是法语或是什么语言吧？

21
00:01:33,980 --> 00:01:36,520
不知道 也无所谓

22
00:01:36,590 --> 00:01:38,800
有一个集合E

23
00:01:39,070 --> 00:01:45,480
是V叉乘V条边的子集

24
00:01:46,390 --> 00:01:48,130
这是一个有向图

25
00:01:48,190 --> 00:02:02,200
在无向图里 E包含的是无序的顶点对

26
00:02:14,650 --> 00:02:17,850
你说啥？ 噢 它是拉丁语

27
00:02:17,890 --> 00:02:21,460
确实是非常古老的英语

28
00:02:21,460 --> 00:02:23,790
我猜顶点这个单词有可能是

29
00:02:23,870 --> 00:02:26,310
一种外来语 但可能不是法语

30
00:02:28,550 --> 00:02:32,270
在1570年开始使用

31
00:02:32,950 --> 00:02:37,460
非常好

32
00:02:38,780 --> 00:02:44,440
那么 边的数量是

33
00:02:44,510 --> 00:02:49,870
无论有向还是无向 复杂度是多少？

34
00:02:56,560 --> 00:02:58,670
O(V^2) 很好

35
00:03:00,890 --> 00:03:03,900
在做这类问题时 有一种约定俗成的事情是

36
00:03:04,010 --> 00:03:06,780
一旦涉及到图 就会有很多集合需要处理

37
00:03:06,840 --> 00:03:12,360
我们通常会把大O记法的那两竖线去掉

38
00:03:12,370 --> 00:03:15,250
因为它已经隐含了这层意思 加上双竖只会更乱

39
00:03:15,320 --> 00:03:17,810
这又是一种符号的滥用

40
00:03:17,870 --> 00:03:20,970
实际上应该是O(|V^2|)

41
00:03:21,040 --> 00:03:23,130
但这样很容易混淆

42
00:03:23,210 --> 00:03:26,210
只是要写的东西变多了

43
00:03:26,280 --> 00:03:29,220
你一边要相乘 一边又有两条竖线

44
00:03:29,340 --> 00:03:33,210
而一般人甚至觉得这两竖线意义不明

45
00:03:33,220 --> 00:03:34,380
这只会越来越乱

46
00:03:34,390 --> 00:03:38,680
所以在大O记法里面

47
00:03:39,360 --> 00:03:42,000
这里竖线符号可以去掉

48
00:03:42,060 --> 00:03:46,600
那么 一对顶点代表一条边 所以|E|=O(V^2)

49
00:03:46,630 --> 00:03:47,820
因为如果它是顶点对的集合

50
00:03:47,890 --> 00:03:50,760
最多有n选2种组合

51
00:03:50,940 --> 00:03:53,370
它最大就是n^2/2

52
00:03:53,410 --> 00:03:55,510
所以它最大也就是

53
00:03:55,550 --> 00:03:58,870
口误了 是V^2/2 所以大O里面是V^2

54
00:03:58,940 --> 00:04:01,700
还有一个有时会用到性质是

55
00:04:01,770 --> 00:04:05,470
如果G是连通的 我们就有另一个界限

56
00:04:08,460 --> 00:04:11,450
绑定了E的大小

57
00:04:11,480 --> 00:04:15,770
至少是V-1

58
00:04:18,670 --> 00:04:23,170
所以 如果是连通图 那么

59
00:04:23,200 --> 00:04:26,630
怎么样的图才算是连通图呢？

60
00:04:26,650 --> 00:04:29,150
[学生]：...

61
00:04:29,180 --> 00:04:33,240
没错 对于图里的任意顶点 总有路径可达其它顶点

62
00:04:33,270 --> 00:04:36,160
这就是“连通”的意思

63
00:04:36,230 --> 00:04:39,810
如果是这种情况 则边的数量

64
00:04:39,850 --> 00:04:43,920
至少是顶点数减1

65
00:04:44,230 --> 00:04:45,920
所以 这就是说

66
00:04:45,980 --> 00:04:48,350
我们要研究的是

67
00:04:48,390 --> 00:04:52,790
事实上我只是想提醒你们 在这种情况下

68
00:04:52,860 --> 00:05:00,880
如果计算log E  给边数取对数

69
00:05:01,980 --> 00:05:10,080
这种情况下是O(log V)

70
00:05:10,790 --> 00:05:15,640
这种情况是Ω(log V)

71
00:05:15,680 --> 00:05:19,010
所以它等于θ(log V)

72
00:05:21,210 --> 00:05:22,600
所以 基本上这个数量...

73
00:05:22,670 --> 00:05:25,890
在连通图的情况下 边的数量

74
00:05:25,960 --> 00:05:28,250
与顶点的数量是多项式相关的

75
00:05:28,320 --> 00:05:31,340
所以它们log值就差不多了的

76
00:05:33,240 --> 00:05:35,660
知道这个很有用

77
00:05:35,730 --> 00:05:37,480
因为你日后就会遇到这种问题

78
00:05:37,520 --> 00:05:40,270
可能有人会说 虽然你证明它为log E

79
00:05:40,310 --> 00:05:42,210
但你没有证明它是log V吧？

80
00:05:42,250 --> 00:05:45,630
然而我却能反驳 他们实际上是等价的

81
00:05:51,610 --> 00:05:58,390
计算机有很多不同的表示图的方式

82
00:05:58,900 --> 00:06:01,520
我只讲几个比较重要的

83
00:06:01,560 --> 00:06:06,520
实际上还有很多 我们日后会看到更多的

84
00:06:06,590 --> 00:06:11,770
最简单的一个 称为邻接矩阵

85
00:06:13,260 --> 00:06:23,800
一个邻接矩阵

86
00:06:24,630 --> 00:06:30,600
图G=(V,E)的一个邻接矩阵

87
00:06:30,880 --> 00:06:34,540
为简便起见

88
00:06:34,580 --> 00:06:41,950
让V为从1到n的整数集

89
00:06:43,390 --> 00:07:01,470
(邻接矩阵)是一个n乘n的矩阵A 它的第ij项...

90
00:07:01,540 --> 00:07:10,380
如果边集里存在一条边ij——则A[i,j]=1

91
00:07:10,690 --> 00:07:17,110
如果边ij不在边集里 则为0

92
00:07:18,510 --> 00:07:21,690
只是这样一个矩阵

93
00:07:21,730 --> 00:07:24,930
如果边(i,j)存在 则第ij项是1

94
00:07:25,000 --> 00:07:26,700
这在某种程度上

95
00:07:26,740 --> 00:07:31,470
是一个条件判断 判断是否存在一条边从i到j的？

96
00:07:31,480 --> 00:07:32,850
好的，条件判断 要记住

97
00:07:32,920 --> 00:07:37,490
也就是一条布尔公式 非0则1

98
00:07:37,560 --> 00:07:41,510
在这种情况下 A[i,j]为1

99
00:07:41,550 --> 00:07:46,760
如果有一条从i到j的边的话 否则为0

100
00:07:46,970 --> 00:07:53,140
有时候 有些图的边是加权了的

101
00:07:53,180 --> 00:07:54,890
那么人们有时会这样处理

102
00:07:54,930 --> 00:07:57,600
用边的权重来替换1或0

103
00:07:58,020 --> 00:08:01,010
它变成了边ij的权重

104
00:08:01,140 --> 00:08:06,300
举一个例子

105
00:08:06,300 --> 00:08:11,320
来证明我们的直觉

106
00:08:11,390 --> 00:08:17,770
跟我们的数学定义相符

107
00:08:17,840 --> 00:08:22,080
这是一个图例

108
00:08:24,110 --> 00:08:28,330
假设这是我们的图

109
00:08:28,640 --> 00:08:35,290
画一下它的邻接矩阵

110
00:08:38,290 --> 00:08:43,390
这里是什么：从1到1是否有一条边相连？

111
00:08:43,830 --> 00:08:45,110
答案是没有

112
00:08:45,190 --> 00:08:48,330
从1到2呢？ 有

113
00:08:48,490 --> 00:08:52,400
有一条边从1到3？ 有

114
00:08:52,430 --> 00:08:56,010
从1到4? 没有

115
00:08:56,080 --> 00:08:59,850
从2到1？ 没有

116
00:08:59,880 --> 00:09:04,340
2到2？ 没有 2到3？ 有

117
00:09:04,420 --> 00:09:08,340
2到4？ 没有

118
00:09:08,870 --> 00:09:12,990
没有边从顶点3出发

119
00:09:13,640 --> 00:09:17,990
从4到3的边 是这一条

120
00:09:18,060 --> 00:09:25,740
这就是这个图特有的邻接矩阵

121
00:09:27,410 --> 00:09:32,380
所以 我可以用邻接矩阵来表示一个图

122
00:09:32,420 --> 00:09:35,230
当用这种方式表示时

123
00:09:35,290 --> 00:09:37,360
需要多少存储空间？

124
00:09:41,050 --> 00:09:44,020
n^2或是V^2

125
00:09:44,280 --> 00:09:49,810
因为大小跟V^2是一样的

126
00:09:50,730 --> 00:09:57,680
这就是所说的稠密表示

127
00:10:01,170 --> 00:10:04,110
如果图是稠密的话 它的效果灰常好

128
00:10:04,180 --> 00:10:07,910
图是稠密的也就是说 如果边的数量

129
00:10:08,260 --> 00:10:13,320
很接近最大可能边数

130
00:10:13,970 --> 00:10:16,120
这样的话 稠密表示就很不错

131
00:10:16,190 --> 00:10:18,410
但对于大多数图来说 边的数量

132
00:10:18,440 --> 00:10:25,410
都会远远少于最大可能边数

133
00:10:25,480 --> 00:10:27,370
这种情况我们称图是稀疏的

134
00:10:27,480 --> 00:10:30,660
谁能给出一个稀疏图的例子吗？

135
00:10:30,770 --> 00:10:32,570
一类图

136
00:10:32,600 --> 00:10:35,610
我想要一类图 在这种图里随着n的增加

137
00:10:35,650 --> 00:10:39,410
图内边的数量不会按n^2的比例增加

138
00:10:39,480 --> 00:10:45,980
其增长速度会相对小得多

139
00:10:46,450 --> 00:10:49,460
一个链表 一条链

140
00:10:49,530 --> 00:10:51,160
理论上 如果从图的角度来看

141
00:10:51,200 --> 00:10:55,190
这会是一个绝佳的例子：只有n条边

142
00:10:55,260 --> 00:10:57,040
存放在一条长为n的链里

143
00:10:57,100 --> 00:11:00,000
因此 边的数量会是O(V)

144
00:11:00,040 --> 00:11:07,260
这样一来 这里每一行都只有一条边

145
00:11:07,270 --> 00:11:12,090
还有什么图是稀疏的？

146
00:11:12,160 --> 00:11:15,840
[学生]：……

147
00:11:15,910 --> 00:11:17,860
很好 平面图

148
00:11:17,890 --> 00:11:20,380
一个只能在平面上画出来的图

149
00:11:20,450 --> 00:11:24,910
如果它有V个顶点 而V至少是3

150
00:11:24,980 --> 00:11:29,460
那么 它最多只有(3V－6)条边

151
00:11:29,490 --> 00:11:33,760
所以 结果还是O(V)条边

152
00:11:33,790 --> 00:11:38,040
还有一种常见图的例子是什么？

153
00:11:38,110 --> 00:11:40,910
没错 二叉树或者是其它任意树

154
00:11:40,950 --> 00:11:44,210
如果你看过附录 你就知道那叫自由树

155
00:11:44,350 --> 00:11:49,430
树是一种没有环的连通图

156
00:11:49,500 --> 00:11:50,880
这是另一个例子

157
00:11:50,950 --> 00:11:53,800
稠密图有什么例子？

158
00:11:59,790 --> 00:12:05,620
完全图 这里全部是1

159
00:12:05,680 --> 00:12:07,290
好吧 如果边有权重的话

160
00:12:07,380 --> 00:12:09,130
这个矩阵会被完全填满

161
00:12:09,200 --> 00:12:10,840
非常好

162
00:12:10,950 --> 00:12:14,210
所以它很适用于稠密表示

163
00:12:14,270 --> 00:12:18,140
但有时候你想要用稀疏表示

164
00:12:18,200 --> 00:12:26,210
不想花费V^2的空间来表示

165
00:12:26,210 --> 00:12:29,030
因为这里很多地方都是0

166
00:12:29,070 --> 00:12:31,120
傲娇一下 既然都是0的话

167
00:12:31,190 --> 00:12:33,530
人家才不会写得这么麻烦呢~~

168
00:12:33,570 --> 00:12:39,060
好的 有一种方法是用邻接表来表示

169
00:12:45,240 --> 00:12:53,890
实际上 一个给定顶点的邻接表

170
00:12:53,960 --> 00:13:07,290
我们用Adj(V)来表示 它记录了与V相邻的顶点

171
00:13:07,360 --> 00:13:09,640
根据它们的术语

172
00:13:09,700 --> 00:13:16,720
顶点之间是邻接的 但边与顶点是关联的

173
00:13:16,780 --> 00:13:21,540
所以 关联是指顶点与边之间的爱情

174
00:13:21,600 --> 00:13:26,720
邻接是指两个顶点之间的羁绊

175
00:13:26,780 --> 00:13:28,730
这只是叫法不同

176
00:13:28,810 --> 00:13:32,120
为什么会有不同的术语 我不知道

177
00:13:32,160 --> 00:13:33,810
这是哲学的问题了

178
00:13:34,640 --> 00:13:37,510
举个例子 在这个图里

179
00:13:37,580 --> 00:13:41,500
顶点1的邻接表

180
00:13:41,560 --> 00:13:49,610
是包含2和3的链表或者集合

181
00:13:49,680 --> 00:13:54,930
因为从1出发的边 有一条到2 有一条到3

182
00:13:55,010 --> 00:14:00,720
2的邻接表只有3

183
00:14:01,290 --> 00:14:12,210
3的邻接表是个空集 4的邻接表是3

184
00:14:16,540 --> 00:14:21,000
这是这个表示方法

185
00:14:21,070 --> 00:14:22,840
如果想要知道这种表示法

186
00:14:22,950 --> 00:14:26,300
需要占用多少存储空间的话

187
00:14:26,370 --> 00:14:30,000
那就必须先知道这个邻接表有多长

188
00:14:30,040 --> 00:14:36,970
对于一个顶点V 其邻接表的长度是多少?

189
00:14:37,560 --> 00:14:41,170
我们用什么名词来描述?

190
00:14:44,350 --> 00:14:49,200
那就是度 在一个无向图里

191
00:14:49,590 --> 00:14:53,750
我们称之为顶点的度

192
00:14:53,820 --> 00:14:55,680
这是无向图

193
00:14:59,330 --> 00:15:06,070
在这里

194
00:15:06,140 --> 00:15:07,550
这是无向的情况

195
00:15:07,620 --> 00:15:10,960
在有向的情况下

196
00:15:11,010 --> 00:15:14,300
实际上我想这里应该这样写

197
00:15:14,370 --> 00:15:22,460
我们称之为有向图的出度

198
00:15:25,930 --> 00:15:27,270
在有向图里

199
00:15:27,340 --> 00:15:31,080
每个顶点都有一个出度和一个入度

200
00:15:31,190 --> 00:15:33,520
这里入度是3

201
00:15:33,590 --> 00:15:38,190
这里的出度是2

202
00:15:40,810 --> 00:15:49,240
接下来 我们要讲的一个最重要的引理

203
00:15:51,190 --> 00:15:54,200
叫做握手引理

204
00:15:56,870 --> 00:16:00,930
它是数学引理之一

205
00:16:09,390 --> 00:16:11,940
好的 我讲个故事

206
00:16:12,120 --> 00:16:14,690
一个晚会派对上

207
00:16:14,790 --> 00:16:20,690
每个人都要和其他人握手

208
00:16:20,760 --> 00:16:22,880
有些人可能一个都没握

209
00:16:22,950 --> 00:16:28,640
有些人可能跟几个人握了手

210
00:16:28,710 --> 00:16:32,170
没有人跟自己握手

211
00:16:32,250 --> 00:16:37,030
在晚会期间的某个时间

212
00:16:38,040 --> 00:16:42,950
主人环视现场 然后数了数

213
00:16:43,020 --> 00:16:49,910
每个人握手次数的总和

214
00:16:49,970 --> 00:16:51,650
他一个一个问:你握了几次手?

215
00:16:51,690 --> 00:16:53,150
你握了几次手? 你又握手了多少次?

216
00:16:53,220 --> 00:17:00,680
他把这些加起来 总数一定是偶数

217
00:17:01,710 --> 00:17:03,370
这就是握手定理

218
00:17:03,440 --> 00:17:09,190
或者 更精确地说

219
00:17:10,340 --> 00:17:14,360
如果对任意图取顶点的度

220
00:17:14,400 --> 00:17:18,410
把所有度加起来 也就是所有人握手的总次数

221
00:17:18,560 --> 00:17:23,410
实际总是等于边数的两倍

222
00:17:25,120 --> 00:17:27,730
为什么这是成立的?

223
00:17:28,270 --> 00:17:30,960
为什么会等于边数的两倍?

224
00:17:31,480 --> 00:17:32,510
说一下?

225
00:17:32,580 --> 00:17:37,190
[学生]:……

226
00:17:37,260 --> 00:17:40,280
没错 每次你加入一条边

227
00:17:40,350 --> 00:17:45,230
你在边的每一个端点都加了1的度

228
00:17:45,280 --> 00:17:46,500
这只是两种不同的

229
00:17:46,570 --> 00:17:48,530
计算边的数量的方法

230
00:17:48,600 --> 00:17:52,050
如果你想像一下

231
00:17:52,120 --> 00:17:55,270
每次我计算一个顶点的度时

232
00:17:55,340 --> 00:17:58,070
我都在它每条边上做一个标记

233
00:17:58,880 --> 00:18:00,490
当我完成时

234
00:18:00,570 --> 00:18:04,790
每条边都有两个标记 一端一个

235
00:18:05,870 --> 00:18:09,460
一个非常简单的理论

236
00:18:09,530 --> 00:18:13,270
这对于无向图来说

237
00:18:18,170 --> 00:18:25,230
它意味着其邻接表表示法

238
00:18:26,430 --> 00:18:30,650
会占用多少存储空间?

239
00:18:33,500 --> 00:18:38,960
最多是2E 所以是O(E) 但还没完

240
00:18:43,080 --> 00:18:44,850
[学生]:……

241
00:18:44,920 --> 00:18:48,050
对 所以你还必须知道顶点的数量

242
00:18:48,130 --> 00:18:52,210
加上边的数量阶

243
00:18:52,280 --> 00:18:54,730
无论是有向图还是无向图

244
00:18:55,120 --> 00:18:56,820
因为可能有一个图

245
00:18:56,890 --> 00:19:00,390
有一堆顶点但是没有边

246
00:19:00,460 --> 00:19:03,510
但它仍要占用O(V)的空间

247
00:19:03,590 --> 00:19:10,330
所以需要θ(V+E)的空间

248
00:19:11,450 --> 00:19:15,320
这两者基本上是互相等同的

249
00:19:16,080 --> 00:19:21,180
实际上 对于有向图而言 从某种程度来看更直观

250
00:19:23,660 --> 00:19:28,130
因为对于有向图 我要做的只是把所有的出度加起来

251
00:19:28,210 --> 00:19:32,320
而那会等于E

252
00:19:32,720 --> 00:19:35,290
将所有出度都加起来

253
00:19:35,400 --> 00:19:40,020
实际上这有点类似平摊分析

254
00:19:40,060 --> 00:19:42,560
你可以看成是记账分析

255
00:19:42,620 --> 00:19:45,190
如果我加上所有边的度

256
00:19:45,260 --> 00:19:49,020
一种方法是一个顶点一个顶点地计算

257
00:19:50,000 --> 00:19:54,970
对于每个顶点 基本都能得到它的度

258
00:19:55,040 --> 00:19:58,200
然后我们查看每个顶点的度

259
00:19:58,270 --> 00:20:01,980
把它平摊到每条边上

260
00:20:02,050 --> 00:20:04,100
结果刚好是每条边都有2的度

261
00:20:04,170 --> 00:20:07,040
这正是记账法分析

262
00:20:07,080 --> 00:20:09,900
我们可以拿来做平摊分析

263
00:20:10,430 --> 00:20:12,520
好的 我们待会儿会看到

264
00:20:12,820 --> 00:20:15,870
这是一种稀疏表示法

265
00:20:20,020 --> 00:20:28,610
一般都比邻接矩阵要好

266
00:20:28,760 --> 00:20:32,990
举个例子 你想像一下 如果万维网

267
00:20:33,050 --> 00:20:38,530
是用邻接矩阵来表示的

268
00:20:38,600 --> 00:20:43,120
而不是用邻接表的表示方式

269
00:20:43,180 --> 00:20:46,720
每个万维网的链接 我必须吐槽

270
00:20:46,790 --> 00:20:48,360
要连接的站点有这么多

271
00:20:48,430 --> 00:20:51,910
没有连接的站点有这么多！！

272
00:20:52,010 --> 00:20:54,800
那些没有连接的所有站点

273
00:20:54,860 --> 00:20:58,880
将会非常戏剧性地

274
00:20:59,660 --> 00:21:03,550
向你展示稀疏表示的一个优点

275
00:21:03,620 --> 00:21:04,840
另一方面

276
00:21:04,870 --> 00:21:10,210
邻接矩阵表示法的一个优点是

277
00:21:10,280 --> 00:21:14,750
每条边都能用一个单独的位来表示

278
00:21:15,630 --> 00:21:21,070
然而 反观这边

279
00:21:21,140 --> 00:21:23,570
如果用邻接表表示法的话

280
00:21:23,650 --> 00:21:33,100
我需要多少位来表示每个邻接的边?

281
00:21:33,400 --> 00:21:36,690
需要O(log V)

282
00:21:36,730 --> 00:21:40,390
为了表示每个不同的顶点

283
00:21:40,510 --> 00:21:43,100
log(顶点数)个位来表示一个顶点

284
00:21:43,200 --> 00:21:45,060
所以 在某些情况下

285
00:21:45,100 --> 00:21:47,210
这是一个非常有效的表示方法

286
00:21:47,280 --> 00:21:49,710
尤其是用来表示一张非常稠密的图时

287
00:21:50,270 --> 00:21:53,680
这将会是一种更好的表示方法

288
00:21:53,750 --> 00:21:55,460
另一个需要你们理解的是

289
00:21:55,530 --> 00:21:58,510
在下周我们将会进行更深入探讨

290
00:21:58,580 --> 00:22:04,960
矩阵和图

291
00:22:05,070 --> 00:22:08,740
它们看待同一件事物的两种不同方式

292
00:22:10,230 --> 00:22:13,700
实际上 有很多图论专门涉及到

293
00:22:13,770 --> 00:22:18,990
类似邻接矩阵相乘这样的操作

294
00:22:19,250 --> 00:22:20,290
各种各样

295
00:22:20,360 --> 00:22:24,140
所以 图和矩阵有很多共通之处

296
00:22:24,190 --> 00:22:26,030
有很多数学知识 当适用于其中一个时

297
00:22:26,070 --> 00:22:29,070
另一个也同样适用 你是有问题想问

298
00:22:29,180 --> 00:22:31,490
还是只是在练一阳指?

299
00:22:31,560 --> 00:22:33,400
好的

300
00:22:33,470 --> 00:22:36,260
刚才所讲的只是复习

301
00:22:36,330 --> 00:22:38,910
现在进入今天要讲的内容

302
00:22:39,450 --> 00:22:41,310
对于图还有什么问题吗?

303
00:22:41,360 --> 00:22:43,570
这是复习附录B的好机会

304
00:22:43,600 --> 00:22:45,200
里面有很多不错的相关性质

305
00:22:45,230 --> 00:22:48,460
特别是 里面有一个理论

306
00:22:48,500 --> 00:22:54,860
我们在今天将要介绍到的

307
00:22:54,940 --> 00:22:57,190
它是树的性质

308
00:22:57,300 --> 00:22:59,990
树是非常特殊的一类图

309
00:23:00,060 --> 00:23:01,930
真诚地希望你们能回去

310
00:23:02,000 --> 00:23:03,280
看一下那些性质是什么

311
00:23:03,350 --> 00:23:06,320
那大概是 我想想 有六种不同的

312
00:23:06,390 --> 00:23:09,770
但又等价的树的定义

313
00:23:09,840 --> 00:23:11,880
我觉得绝对是物超所值

314
00:23:11,950 --> 00:23:14,600
如果你阅读了那个理论的话

315
00:23:14,670 --> 00:23:17,260
我不打算在课堂上进行证明 但它真心地

316
00:23:17,310 --> 00:23:19,430
会给我们今天要讲的内容

317
00:23:19,500 --> 00:23:21,420
提供一个超棒的思想基础

318
00:23:21,490 --> 00:23:24,790
日后 我们会学到更多相关内容

319
00:23:25,120 --> 00:23:29,020
今天我们要讲到的是最小生成树

320
00:23:34,820 --> 00:23:38,890
这是世界上最重要的算法之一

321
00:23:39,560 --> 00:23:42,390
它在分布式系统里尤为重要

322
00:23:42,460 --> 00:23:43,670
这是几乎所有分布式系统

323
00:23:43,710 --> 00:23:46,670
第一个想要解决的问题

324
00:23:46,820 --> 00:23:52,140
就是找出一棵最小生成树

325
00:23:52,250 --> 00:23:55,530
所有节点在任意时刻都是活跃的

326
00:23:55,640 --> 00:24:00,600
某些人们就是为此设计了这个算法

327
00:24:00,680 --> 00:24:04,830
这部分稍后会再进行介绍

328
00:24:05,330 --> 00:24:08,430
它是AT&T的记账系统的基础

329
00:24:08,500 --> 00:24:11,740
这么多年来 从未被超越

330
00:24:12,100 --> 00:24:15,240
它真的非常重要

331
00:24:15,310 --> 00:24:17,810
它有海量的应用

332
00:24:17,920 --> 00:24:20,020
那么 问题是这样的

333
00:24:21,120 --> 00:24:34,920
你有一个连通的无向图 G=(V,E)

334
00:24:35,840 --> 00:24:44,850
还有一个给边加权的函数w

335
00:24:44,920 --> 00:24:51,080
它给每条边都加一个实数的权值

336
00:24:53,130 --> 00:24:54,810
这堂课上

337
00:24:54,880 --> 00:24:57,410
我们将要做一个重要的假设

338
00:24:57,480 --> 00:25:00,000
为了简单起见

339
00:25:00,250 --> 00:25:02,980
这本书里没有做这个假设

340
00:25:03,760 --> 00:25:08,150
所以 我诚邀你们来看看另一种方法的演示

341
00:25:08,220 --> 00:25:13,920
因为书本上的做法更加一般化

342
00:25:13,990 --> 00:25:17,620
但为了简单和直观

343
00:25:17,690 --> 00:25:21,340
我要降低一下难度

344
00:25:21,390 --> 00:25:32,960
我们假设 所有边的权值都是互异的

345
00:25:35,900 --> 00:25:38,320
所有边的权值都是互异的

346
00:25:38,390 --> 00:25:39,650
这意味着什么

347
00:25:39,760 --> 00:25:42,550
这个w函数意味着什么？

348
00:25:42,590 --> 00:25:44,280
这个w函数会具有什么特性？

349
00:25:44,350 --> 00:25:46,950
如果所有边的权值都是互异的话？

350
00:25:47,610 --> 00:25:50,790
谁还记得离散数学怎么说？

351
00:25:51,130 --> 00:25:52,870
它是内映射的

352
00:25:52,940 --> 00:25:55,020
没错 是一对一的

353
00:25:55,510 --> 00:25:57,810
而且它不一定是一对一的满映射

354
00:25:57,880 --> 00:25:59,560
实际上 这很难做到

355
00:25:59,630 --> 00:26:01,000
因为那会是一个很大的集合

356
00:26:01,110 --> 00:26:02,670
但它是一对一的

357
00:26:02,740 --> 00:26:04,460
它是内映射的

358
00:26:04,820 --> 00:26:07,540
好的 这就是为了简单起见而做的假设

359
00:26:07,610 --> 00:26:09,920
但在书里 我们不做假设

360
00:26:09,990 --> 00:26:16,290
这也就意味着 你的表述

361
00:26:16,330 --> 00:26:18,100
需要更加精确

362
00:26:18,210 --> 00:26:20,490
灰常灰常地精确

363
00:26:21,160 --> 00:26:28,080
那么 这是输入 而输出是...

364
00:26:31,400 --> 00:26:40,480
输出是一棵生成树T

365
00:26:40,550 --> 00:26:48,160
一棵生成树是指 它连接了所有的顶点

366
00:26:50,990 --> 00:26:53,820
而且权重的总和还必须最小

367
00:27:00,210 --> 00:27:05,880
那这棵树的权重就可以写成是...

368
00:27:06,490 --> 00:27:11,050
根据定义 它是所有的在这棵树里的边的权值

369
00:27:11,850 --> 00:27:15,150
加起来的总和

370
00:27:23,240 --> 00:27:27,180
这里我又滥用了一下符号

371
00:27:27,880 --> 00:27:34,000
也就是 我应该写的是w((u,v))

372
00:27:34,060 --> 00:27:36,370
因为(u,v)指的是一条边

373
00:27:36,440 --> 00:27:39,730
所以这里应该是双重括号

374
00:27:39,800 --> 00:27:43,770
但你知道 滥用符号神马的最喜欢了

375
00:27:43,840 --> 00:27:45,700
所以 我毫不犹豫地抛弃了一对括号

376
00:27:45,770 --> 00:27:48,740
因为我们都懂的 这就是边的权值

377
00:27:48,800 --> 00:27:51,430
不是顶点对的权值

378
00:27:53,850 --> 00:28:00,000
那么 这是取巧的写法

379
00:28:01,050 --> 00:28:04,420
有一点要注意 当我们做家庭作业时

380
00:28:04,480 --> 00:28:07,090
这些取巧的写法可能会引起误解

381
00:28:07,160 --> 00:28:11,410
可能方便一时 也可能毁于一旦

382
00:28:11,440 --> 00:28:14,530
所以 要三思而后行

383
00:28:14,600 --> 00:28:19,630
选择合适的写法来解题

384
00:28:19,920 --> 00:28:22,380
总的来说 交流的艺术就是

385
00:28:22,420 --> 00:28:24,810
好的表达能使人理解

386
00:28:24,880 --> 00:28:27,520
而糟糕的表达

387
00:28:27,840 --> 00:28:30,430
没人会管你做了些什么

388
00:28:30,490 --> 00:28:32,790
因为他们都不知道你在说啥

389
00:28:34,000 --> 00:28:36,970
好吧 举个例子

390
00:28:44,100 --> 00:28:48,180
这里有幅图

391
00:29:00,190 --> 00:29:03,290
我觉得会有人问我

392
00:29:03,360 --> 00:29:06,960
这是不是通过有机化学得到的灵感？

393
00:29:07,210 --> 00:29:11,570
但它不是 我只是普通的写写而已

394
00:29:11,610 --> 00:29:15,240
好的 这有个图 我们给边加一些权值

395
00:29:31,020 --> 00:29:33,050
好的 这些是边的权值

396
00:29:33,130 --> 00:29:37,290
现在 我们要做的是找到一棵树

397
00:29:37,610 --> 00:29:40,460
一个连通的无环图

398
00:29:42,660 --> 00:29:45,980
而且每一个顶点都是树的一部分

399
00:29:46,500 --> 00:29:49,960
但这棵树的总权值必须是可能的最小值

400
00:29:53,030 --> 00:29:55,190
谁能告诉我

401
00:29:55,260 --> 00:30:00,560
哪些是属于这棵最小生成树的边？

402
00:30:02,240 --> 00:30:04,250
好的 ⑨ 没错

403
00:30:04,320 --> 00:30:07,510
⑨肯定在里面 为什么

404
00:30:07,620 --> 00:30:11,010
因为这是唯一连着这个顶点的边 对伐？

405
00:30:11,080 --> 00:30:13,200
同样地 15肯定也是

406
00:30:13,270 --> 00:30:14,240
这两个都是

407
00:30:14,340 --> 00:30:17,100
还有那些边肯定是的？

408
00:30:21,590 --> 00:30:25,010
哪条？14肯定是

409
00:30:25,080 --> 00:30:27,380
为什么14肯定是？

410
00:30:27,450 --> 00:30:31,590
[学生]：……

411
00:30:31,660 --> 00:30:35,080
[教授]：嗯 14和3之中肯定有一个在里面

412
00:30:42,560 --> 00:30:44,620
我要的是最小的总权值

413
00:30:44,690 --> 00:30:48,260
它必须有全局最小的权值

414
00:30:52,630 --> 00:30:56,210
谁能反驳说3一定会在里面？

415
00:31:02,020 --> 00:31:02,820
你说？

416
00:31:02,900 --> 00:31:06,390
[学生]：……

417
00:31:06,430 --> 00:31:09,530
[教授]：这是两者的最小值 也就是说如果我

418
00:31:09,550 --> 00:31:12,560
如果你给最小生成树里添加的边里

419
00:31:12,630 --> 00:31:16,750
它不包括3 好吧

420
00:31:16,820 --> 00:31:19,570
那就一定有14

421
00:31:20,480 --> 00:31:23,210
我大可以删掉这一条边14

422
00:31:23,280 --> 00:31:25,100
换成边3

423
00:31:25,170 --> 00:31:29,600
那我就能有更小的总权值了 对伐？

424
00:31:29,670 --> 00:31:32,120
所以 3肯定在里面

425
00:31:34,110 --> 00:31:36,320
还有什么变肯定在里面？

426
00:31:36,470 --> 00:31:40,050
做一个逻辑小测试

427
00:31:41,900 --> 00:31:44,210
6和5肯定在里面？

428
00:31:44,250 --> 00:31:46,620
为什么它们肯定在里面？

429
00:31:46,620 --> 00:31:59,930
[学生]:……

430
00:31:59,990 --> 00:32:02,840
[教授]：对对对 我是说 它可以...

431
00:32:02,910 --> 00:32:06,100
像这样子连 或怎样

432
00:32:06,730 --> 00:32:09,000
它不是一定要这样走

433
00:32:09,150 --> 00:32:10,900
6肯定在里面

434
00:32:10,970 --> 00:32:13,120
跟3在里面的理由一样 对伐？

435
00:32:13,480 --> 00:32:17,120
因为跟这家伙相连有两种选择

436
00:32:17,190 --> 00:32:21,400
所以 如果连的是12这条边

437
00:32:21,470 --> 00:32:22,540
我是说 12在里面

438
00:32:22,610 --> 00:32:24,110
我总是可以反驳

439
00:32:24,170 --> 00:32:26,770
我们还是这样连吧

440
00:32:27,170 --> 00:32:29,540
所以 6肯定在里面

441
00:32:33,110 --> 00:32:35,570
但现在还没全部连完呢

442
00:32:47,990 --> 00:32:51,680
还有哪些边一定会在最小生成树里的？

443
00:32:56,230 --> 00:33:00,580
7 4 还8 为什么是它们？

444
00:33:01,340 --> 00:33:07,230
[学生]:……

445
00:33:07,300 --> 00:33:10,320
[教授]：好的 我们可以一个个讨论吗？

446
00:33:12,370 --> 00:33:15,440
为什么是5？

447
00:33:28,020 --> 00:33:35,490
[学生]:……

448
00:33:35,560 --> 00:33:37,470
[教授]：好的 我们有4个连通的顶点了

449
00:33:37,540 --> 00:33:40,470
因为我们有这条边 这条边

450
00:33:40,540 --> 00:33:42,870
实际上我们还有 对了 这条边

451
00:33:42,940 --> 00:33:44,170
和这条边 不错啊

452
00:33:44,240 --> 00:33:46,940
[学生]:……

453
00:33:47,000 --> 00:33:48,660
[教授]：我们至少要3条边来把他们连起来

454
00:33:48,740 --> 00:33:53,190
因为每条边都会减少一个要连接的顶点

455
00:33:53,300 --> 00:33:56,110
所以我们还要三条边

456
00:33:56,180 --> 00:34:00,080
而那三条都是最便宜的

457
00:34:00,190 --> 00:34:01,690
而且还可行

458
00:34:02,660 --> 00:34:04,350
它们可行 对吧？

459
00:34:04,420 --> 00:34:08,480
其他边都会比较大 所以它们可行 好的

460
00:34:11,020 --> 00:34:13,830
那么 现在我们有生成树了吗？

461
00:34:13,890 --> 00:34:19,900
一切就绪 我们有了一个大连通图 对伐？

462
00:34:20,870 --> 00:34:22,260
我的也是这样吗？

463
00:34:22,330 --> 00:34:25,330
嘿~~我的也是这样

464
00:34:30,960 --> 00:34:32,990
我可以做成魔术表演了

465
00:34:38,500 --> 00:34:44,350
好的 大家都有最小生成树的概念了吗？

466
00:34:44,410 --> 00:34:47,430
从这幅图里 我们看出什么？

467
00:34:47,640 --> 00:34:53,130
我们先来对这问题做一些观察

468
00:34:53,200 --> 00:34:55,340
我要提醒你们一下

469
00:34:55,420 --> 00:34:58,500
关于最优子结构的性质

470
00:35:02,470 --> 00:35:04,410
因为实际上 最小生成树

471
00:35:04,480 --> 00:35:07,480
它有最优子结构

472
00:35:10,510 --> 00:35:13,580
好的 这个前提是

473
00:35:13,620 --> 00:35:15,710
我们有一个最小生成树

474
00:35:15,750 --> 00:35:17,420
我们称它为T

475
00:35:18,380 --> 00:35:22,500
而图里的其他的边

476
00:35:25,710 --> 00:35:28,140
我们忽略不画

477
00:35:30,410 --> 00:35:37,330
好的 这有一幅图

478
00:35:52,710 --> 00:35:55,040
好的 这是我们的图

479
00:35:56,730 --> 00:35:59,420
跟我的小抄上的一模一样

480
00:35:59,490 --> 00:36:04,200
好的 这个思路是 有一棵最小生成树

481
00:36:04,880 --> 00:36:09,740
我们要观察它的最优子结构的特性

482
00:36:09,790 --> 00:36:10,670
我观察的方法是

483
00:36:10,730 --> 00:36:14,720
我移除某条边(u,v)

484
00:36:15,780 --> 00:36:20,800
任意地在最小生成树中移除一条边(u,v)

485
00:36:20,870 --> 00:36:24,460
我们把它成为u 它成为v

486
00:36:24,530 --> 00:36:27,340
那儿 我们移除这条边

487
00:36:28,730 --> 00:36:32,530
当我从树中移除一条边

488
00:36:32,630 --> 00:36:37,910
对树有什么影响？还剩下什么？

489
00:36:38,540 --> 00:36:42,080
剩下的变成两棵树了

490
00:36:42,110 --> 00:36:46,600
我剩下两棵树 现在要证明

491
00:36:46,670 --> 00:36:51,220
这基本上就是附录里写的一个特性

492
00:36:51,290 --> 00:36:54,090
这就是我要你们读的其中一个树的特性

493
00:36:54,160 --> 00:36:55,920
因为你们实际上可以证明它

494
00:36:55,990 --> 00:37:01,040
而不是看上去很显然是 你懂的

495
00:37:01,370 --> 00:37:02,910
好的 我们移除它

496
00:37:03,010 --> 00:37:17,420
然后 T被分成了两棵子树

497
00:37:19,400 --> 00:37:24,260
我们把它称为T_1 和 T_2

498
00:37:24,360 --> 00:37:29,890
这是一棵子树 这是另一棵

499
00:37:29,940 --> 00:37:31,830
我们把它分割开来了

500
00:37:31,940 --> 00:37:33,440
不管我选的是哪条边

501
00:37:33,510 --> 00:37:36,300
它都会被分割成两棵子树的

502
00:37:36,370 --> 00:37:39,060
即使那棵子树很小

503
00:37:39,130 --> 00:37:42,290
举个例子 它可能只有一个顶点而且没有边

504
00:37:56,120 --> 00:37:58,430
我们要证明的定理

505
00:37:58,700 --> 00:38:05,060
它阐述了最优子结构的特性

506
00:38:11,610 --> 00:38:24,890
T_1是图G_1的最小生成树

507
00:38:29,360 --> 00:38:49,170
（G_1是）一个由T_1的顶点所导出的图G的子图

508
00:38:50,500 --> 00:38:55,900
也就是说 V_1是集T_1中的顶点

509
00:38:57,130 --> 00:39:00,230
这就是导出的意思

510
00:39:00,910 --> 00:39:06,300
V_1是T_1的顶点

511
00:39:06,420 --> 00:39:10,300
但在这图里 我没有这样标记

512
00:39:10,410 --> 00:39:14,740
这是T_1 这是T_2 在这幅图里

513
00:39:16,090 --> 00:39:17,960
这些是T_1的顶点

514
00:39:18,030 --> 00:39:21,350
这是V_1 好吧？

515
00:39:22,710 --> 00:39:31,960
E_1是顶点对的集 而x和y则是

516
00:39:32,350 --> 00:39:35,920
E_1里面的边

517
00:39:35,980 --> 00:39:41,830
这样一来 x和y都属于V_1

518
00:39:45,260 --> 00:39:48,430
我还没把G的所有边都画出来

519
00:39:48,530 --> 00:39:51,890
但基本上 如果边是从这到这

520
00:39:51,960 --> 00:39:54,110
它都是属于E_1的

521
00:39:54,170 --> 00:39:56,800
如果是从这到这 就不是了

522
00:39:56,870 --> 00:39:59,560
如是从这到这 也不是了

523
00:40:00,930 --> 00:40:03,780
那么这些顶点 这个图...

524
00:40:03,850 --> 00:40:06,290
这个由T_1的顶点导出的子图

525
00:40:06,360 --> 00:40:12,020
它把T_1里的顶点都连了起来

526
00:40:13,550 --> 00:40:15,680
同理 T_2也一样

527
00:40:25,680 --> 00:40:27,680
那么 这个定理说

528
00:40:27,740 --> 00:40:37,400
如果我只观察图G_1里面的边

529
00:40:37,550 --> 00:40:39,730
它们是由这些顶点导出的

530
00:40:39,800 --> 00:40:45,150
实际上 T_1是这个子图的最小生成树

531
00:40:46,230 --> 00:40:48,030
这个定理就是这样子的

532
00:40:50,610 --> 00:40:56,000
好的 相反地 或者说相应地 如果我观察这一边

533
00:40:58,330 --> 00:41:01,730
如果我观察这一些由这些顶点

534
00:41:01,760 --> 00:41:05,640
由T_2中的顶点所导出的边

535
00:41:05,710 --> 00:41:09,720
实际上 T_2是这边这个子图的最小生成树

536
00:41:12,820 --> 00:41:16,010
我们甚至可以试一下

537
00:41:16,460 --> 00:41:20,150
让我们看一看 例如这些

538
00:41:21,790 --> 00:41:25,710
如果我们试着把这个边5砍掉

539
00:41:25,780 --> 00:41:30,890
比方说我们砍掉了5这条边的话

540
00:41:30,960 --> 00:41:36,180
那T_1就由这四个顶点组成

541
00:41:36,400 --> 00:41:37,240
然而 重点是

542
00:41:37,290 --> 00:41:41,900
如果我观察由这些边所导出的子图

543
00:41:41,940 --> 00:41:45,770
实际山 这个6、8和3的边

544
00:41:45,840 --> 00:41:51,150
它们全都是这个子图的最小生成树的边

545
00:41:52,140 --> 00:41:54,700
那么 这就是这个定理所说的

546
00:41:54,770 --> 00:41:56,270
我们来证明一下

547
00:42:06,780 --> 00:42:10,360
好的 我们要用什么方法来证明？

548
00:42:16,250 --> 00:42:18,650
我们之前学到过这个技巧

549
00:42:19,220 --> 00:42:21,290
爱心小提示

550
00:42:28,780 --> 00:42:31,850
你们平时做文本编辑是经常会用到的

551
00:42:32,380 --> 00:42:36,220
剪贴法 很好

552
00:42:38,390 --> 00:42:42,840
好的 T的权值我可以表示为

553
00:42:42,910 --> 00:42:46,120
我移除的边的权值

554
00:42:46,190 --> 00:42:51,990
加上T_1的权值 加上T_2的权值

555
00:42:58,590 --> 00:43:00,520
那么 这就是总权值

556
00:43:01,390 --> 00:43:03,480
那么 这个论证很简单

557
00:43:03,550 --> 00:43:07,790
假设存在某个T_1'

558
00:43:07,830 --> 00:43:22,000
它比T_1更适合图G_1

559
00:43:22,070 --> 00:43:26,530
假设我有一些更好的生成树

560
00:43:33,180 --> 00:43:37,620
那我就能得到一棵T'

561
00:43:37,680 --> 00:43:45,980
它包含了边(u,v)

562
00:43:46,050 --> 00:43:52,820
并上T_1' 在并上T_2

563
00:43:53,390 --> 00:43:57,420
所以 我会取 如果我有一棵更好的生成树

564
00:43:59,940 --> 00:44:05,870
它比T_1有更低的权值

565
00:44:06,190 --> 00:44:07,980
我把它成为T_1'

566
00:44:08,050 --> 00:44:11,490
我只要把它替换掉 然后重建一棵新的生成树

567
00:44:11,530 --> 00:44:14,680
并上这一条边(u,v)

568
00:44:14,730 --> 00:44:19,550
对T_1’有效的话 那对T也一样有效

569
00:44:19,620 --> 00:44:25,680
那我们就会有一棵新的生成树

570
00:44:25,740 --> 00:44:39,240
而它则会比T更适合图G

571
00:44:41,100 --> 00:44:45,490
因为这些权值就像这些一样

572
00:44:45,570 --> 00:44:47,990
只是现在 我把它替换成T_1'的权值

573
00:44:48,020 --> 00:44:51,310
而且它更小

574
00:44:53,110 --> 00:44:58,230
这样一来 我们的假设

575
00:44:58,300 --> 00:45:00,840
T是最小生成树这个命题就矛盾了

576
00:45:00,920 --> 00:45:03,770
如果我能找到一个更好的子树的话

577
00:45:08,410 --> 00:45:15,170
所以 我们得到了这个最优子结构的特性

578
00:45:15,210 --> 00:45:20,870
我们的子问题会是最优化的

579
00:45:20,940 --> 00:45:24,060
如果对于整个问题来说

580
00:45:24,130 --> 00:45:26,320
我们有全局最优解的话

581
00:45:26,390 --> 00:45:29,970
那我们就能找到子问题的最优解

582
00:45:30,340 --> 00:45:33,680
那么 现在的问题是 这是一个标志

583
00:45:33,750 --> 00:45:35,920
动态规划的标志

584
00:45:35,990 --> 00:45:38,270
那重叠子问题呢？

585
00:45:38,340 --> 00:45:40,810
会不会有这个特性？

586
00:45:51,570 --> 00:45:54,380
对于这类问题 我们会不会有

587
00:45:54,860 --> 00:45:57,000
重叠子问题的特性？

588
00:46:16,550 --> 00:46:22,080
试想一下 例如 我移除了几条不同的边

589
00:46:22,790 --> 00:46:25,830
我先观察一下 选出一条边 把它移走

590
00:46:25,890 --> 00:46:27,510
然后树就分成两半

591
00:46:27,580 --> 00:46:30,190
而现在 我选择了另一条边 移除它 等等

592
00:46:30,220 --> 00:46:32,890
我这样做的话 会不会到最后

593
00:46:32,940 --> 00:46:34,510
我会有一堆相似的子问题？

594
00:46:34,580 --> 00:46:36,790
肯定会

595
00:46:36,950 --> 00:46:39,950
如果我取出的是这一条 我把它移走

596
00:46:40,020 --> 00:46:45,080
这一条的话 我就会得到这一棵和这一棵子树

597
00:46:45,160 --> 00:46:48,500
然而 结果会是一样的

598
00:46:48,530 --> 00:46:52,160
如果我先取出的是这条 然后再取出这条

599
00:46:52,330 --> 00:46:55,910
如果我只是简单地改改取出的顺序

600
00:46:55,980 --> 00:46:59,440
那么我会得到一大堆重叠的子问题

601
00:46:59,560 --> 00:47:06,710
好的 这说明我们要怎么做？

602
00:47:09,230 --> 00:47:11,820
动态规划 很好

603
00:47:11,970 --> 00:47:14,360
太阳从西边掉下来了

604
00:47:18,340 --> 00:47:22,300
没错 但是..

605
00:47:25,420 --> 00:47:27,880
你当然可以用动态规划

606
00:47:27,950 --> 00:47:31,150
但隐藏剧情是 这个最小生成树

607
00:47:31,230 --> 00:47:39,530
它还有一个更强大的特性

608
00:47:48,780 --> 00:47:52,930
我们虽然已经集齐了所有动态规划的条件

609
00:47:53,000 --> 00:47:55,200
但实际上 这还有一个更强大的隐藏条件

610
00:47:55,270 --> 00:48:00,610
可以触发隐藏剧情 开启这个更为强大的技术

611
00:48:04,960 --> 00:48:12,710
这就是 贪心算法的标志

612
00:48:30,770 --> 00:48:40,040
我们获得了一个贪心选择的属性

613
00:48:42,830 --> 00:48:56,550
它指的是 一个局部最优解也是全局最优解

614
00:49:01,610 --> 00:49:04,870
当然 就像所有标志一样

615
00:49:04,940 --> 00:49:08,290
我们都想把它框起来

616
00:49:08,360 --> 00:49:10,360
因为这是你可以应用某算法的证据

617
00:49:10,460 --> 00:49:12,690
那么 我们得到了这个属性

618
00:49:12,760 --> 00:49:15,570
我们称之为贪心选择属性

619
00:49:15,650 --> 00:49:17,970
我会告诉你们它的原理

620
00:49:18,080 --> 00:49:19,720
当你有了贪心选择的属性时

621
00:49:19,790 --> 00:49:24,430
实际上你做的会比动态规划还要好

622
00:49:26,800 --> 00:49:30,970
当你看到这两个动态规划的条件时

623
00:49:32,010 --> 00:49:35,820
这首先说明你可以动态规划

624
00:49:35,890 --> 00:49:37,250
但它同时也说

625
00:49:37,280 --> 00:49:40,510
我们不如试下能不能用贪心属性？

626
00:49:40,580 --> 00:49:42,330
如果能 那你就得到了

627
00:49:42,400 --> 00:49:46,360
比用动态规划更好地方法了

628
00:49:47,670 --> 00:49:49,020
所以如果有这两个条件

629
00:49:49,090 --> 00:49:51,050
通常你都会用动态规划

630
00:49:51,120 --> 00:49:53,560
但如果你有这第三个属性

631
00:49:53,630 --> 00:49:56,280
你就要喊：哥要超神了！

632
00:49:58,560 --> 00:50:04,800
这个是阐述了这一思想的定理

633
00:50:04,880 --> 00:50:06,820
再有 这并不是

634
00:50:06,890 --> 00:50:10,300
这些标志并不是什么启发式

635
00:50:10,860 --> 00:50:13,120
我不会给你一个算法 然后说

636
00:50:13,190 --> 00:50:14,840
这个能用动态规划

637
00:50:14,910 --> 00:50:17,140
这个能用贪心算法

638
00:50:17,330 --> 00:50:19,710
我只是告诉你 它们的结构会是这样子

639
00:50:19,780 --> 00:50:21,700
如果它们能用得上的话

640
00:50:23,210 --> 00:50:25,030
好的 接下来是定理

641
00:50:25,100 --> 00:50:33,180
设T为我们的图的MST

642
00:50:36,550 --> 00:50:42,440
令A是V的任意子集

643
00:50:43,250 --> 00:50:45,240
也就是 顶点的子集

644
00:50:47,120 --> 00:51:01,900
现在 我们假设边(u,v)是 连接着A到A的补集

645
00:51:08,390 --> 00:51:20,100
也就是V-A的 有着最小权值的边

646
00:51:25,090 --> 00:51:34,260
那么这个定理就说 边(u,v)属于最小生成树

647
00:51:36,870 --> 00:51:39,970
我们先观察一下我们的图

648
00:51:40,040 --> 00:51:42,420
然后看看 实际上 这种情况下

649
00:51:43,230 --> 00:51:45,340
我们取...

650
00:51:45,740 --> 00:51:49,810
我们可以对A做的一件事是 取一个单元素点

651
00:51:50,940 --> 00:51:52,430
那我选一个单元素点

652
00:51:52,500 --> 00:51:55,930
假设是它 它是我们的A

653
00:51:56,000 --> 00:51:58,240
然后其他所有顶点都属于V-A

654
00:51:58,340 --> 00:52:01,070
我观察最小权值边

655
00:52:01,130 --> 00:52:03,530
连接这一点和其他所有点的边

656
00:52:03,640 --> 00:52:06,880
好吧 这有两条边连接它和其他的点

657
00:52:06,960 --> 00:52:07,800
这个定理是说

658
00:52:07,870 --> 00:52:10,970
这个小一点的边 它属于最小生成树

659
00:52:11,830 --> 00:52:13,270
好吧 我赢了

660
00:52:13,340 --> 00:52:16,320
如果你观察一下 我选哪个顶点都好

661
00:52:16,360 --> 00:52:19,100
从这个顶点出来的最小的那条边

662
00:52:19,170 --> 00:52:21,540
就属于最小生成树

663
00:52:23,770 --> 00:52:28,200
对 就是外连的权值最小的边

664
00:52:28,270 --> 00:52:30,830
但这并不是这里所有的边

665
00:52:33,770 --> 00:52:36,400
我们可以试想一下

666
00:52:36,470 --> 00:52:39,220
我们观察这三个顶点

667
00:52:39,290 --> 00:52:44,160
它们和这一个顶点集相连

668
00:52:44,230 --> 00:52:45,850
我们有三条连接的边

669
00:52:45,910 --> 00:52:47,150
权值最小的是5

670
00:52:47,220 --> 00:52:49,160
它就属于最小生成树

671
00:52:50,400 --> 00:52:52,870
或者 我可以这样划分

672
00:52:53,140 --> 00:52:56,390
上面这一个

673
00:52:56,520 --> 00:52:58,870
从上面下来的边有 14、8和7

674
00:52:58,980 --> 00:53:02,110
7是最小的

675
00:53:02,220 --> 00:53:04,780
它属于最小生成树

676
00:53:07,010 --> 00:53:09,020
无论我选的是哪一个

677
00:53:09,090 --> 00:53:14,610
选这个 不选这个……

678
00:53:14,680 --> 00:53:16,660
再看看所有的边里面

679
00:53:16,730 --> 00:53:18,260
哪个的权值是最小的

680
00:53:18,330 --> 00:53:20,310
那个就在最小生成树里

681
00:53:23,400 --> 00:53:29,070
某种程度上 它是一个局部性质

682
00:53:29,320 --> 00:53:31,510
因为我不用管树的其他部分

683
00:53:31,610 --> 00:53:36,380
我只要看到一小部分顶点就好

684
00:53:36,450 --> 00:53:39,100
我说 好吧 如果我要把这个顶点集

685
00:53:39,180 --> 00:53:41,620
连接到外面的世界去 我选哪一条边好？

686
00:53:41,690 --> 00:53:46,410
我会选最便宜的那条边 这就是贪心的做法

687
00:53:46,440 --> 00:53:50,200
结果是 它做到了

688
00:53:50,260 --> 00:53:55,930
给子集A选择局部最优的边

689
00:53:56,240 --> 00:53:59,340
对全局也是最优的

690
00:53:59,810 --> 00:54:01,700
它是一种全局的优化

691
00:54:01,780 --> 00:54:04,670
这就是这个定理要说的

692
00:54:05,980 --> 00:54:07,140
那么 我们来证明它吧

693
00:54:07,210 --> 00:54:09,600
有没有问题？

694
00:54:12,000 --> 00:54:13,620
我们来证明它吧

695
00:54:21,670 --> 00:54:27,410
那么 边(u,v)是连接A到V-A的权值最小的边

696
00:54:27,520 --> 00:54:31,820
我们假设这条边(u,v)

697
00:54:31,890 --> 00:54:34,870
它不属于最小生成树里

698
00:54:38,690 --> 00:54:42,760
我们假设 有个最小生成树不知怎的

699
00:54:43,010 --> 00:54:50,770
没有把最小权值边包含进去

700
00:54:50,880 --> 00:54:52,590
那么 我们要用什么技巧

701
00:54:52,660 --> 00:54:55,790
来证明它是矛盾的？

702
00:54:56,820 --> 00:54:58,870
剪贴法 很好

703
00:54:58,970 --> 00:55:02,720
耶 我们要用剪贴法

704
00:55:04,580 --> 00:55:05,820
我们要来剪一剪 粘一粘

705
00:55:05,890 --> 00:55:12,360
这里 我举个例子 好的

706
00:55:25,860 --> 00:55:28,630
Vv_绝对♂冷冻气_vV

707
00:55:38,870 --> 00:55:41,330
好的 我要用到这种画法

708
00:55:41,410 --> 00:55:43,980
我要把一些点涂白

709
00:56:03,710 --> 00:56:08,900
好的 我这里的画法是 这是属于A的元素

710
00:56:08,970 --> 00:56:10,680
而涂成白色的那些

711
00:56:10,790 --> 00:56:13,330
则是V-A的元素

712
00:56:14,530 --> 00:56:17,110
如果没有上色 它就属于A

713
00:56:17,220 --> 00:56:18,680
这是我的最小生成树 再有

714
00:56:18,750 --> 00:56:21,700
我这里不会把所有的边都画出来

715
00:56:21,770 --> 00:56:24,820
但它们是存在的 好吧？

716
00:56:26,400 --> 00:56:33,530
那么边(u,v) 我们说过它不属于最小生成树

717
00:56:33,530 --> 00:56:35,110
假设就是这一条边

718
00:56:35,180 --> 00:56:40,410
它是从u  u在A里面  到v  v在V-A里面

719
00:56:45,060 --> 00:56:47,420
大家都看到这设定了吧？

720
00:56:47,460 --> 00:56:50,460
那么 我要证明

721
00:56:50,570 --> 00:56:53,230
这条边本应是在最小生成树里的

722
00:56:53,270 --> 00:56:55,710
论点就是 这是最小生成树

723
00:56:55,820 --> 00:56:59,330
它没包含(u,v)是错的

724
00:57:00,330 --> 00:57:02,560
我要做的是

725
00:57:02,630 --> 00:57:05,360
我这儿有一棵树T

726
00:57:05,430 --> 00:57:08,600
然后我有两个顶点 u跟v 在这棵树里

727
00:57:08,670 --> 00:57:12,430
两个顶点之间有一条唯一的 简单的路径

728
00:57:12,500 --> 00:57:14,010
简单的路径是指它不会往回走

729
00:57:14,080 --> 00:57:17,180
或者不断地重复某条边或顶点

730
00:57:17,250 --> 00:57:20,120
好的 它是u跟v之间唯一的 简单的路径

731
00:57:20,190 --> 00:57:22,380
我们考虑这条路径

732
00:57:40,860 --> 00:57:44,280
我之所以知道这条路径存在是因为

733
00:57:44,350 --> 00:57:51,300
我看过书里的附录B的B.5.1节

734
00:57:51,380 --> 00:57:55,630
它介绍了一些很不错的树的性质

735
00:57:56,150 --> 00:58:01,180
所以我知道这存在一条唯一的 简单路径

736
00:58:01,790 --> 00:58:07,830
我们现在要做的是观察这一条路径

737
00:58:07,860 --> 00:58:11,820
在这种情况了 它从这里 到这里x3

738
00:58:11,890 --> 00:58:15,750
在这条路径上 肯定存在一点

739
00:58:15,820 --> 00:58:24,130
使得我能连接A的顶点到V-A的顶点

740
00:58:24,600 --> 00:58:30,240
为什么？ 因为这是在A里面 这是在V-A里面

741
00:58:30,310 --> 00:58:35,330
所以 这条路径的某处 肯定有过渡点

742
00:58:35,570 --> 00:58:39,290
这条路不都是在A之中的

743
00:58:39,370 --> 00:58:41,430
因为 v就不是

744
00:58:41,500 --> 00:58:49,430
我们要做的是 把边(u,v)

745
00:58:49,500 --> 00:58:57,100
跟这条路径中的第一条

746
00:59:00,710 --> 00:59:16,370
连接A和V-A的边交换

747
00:59:16,440 --> 00:59:19,200
在这里 也就是指这一条边

748
00:59:19,310 --> 00:59:20,860
我从A到V-A要经过它

749
00:59:20,930 --> 00:59:23,590
一般来说 可能会存在很多条过渡边

750
00:59:23,660 --> 00:59:27,270
但我只是选择我碰到的第一条

751
00:59:27,370 --> 00:59:32,210
也就是这一条 我要做的就是拿这条替换它

752
00:59:39,700 --> 00:59:41,530
然后会发生什么？

753
00:59:41,560 --> 00:59:47,310
好吧 边(u,v)是连接A跟V-A的

754
00:59:47,330 --> 00:59:49,590
权值最小的边

755
00:59:49,660 --> 00:59:50,810
这意味着 在这种情况下

756
00:59:50,880 --> 00:59:55,540
它比这条边的权值要小

757
00:59:55,910 --> 00:59:57,880
这样一交换

758
00:59:57,950 --> 01:00:03,090
我们就得到一棵有更小总权值的树

759
01:00:03,170 --> 01:00:04,410
这跟我们的假设矛盾了

760
01:00:04,480 --> 01:00:07,150
这才是真正的最小生成树

761
01:00:07,250 --> 01:00:25,950
所以 一个比T的权值更小的生成树

762
01:00:26,580 --> 01:00:29,710
矛盾了

763
01:00:38,540 --> 01:00:40,160
怎么样？大家跟得上吗？

764
01:00:42,900 --> 01:00:49,160
现在我们要实现这个算法了 来吧

765
01:00:49,230 --> 01:00:54,960
我们要用一种叫Prim的算法来实现它

766
01:00:56,990 --> 01:01:03,860
Prim现在在AT&T里混得风生水起

767
01:01:03,930 --> 01:01:09,460
正因为他发明了这个算法来实现最小生成树

768
01:01:11,160 --> 01:01:20,920
AT&T所有的计帐代码都用了它好多年

769
01:01:20,990 --> 01:01:23,420
他在贝尔实验室里位高权重

770
01:01:23,660 --> 01:01:26,630
而且那时还是在贝尔实验室的全盛时期

771
01:01:26,710 --> 01:01:29,590
这个故事告诉我们 只要发明一个算法

772
01:01:29,660 --> 01:01:33,570
你也能成为垄断巨头里的人参赢家

773
01:01:34,280 --> 01:01:37,830
当然 政府迟早会反垄断

774
01:01:37,900 --> 01:01:43,580
但无论如何 它都是你一生的主线任务

775
01:01:43,950 --> 01:01:46,230
骚年去创造算法吧！

776
01:01:46,580 --> 01:01:49,700
下面是它的思路

777
01:01:49,810 --> 01:01:53,510
我们要做的是

778
01:01:55,750 --> 01:02:01,020
把V-A维护成一个优先队列

779
01:02:05,960 --> 01:02:08,110
我们称它为Q

780
01:02:08,490 --> 01:02:18,890
Q里的每一个顶点 我们都赋一个键值给它

781
01:02:19,930 --> 01:02:28,700
那就是连接V-A和A之间的

782
01:02:33,310 --> 01:02:46,040
权值最小的边的权值

783
01:02:48,650 --> 01:02:51,630
下面是伪代码

784
01:02:51,740 --> 01:02:58,260
一开始 Q包含了所有的顶点

785
01:02:59,170 --> 01:03:05,100
我们一开始把A设成是空集 根据个人喜好

786
01:03:05,760 --> 01:03:09,820
因为我们要求的是权值最小的边

787
01:03:09,860 --> 01:03:15,680
因此 优先队列里的所有权值

788
01:03:15,750 --> 01:03:19,620
一开始都会设成正无穷

789
01:03:20,490 --> 01:03:22,970
因为A和V-A之间没有边相连

790
01:03:23,040 --> 01:03:27,360
到空集的权值最小边为空

791
01:03:27,470 --> 01:03:30,700
接着 我们从一个顶点开始

792
01:03:30,810 --> 01:03:33,300
我们称它为S

793
01:03:34,040 --> 01:03:42,860
我们会从V中任意选一点S 设为0

794
01:03:42,970 --> 01:03:47,380
然后就是算法的主体

795
01:03:47,910 --> 01:03:50,420
这是我们的初始化步骤

796
01:03:53,450 --> 01:03:55,360
好的 在做分析时

797
01:03:55,430 --> 01:03:57,980
我会写些东西在左手边的黑板上

798
01:03:58,050 --> 01:04:01,030
如果你要记笔记的话 你可能也要

799
01:04:01,100 --> 01:04:04,590
在你笔记本的左边预留一点点的空间

800
01:04:07,360 --> 01:04:12,480
所以当Q不为空集时

801
01:04:18,270 --> 01:04:30,450
我们从中取出最小的元素

802
01:04:39,130 --> 01:04:42,170
然后再进行其它操作

803
01:05:17,630 --> 01:05:19,950
就是这样

804
01:05:20,150 --> 01:05:23,210
这是我唯一要说的一点

805
01:05:23,280 --> 01:05:24,930
让我们看一下 这里具体是怎样的

806
01:05:25,000 --> 01:05:28,210
之后我们会用一个例子来演示

807
01:05:28,870 --> 01:05:32,290
我们要做的 是每次都从队列里

808
01:05:32,330 --> 01:05:34,430
取出最小元素

809
01:05:34,500 --> 01:05:37,220
然后对于每一步 在邻接表里 换句话说

810
01:05:37,300 --> 01:05:43,070
对于所有从v到u的边

811
01:05:43,140 --> 01:05:52,150
如果v仍属于集合V-A的话 我就进行查看

812
01:05:52,220 --> 01:05:55,880
所以 取出来的元素就成为了A的一部分

813
01:05:55,990 --> 01:05:57,590
每次取出元素时

814
01:05:57,660 --> 01:06:00,110
都会构成一个新的A

815
01:06:00,180 --> 01:06:01,500
在每一步 我们都想找出

816
01:06:01,580 --> 01:06:05,870
哪一条是连接A到其它点的最便宜的边？

817
01:06:05,940 --> 01:06:10,860
基本上 我们就是取所有最小权值的边

818
01:06:10,930 --> 01:06:12,810
把边加入这里

819
01:06:12,880 --> 01:06:16,900
把它放入A 然后再找下一个权值最小的边

820
01:06:17,170 --> 01:06:19,780
持续重复这个过程

821
01:06:19,840 --> 01:06:21,940
举一个例子来说明

822
01:06:22,050 --> 01:06:25,950
我们要做的就是 每次加入一条边时

823
01:06:26,010 --> 01:06:33,890
我都追踪哪一个是相关的顶点

824
01:06:33,960 --> 01:06:37,440
我要声明的是 在最后

825
01:06:38,510 --> 01:06:42,960
当我观察这个顶点对的集合时

826
01:06:43,030 --> 01:06:53,290
V还有π[V]就组成了最小生成树

827
01:06:55,510 --> 01:06:57,890
我们来演示一下

828
01:07:00,880 --> 01:07:04,580
这是什么？我们已经画过一次了

829
01:07:04,660 --> 01:07:11,690
那就擦掉这些点

830
01:07:11,830 --> 01:07:15,860
因为我们要在这张草图上重新进行计算

831
01:07:19,750 --> 01:07:24,980
你们可能要重新画个新的图

832
01:07:25,050 --> 01:07:28,090
在你的笔记上再画一个新的

833
01:07:28,160 --> 01:07:29,410
我其实也打算这么做 但结果表明

834
01:07:29,480 --> 01:07:33,560
擦掉这些点之后 这正是我要的板图

835
01:07:33,630 --> 01:07:35,710
好了 我们再来修改它

836
01:07:35,780 --> 01:07:40,520
一开始让所有顶点都是无限的

837
01:07:46,260 --> 01:07:51,820
这是我记录键值的地方

838
01:07:52,160 --> 01:08:03,690
接下来 我们要做的是找一个顶点

839
01:08:03,760 --> 01:08:05,390
把它称之为S

840
01:08:05,460 --> 01:08:07,530
我们取这个顶点

841
01:08:07,600 --> 01:08:08,700
称之为S

842
01:08:08,780 --> 01:08:11,490
然后 把它变为O

843
01:08:16,360 --> 01:08:20,270
现在要做的是 执行取出最小值

844
01:08:20,850 --> 01:08:25,740
那基本上 我会给它加个阴影 像这样

845
01:08:25,850 --> 01:08:32,730
表示它现在加入了集合A

846
01:08:33,150 --> 01:08:37,150
所以 这个表示集合A

847
01:08:38,810 --> 01:08:42,340
这是集合V-A里的元素

848
01:08:47,000 --> 01:08:52,110
接下来 我们要观察一下

849
01:08:53,470 --> 01:08:59,450
取出这个点 然后对于它邻接表里的每条边

850
01:08:59,510 --> 01:09:01,760
对于它邻接表里的每个顶点

851
01:09:01,830 --> 01:09:05,130
也就是这些顶点

852
01:09:05,210 --> 01:09:07,860
我们看看它是否仍在队列Q里

853
01:09:07,930 --> 01:09:09,930
即集合V-A

854
01:09:11,100 --> 01:09:13,600
如果还在 那我们就要

855
01:09:14,220 --> 01:09:19,320
而且如果它的键值还要小于这条边的权值

856
01:09:19,390 --> 01:09:21,670
那我们就用边值取代其键值

857
01:09:21,770 --> 01:09:24,480
所以在这个例子里 我们就用7来替换它

858
01:09:24,560 --> 01:09:26,850
用15来替换它

859
01:09:27,400 --> 01:09:29,880
还有用10替换它

860
01:09:32,490 --> 01:09:36,150
因为我们感兴趣的是最小的权值

861
01:09:36,230 --> 01:09:40,590
现在 注意到所有V-A里的元素

862
01:09:40,730 --> 01:09:43,770
也就是优先队列里面所有顶点

863
01:09:43,800 --> 01:09:49,470
现在 它们都有一条最便宜的路径

864
01:09:49,500 --> 01:09:51,220
跟被我们移除的点相连

865
01:09:51,260 --> 01:09:53,180
也就是A里面的点

866
01:09:54,100 --> 01:09:59,650
那现在我要做一步更新操作

867
01:10:01,630 --> 01:10:05,270
实际上 这个优先队列里有一个隐含的操作

868
01:10:05,400 --> 01:10:08,470
那就是降低键值的操作

869
01:10:08,540 --> 01:10:14,170
这隐含了一个降低键值操作

870
01:10:14,310 --> 01:10:17,500
降低键值是一个优先队列的操作

871
01:10:17,570 --> 01:10:22,510
它会减小优先队列里的键值

872
01:10:23,940 --> 01:10:25,560
所以 这也隐式地影响到了

873
01:10:25,630 --> 01:10:27,910
我会要选用什么数据结构

874
01:10:27,970 --> 01:10:30,420
来实现这个优先队列

875
01:10:30,600 --> 01:10:33,870
那一般实现优先队列的数据结构是

876
01:10:35,280 --> 01:10:37,540
堆  一个最小堆

877
01:10:37,610 --> 01:10:41,710
但我要确保有进行这个操作

878
01:10:41,770 --> 01:10:43,970
我不能为了不影响我的堆 而修改它

879
01:10:44,010 --> 01:10:47,660
所以 这里有一个隐含的操作

880
01:10:47,770 --> 01:10:49,500
现在重复一次

881
01:10:49,610 --> 01:10:51,810
找到权值最小的边

882
01:10:51,880 --> 01:10:54,220
同时我们还要

883
01:10:54,290 --> 01:10:58,830
设置一些指针 从这些顶点指回u

884
01:10:58,900 --> 01:11:03,390
所以这个顶点 要设一个指针指回去

885
01:11:04,030 --> 01:11:06,820
这个顶点设一个指针指回去

886
01:11:06,930 --> 01:11:08,440
还有这个顶点设一个指针指回去

887
01:11:08,520 --> 01:11:11,350
这是π函数要追踪的

888
01:11:11,420 --> 01:11:17,190
促使我把键值设为新键值的顶点

889
01:11:18,560 --> 01:11:21,960
现在回到队列里 找最便宜的点

890
01:11:23,520 --> 01:11:25,930
而且我们要做得快一点

891
01:11:26,350 --> 01:11:27,610
这是一个快速算法

892
01:11:27,680 --> 01:11:31,410
现在要再进行同样的步骤

893
01:11:31,510 --> 01:11:34,760
现在要取出的最便宜的是哪一个？

894
01:11:35,170 --> 01:11:40,050
这个顶点 是吧？将它取出来

895
01:11:41,220 --> 01:11:43,880
然后更新它的邻接顶点

896
01:11:43,950 --> 01:11:46,180
这个顶点变为5

897
01:11:46,830 --> 01:11:50,230
这个顶点是12

898
01:11:50,560 --> 01:11:52,960
这个顶点是9

899
01:11:53,250 --> 01:11:58,530
这个不用更新 不用更新它

900
01:11:58,600 --> 01:12:03,150
因为它不再是优先队列里的元素

901
01:12:03,220 --> 01:12:04,420
所有这些顶点

902
01:12:04,490 --> 01:12:09,600
设置指针指向它们应该指向的地方

903
01:12:09,670 --> 01:12:11,730
这一步就完成了

904
01:12:11,840 --> 01:12:13,170
现在继续找权值最小的

905
01:12:13,240 --> 01:12:15,770
现在哪个是最小的？

906
01:12:16,160 --> 01:12:20,490
这个5 很好 将它带走

907
01:12:20,860 --> 01:12:24,320
再更新它的邻居

908
01:12:24,470 --> 01:12:28,880
这里 没错 现在变为6

909
01:12:28,980 --> 01:12:32,220
还有一个指针

910
01:12:32,290 --> 01:12:35,000
这个顶点不更新 因为它不在队列里

911
01:12:35,070 --> 01:12:43,270
这个顶点变为14 还有这个变为8

912
01:12:43,660 --> 01:12:50,410
更新这个顶点 变为8

913
01:12:50,490 --> 01:12:53,780
我有木有做错喔？

914
01:12:54,420 --> 01:12:57,010
[学生]：……

915
01:12:57,080 --> 01:13:00,320
[教授]:对 因为π是这个顶点的一个函数

916
01:13:00,390 --> 01:13:03,930
所以基本上 这些就会消失了

917
01:13:03,940 --> 01:13:06,320
我是不是错过了一个点？

918
01:13:06,950 --> 01:13:11,390
12 对 很好 把它移走

919
01:13:11,550 --> 01:13:14,670
因为π只是一个函数

920
01:13:15,160 --> 01:13:20,760
现在完成了 现在要做什么？

921
01:13:20,900 --> 01:13:25,080
现在我的集合A 包括了这三项

922
01:13:25,150 --> 01:13:26,590
现在我要权值最小的边

923
01:13:26,660 --> 01:13:28,310
我知道它会在最小生成树里

924
01:13:28,380 --> 01:13:31,300
所以贪心地选择它

925
01:13:31,410 --> 01:13:33,630
现在哪个是最小的？

926
01:13:34,620 --> 01:13:39,190
这里这个？对 是6

927
01:13:39,260 --> 01:13:42,750
带它走 然后再更新这些顶点

928
01:13:42,910 --> 01:13:45,680
已经没有相关的顶点了

929
01:13:45,970 --> 01:13:49,360
没什么好改变的了 因为这些都已经在A里

930
01:13:49,540 --> 01:13:54,640
所以现在最便宜的是这里的8

931
01:13:54,710 --> 01:13:57,400
好的 把8取出来

932
01:13:57,470 --> 01:14:00,470
更新这个点 什么都不用做

933
01:14:00,540 --> 01:14:02,080
这个点：什么都不用做

934
01:14:02,150 --> 01:14:07,640
这个顶点 噢不 它要把14换成3

935
01:14:07,710 --> 01:14:12,280
去掉这个指针 让它指向这边

936
01:14:13,160 --> 01:14:15,860
现在3是最便宜的

937
01:14:16,050 --> 01:14:17,620
将它取出来

938
01:14:17,690 --> 01:14:20,170
当然 这边已经没有什么好更新的了

939
01:14:20,230 --> 01:14:24,920
现在 最后取走9 完成了

940
01:14:24,990 --> 01:14:29,710
还有15 完成了 这样算法就结束了

941
01:14:30,800 --> 01:14:35,160
现在正如看到的 所有我选择的边

942
01:14:35,260 --> 01:14:40,780
正是一开始的那些边

943
01:14:43,130 --> 01:14:45,490
这里做一下分析

944
01:14:56,550 --> 01:15:06,620
看这里 这一部分花费O(V) 是吧？

945
01:15:11,430 --> 01:15:13,600
还有这部分

946
01:15:13,670 --> 01:15:17,910
看看我们这里做了啥 我们这部分...

947
01:15:19,090 --> 01:15:24,040
嗯嗯 我们做了这个循环多少次

948
01:15:27,800 --> 01:15:29,300
V次

949
01:15:29,370 --> 01:15:30,900
有V个元素放进队列里

950
01:15:30,970 --> 01:15:33,820
没有进行任何插入 只是将它们取出来

951
01:15:33,930 --> 01:15:36,420
所以这是|V|次

952
01:15:37,420 --> 01:15:45,870
然后还有几个取出最小值操作

953
01:15:45,950 --> 01:15:48,630
所以 我们要O(V)次取出最小值

954
01:15:48,700 --> 01:15:51,100
然后到了邻接表

955
01:15:51,170 --> 01:15:52,440
有一些常值的操作

956
01:15:52,510 --> 01:15:57,360
但这里还有一些隐含的降低键值的操作

957
01:15:57,400 --> 01:15:59,850
也就是这里

958
01:16:01,310 --> 01:16:06,370
有多少隐含的降低键值操作？

959
01:16:06,600 --> 01:16:09,310
这将会是昂贵的开销

960
01:16:09,360 --> 01:16:16,410
在这个情况里 有u的度那么多

961
01:16:24,540 --> 01:16:35,790
所以 总共有多少隐含的降低键值的操作？

962
01:16:37,680 --> 01:16:40,090
我们总共有V的时间

963
01:16:40,160 --> 01:16:42,820
u的度可能有多大？

964
01:16:47,470 --> 01:16:51,840
它可能和V一样大 O(V)

965
01:16:51,880 --> 01:16:54,460
所以是V^2次降低操作

966
01:16:55,440 --> 01:16:57,740
但我们能找出一个更好的上限

967
01:16:57,770 --> 01:17:00,140
实际上有多少？

968
01:17:12,880 --> 01:17:15,720
没错 最多是O(E)

969
01:17:17,300 --> 01:17:19,290
因为我做了什么？

970
01:17:19,340 --> 01:17:22,840
我把所有顶点的度加起来

971
01:17:22,880 --> 01:17:25,770
那就是实际的执行次数

972
01:17:25,820 --> 01:17:33,000
所以是O(E)个隐含的降低键值

973
01:17:37,070 --> 01:17:44,310
所以总共的时间是O(V)乘以

974
01:17:44,360 --> 01:17:48,200
取出最小值所需的时间

975
01:17:49,600 --> 01:17:54,050
加上E乘以降低键值的时间

976
01:18:00,520 --> 01:18:02,580
现在 我们再看数据结构

977
01:18:02,640 --> 01:18:05,490
在不同的数据结构下做评估

978
01:18:05,560 --> 01:18:12,730
看看这条公式会变成怎样

979
01:18:12,790 --> 01:18:15,260
我们有不同的方式来实现这个数据结构

980
01:18:15,630 --> 01:18:18,860
我们有取出最小值的开销

981
01:18:21,140 --> 01:18:28,020
有降低键值的开销 还有总开销

982
01:18:30,050 --> 01:18:33,190
实现这个数据结构的最简单方法

983
01:18:33,250 --> 01:18:36,140
是一个无序数组

984
01:18:36,690 --> 01:18:38,370
对于一个无序数组

985
01:18:38,430 --> 01:18:42,840
我要花费多少时间来取出最小元素？

986
01:18:45,780 --> 01:18:48,200
如果是无序数组的话？

987
01:18:48,700 --> 01:18:53,500
是O(V) 因为它是一个大小为V的数组

988
01:18:53,550 --> 01:18:55,910
还有降低键值操作

989
01:19:00,220 --> 01:19:03,460
我可以在O(1)时间内完成

990
01:19:03,890 --> 01:19:13,690
所以总共是O(V^2) 很好

991
01:19:14,820 --> 01:19:16,690
O(V^2)的算法

992
01:19:17,410 --> 01:19:21,340
或者用人民喜闻乐见的二叉堆怎么样？

993
01:19:24,060 --> 01:19:28,490
从二叉堆里取最小值的开销是多少？

994
01:19:29,250 --> 01:19:36,660
O(log V)  那降低键值呢？

995
01:19:41,340 --> 01:19:43,500
没错 答案是可以在O(log V)里完成

996
01:19:43,570 --> 01:19:47,610
因为基本上只需要把修改的值向上渗透
【译注：教授此处应该口误把sift(渗透操作)说成shuffle(洗牌操作)了】

997
01:19:47,640 --> 01:19:51,280
实际上 是向根渗透操作
【译注：教授此处应该口误把sift(渗透操作)说成shuffle(洗牌操作)了】

998
01:19:51,390 --> 01:19:56,350
所以是O(log V) 那总开销是？

999
01:19:59,110 --> 01:20:01,260
O(E log V)

1000
01:20:03,240 --> 01:20:05,560
哪一个比较好？

1001
01:20:11,130 --> 01:20:12,670
看情况 有见地

1002
01:20:13,380 --> 01:20:15,840
那什么时候这个更好 什么时候另一个更好？

1003
01:20:17,030 --> 01:20:17,860
你说？

1004
01:20:17,920 --> 01:20:21,150
[学生]：……

1005
01:20:21,200 --> 01:20:23,130
[教授]:如果是一个稠密图

1006
01:20:23,160 --> 01:20:26,300
E近似等于V^2 用数组比较好

1007
01:20:26,360 --> 01:20:27,790
但如果是一个稀疏图

1008
01:20:27,940 --> 01:20:30,300
E远小于V^2

1009
01:20:30,400 --> 01:20:32,350
那么二叉堆会比较好

1010
01:20:33,100 --> 01:20:38,330
这催生了一种新的数据结构

1011
01:20:39,120 --> 01:20:41,810
称为菲波那契堆

1012
01:20:44,440 --> 01:20:48,300
菲波那契堆在书的第20章会有全面介绍

1013
01:20:48,420 --> 01:20:50,630
我们不要求掌握这部分内容

1014
01:20:50,740 --> 01:20:51,980
但它是一种很有意思的数据结构

1015
01:20:52,090 --> 01:20:54,410
因为它是一种平摊数据结构

1016
01:20:54,500 --> 01:20:56,220
事实证明 这种数据结构

1017
01:20:56,310 --> 01:21:04,550
你可以在O(log V)的平摊时间内取出最小值

1018
01:21:07,020 --> 01:21:12,530
更酷炫的是 你能在O(1)平摊时间内降低键值

1019
01:21:16,810 --> 01:21:20,080
那么把它们加起来会是多少？

1020
01:21:32,140 --> 01:21:35,910
将会是多少？在这里加起来

1021
01:21:36,000 --> 01:21:48,890
它将会是V乘以log V  加上E + V log V

1022
01:21:51,530 --> 01:21:53,820
这些是平摊的 那这是什么？

1023
01:21:58,190 --> 01:22:03,280
恶作剧之问 它其实是最坏情况

1024
01:22:03,390 --> 01:22:05,990
这里不是平摊的

1025
01:22:06,110 --> 01:22:10,160
这些是平摊的 这就是平摊性之美

1026
01:22:10,260 --> 01:22:13,830
它是最坏情况下的开销 E + V log V

1027
01:22:13,870 --> 01:22:18,030
因为把操作的平摊花销加起来

1028
01:22:18,130 --> 01:22:21,220
得出的是实际开销的上限

1029
01:22:22,090 --> 01:22:24,900
正如我所说的

1030
01:22:24,960 --> 01:22:27,390
这就是平摊分析之美

1031
01:22:27,430 --> 01:22:29,130
尤其是 它还能够

1032
01:22:29,180 --> 01:22:32,040
为不同操作分配不同的花费

1033
01:22:32,070 --> 01:22:35,050
我只需将它们加起来 就能得到最坏情况代价

1034
01:22:35,080 --> 01:22:37,520
这里已经是V log V了

1035
01:22:37,560 --> 01:22:40,310
在下课前 再提一下一些其它的算法

1036
01:22:40,350 --> 01:22:43,040
书里的Kruskal算法

1037
01:22:43,160 --> 01:22:45,820
它使用另一种平摊数据结构

1038
01:22:45,920 --> 01:22:48,800
称为不相交集合数据结构

1039
01:22:48,930 --> 01:22:53,340
同样也花费E log V 也就是这个时间

1040
01:22:53,460 --> 01:22:56,700
运行时间是这个 和二叉堆一样

1041
01:22:56,810 --> 01:22:58,080
我可以告诉你们 在书里面

1042
01:22:58,190 --> 01:23:01,610
处理这个问题的最好算法是

1043
01:23:01,650 --> 01:23:05,600
由我们学校教员中的David Karger

1044
01:23:05,680 --> 01:23:10,510
和我们校友Phil Kline一起完成的

1045
01:23:10,580 --> 01:23:13,630
现在他在布朗大学当教授 还有Robert Tarjan

1046
01:23:13,670 --> 01:23:18,360
他差不多是所有数据结构的砖家

1047
01:23:18,420 --> 01:23:21,590
他在1993年时 还是普林斯顿的教授

1048
01:23:21,690 --> 01:23:23,240
那是一个随机算法

1049
01:23:23,340 --> 01:23:27,330
它的期望时间是O(V+E)

1050
01:23:27,400 --> 01:23:29,480
那也是当今最好的算法

1051
01:23:29,540 --> 01:23:32,890
它对这一类问题也是友好的 如是否有确定性...

1052
01:23:32,980 --> 01:23:35,950
是否有一个最坏情况上限

1053
01:23:36,930 --> 01:23:40,490
是否存在一个是线性时间的最坏情况上限

1054
01:23:40,590 --> 01:23:42,660
好的 对随机化的数据有线性的时间

1055
01:23:42,780 --> 01:23:46,830
否则 这就会是最好的上界了

1056
01:23:46,870 --> 01:23:48,710
如果没有别的假设的话

1057
01:23:49,480 --> 01:23:50,570
非常酷炫啊

1058
01:23:50,620 --> 01:23:54,070
下节课 我们将会看到很多的

1059
01:23:57,570 --> 01:24:01,770
贪心算法和动态编程的应用

