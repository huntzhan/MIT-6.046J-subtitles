1
00:00:09,280 --> 00:00:12,870
So, we're going to talk today about binary search trees.

2
00:00:15,260 --> 00:00:18,480
It's something called randomly built binary search trees.

3
00:00:31,350 --> 00:00:33,310
And, I'll abbreviate binary search trees

4
00:00:33,400 --> 00:00:35,710
as BST's throughout the lecture.

5
00:00:35,810 --> 00:00:39,270
And, you of all seen binary search trees in one place or another,

6
00:00:39,360 --> 00:00:41,450
in particular, recitation on Friday.

7
00:00:41,540 --> 00:00:44,660
So, we're going to build up the basic ideas presented there,

8
00:00:44,750 --> 00:00:48,820
and talk about how to randomize them,

9
00:00:48,900 --> 00:00:50,340
and make them good.

10
00:00:50,430 --> 00:00:54,200
So, you know that there are good binary search trees

11
00:00:54,280 --> 00:00:59,340
which are relatively balanced, something like this.

12
00:00:59,420 --> 00:01:01,000
The height is log n.

13
00:01:01,100 --> 00:01:05,030
We called them balanced, and that's good.

14
00:01:05,120 --> 00:01:07,350
Anything order log n will be fine.

15
00:01:07,430 --> 00:01:10,240
In terms of searching, it will then cost order log n.

16
00:01:10,340 --> 00:01:12,230
And, there are bad binary search trees

17
00:01:12,310 --> 00:01:18,480
which have really large height, possibly as big as n.

18
00:01:18,580 --> 00:01:22,540
So, this is good, and this is bad.

19
00:01:22,630 --> 00:01:23,900
We'd sort of like to know,

20
00:01:24,000 --> 00:01:25,110
we'd like to build binary search trees

21
00:01:25,210 --> 00:01:28,110
in such a way that they are good all the time,

22
00:01:28,210 --> 00:01:30,520
or at least most of the time.

23
00:01:30,610 --> 00:01:32,120
There are lots of ways to do this,

24
00:01:32,230 --> 00:01:36,540
and in the next couple of weeks, we will see four of them,

25
00:01:36,630 --> 00:01:39,730
if you count the problem set, I believe.

26
00:01:39,820 --> 00:01:43,100
Today, we are going to use randomization

27
00:01:43,200 --> 00:01:46,730
to make them balanced most of the time in a certain sense.

28
00:01:46,810 --> 00:01:48,640
And then, in your problem set,

29
00:01:48,730 --> 00:01:51,530
you will make that in a broader sense.

30
00:01:51,620 --> 00:01:54,920
But, one way to motivate this topic,

31
00:01:55,010 --> 00:01:56,070
so I'm not going to define

32
00:01:56,180 --> 00:01:59,140
randomly built binary search trees for a little bit.

33
00:01:59,230 --> 00:02:00,650
One way to motivate the topic is

34
00:02:00,760 --> 00:02:03,760
through sorting, our good friend.

35
00:02:03,870 --> 00:02:07,270
So, there's a natural way to sort n numbers

36
00:02:07,360 --> 00:02:09,310
using binary search trees.

37
00:02:09,400 --> 00:02:11,220
So, if I give you an array, A,

38
00:02:11,290 --> 00:02:15,010
how would you sort that array

39
00:02:15,090 --> 00:02:19,330
using binary search tree operations as a black box?

40
00:02:22,570 --> 00:02:23,750
Build the binary search tree,

41
00:02:23,850 --> 00:02:25,580
and then traverse it in order. Exactly.

42
00:02:25,660 --> 00:02:29,360
So, let's say we have some initial tree,

43
00:02:29,470 --> 00:02:36,330
which is empty, and then for each element of the array,

44
00:02:36,410 --> 00:02:39,260
we insert it into the tree.

45
00:02:39,350 --> 00:02:45,620
That's what you meant by building the search tree.

46
00:02:46,730 --> 00:02:48,660
So, we insert A[i] into the tree.

47
00:02:48,750 --> 00:02:52,310
This is the binary search tree insertion, standard insertion.

48
00:02:52,400 --> 00:02:55,050
And then, we do an in order traversal,

49
00:02:55,150 --> 00:03:02,570
which in the book is called in order tree walk.

50
00:03:08,020 --> 00:03:10,380
OK, you should know these algorithms are,

51
00:03:10,480 --> 00:03:13,070
but just for very quick reminder,

52
00:03:13,160 --> 00:03:16,230
tree insert basically searches for that element A[i]

53
00:03:16,320 --> 00:03:19,190
until it finds the place where it should have been

54
00:03:19,280 --> 00:03:20,870
if it was in the tree already,

55
00:03:20,960 --> 00:03:24,240
and then adds a new leaf there to insert that value.

56
00:03:24,330 --> 00:03:27,530
Tree walk recursively walks the left subtree,

57
00:03:27,620 --> 00:03:29,210
then prints out the root,

58
00:03:29,300 --> 00:03:31,940
and then recursively walks the right subtree.

59
00:03:32,040 --> 00:03:33,360
And, by the binary search tree property,

60
00:03:33,450 --> 00:03:36,330
that will print the elements out in sorted order.

61
00:03:36,430 --> 00:03:39,070
So, let's do a quick example

62
00:03:39,160 --> 00:03:41,180
because this turns out to be

63
00:03:41,270 --> 00:03:42,750
related to another sorting algorithm we've seen already.

64
00:03:42,840 --> 00:03:47,870
So, while the example is probably pretty trivial,

65
00:03:47,950 --> 00:03:50,130
the connection is pretty surprising.

66
00:03:50,210 --> 00:03:58,000
At least, it was to me the first time I taught this class.

67
00:04:00,810 --> 00:04:10,170
So, my array is three, one, eight, two, six, seven, five.

68
00:04:10,240 --> 00:04:12,040
And, I'm going to visit these elements

69
00:04:12,220 --> 00:04:13,380
in order from left to right,

70
00:04:13,470 --> 00:04:15,000
and just build a tree.

71
00:04:15,090 --> 00:04:17,180
So, the first element I see is three.

72
00:04:17,270 --> 00:04:19,910
So, I insert three into an empty tree.

73
00:04:20,020 --> 00:04:22,070
That requires no comparisons.

74
00:04:22,160 --> 00:04:26,440
Then I insert one. I see, is one bigger or less than three?

75
00:04:26,540 --> 00:04:28,540
It's smaller. So, I put it over here.

76
00:04:28,650 --> 00:04:30,250
Then I insert eight.

77
00:04:30,360 --> 00:04:33,790
That's bigger than three, so it get's a new leaf over here.

78
00:04:33,890 --> 00:04:35,200
Then I insert two.

79
00:04:35,290 --> 00:04:36,990
That sits between one and three.

80
00:04:37,100 --> 00:04:40,550
And so, it would fall off this right child of one.

81
00:04:40,660 --> 00:04:42,200
So, I add two there.

82
00:04:42,300 --> 00:04:45,280
Six is bigger than three, and less than eight.

83
00:04:45,370 --> 00:04:49,650
So, it goes here.  Seven is bigger than three,

84
00:04:49,730 --> 00:04:52,150
and less than eight, bigger than six.

85
00:04:52,240 --> 00:04:58,760
So, it goes here, and five fits in between three and five,

86
00:04:58,860 --> 00:05:00,940
three and six rather.

87
00:05:01,030 --> 00:05:03,540
And so, that's the binary search tree that again.

88
00:05:03,620 --> 00:05:05,730
Then I run an in order traversal,

89
00:05:05,840 --> 00:05:11,310
which will print one, two, three, five, six, seven, eight.

90
00:05:11,410 --> 00:05:12,690
OK, I can run I quickly in my head

91
00:05:12,790 --> 00:05:14,180
because I've got a big stack.

92
00:05:14,270 --> 00:05:15,920
I've got to be a little bit careful.

93
00:05:16,010 --> 00:05:17,160
Of course, you should check that

94
00:05:17,300 --> 00:05:18,810
they come out in sorted order:

95
00:05:18,900 --> 00:05:25,110
one, two, three, five, six, seven, eight.

96
00:05:25,220 --> 00:05:28,650
And, if you don't have a big stack, you can go and buy one.

97
00:05:28,740 --> 00:05:30,870
That's always useful.

98
00:05:30,970 --> 00:05:33,620
Memory costs are going up a bit these days, or going down.

99
00:05:33,710 --> 00:05:37,290
They should be because of politics,

100
00:05:37,380 --> 00:05:41,920
but price-fixing, or whatever.

101
00:05:42,020 --> 00:05:45,330
So, the question is, what's the running time of the algorithm?

102
00:05:45,420 --> 00:05:49,490
Here, this is one of those answers where it depends.

103
00:05:49,580 --> 00:05:55,960
The parts that are easy to analyze are, well, initialization.

104
00:05:56,050 --> 00:05:59,400
The in order tree walk, how long does that take?

105
00:05:59,490 --> 00:06:03,130
n, good. So, it's order n for the walk,

106
00:06:03,220 --> 00:06:07,340
and for the initialization, which is constant.

107
00:06:07,470 --> 00:06:19,560
The question is, how long does it take me to do n tree inserts?

108
00:06:19,650 --> 00:06:21,600
Anyone want to guess any kind of

109
00:06:21,690 --> 00:06:24,530
answer to that question,  other than it depends?

110
00:06:24,630 --> 00:06:29,000
I've already stolen the thunder there.

111
00:06:29,080 --> 00:06:30,330
Yeah?

112
00:06:30,410 --> 00:06:32,810
STUDENT: [INAUDIBLE]

113
00:06:32,890 --> 00:06:34,750
Big Omega of n log n, that's good.

114
00:06:34,830 --> 00:06:40,680
It's at least n log n. Why?

115
00:06:40,760 --> 00:06:55,680
STUDENT: [INAUDIBLE]

116
00:06:55,760 --> 00:06:57,510
Right. So, you gave two reasons.

117
00:06:57,600 --> 00:07:00,190
The first one is because of the decision tree lower bound.

118
00:07:00,270 --> 00:07:03,240
That doesn't actually prove this.

119
00:07:03,340 --> 00:07:04,420
You have to be a little bit careful.

120
00:07:04,530 --> 00:07:08,670
This is a claim that it's omega n log n all the time.

121
00:07:08,740 --> 00:07:10,460
It's certainly omega n log n in the worst case.

122
00:07:10,540 --> 00:07:13,430
Every comparison-based sorting algorithm

123
00:07:13,510 --> 00:07:15,270
is omega n log n in the worst case.

124
00:07:15,360 --> 00:07:17,930
It's also n log n every single time,

125
00:07:18,010 --> 00:07:21,500
omega n log n because of the second reason you gave,

126
00:07:21,600 --> 00:07:24,320
which is the best thing that could happen

127
00:07:24,410 --> 00:07:26,780
is we have a perfectly balanced tree.

128
00:07:26,880 --> 00:07:31,140
So, this is the figure that I have drawn the most

129
00:07:31,220 --> 00:07:35,030
on a blackboard in my life,

130
00:07:35,110 --> 00:07:39,980
the perfect tree on 15 nodes, I guess.

131
00:07:40,060 --> 00:07:41,490
So, if we're lucky, we have this.

132
00:07:41,570 --> 00:07:44,330
And if you add up all the depths of the nodes here,

133
00:07:44,420 --> 00:07:46,840
which gives you the search tree cost

134
00:07:46,900 --> 00:07:53,610
in particular, these n over two nodes in the bottom, each have depth log n.

135
00:07:53,690 --> 00:07:55,050
And, therefore, you're going to

136
00:07:55,130 --> 00:07:57,200
have to pay it least n log n for those.

137
00:07:57,270 --> 00:07:59,930
And, if you're less balanced, it's going to be even worse.

138
00:08:00,020 --> 00:08:02,320
That takes some proving, but it's true.

139
00:08:02,400 --> 00:08:08,290
So, it's actually omega n log n all the time.

140
00:08:10,050 --> 00:08:12,460
OK, there are some cases, like you do know that

141
00:08:12,540 --> 00:08:14,130
the elements are almost already in order,

142
00:08:14,210 --> 00:08:17,100
you can do it in linear number comparisons.

143
00:08:17,190 --> 00:08:19,680
But here, you can't.

144
00:08:19,770 --> 00:08:24,010
Any other guesses at an answer to this question?

145
00:08:24,120 --> 00:08:26,190
Yeah?

146
00:08:26,290 --> 00:08:27,620
STUDENT: [INAUDIBLE]

147
00:08:27,720 --> 00:08:31,710
Big O n^2? Good, why?

148
00:08:31,800 --> 00:08:38,220
STUDENT: [INAUDIBLE]

149
00:08:38,330 --> 00:08:39,520
Right. We are doing n things,

150
00:08:39,610 --> 00:08:41,390
and each node has depth, at most, n.

151
00:08:41,490 --> 00:08:43,950
So, the number of comparisons we're making per element we insert,

152
00:08:44,040 --> 00:08:49,420
is, at most, n. So that's, at most, n^2.

153
00:08:49,510 --> 00:08:52,820
Any other answers?

154
00:08:55,720 --> 00:08:58,900
Is it possible for this algorithm to take n^2 time?

155
00:08:58,990 --> 00:09:04,600
Are there instances where it takes theta n^2?

156
00:09:06,320 --> 00:09:10,880
If it's already sorted, that would be pretty bad.

157
00:09:14,820 --> 00:09:17,820
So, if it's already sorted

158
00:09:17,890 --> 00:09:23,310
or if it's reverse sorted, you are in bad shape

159
00:09:23,390 --> 00:09:25,730
because then you get a tree like this.

160
00:09:25,810 --> 00:09:29,780
This is the sorted case. And, you compute.

161
00:09:29,860 --> 00:09:34,250
So, the total cost, the time in general is going to be

162
00:09:34,330 --> 00:09:42,410
the sum of the depths of the nodes for each node, X, in the tree.

163
00:09:42,490 --> 00:09:44,830
And in this case, it's one plus two plus three plus four,

164
00:09:44,920 --> 00:09:46,120
this arithmetic series.

165
00:09:46,210 --> 00:09:49,200
There's n of them, so this is theta n squared.

166
00:09:49,280 --> 00:09:52,800
It's like n^2 over two.

167
00:09:52,880 --> 00:09:55,240
So, that's bad news.

168
00:09:55,320 --> 00:10:01,340
The worst-case running time of this algorithm is n^2.

169
00:10:01,440 --> 00:10:03,100
Does that sound familiar at all,

170
00:10:03,190 --> 00:10:05,420
and algorithms worst-case running time is n^2,

171
00:10:05,510 --> 00:10:08,750
in particular, in the already-sorted case?

172
00:10:08,830 --> 00:10:13,140
But if we're lucky, at the lucky case,

173
00:10:13,220 --> 00:10:17,610
as we said, it's a balanced tree.

174
00:10:17,690 --> 00:10:18,760
Wouldn't that be great?

175
00:10:18,830 --> 00:10:24,880
Anything with omega log n height would give us

176
00:10:24,960 --> 00:10:31,260
a sorting algorithm that runs in n log n.

177
00:10:32,390 --> 00:10:34,870
So, in the lucky case, we are n log n.

178
00:10:34,950 --> 00:10:37,550
But in the unlucky case, we are n^2

179
00:10:37,630 --> 00:10:41,820
and unlucky case is sorted.

180
00:10:43,500 --> 00:10:47,750
Does it remind you of any algorithm we've seen before?

181
00:10:47,820 --> 00:10:50,920
Quicksort.

182
00:10:58,570 --> 00:11:01,410
It turns out the running time of this algorithm

183
00:11:01,480 --> 00:11:04,540
is the same as the running time of quicksort

184
00:11:04,620 --> 00:11:07,730
in a very strong sense.

185
00:11:07,820 --> 00:11:10,320
It turns out the comparisons that this algorithm makes

186
00:11:10,400 --> 00:11:13,820
are exactly the same comparisons that quicksort makes.

187
00:11:13,890 --> 00:11:16,170
It makes them in a different order,

188
00:11:16,250 --> 00:11:21,560
but it's really the same algorithm in disguise.

189
00:11:26,590 --> 00:11:32,700
That's the surprise here.

190
00:11:32,770 --> 00:11:34,970
So, in particular, we've already analyzed quicksort.

191
00:11:35,050 --> 00:11:43,350
We should get something for free out of that analysis.

192
00:11:52,740 --> 00:11:56,750
So, the relation is, BST sort

193
00:11:56,830 --> 00:12:04,540
and quicksort make the same comparisons

194
00:12:12,820 --> 00:12:17,120
but in a different order.

195
00:12:24,800 --> 00:12:31,970
So, let me walk through the same example we did before:

196
00:12:32,050 --> 00:12:40,620
three, one, eight, two, six, seven, five.

197
00:12:40,700 --> 00:12:41,790
So, there is an array.

198
00:12:41,870 --> 00:12:44,360
We are going to run a particular version of quicksort.

199
00:12:44,450 --> 00:12:48,920
I have to be a little bit careful here.

200
00:12:49,010 --> 00:12:51,030
It's sort of the obvious version of quicksort.

201
00:12:51,120 --> 00:12:53,760
Remember, our standard, boring quicksort is

202
00:12:53,840 --> 00:12:56,420
you take the first element as the partition element.

203
00:12:56,500 --> 00:12:58,900
So, I'll take three here.

204
00:12:58,990 --> 00:13:00,930
And, I split into the elements less than three,

205
00:13:01,010 --> 00:13:02,990
which is one and two.

206
00:13:03,070 --> 00:13:05,080
And, the elements bigger than three,

207
00:13:05,140 --> 00:13:08,150
which is eight, six, seven, five.

208
00:13:08,230 --> 00:13:09,380
And, in this version of quicksort,

209
00:13:09,480 --> 00:13:12,500
I don't change the order of the elements, eight, six, seven, five.

210
00:13:12,590 --> 00:13:14,940
So, let's say the order is preserved

211
00:13:15,030 --> 00:13:18,370
because only then will this equivalence hold.

212
00:13:18,460 --> 00:13:22,600
So, this is sort of a stable partition algorithm.

213
00:13:22,670 --> 00:13:26,480
It's easy enough to do. It's a particular version of quicksort.

214
00:13:26,560 --> 00:13:27,810
And soon, we're going to randomize it.

215
00:13:27,890 --> 00:13:31,650
And after we randomize, this difference doesn't matter.

216
00:13:31,730 --> 00:13:32,820
OK, then on the left recursion,

217
00:13:32,970 --> 00:13:34,930
we split in the partition element.

218
00:13:35,020 --> 00:13:36,070
There is things less than one,

219
00:13:36,160 --> 00:13:40,190
which is nothing, things bigger than one,  which is two.

220
00:13:40,270 --> 00:13:42,810
And then, that's our partition element.

221
00:13:42,900 --> 00:13:46,240
We are done. Over here, we partition on eight.

222
00:13:46,330 --> 00:13:47,880
Everything is less than eight.

223
00:13:47,960 --> 00:13:52,850
So, we get six, seven, five, nothing on the right.

224
00:13:52,930 --> 00:13:55,080
Then we partition at six.

225
00:13:55,170 --> 00:13:57,870
We get things less than six, mainly five,

226
00:13:57,950 --> 00:14:00,860
things bigger than six, mainly seven.

227
00:14:00,940 --> 00:14:05,670
And, those are sort of partition elements in a trivial way.

228
00:14:05,760 --> 00:14:12,080
Now, this tree that we get on the partition elements

229
00:14:12,160 --> 00:14:15,050
looks an awful lot like this tree.

230
00:14:15,130 --> 00:14:17,380
OK, it should be exactly the same tree.

231
00:14:17,460 --> 00:14:20,070
And, you can walk through,

232
00:14:20,150 --> 00:14:21,280
what comparisons does quicksort make?

233
00:14:21,360 --> 00:14:25,970
Well, first, it compares everything to three,

234
00:14:26,060 --> 00:14:27,890
OK, except three itself.

235
00:14:27,980 --> 00:14:29,030
Now, if you look over here,

236
00:14:29,130 --> 00:14:30,670
what happens when we are inserting elements?

237
00:14:30,750 --> 00:14:32,380
Well, each time we insert an element,

238
00:14:32,450 --> 00:14:34,180
the first thing we do is compare with three.

239
00:14:34,260 --> 00:14:36,120
If it's less than, we go to the left branch.

240
00:14:36,200 --> 00:14:38,390
If it's greater than, we go to the right branch.

241
00:14:38,470 --> 00:14:42,440
So, we are making all these comparisons with three in both cases.

242
00:14:42,530 --> 00:14:44,110
Then, if we have an element less than three,

243
00:14:44,200 --> 00:14:45,310
it's either one or two.

244
00:14:45,390 --> 00:14:51,190
If it's one, we're done. No comparisons happen here one to one.

245
00:14:51,270 --> 00:14:52,540
But, we compare two to one.

246
00:14:52,620 --> 00:14:54,480
And indeed, when we insert two over there

247
00:14:54,560 --> 00:14:57,060
after comparing it to three, we compare it to one.

248
00:14:57,140 --> 00:14:58,900
And then we figure out that it happens here.

249
00:14:58,980 --> 00:15:00,730
Same thing happens in quicksort.

250
00:15:00,820 --> 00:15:02,480
For elements greater than three,

251
00:15:02,560 --> 00:15:04,870
we compare everyone to eight here

252
00:15:04,960 --> 00:15:08,230
because we are partitioning with respect to eight,

253
00:15:08,310 --> 00:15:11,900
and here because that's the next node after three.

254
00:15:12,000 --> 00:15:14,090
As soon as eight is inserted, we compare everything

255
00:15:14,180 --> 00:15:17,670
with eight to see in fact that's less than eight, and so on:

256
00:15:17,750 --> 00:15:21,150
so, all of the same comparisons, just in a different order.

257
00:15:27,510 --> 00:15:34,930
So, this has various consequences in the analysis.

258
00:15:49,680 --> 00:15:54,050
So, in particular, the worst-case running time is theta n^2,

259
00:15:54,130 --> 00:15:55,570
which is not so exciting.

260
00:15:55,650 --> 00:16:00,740
What we really care about is the randomized version

261
00:16:02,130 --> 00:16:03,790
because that's what performs well.

262
00:16:03,870 --> 00:16:10,410
So, randomized BST sort is just like randomized quicksort.

263
00:16:10,490 --> 00:16:12,030
So, the first thing you do is

264
00:16:12,130 --> 00:16:17,460
randomly permute the array uniformly,

265
00:16:17,540 --> 00:16:21,650
picking all permutations with equal probability.

266
00:16:21,730 --> 00:16:28,270
And then, we call BST sort.

267
00:16:28,340 --> 00:16:30,400
OK, this is basically

268
00:16:30,470 --> 00:16:33,930
what randomized quicksort could be formulated as.

269
00:16:34,020 --> 00:16:36,080
And then, randomized BST sort is going to make

270
00:16:36,150 --> 00:16:39,150
exactly the same comparisons as randomized quicksort.

271
00:16:39,240 --> 00:16:44,580
Here, we are picking the root essentially randomly.

272
00:16:44,670 --> 00:16:46,340
And here in quicksort,

273
00:16:46,420 --> 00:16:49,410
you are picking the partition elements randomly.

274
00:16:49,490 --> 00:16:52,170
It's the same difference.

275
00:16:52,260 --> 00:16:57,130
OK, so the time of this algorithm

276
00:16:57,220 --> 00:17:05,560
equals the time of randomized quicksort

277
00:17:05,640 --> 00:17:06,930
because we are making the same comparisons.

278
00:17:07,000 --> 00:17:09,230
So, the number of comparisons is equal.

279
00:17:09,320 --> 00:17:11,010
And this is true as random variables.

280
00:17:11,100 --> 00:17:12,550
The random variable, the running time,

281
00:17:12,630 --> 00:17:15,380
this algorithm is equal to the random variable of this algorithm.

282
00:17:15,450 --> 00:17:21,040
In particular, the expectations are the same.

283
00:17:32,000 --> 00:17:34,960
OK, and we know that the expected running time

284
00:17:35,030 --> 00:17:39,060
of randomized quicksort on n elements is?

285
00:17:42,900 --> 00:17:50,510
Oh boy. n log n. Good. I was a little worried there.

286
00:17:50,600 --> 00:17:51,820
OK, so in particular,

287
00:17:51,910 --> 00:17:54,210
the expected running time of BST sort is n log n.

288
00:17:54,290 --> 00:17:57,860
Obviously, this is not too exciting from a sorting point of view.

289
00:17:57,940 --> 00:18:01,820
Sorting was just sort of to see this connection.

290
00:18:01,900 --> 00:18:03,460
What we actually care about,

291
00:18:03,540 --> 00:18:05,410
and the reason I've introduced this BST sort

292
00:18:05,490 --> 00:18:07,090
is what the tree looks like.

293
00:18:07,170 --> 00:18:09,080
What we really want is that search tree.

294
00:18:09,160 --> 00:18:11,520
The search tree can do more than sort. n order traversals

295
00:18:11,610 --> 00:18:13,800
are a pretty boring thing to do with the search tree.

296
00:18:13,870 --> 00:18:15,770
You can search in a search tree.

297
00:18:15,860 --> 00:18:17,830
So, OK, that's still not so exciting.

298
00:18:17,920 --> 00:18:19,530
You could sort the elements

299
00:18:19,610 --> 00:18:21,810
and then put them in an array and do binary search.

300
00:18:21,890 --> 00:18:24,330
But, the point of binary search trees,

301
00:18:24,410 --> 00:18:26,590
instead of binary search arrays,

302
00:18:26,670 --> 00:18:29,090
is that you can update them dynamically.

303
00:18:29,170 --> 00:18:31,130
We won't be updating them dynamically in this lecture,

304
00:18:31,210 --> 00:18:33,780
and we will in Wednesday and on your problem set.

305
00:18:33,860 --> 00:18:36,030
For now, it's just sort of warm-up.

306
00:18:36,120 --> 00:18:37,910
Let's say that the elements aren't changing.

307
00:18:38,000 --> 00:18:41,210
We are building one tree from the beginning.

308
00:18:41,300 --> 00:18:43,420
We have all n elements ahead of time.

309
00:18:43,500 --> 00:18:44,890
We are going to build it randomly.

310
00:18:44,970 --> 00:18:46,040
We randomly permute that array.

311
00:18:46,120 --> 00:18:49,410
Then we throw all the elements into a binary search tree.

312
00:18:49,490 --> 00:18:52,470
That's what BST sort does. Then it calls n order traversal.

313
00:18:52,550 --> 00:18:55,010
I don't really care about n order traversal.

314
00:18:55,090 --> 00:18:57,710
What I want, because we've just analyzed it.

315
00:18:57,800 --> 00:19:01,860
It would be a short lecture if I were done.

316
00:19:01,940 --> 00:19:04,830
What we want is this randomly built BST,

317
00:19:04,910 --> 00:19:09,620
which is what we get out of this algorithm.

318
00:19:09,700 --> 00:19:18,940
So, this is the tree resulting from randomized BST sort,

319
00:19:25,270 --> 00:19:27,370
OK, resulting from randomly permute in the array

320
00:19:27,470 --> 00:19:29,500
of just inserting those elements

321
00:19:29,580 --> 00:19:35,210
using the simple tree insert algorithm.

322
00:19:35,290 --> 00:19:40,790
The question is, what does that tree look like?

323
00:19:40,870 --> 00:19:42,250
And in particular, is there anything

324
00:19:42,330 --> 00:19:46,190
we can conclude out of this fact?

325
00:19:46,260 --> 00:19:52,530
The expected running time of BST sort is n log n.

326
00:19:53,300 --> 00:19:55,570
OK, I've mentioned cursorily

327
00:19:55,640 --> 00:19:59,600
what the running time of BST sort is, several times.

328
00:19:59,680 --> 00:20:11,650
It was the sum. So, this is the time of BST sort on n elements.

329
00:20:11,730 --> 00:20:18,650
It's the sum over all nodes, X, of the depth of that node.

330
00:20:18,730 --> 00:20:20,530
OK, depth starts at zero

331
00:20:20,610 --> 00:20:23,670
and works its way down because the root element,

332
00:20:23,750 --> 00:20:24,760
you don't make any comparisons

333
00:20:24,840 --> 00:20:30,890
beyond that, you are making whatever the depth is comparisons.

334
00:20:30,960 --> 00:20:34,960
OK, so we know that this thing is,

335
00:20:35,040 --> 00:20:40,750
in expectation we know that this is n log n.

336
00:20:40,830 --> 00:20:42,900
What does that tell us about the tree?

337
00:20:42,990 --> 00:20:48,820
This is for all nodes, X, in the tree.

338
00:20:54,160 --> 00:20:55,360
Does it tell us anything about

339
00:20:55,450 --> 00:20:59,490
the height of the tree, for example? Yeah?

340
00:20:59,560 --> 00:21:03,640
STUDENT: [INAUDIBLE]

341
00:21:03,750 --> 00:21:05,500
Right, intuitively,

342
00:21:05,610 --> 00:21:08,140
it says that the height of the tree is theta log n,

343
00:21:08,220 --> 00:21:11,820
and not n. But, in fact, it doesn't show that.

344
00:21:11,900 --> 00:21:14,550
And that's why if you feel that that's just intuition,

345
00:21:14,630 --> 00:21:16,790
but it may not be quite right. Indeed it's not.

346
00:21:16,860 --> 00:21:19,660
Let me tell you what it does say.

347
00:21:19,750 --> 00:21:26,320
So, if we take expectation of both sides, here we get n log n.

348
00:21:26,400 --> 00:21:32,700
So, the expected value of that is n log n.

349
00:21:32,780 --> 00:21:41,340
So, over here, well, we get the expected total depth,

350
00:21:41,410 --> 00:21:42,680
which is not so exciting.

351
00:21:42,750 --> 00:21:46,620
Let's look at the expected average depth.

352
00:21:46,700 --> 00:21:48,320
So, if I look at one over n,

353
00:21:48,390 --> 00:21:52,900
the sum over all n nodes in the tree of the depth of X,

354
00:21:52,980 --> 00:21:58,030
that would be the average depth over all the nodes.

355
00:21:58,130 --> 00:22:05,070
And what I should get is theta n log n over n

356
00:22:05,150 --> 00:22:08,230
because I divided n on both sides.

357
00:22:08,320 --> 00:22:13,230
And, I'm using, here, linearity of expectation, which is log n.

358
00:22:13,300 --> 00:22:16,800
So, what this fact about the expected running time

359
00:22:16,870 --> 00:22:20,760
tells me is that the average depth in the tree is log n,

360
00:22:20,830 --> 00:22:27,320
which is not quite the height of the tree being log n.

361
00:22:33,920 --> 00:22:35,030
OK, remember the height of the tree

362
00:22:35,120 --> 00:22:39,460
is the maximum depth of any node.

363
00:22:39,540 --> 00:22:44,630
Here, we are just bounding the average depth.

364
00:23:03,690 --> 00:23:08,820
Let's look at an example of a tree.

365
00:23:11,860 --> 00:23:15,200
I'll draw my favorite picture.

366
00:23:17,800 --> 00:23:19,470
So, here we have a nice balanced tree,

367
00:23:19,540 --> 00:23:24,430
let's say, on half of the nodes or a little more.

368
00:23:24,500 --> 00:23:27,490
And then, I have one really long path

369
00:23:27,600 --> 00:23:32,130
hanging off one particular leaf.

370
00:23:32,210 --> 00:23:33,340
It doesn't matter which one.

371
00:23:33,420 --> 00:23:36,260
And, I'm going to say that this path has length,

372
00:23:36,340 --> 00:23:39,180
with a total height here, I want to make root n,

373
00:23:39,260 --> 00:23:42,140
which is a lot bigger than log n.

374
00:23:42,210 --> 00:23:43,920
This is roughly log n.

375
00:23:44,000 --> 00:23:50,560
It's going to be log of n minus root n, or so, roughly.

376
00:23:50,640 --> 00:23:54,330
So, most of the nodes have logarithmic height and,

377
00:23:54,420 --> 00:23:56,730
sorry, logarithmic depth.

378
00:23:56,810 --> 00:24:01,340
If you compute the average depth in this particular tree,

379
00:24:01,420 --> 00:24:03,320
for most of the nodes, let's say it's,

380
00:24:03,410 --> 00:24:10,580
at most, n of the nodes have height log n.

381
00:24:10,670 --> 00:24:12,620
And then, there are root n nodes, at most,

382
00:24:12,700 --> 00:24:17,310
down here, which have depth, at most, root n.

383
00:24:17,390 --> 00:24:20,610
So, it's, at most, root n times root n.

384
00:24:20,690 --> 00:24:23,320
In fact, it's like half that, but not a big deal.

385
00:24:23,400 --> 00:24:29,330
So, this is n. So, this is n log n, or, sorry,

386
00:24:29,510 --> 00:24:35,080
average depth...I have to divide everything by n.

387
00:24:35,150 --> 00:24:41,630
n log n would be rather large for an average height, average depth.

388
00:24:41,710 --> 00:24:43,790
So, the average depth here is log n,

389
00:24:43,880 --> 00:24:46,660
but the height of the tree is square root of n.

390
00:24:46,730 --> 00:24:49,280
So, this is not enough.

391
00:24:49,350 --> 00:24:51,330
Just to know that the average depth is log n

392
00:24:51,410 --> 00:24:54,790
doesn't mean that the height is log n.

393
00:24:54,870 --> 00:25:00,130
OK, but the claim is this theorem for today

394
00:25:00,220 --> 00:25:05,330
is that the expected height of

395
00:25:05,400 --> 00:25:15,930
a randomly built binary search tree is indeed log n.

396
00:25:16,020 --> 00:25:21,950
BST is order log n.

397
00:25:22,030 --> 00:25:25,500
This is what we like to know because that tells us,

398
00:25:25,580 --> 00:25:29,360
if we just build a binary search tree randomly,

399
00:25:29,440 --> 00:25:32,470
then we can search in it in log n time.

400
00:25:32,560 --> 00:25:36,030
OK, for sorting, it's not as big a deal.

401
00:25:36,110 --> 00:25:40,100
We just care about the expected running time of creating the thing.

402
00:25:40,190 --> 00:25:43,100
Here, now we know that once we prove this theorem,

403
00:25:43,180 --> 00:25:47,340
we know that we can search quickly in expectation,

404
00:25:47,420 --> 00:25:50,860
in fact, most of the time.

405
00:25:50,940 --> 00:25:53,030
So, the rest of today's lecture will be proving this theorem.

406
00:25:53,110 --> 00:25:55,040
It's quite tricky, as you might imagine.

407
00:25:55,120 --> 00:25:57,360
It's another big probability analysis

408
00:25:57,430 --> 00:26:02,730
along the lines of quicksort and everything.

409
00:26:20,900 --> 00:26:26,680
So, I'm going to start with an outline of the proof,

410
00:26:28,230 --> 00:26:29,950
unless there are any questions about the theorem.

411
00:26:30,030 --> 00:26:32,740
It should be pretty clear what we want to prove.

412
00:26:32,830 --> 00:26:36,860
This is even weirder than most of the analyses we've seen.

413
00:26:36,940 --> 00:26:40,970
It's going to use a fancy trick,

414
00:26:41,060 --> 00:26:44,080
which is exponentiating a random variable.

415
00:26:44,170 --> 00:26:51,930
And to do that we need a tool called Jenson's inequality.

416
00:26:52,020 --> 00:26:53,440
We are going to prove that tool.

417
00:26:53,530 --> 00:26:55,640
Usually, we don't prove probability tools.

418
00:26:55,710 --> 00:26:57,700
But this one we are going to prove.

419
00:26:57,780 --> 00:27:06,620
It's not too hard. It's also basic analysis.

420
00:27:06,710 --> 00:27:11,880
So, the lemma, says that if we have

421
00:27:11,970 --> 00:27:14,270
what's called to a convex function, f,

422
00:27:14,350 --> 00:27:16,070
and you should all know what that means,

423
00:27:16,150 --> 00:27:21,000
but I'll define it soon in case you have forgotten.

424
00:27:21,070 --> 00:27:22,390
If you have a convex function, f,

425
00:27:22,470 --> 00:27:23,890
and you have a random variable, X,

426
00:27:23,980 --> 00:27:25,520
you take f of the expectation.

427
00:27:25,600 --> 00:27:30,140
That's, at most, the expectation of f of that random variable.

428
00:27:30,240 --> 00:27:33,200
Think about it enough and draw a convex function

429
00:27:33,290 --> 00:27:35,960
that is fairly intuitive, I guess.

430
00:27:36,050 --> 00:27:38,410
But we will prove it.

431
00:27:38,490 --> 00:27:46,470
What that allows us to do is instead of

432
00:27:46,550 --> 00:27:54,670
analyzing the random variable that tells us the height of a tree,

433
00:27:54,760 --> 00:27:59,350
so, X_n I'll call the random variable, RV,

434
00:27:59,430 --> 00:28:08,250
of the height of a BST, randomly constructed BST

435
00:28:08,350 --> 00:28:17,340
on n nodes we will analyze.

436
00:28:17,420 --> 00:28:21,860
Well, instead of analyzing this desired random variable, X_n,

437
00:28:21,930 --> 00:28:27,070
sorry, this should have been in capital X.

438
00:28:27,150 --> 00:28:32,270
We can analyze any convex function of X_n.

439
00:28:32,360 --> 00:28:35,930
And, we're going to analyze the exponentiation.

440
00:28:36,010 --> 00:28:43,440
So, I'm going to define Y_n to be two to the power of X_n.

441
00:28:43,520 --> 00:28:47,220
OK, the big question here is why bother doing this?

442
00:28:47,300 --> 00:28:48,850
The answer is because it works

443
00:28:48,930 --> 00:28:51,090
and it wouldn't work if we analyze X_n.

444
00:28:51,170 --> 00:28:54,230
We will see some intuition of that later on,

445
00:28:54,310 --> 00:28:56,070
but it's not very intuitive.

446
00:28:56,150 --> 00:29:00,680
This is our analysis where you need this extra trick.

447
00:29:00,770 --> 00:29:03,550
So, we're going to bound the expectation of Y_n,

448
00:29:03,630 --> 00:29:05,650
and from that, and using Jensen's inequality,

449
00:29:05,740 --> 00:29:08,940
we're going to get a bound on the expectation of X_n,

450
00:29:09,010 --> 00:29:11,420
a pretty tight bound, actually,

451
00:29:11,500 --> 00:29:15,200
because if we can bound the exponent up to constant factors,

452
00:29:15,280 --> 00:29:16,910
the exponentiation up to constant factors,

453
00:29:17,000 --> 00:29:19,800
we can bound X_n even better

454
00:29:19,880 --> 00:29:23,240
because you take logs to get X_n.

455
00:29:23,320 --> 00:29:26,780
So, we will even figure out what the constant is.

456
00:29:26,870 --> 00:29:32,610
So, what we will prove, this is the heart of the proof,

457
00:29:32,690 --> 00:29:37,660
is that the expected value of Y_n is order n^3.

458
00:29:37,750 --> 00:29:40,220
Here, we won't really know what the constant is.

459
00:29:40,310 --> 00:29:42,770
We don't need to.

460
00:29:42,850 --> 00:29:45,230
And then, we put these pieces together.

461
00:29:45,310 --> 00:29:48,030
So, let's do that.

462
00:29:48,100 --> 00:29:52,920
What we really care about is the expectation of X_n,

463
00:29:53,000 --> 00:29:55,000
which is the height of our tree.

464
00:29:55,070 --> 00:29:59,920
What we find out about is this fact.

465
00:30:00,010 --> 00:30:05,070
So, leave some horizontal space here.

466
00:30:05,150 --> 00:30:08,540
We get the expectation of two to the X_n.

467
00:30:08,620 --> 00:30:13,330
That's the expectation of Y_n.

468
00:30:13,410 --> 00:30:16,770
So, we learned that that's order n^3.

469
00:30:16,840 --> 00:30:18,840
And, Jensen's inequality tells us that

470
00:30:18,930 --> 00:30:21,870
if we take this function, two to the X,

471
00:30:21,950 --> 00:30:26,360
we plug it in here, that on the left-hand side

472
00:30:26,440 --> 00:30:29,670
we get two to the E of X.

473
00:30:29,750 --> 00:30:36,870
So, we get two to the E of X_n is at most E of two to the X_n.

474
00:30:36,960 --> 00:30:38,750
So, that's where we use Jensen's inequality,

475
00:30:38,830 --> 00:30:41,670
because what we care about is E of X_n.

476
00:30:41,750 --> 00:30:42,810
So now, we have a bound.

477
00:30:42,930 --> 00:30:47,160
We say, well, two to the E of X_n is, at most, n^3.

478
00:30:47,240 --> 00:30:49,020
So, if we take the log of both sides,

479
00:30:49,100 --> 00:30:58,060
we get E of X_n is, at most, the log of n^3.

480
00:30:58,140 --> 00:31:01,740
OK, I will write it in this funny way, log of order n^3,

481
00:31:01,820 --> 00:31:04,220
which will actually tell us the constant.

482
00:31:04,310 --> 00:31:12,330
This is three log n plus order one.

483
00:31:12,400 --> 00:31:14,660
So, we will prove that the expected

484
00:31:14,740 --> 00:31:17,470
height of a randomly constructed binary search tree

485
00:31:17,550 --> 00:31:23,630
on n nodes is roughly three log n, at most.

486
00:31:23,710 --> 00:31:28,400
OK, I will say more about that later.

487
00:31:28,470 --> 00:31:32,100
So, you've now seen the end of the proof.

488
00:31:32,200 --> 00:31:33,430
That's the foreshadowing.

489
00:31:33,520 --> 00:31:35,850
And now, this is the top-down approach.

490
00:31:35,930 --> 00:31:37,930
So, you sort of see what the steps are.

491
00:31:38,010 --> 00:31:39,670
Now, we just have to do the steps.

492
00:31:39,750 --> 00:31:43,250
OK, step one: take a bit of work, but it's easy

493
00:31:43,330 --> 00:31:45,530
because it's pretty basic stuff.

494
00:31:45,600 --> 00:31:48,460
Step two is just a definition and we are done.

495
00:31:48,540 --> 00:31:50,960
Step three is probably the hardest part.

496
00:31:51,040 --> 00:31:53,450
Step four, we've already done.

497
00:31:53,530 --> 00:31:59,660
So, let's start with step one.

498
00:32:16,090 --> 00:32:18,920
So, the first thing I need to do is define a convex function

499
00:32:19,000 --> 00:32:24,600
because we are going to manipulate the definition a fair amount.

500
00:32:25,760 --> 00:32:31,010
So, this is a notion from real analysis.

501
00:32:34,040 --> 00:32:35,900
Analysis is a fancy word for calculus

502
00:32:35,990 --> 00:32:38,850
if you haven't taken the proper analysis class.

503
00:32:38,930 --> 00:32:42,090
You should have seen convexity in any calculus class.

504
00:32:42,180 --> 00:32:44,640
A convex function is one that looks like this.

505
00:32:44,730 --> 00:32:50,570
OK, good. One way to formalize that notion is

506
00:32:50,670 --> 00:32:53,320
to consider any two points on this curve.

507
00:32:53,400 --> 00:32:56,200
So, I'm only interested in functions from reals to reals.

508
00:32:56,270 --> 00:32:59,770
So, it looks like this. This is f of something.

509
00:32:59,850 --> 00:33:02,570
And, this is the something.

510
00:33:02,650 --> 00:33:04,810
If I take two points on this curve,

511
00:33:04,890 --> 00:33:07,750
and I draw a line segment connecting them,

512
00:33:07,820 --> 00:33:10,350
that line segment is always above the curve.

513
00:33:10,430 --> 00:33:13,080
That's the meaning of convexity.

514
00:33:13,170 --> 00:33:15,710
It has a geometric notion, which is basically the same.

515
00:33:15,810 --> 00:33:19,560
But for functions, this line segment should stay above the curve.

516
00:33:19,640 --> 00:33:21,060
The line does not stay above the curve.

517
00:33:21,150 --> 00:33:24,330
If I extended it farther, it goes beneath the curve, of course.

518
00:33:24,430 --> 00:33:27,480
But, that segment should.

519
00:33:27,560 --> 00:33:29,330
So, I'm going to formalize that a little bit.

520
00:33:29,420 --> 00:33:33,450
I'll call this x, and then this is f of x.

521
00:33:33,530 --> 00:33:38,480
And, I'll call this y, and this is f of y.

522
00:33:38,560 --> 00:33:43,180
So, the claim is that I take any number between x and y,

523
00:33:43,260 --> 00:33:47,710
and I look up, and I say, OK, here's the point on the curve.

524
00:33:47,800 --> 00:33:49,730
Here's the point on the line segment.

525
00:33:49,810 --> 00:33:52,870
The value of that point on the y value, here,

526
00:33:52,950 --> 00:33:57,570
should be greater than or equal to the y value here, OK?

527
00:33:57,650 --> 00:33:59,700
To figure out what the point is,

528
00:33:59,770 --> 00:34:04,110
we need some, I would call it geometry.

529
00:34:04,200 --> 00:34:06,330
I'm sure it's an analysis concept, too.

530
00:34:06,410 --> 00:34:09,880
But, I'm a geometer, so I get to call it geometry.

531
00:34:09,960 --> 00:34:14,690
If you have two points, p and q,

532
00:34:14,800 --> 00:34:18,180
and you want to parameterize this line segment between them,

533
00:34:18,270 --> 00:34:21,180
so, I want to parameterize some points here,

534
00:34:21,260 --> 00:34:25,620
the way to do it is to take a linear combination.

535
00:34:25,700 --> 00:34:29,090
And, if you should have taken some linear algebra,

536
00:34:29,170 --> 00:34:31,990
linear combination look something like this.

537
00:34:32,070 --> 00:34:33,720
And, in fact, we're going to take something

538
00:34:33,800 --> 00:34:39,260
called an affine combination where alpha plus beta equals one.

539
00:34:39,330 --> 00:34:43,990
It turns out, if you take all such points,

540
00:34:44,070 --> 00:34:48,070
some number, alpha, times the point, p, plus some number,

541
00:34:48,150 --> 00:34:50,450
beta times the point, q, where alpha plus beta equals one.

542
00:34:50,540 --> 00:34:51,780
If you take all those points,

543
00:34:51,870 --> 00:34:55,090
you get the entire line here, which is nifty.

544
00:34:55,160 --> 00:34:56,580
But, we don't want the entire line.

545
00:34:56,660 --> 00:35:00,140
If you also constrained alpha and beta to be nonnegative,

546
00:35:00,220 --> 00:35:02,220
you just get this line segment.

547
00:35:02,300 --> 00:35:04,980
So, this forces alpha and beta to be between zero and one

548
00:35:05,060 --> 00:35:07,200
because they have to sum to one,

549
00:35:07,280 --> 00:35:08,560
and they are nonnegative.

550
00:35:08,640 --> 00:35:10,240
So, what we are going to do here is

551
00:35:10,320 --> 00:35:13,500
take alpha times x plus beta times y.

552
00:35:13,600 --> 00:35:17,210
That's going to be our point between with these constraints:

553
00:35:17,290 --> 00:35:18,600
alpha plus beta equals one.

554
00:35:18,690 --> 00:35:20,290
Alpha and beta are greater than or equal to zero.

555
00:35:20,370 --> 00:35:24,590
Then, this point is f of that.

556
00:35:24,670 --> 00:35:29,500
This is f of alpha x plus beta, y.

557
00:35:29,580 --> 00:35:34,940
And, this point is the linear interpolation

558
00:35:35,020 --> 00:35:37,650
between f of x and f of y, the same one.

559
00:35:37,730 --> 00:35:43,670
So, it's alpha times f of x plus beta times f of y.

560
00:35:43,750 --> 00:35:45,900
OK, that's the intuition.

561
00:35:45,980 --> 00:35:48,980
If you didn't follow it, it's not too big a deal

562
00:35:49,060 --> 00:35:50,100
because all we care about

563
00:35:50,200 --> 00:35:53,180
are the symbolic answer for proving things.

564
00:35:53,270 --> 00:35:55,160
But, that's where this comes from.

565
00:35:55,250 --> 00:35:57,490
So, here's the definition.

566
00:35:57,570 --> 00:36:00,600
Its function is convex.

567
00:36:00,680 --> 00:36:11,130
If, for all x and y, and all alpha and beta

568
00:36:11,210 --> 00:36:17,780
are greater than or equal to zero, whose sum is one,

569
00:36:17,840 --> 00:36:27,490
we have f of alpha x plus beta y is less than

570
00:36:27,580 --> 00:36:33,100
or equal to alpha f of x plus beta f of y.

571
00:36:33,190 --> 00:36:35,820
So, that's just saying that this y coordinate here

572
00:36:35,900 --> 00:36:40,270
is less than or equal to this y coordinate.

573
00:36:40,340 --> 00:36:46,570
OK, but that's the symbolism behind that picture.

574
00:36:46,660 --> 00:36:49,180
OK, so now we want to prove Jensen's inequality.

575
00:36:49,260 --> 00:36:51,340
OK, we're not quite there yet.

576
00:36:51,420 --> 00:36:55,300
We are going to prove a simple lemma,

577
00:36:55,390 --> 00:37:00,930
from which it will be easy to derive Jenson's equality.

578
00:37:01,570 --> 00:37:05,400
So, this is the theorem we are proving.

579
00:37:11,670 --> 00:37:15,810
So, here's a lemma about convex functions.

580
00:37:15,890 --> 00:37:17,960
You may have seen it before.

581
00:37:18,040 --> 00:37:22,710
It will be crucial to Jensen's inequality.

582
00:37:30,780 --> 00:37:32,630
So, suppose, this is a statement

583
00:37:32,700 --> 00:37:37,810
about affine combinations of n things instead of two things.

584
00:37:37,900 --> 00:37:39,030
So, this will say that convexity

585
00:37:39,100 --> 00:37:43,870
can be generalized to taking n things.

586
00:37:43,950 --> 00:37:46,970
So, suppose we have n real numbers,

587
00:37:48,510 --> 00:37:52,840
and we have n values alpha i, alpha one up to alpha n.

588
00:37:52,930 --> 00:37:55,180
They are all nonnegative.

589
00:37:55,270 --> 00:37:57,870
And, their sum is one.

590
00:37:57,950 --> 00:38:01,590
So, the sum of alpha k, I guess,

591
00:38:01,670 --> 00:38:07,550
k equals one to n, is one.

592
00:38:07,640 --> 00:38:09,410
So, those are the assumptions.

593
00:38:09,490 --> 00:38:16,130
The conclusion is the same thing, but summing over all k.

594
00:38:16,210 --> 00:38:20,520
So, k equals one to n, alpha_k * x_k.

595
00:38:20,610 --> 00:38:27,810
Take f of that versus taking the sum of the alphas times the f's.

596
00:38:27,900 --> 00:38:31,660
k equals one to n.

597
00:38:31,750 --> 00:38:35,640
So, the definition of convexity is exactly that statement,

598
00:38:35,720 --> 00:38:38,200
but where n equals two.

599
00:38:38,280 --> 00:38:42,110
OK, alpha one and alpha two are alpha and beta.

600
00:38:42,190 --> 00:38:48,660
This is just a statement for general n.

601
00:38:48,740 --> 00:38:52,950
And, you can interpret this in some funnier way,

602
00:38:53,030 --> 00:38:57,040
which I won't get into. Oh, sure, why not?

603
00:38:57,120 --> 00:38:58,500
I'm a geometer.

604
00:38:58,580 --> 00:39:02,420
So, this is saying you take several points on this curve.

605
00:39:02,500 --> 00:39:06,360
You take the polygon that they define.

606
00:39:06,440 --> 00:39:07,850
So, these are straight-line segments.

607
00:39:07,920 --> 00:39:10,350
You take the interior.

608
00:39:10,440 --> 00:39:12,160
If you take an affine combination like that,

609
00:39:12,230 --> 00:39:14,760
you will get a point inside that polygon,

610
00:39:14,850 --> 00:39:16,240
or possibly on the boundary.

611
00:39:16,330 --> 00:39:19,300
The claim is that all those points are above the curve.

612
00:39:19,390 --> 00:39:22,350
Again, intuitively: true if you draw a nice,

613
00:39:22,440 --> 00:39:25,490
canonical convex curve,

614
00:39:25,570 --> 00:39:27,150
but in fact, it's true algebraically, too.

615
00:39:27,240 --> 00:39:29,770
It's always a good thing.

616
00:39:29,860 --> 00:39:32,920
Any suggestions on how we might prove this theorem, this lemma?

617
00:39:33,000 --> 00:39:40,800
It's pretty easy. So, what technique might we use to prove it?

618
00:39:45,310 --> 00:39:47,900
One word: induction.

619
00:39:47,940 --> 00:39:51,380
Always a good answer, yeah.

620
00:39:52,160 --> 00:39:54,500
Induction should shout out at you here

621
00:39:54,590 --> 00:39:55,960
because we already know that

622
00:39:56,040 --> 00:39:58,820
this is true by definition of convexity for n equals two.

623
00:39:58,890 --> 00:40:00,860
So, the base case is clear.

624
00:40:00,940 --> 00:40:02,360
In fact, there's an even simpler base case,

625
00:40:02,440 --> 00:40:05,560
which is when n equals one.

626
00:40:05,660 --> 00:40:10,820
If n equals one, then you have one number that sums to one.

627
00:40:10,900 --> 00:40:15,080
So, alpha one is one. And so, nothing is going on here.

628
00:40:15,160 --> 00:40:22,430
This is just saying that f of one times x_1 is,

629
00:40:22,510 --> 00:40:26,930
at most, one times f of x_1:

630
00:40:27,010 --> 00:40:32,930
so, not terribly exciting because that holds with the equality.

631
00:40:33,030 --> 00:40:36,940
OK, so we don't even need the n equals two base case.

632
00:40:37,030 --> 00:40:38,270
So, the interesting part,

633
00:40:38,350 --> 00:40:42,000
although still not terribly interesting, is the induction step.

634
00:40:42,090 --> 00:40:45,770
This is good practice in induction.

635
00:40:45,860 --> 00:40:51,990
So, what we care about is this f of this linear combination,

636
00:40:52,070 --> 00:40:58,260
f on combination,  alpha_k times x_k summed over all k.

637
00:40:58,340 --> 00:41:01,220
Now, what I would like to do is apply induction.

638
00:41:01,300 --> 00:41:05,410
What I know about inductively, is say f of this sum,

639
00:41:05,490 --> 00:41:07,440
if it's summed only up to n minus one

640
00:41:07,530 --> 00:41:09,150
instead of all the way up to n.

641
00:41:09,240 --> 00:41:12,470
Any smaller sum I can deal with by induction.

642
00:41:12,560 --> 00:41:14,480
So, I'm going to try and get rid of the nth term.

643
00:41:14,560 --> 00:41:16,780
I want to separate it out.

644
00:41:16,860 --> 00:41:21,370
And, this is fairly natural

645
00:41:21,460 --> 00:41:23,750
if you've played with affine combinations before.

646
00:41:23,830 --> 00:41:27,620
But it's just some algebra.

647
00:41:30,710 --> 00:41:35,120
So, I want to separate out the alpha_n*x_n term.

648
00:41:35,210 --> 00:41:39,010
And, I'd also like to make it an affine combination.

649
00:41:39,100 --> 00:41:41,370
This is the trick.

650
00:41:44,340 --> 00:41:47,060
Sorry, no f here.

651
00:41:53,670 --> 00:41:55,790
If I just removed the last term,

652
00:41:55,870 --> 00:41:57,800
the alpha k's from one up to n minus one

653
00:41:57,880 --> 00:41:59,390
wouldn't sum to one anymore.

654
00:41:59,470 --> 00:42:01,080
They'd sum to something smaller.

655
00:42:01,160 --> 00:42:02,740
So, I can't just take out this term.

656
00:42:02,830 --> 00:42:13,390
I'm going to have to do some trickery here, x_k plus the f.

657
00:42:14,330 --> 00:42:18,020
Good. So, you should see why this is true,

658
00:42:18,100 --> 00:42:20,280
because the one minus alpha n's cancel.

659
00:42:20,370 --> 00:42:23,320
And then, I'm just getting the sum of alpha_k*x_k,

660
00:42:23,400 --> 00:42:27,080
k equals one to n minus one, plus the alpha_n*x_n term.

661
00:42:27,160 --> 00:42:28,500
So, I haven't done anything here.

662
00:42:28,590 --> 00:42:29,930
These are equal.

663
00:42:30,010 --> 00:42:32,370
But now, I have this nifty feature,

664
00:42:32,460 --> 00:42:34,790
that on the one hand, these two numbers,

665
00:42:34,870 --> 00:42:37,770
alpha n and one minus alpha n sum to one.

666
00:42:37,860 --> 00:42:39,460
And on the other hand, if I did it right,

667
00:42:39,540 --> 00:42:42,660
these numbers should sum up to one

668
00:42:42,750 --> 00:42:46,230
just going from one up to n minus one.

669
00:42:46,320 --> 00:42:48,380
Why do they sum up to one?

670
00:42:48,470 --> 00:42:53,210
Well, these numbers summed up to one minus alpha n.

671
00:42:53,290 --> 00:42:55,390
And so, I'm dividing everything by one minus alpha n.

672
00:42:55,470 --> 00:42:56,830
So, they will sum to one.

673
00:42:56,910 --> 00:42:58,950
So now, I have two affine combinations.

674
00:42:59,030 --> 00:43:01,260
I just apply the two things that I know.

675
00:43:01,340 --> 00:43:08,590
I know this affine combination will work because, well, why?

676
00:43:08,670 --> 00:43:13,880
Why can I say that this is alpha n f of x_n

677
00:43:13,970 --> 00:43:19,610
plus one minus alpha n f of this crazy sum?

678
00:43:33,710 --> 00:43:38,460
Shout it out. There are two possible answers.

679
00:43:38,540 --> 00:43:41,820
One is correct, and one is incorrect.

680
00:43:41,890 --> 00:43:44,330
So, which will it be?

681
00:43:51,140 --> 00:43:55,110
This should have been less than or equal to.

682
00:43:55,200 --> 00:43:57,200
That's important.

683
00:44:00,370 --> 00:44:03,840
It's on the board. It can't be too difficult.

684
00:44:16,450 --> 00:44:20,600
So, I'm treating this as just one big X value.

685
00:44:20,680 --> 00:44:26,390
So, I have some x_n, and I have some crazy X.

686
00:44:26,480 --> 00:44:29,260
I want f of the affine combination of those two X values is,

687
00:44:29,340 --> 00:44:35,760
at most, the affine combinations of the f's of those X values.

688
00:44:35,840 --> 00:44:41,820
This is? It is the inductive hypothesis where n equals two.

689
00:44:41,910 --> 00:44:44,870
Unfortunately, we didn't prove the n equals two case

690
00:44:44,950 --> 00:44:46,820
is a special base case.

691
00:44:46,910 --> 00:44:48,760
So, we can't use induction here

692
00:44:48,840 --> 00:44:50,170
the way that I've stated the base case.

693
00:44:50,250 --> 00:44:52,000
If you did n equals two base case,

694
00:44:52,080 --> 00:44:55,450
you can do that. Here, we can't.

695
00:44:55,540 --> 00:44:59,030
So, the other answer is by convexity, good.

696
00:44:59,120 --> 00:45:01,100
That's right here.

697
00:45:01,190 --> 00:45:04,830
So, f is convex. We know that this is true for any two X values,

698
00:45:04,930 --> 00:45:09,050
and provided these two sum to one.

699
00:45:09,140 --> 00:45:12,330
So, we know that this is true.

700
00:45:12,630 --> 00:45:15,910
Now is when we apply induction.

701
00:45:27,820 --> 00:45:33,870
So, now we are going to manipulate this right term by induction.

702
00:45:33,950 --> 00:45:35,670
See, before we didn't necessarily know that

703
00:45:35,760 --> 00:45:38,480
n was bigger than two.

704
00:45:38,560 --> 00:45:41,230
But, we know that n is bigger than n minus one.

705
00:45:41,320 --> 00:45:43,890
That much, I can be sure of.

706
00:45:43,970 --> 00:45:51,360
So, this is one minus alpha n times the sum,

707
00:45:51,440 --> 00:45:56,360
k equals one to n minus one of alpha k over one

708
00:45:56,460 --> 00:46:04,520
minus alpha n times f of x_k, if I got that right.

709
00:46:04,610 --> 00:46:10,680
This is by induction, the induction hypothesis,

710
00:46:10,760 --> 00:46:14,780
because these alpha k's over one minus alpha n sum to one.

711
00:46:14,860 --> 00:46:19,490
Now, these one minus alpha n's cancel,

712
00:46:19,570 --> 00:46:22,010
and we just get what we want.

713
00:46:22,100 --> 00:46:30,380
This is sum k equals one to n of alpha k, f of x_k.

714
00:46:30,470 --> 00:46:35,000
So, we get f of the sum is, at most, sum of the f's.

715
00:46:35,100 --> 00:46:36,910
That proves the lemma.

716
00:46:37,010 --> 00:46:40,750
OK, a bit tedious, but each step is pretty straightforward.

717
00:46:40,830 --> 00:46:43,430
Do you agree?

718
00:46:45,940 --> 00:46:47,330
Now, it turns out to be

719
00:46:47,410 --> 00:46:49,360
relatively straightforward to prove Jensen's inequality.

720
00:46:49,450 --> 00:46:51,760
That's the magic.

721
00:46:58,620 --> 00:47:01,860
And then, we get to do the expectation analysis.

722
00:47:01,940 --> 00:47:08,930
So, we use our good friends, indicator random variables.

723
00:47:09,010 --> 00:47:14,230
OK, but for now, we just want to prove this statement.

724
00:47:18,830 --> 00:47:21,820
If we have a convex function, f of the expectation is,

725
00:47:21,930 --> 00:47:27,350
at most, expectation of f of that random variable.

726
00:47:27,430 --> 00:47:29,870
OK, this is a random variable, right?

727
00:47:29,950 --> 00:47:33,120
If you want to sample from this random variable,

728
00:47:33,200 --> 00:47:35,320
you sample from X, and then you apply f to it.

729
00:47:35,400 --> 00:47:38,870
That's the meaning of this notation, f of X

730
00:47:38,960 --> 00:47:41,960
because X is a random variable.

731
00:47:45,470 --> 00:47:48,570
We get to use that f is convex.

732
00:47:48,660 --> 00:47:52,750
OK, it turns out this is not hard,

733
00:47:52,850 --> 00:47:55,830
if you remember the definition of expectation,

734
00:47:55,930 --> 00:47:58,640
oh, I want to make one more assumption here,

735
00:47:58,730 --> 00:48:04,060
which is that X is integral.

736
00:48:05,220 --> 00:48:07,320
So, it's an integer random variable,

737
00:48:07,400 --> 00:48:11,850
meaning it takes integer values.

738
00:48:11,950 --> 00:48:13,090
OK, that's all we care about

739
00:48:13,220 --> 00:48:14,190
because we're looking at running times.

740
00:48:14,210 --> 00:48:17,380
This statement is true for continuous random variables, too,

741
00:48:17,480 --> 00:48:19,420
but I would like to do the discrete case

742
00:48:19,500 --> 00:48:25,140
because then I get to write down what U of X is.

743
00:48:25,220 --> 00:48:31,360
So, what is the definition of E of X?

744
00:48:32,970 --> 00:48:36,190
X only takes on integer values.

745
00:48:38,030 --> 00:48:40,850
This is easy, but you have to remember it.

746
00:48:43,190 --> 00:48:45,220
It's a good drill.

747
00:48:49,420 --> 00:48:50,850
I don't really know much about X

748
00:48:50,940 --> 00:48:52,940
except that it takes on integer values.

749
00:48:53,020 --> 00:48:57,350
Any suggestions on how I should expand the expectation of X?

750
00:49:07,240 --> 00:49:09,300
How many people know this by heart?

751
00:49:10,230 --> 00:49:12,170
OK, it's not too easy then.

752
00:49:16,170 --> 00:49:19,590
Well, expectation has something to do with probability, right?

753
00:49:20,190 --> 00:49:23,730
So, I should be looking at something like the probability that

754
00:49:23,810 --> 00:49:26,590
X equals some value, x.

755
00:49:26,670 --> 00:49:28,870
That would seem like a good thing to do.

756
00:49:34,100 --> 00:49:36,610
What else goes here?

757
00:49:39,890 --> 00:49:41,560
A sum, yeah.

758
00:49:42,330 --> 00:49:44,660
The sum, well, X could be somewhere

759
00:49:44,750 --> 00:49:46,230
between minus infinity and infinity.

760
00:49:46,310 --> 00:49:47,980
That's certainly true.

761
00:49:48,060 --> 00:49:50,170
And, we have some more?

762
00:49:51,620 --> 00:49:52,800
There's something missing here.

763
00:49:52,880 --> 00:49:56,750
What is this sum? What does it come out to

764
00:49:57,140 --> 00:50:00,220
for any random variable, X, that takes on integer values?

765
00:50:00,700 --> 00:50:02,510
One, good.

766
00:50:02,600 --> 00:50:07,620
So, I need to add in something here, namely X.

767
00:50:08,250 --> 00:50:10,840
OK, that's the definition of the expectation.

768
00:50:10,930 --> 00:50:14,260
Now, f of a sum of things,

769
00:50:14,340 --> 00:50:18,680
where these coefficients sum to one

770
00:50:18,780 --> 00:50:22,260
looks an awful lot like the lemma that we just proved.

771
00:50:22,360 --> 00:50:23,730
OK, we proved it in the finite case.

772
00:50:23,810 --> 00:50:28,860
It turns out, it holds just as well if you take all integers.

773
00:50:28,950 --> 00:50:30,740
So, I'm just going to assume that.

774
00:50:30,820 --> 00:50:37,560
So, I have these probabilities, these alpha values sum to one.

775
00:50:38,460 --> 00:50:40,610
Therefore, I can use this inequality,

776
00:50:40,680 --> 00:50:45,360
that this is, at most, let me get this right,

777
00:50:45,450 --> 00:50:47,460
I have the alphas, so I have a sum,

778
00:50:47,550 --> 00:50:52,610
x equals minus infinity to infinity of the alphas,

779
00:50:52,700 --> 00:50:54,780
which are a probability;

780
00:50:54,870 --> 00:51:02,660
capital X equals little x times f of the value, f of little x.

781
00:51:06,010 --> 00:51:09,410
OK, so there it is. I've used the lemma.

782
00:51:09,480 --> 00:51:14,050
So, maybe now I'll erase the lemma.

783
00:51:21,070 --> 00:51:24,570
OK, I cheated by using the countable version

784
00:51:24,660 --> 00:51:29,120
of the lemma while only proving the finite case.

785
00:51:31,810 --> 00:51:33,890
It's all I can do in lecture.

786
00:51:35,530 --> 00:51:37,240
So, this is by a lemma.

787
00:51:41,910 --> 00:51:45,460
Now, what I'd like to prove and leave some blank space here is

788
00:51:45,540 --> 00:51:48,850
this is, at most, E of f of X,

789
00:51:51,820 --> 00:51:53,320
so that this summation is,

790
00:51:53,410 --> 00:51:55,480
at most, E of f of X.

791
00:51:55,560 --> 00:51:58,800
Actually, it's equal to E of f of X.

792
00:51:59,460 --> 00:52:01,130
And, it really looks kind of equal, right?

793
00:52:01,210 --> 00:52:03,810
You've got sum of some probabilities times f of X.

794
00:52:03,900 --> 00:52:07,740
It almost looks like the definition of E of f of X, but it isn't.

795
00:52:07,830 --> 00:52:10,220
You've got to be a little bit careful because E of f of X

796
00:52:10,310 --> 00:52:12,600
should talk about the probability

797
00:52:12,690 --> 00:52:16,320
that f of X equals a particular value.

798
00:52:16,400 --> 00:52:20,570
We can relate these as follows.

799
00:52:21,010 --> 00:52:22,420
It's not too hard.

800
00:52:26,690 --> 00:52:30,510
You can look at each value that f takes on,

801
00:52:35,130 --> 00:52:36,800
and then look at all the values, k,

802
00:52:36,880 --> 00:52:39,020
that map to that value, x.

803
00:52:39,100 --> 00:52:42,480
So all the k's where f of X equals x,

804
00:52:42,560 --> 00:52:46,830
the probability that X equals k,

805
00:52:47,280 --> 00:52:48,600
OK, this is another way of

806
00:52:48,690 --> 00:52:55,090
writing the probability that f of X equals x.

807
00:52:57,900 --> 00:52:59,110
OK, so, in other words,

808
00:52:59,200 --> 00:53:00,940
I'm grouping the terms in a particular way.

809
00:53:01,030 --> 00:53:05,360
I'm saying, well, f of X takes on various values.

810
00:53:07,950 --> 00:53:10,360
Clever me to switch.

811
00:53:10,450 --> 00:53:12,070
I used to use k's unannounced,

812
00:53:12,160 --> 00:53:13,840
so I better call this something else.

813
00:53:13,930 --> 00:53:19,690
Let's call this Y, sorry, switch notation here.

814
00:53:26,010 --> 00:53:27,270
It makes sense.

815
00:53:27,350 --> 00:53:30,260
I should look at the probability that X equals x.

816
00:53:30,360 --> 00:53:31,650
So, what I really care about is

817
00:53:31,740 --> 00:53:33,170
what this f of X value takes on.

818
00:53:33,250 --> 00:53:34,540
Let's just call it Y,

819
00:53:34,620 --> 00:53:36,910
look at all the values, Y, that f could take on.

820
00:53:37,000 --> 00:53:39,060
That's the range of f. And then,

821
00:53:39,140 --> 00:53:43,160
I'll look at all the different values of X where f of X equals Y.

822
00:53:43,250 --> 00:53:45,480
If I add up those probabilities,

823
00:53:45,560 --> 00:53:47,330
because these are different values of X.

824
00:53:47,410 --> 00:53:50,770
Those are sort of independent events.

825
00:53:50,870 --> 00:53:58,460
So, this summation will be the probability that f of X equals Y.

826
00:53:58,730 --> 00:54:00,400
This is capital X.

827
00:54:00,480 --> 00:54:02,240
This is little y. And then,

828
00:54:02,340 --> 00:54:07,020
if I multiply that by y, I'm getting the expectation of f of X.

829
00:54:07,100 --> 00:54:11,870
So, think about this, these two inequalities hold.

830
00:54:16,680 --> 00:54:18,760
This may be a bit bizarre here

831
00:54:18,850 --> 00:54:21,340
because these sums are potentially infinite.

832
00:54:21,430 --> 00:54:24,450
But, it's true.

833
00:54:27,550 --> 00:54:29,920
OK, this proves Jensen's inequality.

834
00:54:30,000 --> 00:54:32,110
So, it wasn't very hard, just a couple of boards,

835
00:54:32,210 --> 00:54:36,520
once we had this powerful convexity lemma.

836
00:54:37,990 --> 00:54:39,610
So, we just used convexity.

837
00:54:39,710 --> 00:54:42,100
We used the definition of E of X. We used convexity.

838
00:54:42,210 --> 00:54:44,610
That lets us put the f's inside.

839
00:54:44,690 --> 00:54:46,960
Then we do this regrouping of terms, and we figure out,

840
00:54:47,040 --> 00:54:49,130
oh, that's just E of f of X.

841
00:54:49,210 --> 00:54:52,640
So, the only inequality here is coming from convexity.

842
00:54:54,430 --> 00:54:58,200
All right, now comes the algorithms.

843
00:54:58,280 --> 00:55:01,550
So, this was just some basic probability stuff,

844
00:55:01,640 --> 00:55:06,930
which is good to practice.

845
00:55:08,430 --> 00:55:11,760
OK, we could see in the quiz, which is not surprising.

846
00:55:11,840 --> 00:55:14,100
This is the case for me, too.

847
00:55:14,180 --> 00:55:15,940
You have a lot of intuition with algorithms.

848
00:55:16,040 --> 00:55:18,000
Whenever it's algorithmic, it makes a lot of sense

849
00:55:18,100 --> 00:55:20,570
because you're sort of grounded in some things that you know

850
00:55:20,660 --> 00:55:24,980
because you are computer scientists, or something of that ilk.

851
00:55:25,070 --> 00:55:27,620
For the purposes of this class, you are computer scientists.

852
00:55:27,700 --> 00:55:30,500
But, with sort of the basic probability,

853
00:55:30,590 --> 00:55:34,880
unless you happen to be a mathematician, it's less intuitive,

854
00:55:34,970 --> 00:55:38,010
and therefore harder to get fast.

855
00:55:38,090 --> 00:55:41,570
And, in quiz one, speed is pretty important.

856
00:55:41,660 --> 00:55:44,160
On the final, speed will also be important.

857
00:55:44,240 --> 00:55:47,610
The take home certainly doesn't hurt.

858
00:55:47,690 --> 00:55:52,020
So, the take home is more interesting

859
00:55:52,100 --> 00:55:56,890
because it requires being clever.

860
00:55:56,980 --> 00:55:59,240
You have to actually be creative.

861
00:55:59,320 --> 00:56:01,360
And, that really tests algorithmic design.

862
00:56:01,440 --> 00:56:03,540
So far, we've mainly tested analysis, and just,

863
00:56:03,650 --> 00:56:05,490
can you work through probability?

864
00:56:05,570 --> 00:56:06,890
Can you figure out what the,

865
00:56:07,000 --> 00:56:08,940
can you remember what your running time

866
00:56:09,020 --> 00:56:12,780
of randomized quicksort is, and so on?

867
00:56:12,870 --> 00:56:15,480
Quiz two will actually test creativity

868
00:56:15,590 --> 00:56:17,270
because you have more time.

869
00:56:17,350 --> 00:56:20,660
It's hard to be creative in two hours.

870
00:56:20,770 --> 00:56:23,340
OK, so we want to analyze the expected height

871
00:56:23,420 --> 00:56:27,730
of a randomly constructed binary search tree.

872
00:56:27,810 --> 00:56:30,700
So, I've defined this before,

873
00:56:30,800 --> 00:56:32,620
but let me repeat it

874
00:56:32,710 --> 00:56:35,780
because it was a while ago almost at the beginning of lecture.

875
00:56:35,870 --> 00:56:37,860
I'm going to take the random variable

876
00:56:37,950 --> 00:56:45,220
of the height of a randomly built binary search tree on n nodes.

877
00:56:51,470 --> 00:56:54,470
So, that was randomized, the n values.

878
00:56:54,550 --> 00:56:56,080
Take a random permutation,

879
00:56:56,160 --> 00:57:00,450
insert them one by one from left to right with tree insert.

880
00:57:00,530 --> 00:57:02,060
What is the height of the tree that you get?

881
00:57:02,160 --> 00:57:05,160
What is the maximum depth of any node?

882
00:57:05,260 --> 00:57:06,860
I'm not going to look so much at X_n.

883
00:57:06,950 --> 00:57:11,680
I'm going to look at the exponentiation of X_n.

884
00:57:11,770 --> 00:57:14,540
And, still we have no intuition why.

885
00:57:14,630 --> 00:57:17,720
But, two to the X is a convex function.

886
00:57:17,810 --> 00:57:21,790
OK, it looks like that. It's very sharp.

887
00:57:21,870 --> 00:57:25,910
That's the best I can do for drawing, two to the X.

888
00:57:26,000 --> 00:57:27,850
You saw how I drew my histogram.

889
00:57:27,940 --> 00:57:31,300
So, we want to somehow write this random variable

890
00:57:31,400 --> 00:57:34,820
as something, OK, in some algebra.

891
00:57:34,910 --> 00:57:39,810
The main thing here is to split into cases.

892
00:57:39,910 --> 00:57:41,270
That's how we usually go

893
00:57:41,350 --> 00:57:45,670
because there's lots of different scenarios on what happens.

894
00:57:47,330 --> 00:57:51,690
So, I mean, how do we construct a tree from the beginning?

895
00:57:51,790 --> 00:57:54,800
First thing we do is we take the first node.

896
00:57:54,880 --> 00:57:56,660
We throw it in, make it the root.

897
00:57:56,750 --> 00:57:59,810
OK, so whatever the first value happens to be in the array,

898
00:57:59,900 --> 00:58:01,180
which we don't really know how that

899
00:58:01,280 --> 00:58:04,140
falls into sorted order, we put it at the root.

900
00:58:04,240 --> 00:58:05,370
And, it stays the root.

901
00:58:05,470 --> 00:58:07,900
We never change the root from then on.

902
00:58:07,990 --> 00:58:10,190
Now, of all the remaining elements,

903
00:58:10,280 --> 00:58:14,450
some of them are less than this value, and they go over here.

904
00:58:14,550 --> 00:58:17,660
So, let's call this r at the root.

905
00:58:17,750 --> 00:58:20,030
And, some of them are greater than r.

906
00:58:20,130 --> 00:58:21,370
So, they go over here.

907
00:58:21,460 --> 00:58:22,600
Maybe there's more over here.

908
00:58:22,690 --> 00:58:23,960
Maybe there's more over here. Who knows?

909
00:58:24,000 --> 00:58:27,460
Arbitrary partition, in fact, uniformly random partition,

910
00:58:27,540 --> 00:58:29,820
which should sound familiar,

911
00:58:29,910 --> 00:58:32,060
whether there are k elements over here,

912
00:58:32,140 --> 00:58:35,730
and n minus k minus one elements over here,

913
00:58:35,830 --> 00:58:38,710
for any value of k, that's equally likely

914
00:58:38,790 --> 00:58:40,820
because this is chosen uniformly.

915
00:58:40,900 --> 00:58:42,050
The root is chosen uniformly.

916
00:58:42,130 --> 00:58:44,370
It's the first element in a random permutation.

917
00:58:44,460 --> 00:58:47,390
So, what I'm going to do is parameterize by that.

918
00:58:47,470 --> 00:58:48,880
How many elements are over here,

919
00:58:48,970 --> 00:58:50,630
and how many elements are over here?

920
00:58:50,730 --> 00:58:54,830
Because this thing is, again, a randomly built binary search tree

921
00:58:54,920 --> 00:58:56,860
on however many nodes are in there

922
00:58:56,950 --> 00:58:58,140
because after I pick r,

923
00:58:58,230 --> 00:59:00,580
it's determined who is to the left and who is to the right.

924
00:59:00,670 --> 00:59:02,010
And so, I can just partition.

925
00:59:02,100 --> 00:59:03,350
It's like running quicksort.

926
00:59:03,450 --> 00:59:07,170
I partition the elements left of r, the elements right of r,

927
00:59:07,270 --> 00:59:10,250
and I'm sort of recursively constructing

928
00:59:10,340 --> 00:59:14,060
a randomly built binary search tree on those two sub-permutations

929
00:59:14,150 --> 00:59:18,250
because sub-permutations of uniform permutations are uniform.

930
00:59:18,340 --> 00:59:22,150
OK, so these are essentially recursive problems.

931
00:59:22,230 --> 00:59:24,550
And, we know how to analyze recursive problems.

932
00:59:24,640 --> 00:59:27,210
All we need to know is that there are

933
00:59:27,310 --> 00:59:29,310
k minus one elements over here,

934
00:59:29,400 --> 00:59:32,920
and n minus k elements over here.

935
00:59:33,000 --> 00:59:37,900
And, that would mean that r has rank k,

936
00:59:37,990 --> 00:59:42,700
remember, rank in the sense of the index in assorted order.

937
00:59:42,790 --> 00:59:48,160
So, where should I go?

938
01:00:07,600 --> 01:00:15,220
So, if the root, r, has rank, k,

939
01:00:15,300 --> 01:00:19,640
so if this is a statement about condition on this event,

940
01:00:19,720 --> 01:00:24,940
which is a random event, then what we have is X_n equals

941
01:00:25,020 --> 01:00:34,200
one plus the max of X_(k minus one), X_(n minus k)

942
01:00:35,400 --> 01:00:37,170
because the height of this tree is

943
01:00:37,250 --> 01:00:40,630
the max of the heights of the two subtrees plus one

944
01:00:40,720 --> 01:00:43,550
because we have one more level up top.

945
01:00:43,640 --> 01:00:46,250
OK, so that's the natural thing to do.

946
01:00:46,340 --> 01:00:49,840
What we are trying to analyze, though, is Y_n. So, for Y_n,

947
01:00:49,930 --> 01:00:52,520
we have to take two to this power.

948
01:00:52,620 --> 01:00:59,600
So, it's two times the max of two to the X_(k minus one),

949
01:00:59,680 --> 01:01:02,630
which is Y_(k minus one),

950
01:01:02,710 --> 01:01:07,360
and two to this, which is Y_(n minus k).

951
01:01:07,460 --> 01:01:13,160
And, now you start to see, maybe, why we are interested in Y's

952
01:01:13,250 --> 01:01:17,500
instead of X's in the sense that it's what we know how to do.

953
01:01:17,580 --> 01:01:20,480
When we solve a recursion, when we solve,

954
01:01:20,570 --> 01:01:22,480
like, the expected running time,

955
01:01:22,570 --> 01:01:24,710
we haven't taken expectations, yet, here.

956
01:01:24,800 --> 01:01:27,300
But, when we compute the expected running time of quicksort,

957
01:01:27,380 --> 01:01:30,530
we have something like two times, I mean,

958
01:01:30,620 --> 01:01:32,820
we have a couple of recursive subproblems,

959
01:01:32,900 --> 01:01:34,390
which are being added together.

960
01:01:34,480 --> 01:01:36,130
OK, here, we have a factor of two.

961
01:01:36,210 --> 01:01:37,760
Here, we have a max.

962
01:01:37,860 --> 01:01:40,930
But, intuitively, we know how to multiply random variables

963
01:01:41,020 --> 01:01:42,980
by a constant because that's, like,

964
01:01:43,060 --> 01:01:44,280
there's two recursive subproblems

965
01:01:44,370 --> 01:01:47,260
of the size is equal to the max of these two,

966
01:01:47,350 --> 01:01:49,100
which we don't happen to know here.

967
01:01:49,190 --> 01:01:52,290
But, there it is, whereas one plus,

968
01:01:52,380 --> 01:01:54,530
we don't know how to handle so well.

969
01:01:54,620 --> 01:01:56,130
And, indeed, our techniques

970
01:01:56,220 --> 01:01:58,290
are really good at solving recurrences,

971
01:01:58,370 --> 01:02:00,760
except up to the constant factors.

972
01:02:00,850 --> 01:02:03,560
And, this one plus really doesn't affect

973
01:02:03,650 --> 01:02:05,280
the constant factor too much, it would seem.

974
01:02:05,360 --> 01:02:07,540
OK, but it's a big deal.

975
01:02:07,630 --> 01:02:09,390
In exponentiation, it's a factor of two.

976
01:02:09,490 --> 01:02:11,770
So here, it's really hard to see what this one plus is doing.

977
01:02:11,860 --> 01:02:13,410
And, our analysis, if we tried it,

978
01:02:13,510 --> 01:02:16,990
and it's a good idea to try it at home and see what happens,

979
01:02:17,080 --> 01:02:19,850
if you tried to do what I'm about to do with X_n,

980
01:02:19,940 --> 01:02:23,040
the one plus will sort of get lost, and you won't get a bound.

981
01:02:23,140 --> 01:02:25,350
You just can't prove anything.

982
01:02:25,430 --> 01:02:27,210
With a factor of two, we're in good shape.

983
01:02:27,290 --> 01:02:29,680
We sort of know how to deal with that.

984
01:02:29,770 --> 01:02:34,260
We'll say more when we've actually done the proof

985
01:02:36,540 --> 01:02:39,010
about why we use Y_n instead of X_n.

986
01:02:39,100 --> 01:02:40,560
But for now, we're using Y_n.

987
01:02:40,640 --> 01:02:42,020
So, this is sort of a recursion,

988
01:02:42,100 --> 01:02:44,070
except it's conditioned on this event.

989
01:02:44,150 --> 01:02:48,330
So, how do I turn this into a statement that holds all the time?

990
01:02:58,670 --> 01:03:02,320
Sorry? Divide by the probability of the event?

991
01:03:02,400 --> 01:03:09,370
More or less. Indeed, these events are independent.

992
01:03:09,460 --> 01:03:10,890
Or, they're all equally likely, I should say.

993
01:03:10,990 --> 01:03:12,140
They're not independent.

994
01:03:12,230 --> 01:03:14,720
In fact, one determines all the others.

995
01:03:15,510 --> 01:03:20,560
So, how do I generally represent an event in algebra?

996
01:03:24,060 --> 01:03:27,870
Indicator random variables: good.

997
01:03:30,420 --> 01:03:33,930
Remember your friends, indicator random variables.

998
01:03:34,020 --> 01:03:37,710
All of these analyses use indicator random variables.

999
01:03:37,800 --> 01:03:40,650
So, they will just represent this event,

1000
01:03:40,730 --> 01:03:45,260
and we'll call it Z_nk.

1001
01:03:47,440 --> 01:03:52,560
It's going to be one if the root has rank, k,

1002
01:03:55,900 --> 01:03:57,830
and zero otherwise.

1003
01:04:03,310 --> 01:04:07,130
So, in particular, the probability of,

1004
01:04:07,210 --> 01:04:09,110
these things are all equally likely for,

1005
01:04:09,190 --> 01:04:11,980
a particular value of n if you try all the values of k.

1006
01:04:12,070 --> 01:04:14,130
The probability that this equals one,

1007
01:04:14,220 --> 01:04:22,000
which is also the expectation of that indicator random variable,

1008
01:04:22,080 --> 01:04:25,400
which you should know, is it only takes values one or zero.

1009
01:04:25,480 --> 01:04:27,730
The zero doesn't matter in the expectation.

1010
01:04:27,810 --> 01:04:31,720
So, this is going to be, hopefully,

1011
01:04:31,810 --> 01:04:33,900
one over n if I got right.

1012
01:04:34,000 --> 01:04:35,600
So, there are n possibility

1013
01:04:35,690 --> 01:04:36,920
of what the rank of the root could be.

1014
01:04:37,010 --> 01:04:38,190
Each of them are equally likely

1015
01:04:38,280 --> 01:04:41,510
because we have a uniform permutation.

1016
01:04:41,600 --> 01:04:45,930
So, now, I can rewrite this condition statement

1017
01:04:46,010 --> 01:04:49,210
as a summation where the Z_nk's

1018
01:04:49,290 --> 01:04:52,290
will let me choose what case I'm in.

1019
01:04:52,800 --> 01:05:00,560
So, we have Y_n is the sum, k equals one to n of Z_nk

1020
01:05:00,640 --> 01:05:07,710
times two times the max of X, sorry,

1021
01:05:08,110 --> 01:05:14,060
Y, k minus one, Y_n minus k.

1022
01:05:18,370 --> 01:05:21,550
So, now we have our good friend, the recurrence.

1023
01:05:21,650 --> 01:05:23,080
We need to solve it.

1024
01:05:23,170 --> 01:05:24,870
OK, we can't really solve it

1025
01:05:24,960 --> 01:05:26,100
because this is a random variable,

1026
01:05:26,190 --> 01:05:28,160
and it's talking about recursive random variables.

1027
01:05:28,250 --> 01:05:30,720
So, we first take the expectation of both sides.

1028
01:05:30,810 --> 01:05:34,130
That's the only thing we can really bound.

1029
01:05:34,210 --> 01:05:39,200
Y_n could be n^2 in an unlucky case, sorry, not n^2.

1030
01:05:39,280 --> 01:05:41,950
It could be n^2.

1031
01:05:42,030 --> 01:05:47,570
It could be two to the, boy, two to the n if you are unlucky

1032
01:05:47,660 --> 01:05:50,880
because X_n could be as big as n, the height of the tree.

1033
01:05:50,960 --> 01:05:53,500
And, Y_n is two to that.

1034
01:05:53,590 --> 01:05:54,830
So, it could be two to the n.

1035
01:05:54,910 --> 01:05:58,800
What we want to prove is that it's polynomial in n.

1036
01:05:58,890 --> 01:06:00,020
If it's n to some constant,

1037
01:06:00,100 --> 01:06:02,720
and we take logs, it'll be order log n.

1038
01:06:02,800 --> 01:06:05,480
OK, so we'll take the expectation,

1039
01:06:05,560 --> 01:06:08,410
and hopefully that will guarantee that this holds.

1040
01:06:08,490 --> 01:06:12,750
OK, so we have expectation of this summation

1041
01:06:12,840 --> 01:06:19,710
of random variables times recursive random variables.

1042
01:06:24,700 --> 01:06:27,790
So, what is the first, woops, I forgot a bracket.

1043
01:06:27,880 --> 01:06:34,200
What is the first thing that we do in this analysis?

1044
01:06:36,390 --> 01:06:40,730
This should, yeah, linearity of expectation.

1045
01:06:40,820 --> 01:06:43,430
That one's easy to remember.

1046
01:06:44,260 --> 01:06:47,980
OK, we have a sum. So, let's put the E inside.

1047
01:07:02,930 --> 01:07:07,360
OK, now we have the expectation of our product.

1048
01:07:07,450 --> 01:07:11,680
What should we use? Independence.

1049
01:07:11,780 --> 01:07:13,710
Hopefully, things are independent.

1050
01:07:13,800 --> 01:07:17,200
And then, we could write this.

1051
01:07:19,900 --> 01:07:23,080
Then, it would be the expectation of the product.

1052
01:07:23,160 --> 01:07:24,800
And, heck, let's put the two outside,

1053
01:07:24,870 --> 01:07:29,630
because it's not, no sense in keeping it in here.

1054
01:07:34,920 --> 01:07:36,320
Y is there starting to look like X's?

1055
01:07:36,410 --> 01:07:38,410
I can't even read them. Sorry about that.

1056
01:07:38,500 --> 01:07:40,960
This should all be Y's.

1057
01:07:46,920 --> 01:07:51,100
OK, very wise, random variables.

1058
01:07:51,190 --> 01:07:54,930
So. Why are these independent?

1059
01:07:55,010 --> 01:07:57,940
So, here we are looking at the choice of what the root is,

1060
01:07:58,020 --> 01:08:01,500
what rank the root has in a problem of size n.

1061
01:08:01,600 --> 01:08:05,460
In here, we're looking at what the root, I mean,

1062
01:08:05,540 --> 01:08:07,570
there are various choices of what the search tree

1063
01:08:07,670 --> 01:08:09,600
looks like in the stuff left of the root,

1064
01:08:09,690 --> 01:08:11,090
and in the stuff right of the root.

1065
01:08:11,200 --> 01:08:12,490
Those are independent choices

1066
01:08:12,570 --> 01:08:14,930
because everything is uniform here.

1067
01:08:15,010 --> 01:08:17,340
So, the choice of this guy was uniform.

1068
01:08:17,420 --> 01:08:19,410
And then, that determines

1069
01:08:19,490 --> 01:08:21,010
who partitions in the left and the right.

1070
01:08:21,100 --> 01:08:24,060
Those are completely independent recursive choices

1071
01:08:24,150 --> 01:08:26,370
of who's the root in the left subtree?

1072
01:08:26,460 --> 01:08:29,010
Who's the root in the left of the left subtree, and so on?

1073
01:08:29,100 --> 01:08:30,840
So, this is a little trickier than usual.

1074
01:08:30,930 --> 01:08:33,960
Before, it was random choices in the algorithm.

1075
01:08:34,060 --> 01:08:36,400
Now, it's in some construction

1076
01:08:36,490 --> 01:08:39,240
where we choose the random numbers ahead of time.

1077
01:08:39,330 --> 01:08:41,750
It's a bit funny, but this is still independent.

1078
01:08:41,840 --> 01:08:46,310
So, we get this just like we did in quicksort, and so on.

1079
01:08:48,210 --> 01:08:54,820
OK. Now, we continue.

1080
01:09:02,080 --> 01:09:05,020
And, now it's time to be a bit sloppy.

1081
01:09:06,030 --> 01:09:08,050
Well, one of these things we know.

1082
01:09:08,140 --> 01:09:12,750
OK, E of ZNK, that, we wrote over here.

1083
01:09:12,840 --> 01:09:16,910
It's one over n. So, that's cool.

1084
01:09:17,000 --> 01:09:18,910
So, we get a two over n outside,

1085
01:09:19,000 --> 01:09:21,300
and we get this sum of the expectation

1086
01:09:21,390 --> 01:09:24,060
of a max of these two things.

1087
01:09:24,140 --> 01:09:25,760
Normally, we would write, well,

1088
01:09:25,850 --> 01:09:28,300
I think sometimes you write T of max,

1089
01:09:28,400 --> 01:09:30,230
or Y of the max of the two things here.

1090
01:09:30,320 --> 01:09:33,800
You've got to write it as the max of these two variables.

1091
01:09:33,880 --> 01:09:38,340
And, the trick, I mean, it's not too much of a trick,

1092
01:09:38,420 --> 01:09:42,110
is that the max is, at most, the sum.

1093
01:09:42,200 --> 01:09:44,160
So, we have nonnegative things.

1094
01:09:44,240 --> 01:09:50,260
So, we have two over n, sum k equals one to n

1095
01:09:50,350 --> 01:09:59,150
of the expectation of the sum instead of the max.

1096
01:10:02,660 --> 01:10:05,060
OK, this is, in some sense, the key step

1097
01:10:05,150 --> 01:10:07,820
where we are losing something in our bound.

1098
01:10:07,900 --> 01:10:09,130
So far, we've been exact.

1099
01:10:09,220 --> 01:10:11,810
Now, we're being pretty sloppy.

1100
01:10:11,890 --> 01:10:14,130
It's true the max is, at most, the sum.

1101
01:10:14,210 --> 01:10:17,120
But, it's a pretty loose upper bound as things go.

1102
01:10:17,210 --> 01:10:20,840
We'll keep that in mind for later.

1103
01:10:20,930 --> 01:10:23,990
What else can we do with the summation?

1104
01:10:26,140 --> 01:10:28,420
This should, again, look familiar.

1105
01:10:28,490 --> 01:10:30,890
Now that we have a sum of a sum of two things,

1106
01:10:30,980 --> 01:10:35,630
I'm trying to like it to be a sum of one thing.

1107
01:10:41,120 --> 01:10:44,480
Sorry? You can use linearity of expectation, good.

1108
01:10:44,570 --> 01:10:47,000
So, that's the first thing I should do.

1109
01:10:50,360 --> 01:10:52,310
So, linearity of expectation lets me separate that.

1110
01:10:52,410 --> 01:10:55,340
Now I have a sum of 2n things.

1111
01:10:58,690 --> 01:11:01,110
Right, I could break that into the sum of these guys,

1112
01:11:01,210 --> 01:11:03,350
and the sum of these guys.

1113
01:11:03,440 --> 01:11:06,830
Do you know anything about those two sums?

1114
01:11:07,680 --> 01:11:10,140
Do we know anything about those two sums?

1115
01:11:10,570 --> 01:11:12,050
They're the same. In fact,

1116
01:11:12,140 --> 01:11:14,430
every term here is appearing exactly twice.

1117
01:11:14,510 --> 01:11:15,940
One says a k minus one.

1118
01:11:16,030 --> 01:11:17,190
One says an n minus k,

1119
01:11:17,270 --> 01:11:19,890
and that even works if it's odd, I think.

1120
01:11:19,990 --> 01:11:22,720
So, in fact, we can just take one of the sums

1121
01:11:22,810 --> 01:11:25,320
and multiply it by two.

1122
01:11:25,410 --> 01:11:28,070
So, this is four over n times the sum,

1123
01:11:28,150 --> 01:11:29,810
and I'll rewrite it a little bit

1124
01:11:29,890 --> 01:11:34,630
from zero to n minus one of E of Y_k.

1125
01:11:34,720 --> 01:11:36,380
Just check the number of times each Y_k

1126
01:11:36,480 --> 01:11:39,810
appears from zero up to n minus one is exactly two.

1127
01:11:39,890 --> 01:11:41,760
So, now I have a recurrence.

1128
01:11:41,850 --> 01:11:44,940
I have E of Y_n is, at most, this thing.

1129
01:11:45,030 --> 01:11:49,350
Let's just write that for our memory.

1130
01:11:51,040 --> 01:11:53,710
So, how's that? Cool.

1131
01:11:53,800 --> 01:11:56,710
Now, I just have to solve the recurrence.

1132
01:11:56,800 --> 01:12:00,030
How should I solve an ugly, hairy, recurrence like this?

1133
01:12:00,120 --> 01:12:07,460
Substitution: yea! Not the master method.

1134
01:12:08,890 --> 01:12:10,720
OK, it's a pretty nasty recurrence.

1135
01:12:10,810 --> 01:12:12,150
So, I'm going to make a guess,

1136
01:12:12,250 --> 01:12:16,750
and I've already told you the guess, that it's n^3.

1137
01:12:21,060 --> 01:12:23,330
I think n^3 is pretty much exactly

1138
01:12:23,430 --> 01:12:27,440
where this proof will be obtainable.

1139
01:12:30,670 --> 01:12:35,010
So, substitution method, substitution method

1140
01:12:35,130 --> 01:12:37,410
is just a proof by induction.

1141
01:12:41,200 --> 01:12:44,860
And, there are two things every proof by induction should have,

1142
01:12:44,960 --> 01:12:48,520
well, almost every proof by induction, unless you're being fancy.

1143
01:12:48,620 --> 01:12:49,890
It should have a base case,

1144
01:12:50,020 --> 01:12:51,660
and the base case here is n equals order one.

1145
01:12:51,760 --> 01:12:53,140
I didn't write it, but, of course,

1146
01:12:53,250 --> 01:12:55,720
if you have a constant size tree, it has constant height.

1147
01:12:55,820 --> 01:12:58,250
So, this thing will be true

1148
01:12:58,350 --> 01:13:07,260
as long as we set true if c is sufficiently large.

1149
01:13:12,850 --> 01:13:14,930
OK, so, don't forget that.

1150
01:13:15,030 --> 01:13:16,800
A lot of people forgot it on the quiz.

1151
01:13:16,900 --> 01:13:20,280
We even mentioned the base case.

1152
01:13:20,420 --> 01:13:22,250
Usually, we don't even mention the base case.

1153
01:13:22,360 --> 01:13:23,720
And, you should assume that there's one there.

1154
01:13:23,820 --> 01:13:26,900
And, you have to say this in any proof by substitution.

1155
01:13:27,010 --> 01:13:32,600
OK, now, we have the induction step.

1156
01:13:34,360 --> 01:13:36,930
So, I claim that E of Y_n is, at most, C of n^3,

1157
01:13:37,040 --> 01:13:39,100
assuming that it's true for smaller n.

1158
01:13:39,210 --> 01:13:41,360
You should write the induction hypothesis here,

1159
01:13:41,480 --> 01:13:44,070
but I'm going to skip it because I'm running out of time.

1160
01:13:44,170 --> 01:13:46,920
Now, we have this recurrence

1161
01:13:47,040 --> 01:13:50,300
that E of Y_n is, at most, this thing.

1162
01:13:50,830 --> 01:13:53,550
So, E of Y_n is, at most, four over n,

1163
01:13:53,670 --> 01:14:02,720
sum k equals zero to n minus one of E of Y_k.

1164
01:14:02,810 --> 01:14:06,280
Now, notice that k is always smaller than n.

1165
01:14:06,370 --> 01:14:08,800
So, we can apply induction.

1166
01:14:08,900 --> 01:14:12,880
So, this is, at most, four over n,

1167
01:14:12,990 --> 01:14:20,000
sum k equals zero to n minus one of c times k^3.

1168
01:14:20,100 --> 01:14:23,650
That's the induction hypothesis.

1169
01:14:25,970 --> 01:14:31,750
Cool. Now, I need an upper bound on this sum,

1170
01:14:31,860 --> 01:14:35,740
if you have a good memory,

1171
01:14:35,860 --> 01:14:38,160
then you know a closed form for this sum.

1172
01:14:38,260 --> 01:14:40,870
But, I don't have such a good memory as I used to.

1173
01:14:41,060 --> 01:14:42,830
I never memorized this sum when I was a kid,

1174
01:14:42,950 --> 01:14:45,580
so I don't remember everything

1175
01:14:45,680 --> 01:14:48,160
when I memorize when I was less than 12 years old.

1176
01:14:48,260 --> 01:14:51,300
I still remember all the digits of pi, whatever.

1177
01:14:51,400 --> 01:14:53,390
But, anything I try to memorize now

1178
01:14:53,490 --> 01:14:55,700
just doesn't quite stick the same way.

1179
01:14:55,820 --> 01:14:58,300
So, I don't happen to know this sum.

1180
01:14:58,460 --> 01:15:02,120
What's a good way to approximate this sum?

1181
01:15:03,470 --> 01:15:05,080
Integral: good.

1182
01:15:06,740 --> 01:15:11,060
So, in fact, I'm going to take the c outside.

1183
01:15:11,170 --> 01:15:13,450
So, this is 4c over n.

1184
01:15:13,550 --> 01:15:15,560
The sum is, at most, the integral.

1185
01:15:15,680 --> 01:15:18,550
If you get the range right, so, you have to go one larger.

1186
01:15:18,780 --> 01:15:21,190
Instead of n minus one, you go up to n.

1187
01:15:22,080 --> 01:15:24,720
This is in the textbook.

1188
01:15:24,830 --> 01:15:27,570
It's intuitive, too, as long as you have a monotone function. That's key

1189
01:15:27,670 --> 01:15:29,640
So, you have something that's like this.

1190
01:15:29,880 --> 01:15:32,960
And, you know, the sum is taking each of these

1191
01:15:33,060 --> 01:15:36,590
and weighting them with a value of one.

1192
01:15:36,710 --> 01:15:39,830
The integral is computing the area under this curve.

1193
01:15:39,970 --> 01:15:41,730
So, in particular, if you look at

1194
01:15:41,830 --> 01:15:43,230
this approximation of the integral,

1195
01:15:43,340 --> 01:15:45,700
then, I mean, this thing is certainly,

1196
01:15:45,810 --> 01:15:50,110
this would be the sum if you go one larger at the end,

1197
01:15:50,220 --> 01:15:51,710
and that's, at most, the integral.

1198
01:15:51,820 --> 01:15:53,170
So, that's proof by picture.

1199
01:15:53,350 --> 01:15:55,970
But, you can see this in the book.

1200
01:15:56,080 --> 01:15:58,800
You should know it from 042 I guess.

1201
01:15:58,900 --> 01:16:01,620
Now, integrals, hopefully, you can solve.

1202
01:16:01,810 --> 01:16:07,350
Integral of x^3 is x^4 over four.

1203
01:16:07,470 --> 01:16:10,080
I got it right. And then, we're valuing that at n.

1204
01:16:10,200 --> 01:16:13,380
And, it's zero. Subtracting the zero doesn't matter

1205
01:16:13,480 --> 01:16:16,070
because zero to the fourth power is zero.

1206
01:16:16,170 --> 01:16:19,890
So, it's just n^4 over four.

1207
01:16:20,020 --> 01:16:24,900
So, this is 4c over n times n^4 over four.

1208
01:16:25,000 --> 01:16:28,540
And, conveniently, this four cancels with this four.

1209
01:16:28,660 --> 01:16:30,830
The four turns into a three because of this,

1210
01:16:30,930 --> 01:16:33,900
and we get n^3.

1211
01:16:34,010 --> 01:16:37,880
We get cn^3. Damn convenient,

1212
01:16:37,990 --> 01:16:40,420
because that's what we wanted to prove.

1213
01:16:40,520 --> 01:16:46,700
OK, so this proof is just barely snaking by: no residual term.

1214
01:16:46,810 --> 01:16:49,830
We've been sloppy all over the place,

1215
01:16:49,940 --> 01:16:51,520
and yet we were really lucky.

1216
01:16:51,800 --> 01:16:53,800
And, we were just sloppy in the right places.

1217
01:16:54,110 --> 01:16:55,480
So, this is a very tricky proof.

1218
01:16:55,590 --> 01:16:57,470
If you just tried to do it by hand,

1219
01:16:57,570 --> 01:16:59,750
it's pretty easy to be too sloppy,

1220
01:16:59,840 --> 01:17:03,250
and not get quite the right answer.

1221
01:17:03,360 --> 01:17:05,030
But, this just barely works.

1222
01:17:05,130 --> 01:17:08,690
So, let me say a couple of things about it

1223
01:17:08,800 --> 01:17:11,700
in my remaining one minute.

1224
01:17:11,790 --> 01:17:13,860
So, we can do the conclusion, again.

1225
01:17:13,960 --> 01:17:17,250
I won't write it because I don't have time,

1226
01:17:17,370 --> 01:17:21,740
but here it is. We just proved a bound on Y_n,

1227
01:17:21,870 --> 01:17:23,220
which was two to the power X_n.

1228
01:17:23,620 --> 01:17:26,300
What we cared about was X_n.

1229
01:17:26,420 --> 01:17:27,790
So, we used Jensen's inequality.

1230
01:17:27,900 --> 01:17:31,960
We get the two to the E of X_n is, at most, E of two to the X_n.

1231
01:17:32,060 --> 01:17:34,630
This is what we know about because that's Y_n.

1232
01:17:34,730 --> 01:17:38,000
So, we know E of Y_n is now order n^3.

1233
01:17:38,100 --> 01:17:40,060
OK, we had to set this constant

1234
01:17:40,160 --> 01:17:41,570
sufficiently large for the base case.

1235
01:17:41,670 --> 01:17:43,610
We didn't really figure out what the constant was here.

1236
01:17:43,800 --> 01:17:46,820
It didn't matter because now we're taking the logs of both sides.

1237
01:17:46,910 --> 01:17:50,080
We get E of X_n is, at most, log of order n^3.

1238
01:17:50,220 --> 01:17:52,080
This constant is a multiplicative constant.

1239
01:17:52,370 --> 01:17:54,160
So, you take the logs. It becomes additive.

1240
01:17:54,290 --> 01:17:56,890
This constant is an exponent.

1241
01:17:57,030 --> 01:17:59,710
So, it would take logs. It becomes a multiple.

1242
01:17:59,820 --> 01:18:01,680
Three log n plus order one.

1243
01:18:01,790 --> 01:18:06,040
This is a pretty damn tight bound on the height

1244
01:18:06,140 --> 01:18:08,270
of a randomly built binary search tree,

1245
01:18:08,370 --> 01:18:10,410
the expected height, I should say.

1246
01:18:10,510 --> 01:18:14,240
In fact, the expected height of X_n

1247
01:18:15,310 --> 01:18:23,850
is equal to, well, roughly, I'll just say it's roughly,

1248
01:18:23,940 --> 01:18:30,830
I don't want to be too precise here, 2.9882 times log n.

1249
01:18:30,930 --> 01:18:34,250
This is the result by a friend of mine,

1250
01:18:34,680 --> 01:18:42,280
Luke Devroy, if I spell it right, in 1986.

1251
01:18:45,720 --> 01:18:49,620
He's a professor at McGill University in Montreal.

1252
01:18:49,730 --> 01:18:53,140
So, we're pretty close, three to 2.98.

1253
01:18:53,250 --> 01:18:54,590
And, I won't prove this here.

1254
01:18:54,790 --> 01:18:56,120
The hard part here is actually the lower bound,

1255
01:18:56,220 --> 01:18:59,420
but it's only that much.

1256
01:18:59,550 --> 01:19:02,320
I should say a little bit more about

1257
01:19:02,420 --> 01:19:04,290
why we use Y_n instead of X_n.

1258
01:19:04,480 --> 01:19:06,070
And, it's all about the sloppiness.

1259
01:19:06,180 --> 01:19:09,650
And, in particular, this step, where we said that

1260
01:19:09,750 --> 01:19:13,840
the max of these two random variables is, at most, the sum.

1261
01:19:14,010 --> 01:19:16,770
And, while that's true for X just

1262
01:19:16,880 --> 01:19:20,830
as well as it is true for Y, it's more true for Y.

1263
01:19:20,960 --> 01:19:24,560
OK, this is a bit weird because, remember,

1264
01:19:24,660 --> 01:19:27,800
what we're analyzing here is all possible values of k.

1265
01:19:27,900 --> 01:19:31,170
This has to work no matter what k is, in some sense.

1266
01:19:31,290 --> 01:19:33,530
I mean, we're bounding all of those cases simultaneously,

1267
01:19:33,640 --> 01:19:35,420
the sum of them all.

1268
01:19:35,550 --> 01:19:39,850
So, here we're looking at k minus one versus n minus k.

1269
01:19:39,950 --> 01:19:42,990
And, in fact, here, there's a polynomial version.

1270
01:19:43,090 --> 01:19:50,540
But, so, if you take two values a and b, and you say,

1271
01:19:50,660 --> 01:19:55,140
well, max of ab is, at most, a plus b.

1272
01:19:55,240 --> 01:19:57,060
And, on the other hand you say, well,

1273
01:19:57,160 --> 01:20:01,020
max of two to the a and two to the b is,

1274
01:20:01,130 --> 01:20:04,230
at most, two to the a plus two to the b.

1275
01:20:04,380 --> 01:20:05,750
Doesn't this feel better than that?

1276
01:20:05,860 --> 01:20:07,660
Well, they are, of course, the same.

1277
01:20:07,760 --> 01:20:14,470
But, if you look at a minus b, as that grows,

1278
01:20:14,600 --> 01:20:17,110
this becomes a tighter bound faster

1279
01:20:17,220 --> 01:20:20,330
than this becomes a tighter bound

1280
01:20:20,440 --> 01:20:21,650
because here we're looking at

1281
01:20:21,740 --> 01:20:24,870
absolute difference between a minus b.

1282
01:20:25,030 --> 01:20:29,660
So, that's why this is pretty good and this is pretty bad.

1283
01:20:29,790 --> 01:20:32,720
We're still really bad if a and b are almost the same.

1284
01:20:32,820 --> 01:20:34,410
But, we're trying to solve this

1285
01:20:34,520 --> 01:20:38,880
for all partitions into k minus one and n minus k.

1286
01:20:38,980 --> 01:20:40,500
So, it's OK if we get a few of the cases wrong

1287
01:20:40,640 --> 01:20:42,790
in the middle where it evenly partitions.

1288
01:20:42,890 --> 01:20:44,420
But, as soon as we get some skew,

1289
01:20:44,570 --> 01:20:47,200
this will be very close to this,

1290
01:20:47,340 --> 01:20:49,530
whereas this will be still pretty far from this.

1291
01:20:49,630 --> 01:20:51,010
You have to get pretty close to the edge

1292
01:20:51,130 --> 01:20:52,800
before you're not losing much here,

1293
01:20:52,900 --> 01:20:55,360
whereas pretty quickly you're not losing much here.

1294
01:20:55,460 --> 01:20:56,710
That's the intuition.

1295
01:20:56,820 --> 01:20:58,690
Try it, and see what happens with X_n,

1296
01:20:58,790 --> 01:21:01,840
and it won't work.

1297
01:21:02,800 --> 01:21:04,240
See you Wednesday.

