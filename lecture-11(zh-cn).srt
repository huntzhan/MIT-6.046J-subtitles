1
00:00:06,630 --> 00:00:12,290
早上好 今天我们

2
00:00:12,750 --> 00:00:15,610
要讲的是扩充的数据结构

3
00:00:24,530 --> 00:00:28,620
这是一个——

4
00:00:28,920 --> 00:00:34,040
通常来讲 与其凭空设计一个新的数据结构

5
00:00:34,420 --> 00:00:37,520
你会更倾向于拿一个现成的数据结构

6
00:00:37,700 --> 00:00:40,100
添加你需要的功能

7
00:00:40,410 --> 00:00:44,250
我们把这个过程称之为数据结构的扩充

8
00:00:44,490 --> 00:00:48,470
也就是说 从今天起我们要开始

9
00:00:48,680 --> 00:00:50,180
进入到设计的阶段

10
00:00:50,290 --> 00:00:53,050
到目前为止我们花了很多时间来分析

11
00:00:53,240 --> 00:00:57,120
我们也将学习到一些新的分析技术

12
00:00:57,300 --> 00:00:59,750
不过现在 我们要把更多注意力放在

13
00:01:00,000 --> 00:01:02,520
如何设计高效的数据结构

14
00:01:02,740 --> 00:01:05,020
以及高效的算法来应对各种问题

15
00:01:05,240 --> 00:01:08,860
在设计阶段中 这是个很好的例子

16
00:01:09,050 --> 00:01:13,980
如果现在你还没有看过课本上的附录B的话

17
00:01:14,170 --> 00:01:18,660
我强烈推荐你去看看

18
00:01:18,910 --> 00:01:23,470
你可以把它当成附加阅读材料

19
00:01:23,730 --> 00:01:24,950
确保你对它足够熟悉

20
00:01:25,170 --> 00:01:27,680
因为接下来几周里我们会

21
00:01:27,880 --> 00:01:30,700
用到附录B里的很多很多东西

22
00:01:30,950 --> 00:01:32,650
它与我们现在的主题

23
00:01:32,840 --> 00:01:34,640
息息相关

24
00:01:34,840 --> 00:01:37,460
如果你们一边忙着学习新的知识点

25
00:01:37,710 --> 00:01:39,300
一边又想学习附录B里的东西

26
00:01:39,400 --> 00:01:40,680
那样还莫不如

27
00:01:40,690 --> 00:01:42,750
现在简单的回顾一下附录B

28
00:01:44,070 --> 00:01:47,210
我们首先来看一个

29
00:01:47,500 --> 00:01:52,730
一个动态有序统计的例子

30
00:01:58,410 --> 00:02:01,760
我们对查找都比较熟悉

31
00:02:01,950 --> 00:02:06,240
诸如找一个序列的中间的数 或者是第k个数什么的

32
00:02:06,430 --> 00:02:08,120
现在我们也是做同样的事

33
00:02:08,350 --> 00:02:10,390
不过这次是在一个动态集合上

34
00:02:10,620 --> 00:02:12,810
数据不再是一下子全部直接列出了

35
00:02:13,050 --> 00:02:15,010
而是以集合的形式出现  在某些情况下

36
00:02:15,020 --> 00:02:18,410
也会有像插入和删除这样的经典操作

37
00:02:18,610 --> 00:02:20,960
而在另一些情况下 有人却想

38
00:02:21,180 --> 00:02:29,050
把第i大的数或者第i小的数找出来

39
00:02:40,220 --> 00:02:53,180
这次是动态集  又或者像查找x的序之类的

40
00:02:57,530 --> 00:03:07,420
就是将集合排序后 返回x处在第几个位置上

41
00:03:11,000 --> 00:03:17,230
比如给你n/2这个数

42
00:03:17,530 --> 00:03:19,690
假设集合里有n个元素 我想求第n/2个

43
00:03:19,880 --> 00:03:21,010
我想求集合里的中位数

44
00:03:21,190 --> 00:03:22,410
我也可能求平均值

45
00:03:22,560 --> 00:03:23,960
也可能求四分位数

46
00:03:24,120 --> 00:03:25,820
我现在取一个集合里的元素

47
00:03:25,960 --> 00:03:27,990
我想知道这个元素

48
00:03:28,130 --> 00:03:30,890
处于集合中的哪个位置

49
00:03:31,060 --> 00:03:34,000
还有 我想要的是动态的集合

50
00:03:34,170 --> 00:03:36,750
所以我需要这个集合可以进行插入和删除的操作

51
00:03:38,700 --> 00:03:41,870
我要给它添加和移除元素

52
00:03:42,110 --> 00:03:45,100
如何解决这个问题呢？

53
00:03:45,300 --> 00:03:53,350
基本的思想是在红黑树的结点上

54
00:03:56,430 --> 00:04:03,160
记录下该结点的子树的大小

55
00:04:06,640 --> 00:04:10,050
我来画个图说明一下

56
00:04:27,880 --> 00:04:38,060
这个树里——我没画那些空结点

57
00:04:38,220 --> 00:04:43,190
我在结点上记录两个值 我会记录键值

58
00:04:43,420 --> 00:04:45,320
这些键值

59
00:04:45,590 --> 00:04:48,620
我用英文字母来表示

60
00:05:05,690 --> 00:05:07,100
这是一个红黑树

61
00:05:07,340 --> 00:05:10,900
那么来练习一下 我如何把这个树

62
00:05:11,190 --> 00:05:12,530
按照红黑树的形式来标记？

63
00:05:12,700 --> 00:05:13,780
我没画那些空结点

64
00:05:13,940 --> 00:05:15,520
那些空结点都是黑色的

65
00:05:18,000 --> 00:05:24,820
我怎么用红黑来进行标记？

66
00:05:25,030 --> 00:05:28,060
从而确保满足红黑树的条件

67
00:05:28,870 --> 00:05:32,260
不是所有树都能标记成红黑树的 对吧

68
00:05:35,870 --> 00:05:38,300
这个练习挺好的

69
00:05:38,510 --> 00:05:40,430
我们可能会在小测试里考到

70
00:05:40,730 --> 00:05:48,620
把F标记成红色 很好 然后其他都是黑色

71
00:05:48,810 --> 00:05:51,360
这肯定是正确答案之一

72
00:05:51,620 --> 00:05:56,850
因为这实际上是把P、H的提升了一层

73
00:05:57,120 --> 00:05:59,070
其实我有一个更复杂的方案

74
00:05:59,320 --> 00:06:00,660
因为复杂的方案更有趣一些

75
00:06:00,860 --> 00:06:04,650
这个方案就是把这个结点标成黑色

76
00:06:05,460 --> 00:06:10,880
这两个是红色的 然后黑色 红色

77
00:06:11,130 --> 00:06:15,900
黑 红 黑 黑

78
00:06:16,140 --> 00:06:20,730
当然你提出的方案也很好

79
00:06:21,020 --> 00:06:25,840
这样所有路径上都没有两个连续的红色结点

80
00:06:26,070 --> 00:06:33,160
而且从任一结点到其每个叶子的所有路径

81
00:06:33,320 --> 00:06:36,490
都包含相同数目的黑色结点

82
00:06:38,580 --> 00:06:42,260
很好 现在我们要做的是

83
00:06:42,410 --> 00:06:44,930
在这些结点上记录子树的大小

84
00:06:45,210 --> 00:06:49,080
这些键值储存在这个动态数组里

85
00:06:49,220 --> 00:06:52,490
我们要把子树的大小也记录在这个红黑树里

86
00:06:52,740 --> 00:06:55,550
比如 它的子树大小是1

87
00:06:55,800 --> 00:06:58,450
这些结点都是叶子 所以它们的子树大小都是1

88
00:06:58,640 --> 00:07:00,170
然后我们继续向上算

89
00:07:00,370 --> 00:07:02,420
这个值是3

90
00:07:02,650 --> 00:07:08,650
这个是5 这个是3

91
00:07:08,900 --> 00:07:12,570
这个是5+3+1=9

92
00:07:13,540 --> 00:07:31,840
总体上 我们有size[x] = size[left[x]]

93
00:07:33,450 --> 00:07:43,760
+ size[right[x]] + 1

94
00:07:44,050 --> 00:07:47,030
这是用递归的方法来计算

95
00:07:47,290 --> 00:07:52,080
只用一个很简单的式子来计算子树大小

96
00:07:52,310 --> 00:07:54,740
而在实际编写代码

97
00:07:54,940 --> 00:07:59,200
实现这些运算时

98
00:08:03,150 --> 00:08:06,550
空结点的大小是很容易算的

99
00:08:06,910 --> 00:08:09,260
那么空结点的大小是多少？

100
00:08:12,030 --> 00:08:17,690
就是0 意思是这里没有元素

101
00:08:17,880 --> 00:08:20,090
但在大多数编程语言中

102
00:08:20,240 --> 00:08:23,090
我对空值取值会发生什么？

103
00:08:23,290 --> 00:08:28,790
会报错 这就很不爽了

104
00:08:28,910 --> 00:08:32,380
在代码里 我需要取空结点大小

105
00:08:32,720 --> 00:08:35,630
意思是 我需要对空结点取大小

106
00:08:35,890 --> 00:08:36,920
或者对任意结点取大小

107
00:08:37,040 --> 00:08:43,500
我们可以这样实现 当结点是空结点时返回0

108
00:08:43,670 --> 00:08:47,210
否则返回子树的大小

109
00:08:47,430 --> 00:08:49,150
我们实现时可以用一个技巧

110
00:08:49,150 --> 00:08:52,870
来简化这个方法

111
00:08:53,020 --> 00:08:54,350
这个技巧叫标记法

112
00:09:00,440 --> 00:09:02,980
所谓的标记其实就是一个伪记录

113
00:09:06,730 --> 00:09:10,370
我们用一个空标记来表示空的结点

114
00:09:10,650 --> 00:09:14,000
给空结点一个伪记录

115
00:09:14,310 --> 00:09:21,840
这样空结点的大小就等于0了

116
00:09:22,150 --> 00:09:25,190
这样 在这些原来是空结点的地方

117
00:09:25,400 --> 00:09:29,290
我都放一个特殊的空的记录

118
00:09:29,560 --> 00:09:32,130
但这的确是一个完好的记录

119
00:09:32,300 --> 00:09:35,690
然后我就可以设置它的值为0

120
00:09:35,880 --> 00:09:39,310
这样我就不用考虑空结点的特殊情况了

121
00:09:39,490 --> 00:09:42,810
这是在编程中很常用的技巧

122
00:09:42,990 --> 00:09:47,210
就是用标记来简化代码

123
00:09:47,390 --> 00:09:49,400
这样你就不用考虑那些边界条件

124
00:09:49,570 --> 00:09:51,780
也不用为特殊情况写额外的函数

125
00:09:51,950 --> 00:09:56,040
就能取到你想要的子树大小的值

126
00:09:56,190 --> 00:09:57,670
大家都跟上了吧？

127
00:09:58,310 --> 00:10:06,900
那根据这个 我们就可以写OS-Select的代码了

128
00:10:14,410 --> 00:10:17,690
它的功能是返回

129
00:10:17,870 --> 00:10:32,160
以x为根的子树中 第i小的元素

130
00:10:32,490 --> 00:10:37,980
这里我们会写得更加一般化

131
00:10:38,200 --> 00:10:41,210
如果只是实现上面的OS-Select

132
00:10:41,370 --> 00:10:43,920
其实需要根结点和i

133
00:10:44,130 --> 00:10:46,870
但这里 我们用递归的方法来实现

134
00:10:47,080 --> 00:10:54,590
这样有助于我们找到

135
00:10:54,770 --> 00:10:56,980
子树里所求的那个结点

136
00:10:58,200 --> 00:10:59,580
这是代码

137
00:12:19,800 --> 00:12:22,340
此乃代码也

138
00:12:24,040 --> 00:12:27,760
我们来看看它的原理

139
00:12:27,940 --> 00:12:30,580
然后来说明一下它的可行性

140
00:12:32,480 --> 00:12:45,800
比如我们求OS-Select(root,5)

141
00:12:46,100 --> 00:12:48,970
意思是求在整个集合里第5大的数

142
00:12:51,260 --> 00:12:57,470
直接可以写成OS-Select(root,5) 哇离得好远

143
00:12:59,500 --> 00:13:01,060
我们从树的顶部开始找

144
00:13:01,260 --> 00:13:08,070
哦 我换一块黑板

145
00:13:08,380 --> 00:13:14,660
我们从顶端开始 i是根结点【译注：口误】

146
00:13:18,220 --> 00:13:25,610
哦 对不起 是从根结点开始 然后i=5

147
00:13:27,950 --> 00:13:29,320
我们要找到第5大的数

148
00:13:29,510 --> 00:13:35,950
我们先来算k值 k = size[left[x]] + 1

149
00:13:36,130 --> 00:13:43,700
这是个什么值？k究竟是什么？

150
00:13:47,670 --> 00:13:53,730
嗯 这里它的值是6 不过k到底是神马意思？

151
00:13:54,050 --> 00:14:00,000
学生：

152
00:14:00,770 --> 00:14:03,530
教授：就是当前结点的顺序 也就是秩

153
00:14:03,800 --> 00:14:06,210
对 就是当前结点的秩

154
00:14:06,400 --> 00:14:09,260
这就是当前结点的秩

155
00:14:09,460 --> 00:14:12,920
k就是左侧子树的结点数+1

156
00:14:13,100 --> 00:14:15,040
而这正好就是当前结点的秩

157
00:14:16,000 --> 00:14:21,180
我们看到这里发现 哦 秩等于k

158
00:14:21,380 --> 00:14:25,430
如果i和k相等 那么这就是我们要找的那个元素

159
00:14:28,080 --> 00:14:30,920
如果i比k小

160
00:14:31,060 --> 00:14:32,750
我们就应该在左边的子树里面找

161
00:14:32,970 --> 00:14:36,470
然后我们就在左子树里继续递归这个操作

162
00:14:36,640 --> 00:14:41,870
于是我们递归到这边 我们要找第五大的元素

163
00:14:42,250 --> 00:14:45,900
这次k的值是多少？

164
00:14:49,960 --> 00:14:57,210
是2 这里我们发现i的值更大

165
00:14:57,370 --> 00:14:59,800
所以我们要找的那个元素

166
00:14:59,970 --> 00:15:01,470
就应该藏在这边的右子树里

167
00:15:01,660 --> 00:15:05,160
不过我们想要的并不是这个子树里第i大的

168
00:15:06,890 --> 00:15:10,240
因为那边还有两个呢

169
00:15:10,430 --> 00:15:15,910
我们想求的其实是这个子树里第三大的元素

170
00:15:16,150 --> 00:15:22,070
那么我们在这个子树进行递归的时候 i的值就为3

171
00:15:22,330 --> 00:15:27,560
然后我们来计算这里的k值 这个值加上1 就是2

172
00:15:29,500 --> 00:15:32,130
i还是比k大 所以递归在右侧进行

173
00:15:32,370 --> 00:15:36,100
在这里i和k都等于1

174
00:15:36,340 --> 00:15:42,070
i和k都相等了 于是这里我们返回该结点的指针

175
00:15:53,210 --> 00:16:03,730
所以这个函数的返回值 就是关键字为H的结点的指针

176
00:16:04,030 --> 00:16:07,290
这里加个注释

177
00:16:07,440 --> 00:16:12,250
我们知道k等于x的秩

178
00:16:13,910 --> 00:16:21,010
对于这个代码有什么疑问吗

179
00:16:22,420 --> 00:16:27,030
好的 其实我们是在不断地往下递归

180
00:16:27,330 --> 00:16:31,150
用子树的大小来决定路径的方向

181
00:16:31,400 --> 00:16:34,700
直到找到第i大的那个元素

182
00:16:37,910 --> 00:16:39,730
我们简单分析一下

183
00:16:41,410 --> 00:16:46,650
在我们的这个红黑树上 OS-Select的运行时间会是多少

184
00:16:50,870 --> 00:16:55,750
嗯？是的 对于有n个元素的树就是O(log n)

185
00:16:55,990 --> 00:16:59,750
因为红黑树是平衡的

186
00:16:59,940 --> 00:17:01,290
它的高度是log n

187
00:17:01,490 --> 00:17:04,320
其实这个代码可以适用于任何

188
00:17:04,490 --> 00:17:08,550
高度为O(log n)的树

189
00:17:09,590 --> 00:17:12,130
那么如果你能保证树的高度

190
00:17:12,310 --> 00:17:17,550
就像红黑树这样的 那就好办多了

191
00:17:17,760 --> 00:17:23,100
OS-Rank 书上有这部分内容 不过我们就不细说了

192
00:17:23,350 --> 00:17:31,550
它的运行时间也是O(log n) 那好 现在我有一个问题

193
00:17:32,030 --> 00:17:57,080
为什么不直接让这些结点记录自己的秩呢？

194
00:17:57,080 --> 00:18:00,500
[学生]：...

195
00:18:00,600 --> 00:18:03,830
[教授]：就是结点自己

196
00:18:04,050 --> 00:18:06,710
要不然你不能取到左子树

197
00:18:08,980 --> 00:18:11,160
其实如果我们用的是正规的编程语言的

198
00:18:11,530 --> 00:18:14,500
那么我们的代码就会足够规范 也就不会有歧义

199
00:18:14,550 --> 00:18:17,340
不过我们用的只是伪代码 这样固然很好

200
00:18:17,510 --> 00:18:19,760
因为这样很简洁 可以让我们更专注于算法

201
00:18:19,960 --> 00:18:21,420
不过 当然啦

202
00:18:21,570 --> 00:18:23,140
伪代码肯定不会有

203
00:18:23,360 --> 00:18:25,310
你真正编程时要考虑的东西

204
00:18:25,460 --> 00:18:30,680
诸如类型安全性这些 什么？

205
00:18:30,680 --> 00:18:38,260
[学生]：...

206
00:18:39,050 --> 00:18:44,340
教授：对 当你对树进行修改的时候 维护这个树将会很费劲

207
00:18:44,660 --> 00:18:48,900
比如 我们在每个结点都保存它们自己的秩

208
00:18:49,230 --> 00:18:55,320
这样的确可以非常容易地找到 秩是给定值的元素

209
00:18:55,620 --> 00:18:58,380
不过如果我想要插入一个最小的元素

210
00:18:58,630 --> 00:19:02,180
比整个树里面的所有元素都要小

211
00:19:02,370 --> 00:19:05,630
那会怎么样？那样所有记录的秩都要修改

212
00:19:05,880 --> 00:19:09,320
这样的话维护就需要O(n)这样巨大的花费

213
00:19:11,460 --> 00:19:15,870
不过如果我记录的是子树大小 那事情就简单了

214
00:19:18,360 --> 00:19:20,620
因为如果红黑树被修改了

215
00:19:25,530 --> 00:19:30,480
记录秩的话就会变得很难维护了

216
00:19:31,660 --> 00:19:36,160
这也是需要注意的技巧

217
00:19:36,360 --> 00:19:47,470
如果要对数据结构进行扩充的话

218
00:19:47,710 --> 00:19:52,260
你想加点东西让它运行得更快

219
00:19:52,470 --> 00:19:56,130
但别忘了 这个数据结构已有的一些基本运算

220
00:19:56,330 --> 00:19:59,060
你还要维护这些基本运算

221
00:19:59,270 --> 00:20:00,680
那门帮着关一下呗

222
00:20:02,390 --> 00:20:09,940
谢了 我们不仅要关注如何构造树的修改操作

223
00:20:10,120 --> 00:20:12,620
而且还要学会维护它们

224
00:20:12,860 --> 00:20:16,030
红黑树的修改操作有

225
00:20:20,180 --> 00:20:24,370
插入和删除

226
00:20:24,670 --> 00:20:28,530
如果我对二叉堆进行扩充

227
00:20:28,740 --> 00:20:31,260
我该考虑哪些运算？

228
00:20:35,610 --> 00:20:39,620
如果对堆的扩张 哪些是堆的修改型运算？

229
00:20:42,390 --> 00:20:46,560
比如对于二叉最小堆这样经典的优先队列

230
00:20:50,390 --> 00:20:59,190
有谁还记得堆？堆上的运算有哪些？

231
00:20:59,530 --> 00:21:01,910
哦 这个用来当期末考试题不错嘛

232
00:21:04,650 --> 00:21:07,730
课上留的作业你们都无所谓

233
00:21:07,960 --> 00:21:11,780
一提到期末考试就着急了 那么堆上的运算有哪些？

234
00:21:12,480 --> 00:21:20,790
可以看一看教科书嘛

235
00:21:22,560 --> 00:21:25,420
大神？这位大神怎么说？

236
00:21:25,820 --> 00:21:29,670
[学生]：...

237
00:21:30,420 --> 00:21:37,060
[教授]：好的 如果这是个最小堆

238
00:21:37,280 --> 00:21:42,620
查找最小值 取出最小值 最典型的操作 还有插入元素

239
00:21:43,690 --> 00:21:52,610
有哪些会对树进行修改？插入和取出最小值 对吧？

240
00:21:52,920 --> 00:21:56,090
嗯 查找最小值没对树改动 不用担心

241
00:21:56,310 --> 00:21:58,480
因为它充其量只是在进行查询

242
00:21:58,730 --> 00:22:02,500
在动态数据结构上你会用到各种运算

243
00:22:02,700 --> 00:22:04,660
有些会对数据经行修改 有些不会

244
00:22:04,830 --> 00:22:07,110
那些不修改数据的运算

245
00:22:07,290 --> 00:22:09,450
可以一直很好地运行

246
00:22:09,680 --> 00:22:11,240
除非你把你的数据销毁了

247
00:22:11,520 --> 00:22:13,670
查询总是很容易

248
00:22:14,010 --> 00:22:16,550
不过对于那些对数据结构进行修改的运算

249
00:22:16,740 --> 00:22:19,550
我们就要考虑他们的稳定性了

250
00:22:20,770 --> 00:22:26,990
这种情况下我们插入删除时采取的策略

251
00:22:29,760 --> 00:22:34,160
是随时更新子树的大小

252
00:22:40,770 --> 00:22:46,960
与插入和删除同步进行

253
00:22:49,080 --> 00:22:53,050
我们来试试 比如说现在

254
00:22:53,190 --> 00:23:02,090
我向树里面插入一个k 键值为K

255
00:23:06,430 --> 00:23:10,730
算法的过程是先把它插到这个地方

256
00:23:11,020 --> 00:23:13,770
子树大小有什么变化？

257
00:23:13,950 --> 00:23:15,590
如果我把k插到这的话？

258
00:23:18,220 --> 00:23:27,520
字数大小就变到10了 然后向左边走

259
00:23:27,720 --> 00:23:30,770
这个就变成6

260
00:23:32,390 --> 00:23:38,480
这边变成4 然后这里是2

261
00:23:40,240 --> 00:23:47,840
插入的k就放在这个地方 子树大小就是1

262
00:23:48,230 --> 00:23:51,660
就是沿着这条路径一直更新下来 没什么难度

263
00:23:57,600 --> 00:24:03,780
嗯？ 对 现在已经不是一个红黑树了

264
00:24:05,470 --> 00:24:18,580
你需要重新使它平衡 使它回到平衡的状态

265
00:24:19,290 --> 00:24:24,330
因为人们总是习惯性地忘记

266
00:24:24,340 --> 00:24:26,310
所以我总是认为

267
00:24:26,540 --> 00:24:28,760
有必要和你们说一下

268
00:24:28,940 --> 00:24:31,170
程序应该怎么走

269
00:24:31,370 --> 00:24:33,100
这样当你们自己遇到这样的情况时

270
00:24:33,330 --> 00:24:35,490
不会犯这样的错误

271
00:24:35,670 --> 00:24:40,620
人们在红黑树上进行运算时 总是忘记平衡的事

272
00:24:40,800 --> 00:24:43,180
普通树的插入当然很好做

273
00:24:43,390 --> 00:24:45,800
不过红黑插入

274
00:24:46,050 --> 00:24:50,170
红黑插入是包含了两个步骤的

275
00:24:50,310 --> 00:24:53,790
不仅要进行树的插入 插入之后还有使树平衡

276
00:24:55,750 --> 00:24:56,820
所以你要请确保

277
00:24:57,110 --> 00:24:59,080
你做的是完整的红黑树插入

278
00:24:59,290 --> 00:25:01,830
而不仅仅是树插入的部分 我们已经完成了插入部分的工作

279
00:25:01,980 --> 00:25:08,110
这很简单 不过我们还要使之平衡

280
00:25:08,310 --> 00:25:11,040
所以我们要关心两件事

281
00:25:11,230 --> 00:25:14,090
首先是红黑颜色的改变

282
00:25:17,410 --> 00:25:22,520
不过他们对子树的大小没有影响

283
00:25:22,760 --> 00:25:27,200
如果我只是改变颜色 那这不会对子树大小有任何影响

284
00:25:30,360 --> 00:25:35,220
不过我们还有一个很有意思的东西 旋转

285
00:25:40,300 --> 00:25:44,150
我们会发现旋转造成的影响很容易修正

286
00:25:44,380 --> 00:25:46,470
因为当我做旋转的时候

287
00:25:46,650 --> 00:25:50,240
我可以从子结点来进行更新 等会我给你们看

288
00:25:50,480 --> 00:25:58,950
只是根据子结点来进行修复

289
00:26:00,780 --> 00:26:07,260
这种情况下 每次旋转的花费是O(1)

290
00:26:07,570 --> 00:26:11,280
比如想象一下

291
00:26:11,510 --> 00:26:14,810
有一个树的某部分是像这个样子的

292
00:26:21,020 --> 00:26:26,180
这些结点的子树大小分别是7 3 4

293
00:26:26,310 --> 00:26:28,520
这里我就不给定键值了

294
00:26:28,700 --> 00:26:32,030
然后我在这条边上做右旋转

295
00:26:32,190 --> 00:26:35,560
把他们调过来

296
00:26:40,060 --> 00:26:42,610
于是他们就这样连在一起了

297
00:26:46,320 --> 00:26:50,810
子结点还是三个

298
00:26:50,900 --> 00:26:52,880
于是我们把结点换上去

299
00:26:53,040 --> 00:26:55,270
然后让另外这个结点为剩下的父结点

300
00:26:56,420 --> 00:26:58,210
那么现在关键就是

301
00:26:58,390 --> 00:27:02,570
把这些值更新一下

302
00:27:02,740 --> 00:27:05,570
这是8 3+4+1=8

303
00:27:05,780 --> 00:27:10,740
用这个子树大小的公式来算

304
00:27:12,650 --> 00:27:17,370
另外这个数就是8+7+1=16

305
00:27:17,600 --> 00:27:18,990
或者可以这么想

306
00:27:19,140 --> 00:27:21,160
无论下面的子树是什么样的

307
00:27:23,320 --> 00:27:27,720
旋转这个运算都不会改变它的子树大小

308
00:27:27,960 --> 00:27:30,830
这下面的所有东西都还在下面

309
00:27:31,030 --> 00:27:34,520
所以这里我们用O(1)的时间就解决了

310
00:27:34,840 --> 00:27:37,460
当然这里肯定还有很多其他不同的运算

311
00:27:37,640 --> 00:27:40,450
放在这里的可能是不一样的值

312
00:27:40,710 --> 00:27:42,990
我记录的可能不是子树大小

313
00:27:43,200 --> 00:27:46,970
而是子树的其他性质

314
00:27:48,760 --> 00:27:50,560
有可能这个值不是16了

315
00:27:50,960 --> 00:27:54,020
而这个性质也会一直传递到根结点

316
00:27:54,280 --> 00:27:57,810
书里有一个不错的小引理

317
00:27:58,100 --> 00:28:02,480
说的就是你可以保证重新平衡这个过程

318
00:28:02,660 --> 00:28:05,280
并不会有太高的花费

319
00:28:07,200 --> 00:28:09,030
这就很不错

320
00:28:09,220 --> 00:28:16,220
那么现在插入和删除 对于旋转我们要做的就这么多

321
00:28:16,410 --> 00:28:19,750
花费时间是O(log n)

322
00:28:21,400 --> 00:28:25,170
因为红黑树的旋转只花费O(1)

323
00:28:25,430 --> 00:28:27,740
普通来说 他们花费也是常数阶吗？

324
00:28:27,930 --> 00:28:29,090
是的 他们的花费都是常数阶

325
00:28:29,320 --> 00:28:30,970
只不过是大一点的常数阶

326
00:28:33,400 --> 00:28:36,890
现在我们就可以完成这个给力的数据结构了

327
00:28:37,080 --> 00:28:43,910
它支持动态有序查询

328
00:28:46,080 --> 00:28:49,420
它的工作时间都是O(log n)

329
00:28:49,730 --> 00:28:52,860
对于插入 删除 还有各种各样的查询而言

330
00:28:53,080 --> 00:28:56,720
无论是OS-Select 又或者是查找一个元素

331
00:28:56,950 --> 00:28:58,340
我们从一个基础的数据结构出发

332
00:28:58,590 --> 00:29:00,510
并且添加了许多新的运算

333
00:29:01,850 --> 00:29:05,240
这部分有什么问题吗

334
00:29:07,100 --> 00:29:11,790
大家都对这部分融会贯通了？

335
00:29:13,360 --> 00:29:20,540
好的 那我们来总结一下吧 做总结如履薄冰啊

336
00:29:35,790 --> 00:29:38,780
那么关于扩展的数据结构

337
00:29:39,050 --> 00:29:42,510
我想告诉你们一套小小的步骤

338
00:29:42,650 --> 00:29:44,900
能够让你们不会犯错

339
00:29:45,080 --> 00:29:48,250
也不会忘掉重要的步骤

340
00:29:48,430 --> 00:29:50,150
通常来说 啊 对了

341
00:29:50,310 --> 00:29:56,340
如果你们在作业里遇到关于扩张的问题

342
00:29:56,520 --> 00:29:59,020
或者在期末考试里遇到

343
00:29:59,160 --> 00:30:03,520
我保证大约四分之一的人

344
00:30:03,750 --> 00:30:09,070
在对红黑树进行扩张时 会忘记旋转这个步骤

345
00:30:09,260 --> 00:30:13,830
妥妥的 总而言之

346
00:30:14,080 --> 00:30:16,140
有个方法可以用来进行检查

347
00:30:16,400 --> 00:30:19,610
就像我说过的 之所以它如此重要

348
00:30:19,760 --> 00:30:21,970
是因为在实际应用中

349
00:30:22,130 --> 00:30:25,580
大部分的时间你都会用到扩张

350
00:30:25,800 --> 00:30:29,040
通常我们不会用现成的数据结构

351
00:30:29,250 --> 00:30:30,510
当你拿到一个数据结构

352
00:30:30,680 --> 00:30:33,510
你会想要添加自己的一些运算

353
00:30:34,490 --> 00:30:35,500
我们来讲这个步骤

354
00:30:35,680 --> 00:30:37,150
接着我刚才说的

355
00:30:37,330 --> 00:30:40,500
我们会以一个有序统计树为例

356
00:30:43,240 --> 00:30:46,560
来说明这个步骤

357
00:30:47,480 --> 00:30:49,860
分为四步

358
00:30:50,060 --> 00:30:55,410
首先选择一个基础的数据结构

359
00:31:02,720 --> 00:31:05,340
这里 我们选择了什么有序统计树？

360
00:31:07,050 --> 00:31:19,900
红黑树 第二步是我们要如何

361
00:31:20,130 --> 00:31:22,980
在这样的数据结构中

362
00:31:23,150 --> 00:31:25,180
维护一些附加的信息

363
00:31:36,000 --> 00:31:46,850
在这种情况下就是子树的大小

364
00:31:47,030 --> 00:31:50,190
我们保存的信息就是子树的大小

365
00:31:52,840 --> 00:31:58,930
这里很容易出错哦亲~

366
00:31:59,140 --> 00:32:00,790
我们可能会想 哦 直接记录秩就好了

367
00:32:00,970 --> 00:32:04,940
于是我们就这么做 其实也行得通

368
00:32:05,090 --> 00:32:07,020
只不过速度实在不敢恭维

369
00:32:07,030 --> 00:32:10,210
我们需要一些想象力来想出

370
00:32:10,370 --> 00:32:11,900
有哪些信息是我们能够保留

371
00:32:12,040 --> 00:32:16,400
同时又能维持所需的其他性质不变

372
00:32:17,940 --> 00:32:27,030
第三步就是验证这个数据结构上的信息

373
00:32:31,490 --> 00:32:35,210
不会受修改操作的影响

374
00:32:43,630 --> 00:32:52,680
这种情况下 对于OS树

375
00:32:54,180 --> 00:32:57,890
它的修改操作就是插入和删除

376
00:32:58,160 --> 00:33:00,800
当然 我们还要处理旋转的问题

377
00:33:07,090 --> 00:33:15,270
因为旋转是其中的一步 所以我们可以把它们分解成

378
00:33:15,300 --> 00:33:18,220
树插入+旋转、树删除+旋转

379
00:33:18,370 --> 00:33:20,340
只要这个搞定了 其他都好办了

380
00:33:20,510 --> 00:33:22,540
不过对于这个特殊的问题

381
00:33:22,680 --> 00:33:25,540
我们要关心颜色的变化 不过那就是

382
00:33:25,690 --> 00:33:29,720
之后你们才会关注的东西了

383
00:33:29,870 --> 00:33:33,790
不知道怎么回事颜色变得重要了

384
00:33:33,930 --> 00:33:36,040
通常颜色并不是很重要的

385
00:33:36,180 --> 00:33:40,470
第四步就是建立新的运算

386
00:33:48,880 --> 00:33:54,250
假设新的数据已经存好了 然后开始使用这些信息

387
00:33:54,500 --> 00:34:00,530
这个是OS-Select和OS-Rank

388
00:34:00,700 --> 00:34:02,980
虽然我们这里没有讲OS-Rank

389
00:34:03,160 --> 00:34:05,750
但这个问题很有意思 你们可以自己考虑下

390
00:34:05,930 --> 00:34:09,120
如何建立OS-Rank这个函数 并不是很难

391
00:34:13,050 --> 00:34:17,050
这套方法实际上不是按部就班的

392
00:34:17,270 --> 00:34:21,150
这更像是一个检查清单

393
00:34:21,320 --> 00:34:27,320
给你检查都完成了哪些

394
00:34:27,460 --> 00:34:28,740
在实际应用中

395
00:34:28,880 --> 00:34:30,970
可能你会先写一个新的运算函数

396
00:34:31,050 --> 00:34:33,620
你先记下这个新的运算

397
00:34:33,830 --> 00:34:35,220
然后验证什么样的信息

398
00:34:35,620 --> 00:34:37,360
可以储存在这里

399
00:34:37,500 --> 00:34:38,890
也许你回过头来

400
00:34:39,030 --> 00:34:41,410
换个顺序把这些步骤再来一遍

401
00:34:41,570 --> 00:34:43,830
这就是一个完成时的检查列表

402
00:34:44,970 --> 00:34:47,330
你可以像这样写

403
00:34:47,640 --> 00:34:52,270
就像这样 把你做了什么用文档记录下来

404
00:34:52,420 --> 00:34:53,930
这样很不错哦 你就有一个检查列表了

405
00:34:54,180 --> 00:34:55,680
这就是我的基础的数据结构

406
00:34:55,870 --> 00:34:58,180
这边有些附加的新的信息

407
00:34:58,340 --> 00:35:01,610
看吧 我仍然保持了数据结构中

408
00:35:01,790 --> 00:35:02,930
原有的运算

409
00:35:03,110 --> 00:35:06,870
同时这里我还添加了我自己的新运算

410
00:35:07,000 --> 00:35:08,320
这的确是一个检查列表

411
00:35:08,510 --> 00:35:12,540
不是让你一步不差地按照这个顺序来做

412
00:35:12,730 --> 00:35:16,140
这些步骤都是必须的 但不一定是按这个顺序来的

413
00:35:16,320 --> 00:35:18,860
这是一套成文的设计指引

414
00:35:19,020 --> 00:35:21,490
当你要扩张一个数据结构的时候

415
00:35:21,770 --> 00:35:25,520
总的来说 就是让你说清楚这四步都是什么

416
00:35:25,680 --> 00:35:26,860
这对你进行管理很有帮助

417
00:35:26,980 --> 00:35:28,070
而且也可以确保你

418
00:35:28,200 --> 00:35:30,170
在做的过程中不会忘了什么

419
00:35:30,880 --> 00:35:34,090
我见过有人进行信息的添加

420
00:35:34,250 --> 00:35:38,430
以及建立新的运算

421
00:35:38,660 --> 00:35:40,780
不过它们完全忘记了

422
00:35:40,970 --> 00:35:43,120
验证要保留的信息

423
00:35:44,830 --> 00:35:46,590
所以你要确保这些都完成了

424
00:35:46,830 --> 00:35:56,310
你要对这种每一步之间的相互作用

425
00:36:02,530 --> 00:36:04,920
有所了解

426
00:36:06,690 --> 00:36:11,520
并不是做完了这个 再做那个 那么简单

427
00:36:12,110 --> 00:36:16,460
现在我们来做一个更复杂的数据结构

428
00:36:16,690 --> 00:36:18,150
并不复杂多少

429
00:36:18,370 --> 00:36:21,560
不过要正确地实现它却是个挑战

430
00:36:30,750 --> 00:36:35,330
其实 这个数据结构相当实用

431
00:36:35,700 --> 00:36:40,940
但我对 有很多人都没有意识到 感到很惊讶

432
00:36:41,350 --> 00:36:44,630
本来这种数据结构对他们很有帮助

433
00:36:44,900 --> 00:36:48,070
但他们却用很低效的代码

434
00:36:49,460 --> 00:36:52,890
我们要讲的这个例子就是区间树

435
00:36:57,490 --> 00:37:00,020
区间树的思想就是

436
00:37:00,250 --> 00:37:06,490
要保存一系列的区间

437
00:37:11,310 --> 00:37:13,790
比如说时间区间

438
00:37:19,000 --> 00:37:21,950
我有整整一个数据库的时间区间

439
00:37:22,120 --> 00:37:23,570
我都想维护

440
00:37:23,790 --> 00:37:26,600
我们来看一个例子

441
00:37:59,880 --> 00:38:08,100
这些区间分别是7到10 5到11 4到8

442
00:38:08,640 --> 00:38:17,820
15到18 17到19 21到23

443
00:38:18,190 --> 00:38:20,890
这是一系列区间

444
00:38:22,100 --> 00:38:26,250
如果我们有一个区间i

445
00:38:26,450 --> 00:38:32,150
我们就设这个从7到10的区间为i

446
00:38:32,280 --> 00:38:39,290
我们把这个端点成为i的低端点

447
00:38:39,520 --> 00:38:43,940
这个则是i的高端点

448
00:38:44,210 --> 00:38:48,770
之所以用的是高低而不是左右

449
00:38:48,880 --> 00:38:50,580
是因为我们使用的是一棵树

450
00:38:50,830 --> 00:38:53,230
以免跟树的左子树和右子树混淆

451
00:38:53,450 --> 00:38:59,000
所以如果我用左右来表示区间和树

452
00:38:59,170 --> 00:39:00,980
这个东西就说不清楚了

453
00:39:01,640 --> 00:39:04,320
这也是个提醒 当你在编程的时候

454
00:39:04,570 --> 00:39:07,390
切记要仔细考虑你的命名

455
00:39:07,560 --> 00:39:08,780
尤其是对于你自己使用的东西

456
00:39:08,910 --> 00:39:10,710
特别是像左右这种命名

457
00:39:10,880 --> 00:39:14,800
因为他们在编程中已经被用烂了

458
00:39:14,910 --> 00:39:18,680
有一个好办法是使用各种同义词

459
00:39:18,830 --> 00:39:22,270
以应对不同的情况 从而保证代码的整洁

460
00:39:22,450 --> 00:39:23,800
比如说吧

461
00:39:23,910 --> 00:39:25,650
当区间遇上了树

462
00:39:25,650 --> 00:39:27,350
这里我们要同时使用他们两个

463
00:39:29,000 --> 00:39:30,590
我们要做的就是

464
00:39:30,810 --> 00:39:39,420
我们想要能够插入和删除区间

465
00:39:39,570 --> 00:39:42,150
而且我们将会用到查询

466
00:39:42,320 --> 00:39:44,620
这是我们要建立的新操作

467
00:39:44,760 --> 00:39:51,390
它是要查询集合里所有的区间

468
00:39:52,500 --> 00:40:07,850
与给定区间发生重合的有哪些

469
00:40:14,060 --> 00:40:25,250
比如给定一个区间 [6,14]

470
00:40:25,490 --> 00:40:30,010
你就可以返回这个区间 这个

471
00:40:30,240 --> 00:40:33,310
还有这个 剩下这些就不行了

472
00:40:33,500 --> 00:40:35,850
因为他们都小于14

473
00:40:36,080 --> 00:40:38,690
所以这几个都可以是返回值

474
00:40:38,800 --> 00:40:40,110
我只要返回一个就好了

475
00:40:40,230 --> 00:40:42,720
只要返回一个有重叠的就行

476
00:40:44,120 --> 00:40:49,890
对于我们要做的东西都清楚了吧？

477
00:40:50,120 --> 00:40:55,980
好的 这就用到了我们的方法论

478
00:40:57,890 --> 00:41:00,090
首先 第一步

479
00:41:02,000 --> 00:41:04,270
嗯 我们的方法论在这

480
00:41:09,820 --> 00:41:15,500
第一步是我们要选择基础的数据结构

481
00:41:15,600 --> 00:41:17,930
有哪位能给个建议不？

482
00:41:18,050 --> 00:41:21,940
我们用什么来实现区间树？

483
00:41:30,640 --> 00:41:33,560
我们用什么样的数据结构

484
00:41:33,840 --> 00:41:36,280
能够支持这样的区间树？

485
00:41:41,390 --> 00:41:43,490
摆脱谁去终结了这个问题吧？

486
00:41:44,000 --> 00:41:48,000
红黑树 二叉搜索树 红黑树

487
00:41:48,300 --> 00:41:49,900
好吧 我们要用的是红黑树

488
00:41:55,000 --> 00:41:57,560
我要讲一下关于关键字

489
00:42:01,030 --> 00:42:03,060
我用什么来作这个红黑树的关键字？

490
00:42:03,170 --> 00:42:05,370
对于每个区间 我用什么作为关键字？

491
00:42:07,910 --> 00:42:13,250
有很多种选择是吧？

492
00:42:19,250 --> 00:42:20,260
告诉我你们的奇思妙想吧

493
00:42:20,380 --> 00:42:23,330
开发新分支总比剪枝好

494
00:42:23,400 --> 00:42:24,470
你可以过后再剪枝

495
00:42:24,770 --> 00:42:27,380
但如果你不开发新的分支 你就永远没有剪枝的机会

496
00:42:27,490 --> 00:42:30,040
所以爆发你们的小宇宙吧

497
00:42:30,150 --> 00:42:32,030
在设计阶段 你会需要这样做

498
00:42:32,140 --> 00:42:36,120
在家做作业也要用到 是吧？

499
00:42:36,340 --> 00:42:38,200
[学生]：...

500
00:42:38,300 --> 00:42:42,360
[教授]：我们把这个称为低端点

501
00:42:42,520 --> 00:42:44,350
好吧 你可以用低端点来做

502
00:42:44,460 --> 00:42:45,630
还有什么别的想法吗

503
00:42:47,900 --> 00:42:52,490
高端点 嗯 你们很关注低端点和高端点

504
00:42:54,410 --> 00:42:58,370
好吧 这两个端点之间哪个更好？

505
00:43:00,340 --> 00:43:02,620
好像都没所谓 对吧？

506
00:43:02,770 --> 00:43:05,220
所以高对低 我们可以先不考虑这个

507
00:43:05,390 --> 00:43:08,370
不过你们可能也会想到 还有一个很常用的点

508
00:43:08,480 --> 00:43:11,960
比如说中点 中间点

509
00:43:13,700 --> 00:43:22,190
至少是对称的 你们认为呢？

510
00:43:22,370 --> 00:43:26,470
我还会用到什么？长度？

511
00:43:29,470 --> 00:43:34,950
我感觉长度不是很靠谱

512
00:43:35,060 --> 00:43:37,430
只是单纯地凭直觉判断的

513
00:43:37,440 --> 00:43:38,730
感觉上不是很给力

514
00:43:38,840 --> 00:43:39,880
因为就算我知道长度了

515
00:43:40,030 --> 00:43:43,160
我也很难弄清楚它到底在哪

516
00:43:43,280 --> 00:43:48,260
而且查询时很难追踪它的位置信息

517
00:43:48,390 --> 00:43:51,160
所以我们要用的是低端点

518
00:43:54,380 --> 00:43:58,260
不过我有些许惊讶

519
00:43:58,410 --> 00:44:00,180
你们居然没有人想用中点来做

520
00:44:00,340 --> 00:44:03,240
因为你们都喜欢这个端点

521
00:44:03,410 --> 00:44:05,900
但其实这么做挺好的 很神奇嘛

522
00:44:08,850 --> 00:44:10,440
还有一种策略

523
00:44:10,590 --> 00:44:16,130
还有另外一种树 叫做线段树

524
00:44:16,280 --> 00:44:17,630
实际上 你要做的就是

525
00:44:17,630 --> 00:44:23,870
把左右两个端点分别存放在树里

526
00:44:24,050 --> 00:44:25,640
然后你要维护这个数据结构

527
00:44:25,790 --> 00:44:34,740
使线段能够通过树相连

528
00:44:35,010 --> 00:44:37,190
你可以有很多种选择

529
00:44:37,340 --> 00:44:40,500
不过我们这里就用低端点作为关键字好了

530
00:44:40,610 --> 00:44:43,320
这也是为什么这个数据结构更智能一些

531
00:44:46,000 --> 00:44:52,820
好的 这里是难点了 这个数据结构真的很智能

532
00:44:52,950 --> 00:44:56,150
我们要在这里储存的是

533
00:44:56,270 --> 00:45:01,320
我感觉这里的方法都不错

534
00:45:01,450 --> 00:45:03,090
都能登大雅之堂

535
00:45:03,210 --> 00:45:07,240
但直到真正用到它之前 你永远也不知道哪个更好

536
00:45:07,360 --> 00:45:12,460
这个 我感觉更难以猜到

537
00:45:12,680 --> 00:45:15,000
你要在一个结点里储存...

538
00:45:15,010 --> 00:45:34,290
这个结点的子树的最大值m

539
00:45:43,880 --> 00:45:46,650
这样画一下 一个这样的结点

540
00:45:46,850 --> 00:45:50,860
我们把区间值放在上面 m值放在下面

541
00:46:00,000 --> 00:46:01,870
画幅图说明一下

542
00:46:37,680 --> 00:46:39,810
再说一次 空的叶子结点我就不画了

543
00:46:58,660 --> 00:47:01,410
我希望这是一个查找树

544
00:47:01,590 --> 00:47:10,030
关键字就是这些低端点 4, 5, 7, 15, 17, 21

545
00:47:10,340 --> 00:47:13,800
以低端点为关键字

546
00:47:13,950 --> 00:47:16,970
不过因为这是一个红黑树 所以我们还需要先做一件事

547
00:47:17,110 --> 00:47:20,990
我如何对它上色 使之成为一个合法的红黑树？

548
00:47:23,810 --> 00:47:26,020
虽然跟我们所做的没什么太大联系

549
00:47:26,190 --> 00:47:30,240
不过有时候拿来试着练习一下也不错

550
00:47:33,270 --> 00:47:35,550
记住 空结点不会显示出来而且它们都是黑的

551
00:47:35,740 --> 00:47:39,720
还有根结点也是黑的 这个我给你们画出来

552
00:47:49,860 --> 00:47:58,460
很好 估计能行 你们通过了一个考验

553
00:47:58,680 --> 00:48:00,850
一个逻辑上的考验

554
00:48:01,600 --> 00:48:03,950
因为这条边实在是很短

555
00:48:04,100 --> 00:48:05,350
所以最好不要有红色在里面

556
00:48:05,510 --> 00:48:07,750
这个是黑的

557
00:48:07,930 --> 00:48:10,070
现在我想要平衡高度

558
00:48:10,210 --> 00:48:11,670
我需要这里有一层结点都是黑的

559
00:48:11,810 --> 00:48:13,670
不能是这个 应该是这两个

560
00:48:16,740 --> 00:48:21,880
不错 现在我们来对这些结点分别计算m值

561
00:48:22,040 --> 00:48:27,850
m是以该结点为根的子树中的最大值

562
00:48:28,020 --> 00:48:33,220
这个结点下的子树最大值是多少？10

563
00:48:34,550 --> 00:48:48,540
这个呢？18 这个？8 18

564
00:48:50,410 --> 00:48:56,670
这个是23 这个也是23

565
00:49:00,660 --> 00:49:04,580
总而言之 m就是

566
00:49:04,830 --> 00:49:10,360
三个可能值里面的最大的

567
00:49:11,730 --> 00:49:17,870
或者是x的高端值

568
00:49:18,100 --> 00:49:31,860
或者是x左子结点的m值 或者是x右子结点的m值

569
00:49:39,420 --> 00:49:41,900
都懂了吗？

570
00:49:42,270 --> 00:49:45,240
这三种都可能是任意结点x的m值

571
00:49:45,490 --> 00:49:47,420
我只需要看一下这里的最大值是多少

572
00:49:47,580 --> 00:49:48,840
这里的又是多少

573
00:49:49,000 --> 00:49:51,390
还有区间的高端点是多少

574
00:49:52,360 --> 00:49:54,260
这三个值的最大值

575
00:49:54,440 --> 00:49:58,530
同时也是子树里面的最大值

576
00:50:14,840 --> 00:50:16,990
那么关于修改操作

577
00:50:27,570 --> 00:50:34,380
我们先来做插入 插入怎么做？

578
00:50:35,640 --> 00:50:37,820
分为两部分

579
00:50:38,040 --> 00:50:40,730
第一部分就是树插入

580
00:50:40,940 --> 00:50:43,530
就是普通二叉搜索树的插入

581
00:50:52,600 --> 00:51:00,640
我怎么做？怎么插入新的区间？

582
00:51:16,980 --> 00:51:19,250
在这里插入一个新的区间？

583
00:51:19,490 --> 00:51:21,310
我怎么搞定这些m呢？

584
00:51:21,660 --> 00:51:31,310
[学生]：...

585
00:51:31,800 --> 00:51:34,750
[教授]：没错 你只要沿着树走

586
00:51:34,940 --> 00:51:38,300
看一看当前的结点

587
00:51:38,510 --> 00:51:40,610
如果出现了更大的最大值

588
00:51:40,800 --> 00:51:43,100
因为这可是要插入到树里的

589
00:51:43,240 --> 00:51:47,560
如果新的高端点比现有的最大值还要大的话

590
00:51:47,690 --> 00:51:49,030
那就更新结点

591
00:51:49,140 --> 00:51:51,960
整个插入过程 我就做这个

592
00:51:52,080 --> 00:51:55,070
无论经过哪棵子树

593
00:51:55,210 --> 00:51:56,900
哪个结点 我都这么做

594
00:51:57,040 --> 00:52:06,800
我只是在新的最大值所经过的路径上 不断地更新结点

595
00:52:12,480 --> 00:52:16,550
很好 你就这样沿着这条路一直这么做下来

596
00:52:24,400 --> 00:52:26,680
不过我们还要做其他的部分

597
00:52:26,870 --> 00:52:35,100
还要做旋转的部分

598
00:52:41,930 --> 00:52:49,320
那么我们举个例子来看一下旋转的过程

599
00:52:57,550 --> 00:53:03,400
我们设这个分别是 11,15,30

600
00:53:12,000 --> 00:53:14,520
假设我们来做一个有旋转

601
00:53:15,300 --> 00:53:17,360
这上面还有东西 就不画了

602
00:53:29,430 --> 00:53:31,860
上面省略

603
00:53:32,430 --> 00:53:36,930
这些子结点还是30

604
00:53:37,110 --> 00:53:39,020
14和19

605
00:53:42,190 --> 00:53:45,110
我们朝这边旋转

606
00:53:45,280 --> 00:53:49,480
于是这个是[11,15] 这边的是[6,20]

607
00:53:52,350 --> 00:53:56,390
我可以使用这个公式来解决

608
00:53:57,980 --> 00:54:02,150
看看这里哪个是最大就行了 14,15还是19？

609
00:54:02,390 --> 00:54:08,890
是19  然后再看这里 那个数是最大的？嗯 30

610
00:54:09,140 --> 00:54:13,530
或者 嗯 再来一遍 这个也不是太难表示

611
00:54:13,770 --> 00:54:16,420
这里总会是这个数

612
00:54:16,610 --> 00:54:18,580
因为我们要的就是子树里面的最大值

613
00:54:18,870 --> 00:54:20,890
而子树的所有成员

614
00:54:21,120 --> 00:54:23,010
并没有在旋转时发生改变

615
00:54:26,400 --> 00:54:28,850
这只用O(1)就能完成

616
00:54:44,180 --> 00:55:03,420
计算m值只需要O(1)的时间

617
00:55:07,200 --> 00:55:17,070
所以插入操作的总时间就是O(log n)

618
00:55:22,320 --> 00:55:26,380
如果我明白这就是我要求的东西

619
00:55:26,400 --> 00:55:29,030
当然我们现在还不知道 这个有什么用

620
00:55:29,160 --> 00:55:32,040
不过一旦我知道了这就是我想要的

621
00:55:32,200 --> 00:55:36,040
那么就能很容易得出 像删除这样的操作

622
00:55:36,190 --> 00:55:37,810
都能在O(log n)时间内解决

623
00:55:37,920 --> 00:55:40,820
删除其实是挺有技巧的

624
00:55:43,890 --> 00:55:46,030
不过我感觉也差不多

625
00:55:47,800 --> 00:55:51,210
因为删除就是先进行遍历查找

626
00:55:51,370 --> 00:55:55,320
再进行一系列交换操作

627
00:55:57,810 --> 00:56:00,190
对于内部结点 我们要拿它

628
00:56:00,300 --> 00:56:02,270
和它的子代或父代交换

629
00:56:02,390 --> 00:56:07,020
我们还有很多要处理的东西

630
00:56:07,120 --> 00:56:08,290
不过基本上就是

631
00:56:08,450 --> 00:56:10,950
如何用这些东西来更新

632
00:56:11,090 --> 00:56:12,870
本质上来说这些都是在更新过程中

633
00:56:12,980 --> 00:56:14,730
在局部发生的变化

634
00:56:16,530 --> 00:56:20,840
因为你只是从根结点开始沿着一条路径走

635
00:56:20,950 --> 00:56:24,260
对树的其他大部分都没有触碰到

636
00:56:24,360 --> 00:56:27,020
这个就留给你们自己想吧

637
00:56:27,140 --> 00:56:30,000
友情提示一下 想偷懒的话就去看看书里的内容吧

638
00:56:31,660 --> 00:56:33,180
不过用来练习还是不错的

639
00:56:33,400 --> 00:56:36,130
前三步有什么问题吗？

640
00:56:40,460 --> 00:56:43,160
第四步就是新的运算了

641
00:57:15,750 --> 00:57:23,300
对i的区间查找就是找到一个

642
00:57:26,220 --> 00:57:32,250
与区间i重叠的区间

643
00:57:32,630 --> 00:57:36,620
i是一个区间  它有两个坐标

644
00:57:36,790 --> 00:57:39,000
还有 相比于用递归来写

645
00:57:39,150 --> 00:57:42,130
虽然可以写成递归

646
00:57:42,240 --> 00:57:44,170
不过我们会用一个while循环来写

647
00:57:47,460 --> 00:57:49,770
你可以用递归来写

648
00:57:49,920 --> 00:57:51,880
而我要写的这一个函数

649
00:57:52,040 --> 00:57:54,930
会写成循环的形式 而不包含任何递归调用

650
00:57:55,150 --> 00:57:57,880
我们现在开始 把根结点的值赋给x

651
00:58:00,570 --> 00:58:02,230
然后呢

652
00:59:45,100 --> 00:59:51,380
这就是代码了 我们来看看它的工作原理

653
00:59:51,660 --> 01:00:12,050
我们来搜索区间[14,16]

654
01:00:13,900 --> 01:00:18,150
看看啊 x从根结点开始

655
01:00:18,480 --> 01:00:22,390
当它不为空的时候

656
01:00:22,610 --> 01:00:26,290
根结点显然不是空的 诶 我们现在在干什么呢？

657
01:00:26,520 --> 01:00:29,340
哪位能告诉我这代码是在干嘛？

658
01:00:29,340 --> 01:00:48,630
[学生]：....

659
01:00:49,320 --> 01:00:51,090
[教授]：嗯 我们在做什么事情呢？

660
01:00:51,380 --> 01:00:56,240
这是对i和区间x做检测

661
01:00:56,530 --> 01:00:59,650
区间x就是储存在x结点的区间

662
01:01:00,560 --> 01:01:03,130
这个检测是在干嘛？

663
01:01:14,740 --> 01:01:16,990
我希望我弄对了

664
01:01:27,980 --> 01:01:32,570
这个检测在干嘛？嗯？

665
01:01:32,570 --> 01:01:39,390
[学生]：...

666
01:01:40,090 --> 01:01:45,250
[教授]：高了还是低了？你简单回答就好

667
01:01:45,570 --> 01:01:53,230
检测重叠的部分 具体一点的话   有没有重叠？

668
01:01:53,540 --> 01:02:03,260
有没有重叠？ 如果我到了这一点

669
01:02:03,390 --> 01:02:14,230
关于i和区间x我都知道什么了？

670
01:02:16,550 --> 01:02:26,620
没重叠 他们不重叠

671
01:02:26,840 --> 01:02:31,140
因为这个高端点小于这个低端点

672
01:02:31,270 --> 01:02:33,400
高端点小于低端点

673
01:02:33,510 --> 01:02:34,520
这么看来它们没重叠

674
01:02:34,680 --> 01:02:36,440
他们能以其他方式重叠吗？

675
01:02:36,570 --> 01:02:41,390
不会的 因为我们还检测了低端点

676
01:02:41,510 --> 01:02:44,160
是否高于另一个的高端点

677
01:02:44,310 --> 01:02:47,080
它们的关系是非此即彼

678
01:02:50,160 --> 01:02:55,840
这样就检测出是不是重叠的 这把过程简化了

679
01:02:56,070 --> 01:02:59,400
当我搜索[14,16]时 我检查这里

680
01:02:59,580 --> 01:03:01,190
我看看他们重叠吗？

681
01:03:01,350 --> 01:03:04,530
答案就是 现在我们已经理解了

682
01:03:04,690 --> 01:03:07,900
不用经过完整的数学计算

683
01:03:08,010 --> 01:03:14,440
他们不是重叠的 如果他们重叠 我就找到我想要的了

684
01:03:14,590 --> 01:03:15,810
然后该怎么做？

685
01:03:17,930 --> 01:03:20,680
然后我就直接跳出循环 并返回x

686
01:03:20,920 --> 01:03:24,120
因为我就是想返回那些重叠的东西

687
01:03:24,300 --> 01:03:27,700
这就是我的目的 这里我们可以看出他们并不重叠

688
01:03:28,970 --> 01:03:33,310
于是我就想啊 如果x的左结点不是空的

689
01:03:34,530 --> 01:03:40,680
换而言之 我已经有一个左子结点了 而且i的低端点

690
01:03:40,930 --> 01:03:45,790
小于等于x的左子的m值 于是我们从左边走

691
01:03:46,030 --> 01:03:49,310
我如果搜索[14,16]会有什么结果？

692
01:03:49,510 --> 01:03:52,440
i的低端点是小于等于x左子的m值吗？

693
01:03:52,670 --> 01:03:56,060
i的下限为14

694
01:03:58,150 --> 01:04:05,620
我们来做一下搜索 这个是不是比18小？

695
01:04:06,310 --> 01:04:09,960
是的 那么我怎么做？

696
01:04:10,160 --> 01:04:15,370
我向左走然后让x指向它

697
01:04:16,210 --> 01:04:19,000
现在来检查一下 它重叠了吗？

698
01:04:19,230 --> 01:04:28,050
没重叠 我看一下左边这个 是8

699
01:04:28,270 --> 01:04:37,460
8和14相比 对吧？是不是它更小？

700
01:04:37,500 --> 01:04:39,470
不是 所以我向右走

701
01:04:41,760 --> 01:04:45,700
我在这里发现了一个重叠的部分 那么就是这货了

702
01:04:46,020 --> 01:04:54,790
于是返回[15,18]作为一个重叠的区间

703
01:04:55,070 --> 01:05:05,270
如果我搜索[12,14]这个区间

704
01:05:11,750 --> 01:05:13,160
我从最上面开始

705
01:05:13,520 --> 01:05:18,310
于是我们来看 [12,14] 这里没有重叠

706
01:05:18,440 --> 01:05:21,940
然后看见这个18了 于是我往左走

707
01:05:23,790 --> 01:05:26,880
到这里了 重叠了吗？

708
01:05:27,060 --> 01:05:29,550
没有 那么接下来怎么办？

709
01:05:29,790 --> 01:05:36,990
看一下左边 看来我应该往右边走 到这里

710
01:05:37,220 --> 01:05:41,570
然后继续看左边 嗯 不行 还是要到右边

711
01:05:41,730 --> 01:05:46,950
到了这里 是个结点 于是我返回空值

712
01:05:47,120 --> 01:05:54,320
[12,14]和集合里的其他区间有重叠的吗？

713
01:05:54,500 --> 01:05:58,700
没有 那看来这样的方法还是挺管用的

714
01:06:00,820 --> 01:06:11,960
没问题吧？嗯 验算过程很快就能做完

715
01:06:12,170 --> 01:06:17,440
不过我们先来做一下分析 验算神马的先不做了

716
01:06:17,730 --> 01:06:25,590
因为算起来其实是挺麻烦的

717
01:06:25,770 --> 01:06:36,210
时间是O(log n) 因为我做的就是沿着树从上到下走

718
01:06:36,460 --> 01:06:39,900
花费的时间与树的高度是成正比的

719
01:06:40,080 --> 01:06:47,030
很容易理解 如果我想要列出所有的重叠区间

720
01:06:47,190 --> 01:06:49,690
如果我想要列出所有重叠区间

721
01:06:49,880 --> 01:06:50,900
我需要花费多长时间？

722
01:06:53,880 --> 01:06:55,660
有没有谁给个建议 让我写出一个

723
01:06:55,770 --> 01:06:59,830
列出所有重叠部分的子程序？

724
01:07:11,060 --> 01:07:13,590
假设我有k个重叠区间

725
01:07:13,860 --> 01:07:16,610
k个与我要查询的区间重合的区间

726
01:07:16,800 --> 01:07:18,880
我想找到他们中的每一个

727
01:07:19,010 --> 01:07:30,890
最快能有多快？我该怎么做？

728
01:07:41,740 --> 01:07:49,750
怎么做？如果我只是再次搜索

729
01:07:49,960 --> 01:07:51,250
那我得到的还是那个值

730
01:07:58,230 --> 01:08:02,120
好的 请说 怎么做？

731
01:08:03,500 --> 01:08:07,520
找到了一个就删除一个 先把找到的拿出来

732
01:08:07,690 --> 01:08:10,280
再找到下一个 然后删除 直到没有剩下的为止

733
01:08:10,460 --> 01:08:18,770
如果你不想修改数据结构

734
01:08:18,930 --> 01:08:20,190
那就把他们再重新插入回去

735
01:08:21,300 --> 01:08:24,850
对k个重叠区间花费就是O(k log n)

736
01:08:25,060 --> 01:08:27,610
这个就是我们所说的输出敏感算法

737
01:08:27,790 --> 01:08:30,540
因为运行时间取决于

738
01:08:30,740 --> 01:08:34,610
它的输出数量 所以叫它输出敏感

739
01:08:40,450 --> 01:08:43,780
这个问题的最好结果

740
01:08:43,890 --> 01:08:51,930
用另一种数据结构下花费是O(k + log n)

741
01:08:53,740 --> 01:08:58,880
这是个开放性的问题

742
01:09:00,870 --> 01:09:13,750
好的 正确性 我们怎么知道算法总能正常工作？

743
01:09:17,340 --> 01:09:20,990
正确性的关键就是

744
01:09:21,310 --> 01:09:25,020
选择正确的方向 左或者右

745
01:09:25,250 --> 01:09:28,310
只要我选择了正确的子树就行

746
01:09:29,150 --> 01:09:32,860
比如说我选择了向左边走

747
01:09:33,010 --> 01:09:34,910
我怎么能确定所要查找的区间

748
01:09:35,010 --> 01:09:36,310
就是在左边呢？

749
01:09:38,290 --> 01:09:40,050
或者反过来

750
01:09:40,160 --> 01:09:42,720
如果我选了右边  又怎么确定左面没有所求的区间呢？

751
01:09:42,830 --> 01:09:44,550
每次只能有一个选择

752
01:09:44,660 --> 01:09:51,810
这就是代码里很巧妙的地方了

753
01:09:52,070 --> 01:09:55,660
有一个定理是说

754
01:09:56,070 --> 01:10:03,140
如果L为x结点左子树里的i'区间的集合

755
01:10:03,170 --> 01:10:09,370
R是右子树i'区间的集合

756
01:10:13,960 --> 01:10:16,910
关键有两点

757
01:10:17,070 --> 01:10:32,510
如果搜索向右进行 那么L集合

758
01:10:32,870 --> 01:10:41,020
里的所有与i区间重合的i'区间为空集

759
01:10:41,230 --> 01:10:44,190
这是第一点

760
01:10:44,350 --> 01:10:47,630
也就是说如果搜索方向向右进行

761
01:10:47,770 --> 01:10:50,500
那么左子树里就一个重叠的区间都没有

762
01:10:50,660 --> 01:10:54,270
这个定理恒成立 只要代码在算的时候往右走了

763
01:10:56,450 --> 01:10:59,440
因为左边的子树里 肯定没有重叠的区间

764
01:10:59,580 --> 01:11:04,120
都明白这个讲的是啥了吧

765
01:11:04,340 --> 01:11:05,560
我们会证明的

766
01:11:05,710 --> 01:11:07,140
不过我想让你们先理解一下

767
01:11:07,280 --> 01:11:09,360
因为第二点不太好理解

768
01:11:09,520 --> 01:11:11,880
所以先把第一点弄明白吧

769
01:11:12,020 --> 01:11:16,260
有什么问题没？好的 如果搜索向左

770
01:11:24,870 --> 01:11:39,530
而且发现L集合中i'和i的重叠区间是空集

771
01:11:39,760 --> 01:11:47,680
那么这说明——

772
01:11:59,090 --> 01:12:04,300
好的 这里说了什么？ 如果往左搜索

773
01:12:10,080 --> 01:12:13,600
如果左边是空集

774
01:12:13,800 --> 01:12:15,860
换而言之 如果你向左搜索

775
01:12:16,050 --> 01:12:17,920
不过一个符合条件的区间都没找到

776
01:12:18,060 --> 01:12:22,230
那么好了

777
01:12:22,370 --> 01:12:25,230
我就知道就算向右搜索也帮不上什么了

778
01:12:25,440 --> 01:12:28,720
因为在右边你也不会找到什么了

779
01:12:30,490 --> 01:12:32,130
它不是保证

780
01:12:32,260 --> 01:12:33,700
左边什么都没有

781
01:12:33,850 --> 01:12:36,680
只是说 如果左边什么都没找到

782
01:12:36,840 --> 01:12:38,650
你可以同时放弃右边了

783
01:12:38,810 --> 01:12:42,450
这就是第二点的内容

784
01:12:42,600 --> 01:12:47,710
两个条件都很有用

785
01:12:54,210 --> 01:13:02,910
那我们来证明吧

786
01:13:03,190 --> 01:13:05,070
大家都明白这个命题说的是什么了吧？

787
01:13:05,250 --> 01:13:11,820
这个命题挺巧妙地 很有逻辑 逻辑就很巧妙

788
01:13:13,880 --> 01:13:18,100
假设搜索向右走了 那么我们先证明第一个命题

789
01:13:25,230 --> 01:13:34,030
如果x左结点是空的 那就完事了

790
01:13:37,730 --> 01:13:43,090
因为命题就已经得证了

791
01:13:43,270 --> 01:13:50,120
如果我想右走 那么就有两种可能

792
01:13:50,320 --> 01:13:56,090
x的左结点是空的或者是非空的

793
01:13:56,320 --> 01:13:58,780
如果是空的 那就完事了 因为要证明的是

794
01:13:58,930 --> 01:14:01,080
如果往右搜索

795
01:14:01,220 --> 01:14:04,580
左子树里面重叠区间的集合是空集

796
01:14:04,720 --> 01:14:06,000
如果右子树什么都没有

797
01:14:06,110 --> 01:14:07,810
那左子树肯定也没有重叠的区间

798
01:14:07,880 --> 01:14:22,250
否则的话 i的低端点比x的左子的m值大

799
01:14:25,560 --> 01:14:32,260
看这里的x 在while判断语句里

800
01:14:32,480 --> 01:14:40,380
要不然x是空值 要不然这条式就为真

801
01:14:40,630 --> 01:14:43,980
我们已经说了它不为空 所以来看看这边

802
01:14:44,180 --> 01:14:49,750
抱歉 我看错行了 现在我在这个循环里

803
01:14:49,980 --> 01:14:56,430
x的左结点不是空的 而且i的低端点是这个

804
01:14:56,610 --> 01:14:59,960
这里我们向哪个方向走？向右走对吧

805
01:15:00,120 --> 01:15:01,880
因此这个命题是非真的

806
01:15:02,030 --> 01:15:05,520
所以x的左结点可能不是空的 也就是第一个

807
01:15:05,670 --> 01:15:13,760
或者i的低端点 比x的左子的m值还要大 那我就向右走

808
01:15:13,900 --> 01:15:17,940
如果我向右边走 那么这两个里面肯定有一个是真的

809
01:15:18,170 --> 01:15:20,300
第一条很简单

810
01:15:20,450 --> 01:15:24,210
否则的话 我们可以得到这样的结果 i的低端点大于x左结点的m值

811
01:15:24,350 --> 01:15:28,970
现在它可能正好是某个值

812
01:15:29,120 --> 01:15:32,890
x左结点的m值正好是一个右(高)端点

813
01:15:33,030 --> 01:15:38,330
正好就是左子树某些区间的高端点

814
01:15:38,510 --> 01:15:48,630
它等于L里一区间j的高端点

815
01:15:48,820 --> 01:15:53,210
x左结点的m值就是某些区间的高端点

816
01:15:53,360 --> 01:15:57,260
因为m值就是这么选出来的

817
01:15:57,400 --> 01:16:00,970
从左子树的某个j区间选出来的

818
01:16:01,040 --> 01:16:18,700
在L中的其他区间的最高点  都没有比——

819
01:16:25,240 --> 01:16:31,730
没有比j的高端点更大 如果用图来说明的话

820
01:16:31,970 --> 01:16:39,800
这是i 然后这是i的低端点

821
01:16:40,110 --> 01:16:43,310
对于区间j的话

822
01:16:43,380 --> 01:16:47,900
它的高端点要比i的低端点还要小

823
01:16:48,050 --> 01:16:51,530
这是j 我也不知道它有多长

824
01:16:55,540 --> 01:16:57,910
对于j的高端点来说

825
01:17:06,890 --> 01:17:10,460
他已经是左子树里面最大的了

826
01:17:10,610 --> 01:17:15,530
没有哪个高端点比它的还要高了

827
01:17:15,750 --> 01:17:17,750
也就是说在这个子树里

828
01:17:17,850 --> 01:17:21,590
不可能有与i区间重叠的

829
01:17:23,420 --> 01:17:28,310
因为那些区间都在这一点前面就结束了

830
01:17:28,550 --> 01:17:31,900
这点已经是最大的高端点了

831
01:17:32,120 --> 01:17:37,970
因此 L中的i'区间

832
01:17:38,110 --> 01:17:45,880
i'区间与i区间重叠的部分就是空集

833
01:17:46,140 --> 01:17:58,790
现在到了难点了 没关系 我有姿势(知识)我自豪

834
01:17:58,990 --> 01:18:01,740
还能跟得上吧？

835
01:18:01,860 --> 01:18:04,400
问题的关键就是

836
01:18:04,470 --> 01:18:07,150
由于这已经是左子树里最高的了

837
01:18:07,340 --> 01:18:09,290
如果连最高的都没重叠

838
01:18:09,360 --> 01:18:10,850
那就谁都重叠不上了

839
01:18:12,560 --> 01:18:15,920
假设要向左搜索

840
01:18:22,530 --> 01:18:31,050
而且在左子树里没有发现重叠的区间

841
01:18:34,420 --> 01:18:45,250
我向左走也什么都没找到

842
01:18:45,390 --> 01:18:50,170
现在我要证明 在这种情况下往右走也是徒劳的

843
01:18:50,330 --> 01:18:53,420
这是就是这个定理的主要内容

844
01:18:53,590 --> 01:18:56,290
假设有这个条件 那向右走也没用

845
01:18:56,390 --> 01:18:57,910
我要证明右子树里没有我们想要找的区间

846
01:18:58,020 --> 01:18:59,430
那到右子树也可以

847
01:18:59,570 --> 01:19:01,280
除非你什么都不想找

848
01:19:01,900 --> 01:19:05,400
其实差不多 分析的过程差不多

849
01:19:06,210 --> 01:19:11,860
i的低端点小于等于x左结点的m值

850
01:19:13,690 --> 01:19:26,230
它还是等于L中某些区间j的高端点

851
01:19:26,470 --> 01:19:34,800
就是说如果向左走的话 这些命题就都是真的

852
01:19:36,080 --> 01:19:53,210
如果往左走 既然j在L里而且与i不重叠

853
01:19:53,540 --> 01:19:59,180
因为这个集合里与i重叠的区间是空集

854
01:19:59,390 --> 01:20:04,800
既然j与i不重合

855
01:20:04,970 --> 01:20:17,450
那么i的高端点一定小于j的低端点

856
01:20:22,820 --> 01:20:28,700
既然L里面的j与i不重叠

857
01:20:29,080 --> 01:20:31,970
那么可能会怎样？

858
01:20:33,060 --> 01:20:37,610
其实就是这样的 我来画个图说明

859
01:20:37,820 --> 01:20:42,450
这是j 还有i

860
01:20:46,840 --> 01:20:50,140
注意他们并没重叠

861
01:20:52,490 --> 01:20:56,630
因此 它肯定是左边的

862
01:20:56,800 --> 01:21:05,550
因为它的低端点比这个还要小

863
01:21:05,700 --> 01:21:07,390
但是他没重叠

864
01:21:07,550 --> 01:21:11,240
因此它的高端点一定比这个低端点还要小

865
01:21:24,990 --> 01:21:28,770
现在我们要用到二叉搜索树的性质了

866
01:21:34,900 --> 01:21:43,050
这就是说对于R中的所有i'区间

867
01:21:43,280 --> 01:21:45,580
就是右子树里面的所有区间

868
01:21:45,800 --> 01:21:54,970
我们可以得出j的低端点小于等于i'的低端点

869
01:21:55,260 --> 01:21:57,960
这次我们基本上是在讨论低端点

870
01:21:59,610 --> 01:22:03,760
右子树里面的所有区间的低端点

871
01:22:03,930 --> 01:22:08,400
都是位于j的低端点右面的

872
01:22:08,740 --> 01:22:10,690
因为j是在左子树里

873
01:22:10,900 --> 01:22:14,530
整棵树里的所有区间都是按照低端点排序的

874
01:22:14,720 --> 01:22:17,520
所以右子树里的任何区间都是从这个地方开始的

875
01:22:17,680 --> 01:22:24,300
这是另一棵子树里的 这些是R里的i'区间

876
01:22:24,540 --> 01:22:26,590
我也不知道有多少

877
01:22:26,700 --> 01:22:29,660
不过它们都是从这个点的右边开始的

878
01:22:29,810 --> 01:22:31,400
所以它们也不会和i重叠

879
01:22:35,890 --> 01:22:38,560
因此 这里没有我们要找的东西

880
01:22:38,680 --> 01:22:50,810
R里面的所有的i'都不重叠

881
01:22:53,610 --> 01:23:00,820
再来复习一下 大体的想法就是

882
01:23:00,970 --> 01:23:07,470
既然它不和左子树的区间相交

883
01:23:07,620 --> 01:23:10,350
那么所有右子树的区间都要更加靠右

884
01:23:10,460 --> 01:23:15,610
所以当我在左边什么都没找到 那就完事了

885
01:23:15,750 --> 01:23:17,410
因为在另一边我还是什么都找不到

886
01:23:17,550 --> 01:23:18,620
右边也不会有重叠的

887
01:23:21,960 --> 01:23:25,490
数据结构的扩张 很给力

888
01:23:25,590 --> 01:23:28,300
他会给你多姿多彩的数据结构

889
01:23:28,510 --> 01:23:32,490
可以从任何已知的数据结构出发

890
01:23:32,620 --> 01:23:37,830
像哈希表 堆 二叉搜索树等等

