1
00:00:11,400 --> 00:00:17,430
And this...Emm...is going to use

2
00:00:17,570 --> 00:00:20,600
some of the techniques we learned last time

3
00:00:22,040 --> 00:00:25,780
with respect to amortized analysis.

4
00:00:26,700 --> 00:00:30,050
And, what's neat about what we're going to talk about today

5
00:00:30,060 --> 00:00:37,410
is it's a way of comparing algorithms

6
00:00:37,410 --> 00:00:41,220
that are so-called online algorithms.

7
00:00:41,300 --> 00:00:47,770
And we're going to introduce this notion with

8
00:00:47,810 --> 00:00:51,810
a problem which is called self organizing lists.

9
00:00:57,650 --> 00:01:00,550
OK, and so the set up for this problem is that

10
00:01:00,650 --> 00:01:06,290
we have a list, L, of n elements.

11
00:01:08,910 --> 00:01:14,340
And, we have an operation.

12
00:01:19,680 --> 00:01:21,400
Woops, I've got to spell things right,

13
00:01:23,420 --> 00:01:31,150
access of x, which accesses item x in the list.

14
00:01:31,410 --> 00:01:32,450
It could be by searching,

15
00:01:32,630 --> 00:01:34,220
or it could be however you want to do it.

16
00:01:34,510 --> 00:01:37,700
But basically, it goes and touches that element.

17
00:01:37,790 --> 00:01:44,030
And we were to say the cost of that operation is

18
00:01:44,360 --> 00:01:49,470
whatever the rank of x is in the list,

19
00:01:49,570 --> 00:02:03,430
which is just the distance of x from the head of the list.

20
00:02:05,270 --> 00:02:07,340
And the other thing that we can do

21
00:02:07,910 --> 00:02:09,570
is that the algorithm can do,

22
00:02:09,730 --> 00:02:11,780
so this is what the user would do.

23
00:02:11,820 --> 00:02:14,980
He just simply runs a whole bunch of accesses on the list,

24
00:02:15,350 --> 00:02:18,190
OK, accessing one element after another

25
00:02:18,260 --> 00:02:22,820
in any order that he or she cares to.

26
00:02:23,310 --> 00:02:27,220
And then, L can be reordered, however,

27
00:02:31,500 --> 00:02:38,710
by transposing adjacent elements.

28
00:02:45,500 --> 00:02:49,530
And the cost for that is one.

29
00:02:50,660 --> 00:02:51,980
So, for example,

30
00:02:54,020 --> 00:03:02,180
suppose the list is the following.

31
00:03:17,890 --> 00:03:22,910
OK, I missed something here.

32
00:03:25,670 --> 00:03:27,730
It doesn't matter.

33
00:03:27,810 --> 00:03:31,250
Well, I'll just make it be what I have

34
00:03:31,530 --> 00:03:36,290
so that it matches the online video.

35
00:03:42,360 --> 00:03:43,760
OK, so here we have a list.

36
00:03:44,120 --> 00:03:48,700
And so, if I do something like access element 14 here,

37
00:03:48,860 --> 00:03:50,780
the element of key 14,

38
00:03:51,690 --> 00:03:57,120
OK, that this costs me one, two, three, four.

39
00:03:57,300 --> 00:04:02,630
So here the cost is four to access.

40
00:04:04,810 --> 00:04:08,450
And so, we're going to have some sequence of accesses

41
00:04:08,510 --> 00:04:10,730
that the user is going to do.

42
00:04:11,320 --> 00:04:14,950
And obviously, if something is accessed more frequently,

43
00:04:15,710 --> 00:04:19,880
we'd like to move it up to the front of the list

44
00:04:19,940 --> 00:04:22,190
so that you don't have to search as far.

45
00:04:22,240 --> 00:04:25,590
OK, and to do that, if I want to transpose something,

46
00:04:25,600 --> 00:04:29,820
so, for example, if I transpose three and 50,

47
00:04:33,410 --> 00:04:36,000
that just costs me one.

48
00:04:36,760 --> 00:04:39,600
OK, so then I would make this be 50,

49
00:04:39,960 --> 00:04:41,820
and make this be three.

50
00:04:42,680 --> 00:04:46,880
OK, sorry, normally you just do it by swapping pointers.

51
00:04:48,300 --> 00:04:51,540
OK, so those are the two operations.

52
00:04:53,070 --> 00:04:57,240
And, we are going to do this in what's called an online fashion.

53
00:04:57,250 --> 00:05:00,980
So, let's just define online.

54
00:05:01,360 --> 00:05:06,660
So, a sequence, S, of operations

55
00:05:06,760 --> 00:05:21,010
is provided one at a time for each operation.

56
00:05:22,750 --> 00:05:33,410
An online algorithm must execute the operation immediately

57
00:05:42,590 --> 00:05:44,660
without getting a chance to look at

58
00:05:44,710 --> 00:05:46,940
what else is coming in the sequence.

59
00:05:47,290 --> 00:05:49,640
So, when you make your decision for the first element,

60
00:05:50,090 --> 00:05:52,200
you don't get to see ahead

61
00:05:52,460 --> 00:05:54,760
as to what the second, or third, or whatever is.

62
00:05:54,940 --> 00:05:57,070
And the second one you get,

63
00:05:57,270 --> 00:05:59,280
and you have to make your decision as to what to do

64
00:05:59,290 --> 00:06:00,210
and so forth.

65
00:06:00,390 --> 00:06:01,980
So, that's an online algorithm.

66
00:06:03,560 --> 00:06:06,380
Similarly, an off-line algorithm,

67
00:06:10,890 --> 00:06:19,760
OK, may see all of S in advance.

68
00:06:25,140 --> 00:06:26,380
OK, so you can see

69
00:06:26,590 --> 00:06:29,160
an off-line algorithm gets to see the whole sequence,

70
00:06:29,180 --> 00:06:30,830
and then decide what it wants to do about

71
00:06:31,050 --> 00:06:33,320
element one, element two, or whatever.

72
00:06:34,140 --> 00:06:37,280
So an off-line algorithm can look at the whole sequence and say,

73
00:06:37,310 --> 00:06:41,690
OK, I can see that item number 17 is being accessed a lot,

74
00:06:42,820 --> 00:06:46,540
or early on move him up closer to the front of the list,

75
00:06:46,610 --> 00:06:50,130
and then the accesses cost less for the off-line algorithm.

76
00:06:50,210 --> 00:06:53,000
The online algorithm doesn't get to see any of that.

77
00:06:53,930 --> 00:06:55,760
OK, so this is sort of like,

78
00:06:55,990 --> 00:06:58,050
if you're familiar with the game Tetris.

79
00:06:58,330 --> 00:06:59,750
OK, and Tetris,

80
00:06:59,930 --> 00:07:02,740
you get one shape after another that starts coming down,

81
00:07:02,880 --> 00:07:04,010
and you have to twiddle it,

82
00:07:04,430 --> 00:07:07,320
and move it to the side, and drop it into place.

83
00:07:08,130 --> 00:07:11,120
And there, sometimes you get a one step look-ahead

84
00:07:11,320 --> 00:07:13,380
on some of them so you can see what the next shape is,

85
00:07:13,560 --> 00:07:15,560
but often it's purely online.

86
00:07:15,780 --> 00:07:17,730
You don't get to see that next shape or whatever,

87
00:07:17,950 --> 00:07:19,460
and you have to make a decision for each one.

88
00:07:19,860 --> 00:07:20,790
And you make a decision,

89
00:07:21,040 --> 00:07:22,580
and you realize that the next shape,

90
00:07:22,750 --> 00:07:24,170
ah, if you had made a different decision

91
00:07:24,460 --> 00:07:25,740
it would have been better.

92
00:07:26,230 --> 00:07:30,170
OK, so that's the kind of problem.

93
00:07:30,370 --> 00:07:31,900
Off-line Tetris would be,

94
00:07:32,130 --> 00:07:34,560
I get to see the whole sequence of shapes.

95
00:07:34,890 --> 00:07:36,900
And now let me decide what I'm going to do with this one.

96
00:07:39,770 --> 00:07:45,240
OK, and so, in this, the goal is for any of the algorithms,

97
00:07:45,280 --> 00:07:52,670
either online or off-line is to minimize the total cost,

98
00:07:53,390 --> 00:07:56,060
which we'll denote by,

99
00:07:59,670 --> 00:08:02,370
☆★☆★☆, I forgot to name this.

99
00:08:02,380 --> 00:08:05,430
This is algorithm A here.

100
00:08:06,350 --> 00:08:10,160
The total cost, C_A of S,

101
00:08:10,340 --> 00:08:14,920
OK, so the cost of algorithm A on the sequence, S.

102
00:08:15,160 --> 00:08:18,590
That's just the notation we'll use for what the total cost is.

103
00:08:19,340 --> 00:08:23,220
So, any questions about the setup to this problem?

104
00:08:24,250 --> 00:08:25,530
So, we have an online problem.

105
00:08:25,680 --> 00:08:27,890
We're going to get these things one at a time,

106
00:08:28,480 --> 00:08:32,710
OK, and we have to decide what to do.

107
00:08:33,720 --> 00:08:39,180
So, let's do a worst-case analysis for this.

108
00:08:50,180 --> 00:08:55,630
OK, so if we're doing a worst-case analysis,

109
00:08:55,770 --> 00:08:57,570
we can view that we have an adversary that

110
00:08:57,690 --> 00:08:59,870
we are playing against who's going to provide the sequence.

111
00:08:59,880 --> 00:09:03,020
The user is going to be able to see what we do.

112
00:09:03,170 --> 00:09:05,860
And so, what's the adversary strategy?

113
00:09:08,020 --> 00:09:13,240
[Student]:Inaudible.

114
00:09:13,410 --> 00:09:15,670
[Prof]:Thwart our plots, yes, that's his idea.

115
00:09:15,890 --> 00:09:18,280
And how is he going to thwart them, or she?

116
00:09:18,340 --> 00:09:21,500
[Student]:Inaudible.

117
00:09:21,660 --> 00:09:24,280
[Prof]:Which is what for this problem?

118
00:09:24,800 --> 00:09:25,780
What's he going to do?

119
00:09:26,260 --> 00:09:27,530
[Student]:Inaudible.

120
00:09:27,540 --> 00:09:33,730
[Prof]:Yeah. No matter how we reorder elements using the transposes,

121
00:09:34,250 --> 00:09:36,830
he's going to look at every step and say,

122
00:09:37,010 --> 00:09:38,240
what's the last element?

123
00:09:38,460 --> 00:09:41,430
That's the one I'm going to access, right?

124
00:09:41,880 --> 00:09:44,150
So, the adversary always,

125
00:09:48,600 --> 00:09:59,460
always accesses the tail element of L.

126
00:09:59,600 --> 00:10:02,580
No matter what it is, no matter how we reorder things,

127
00:10:03,650 --> 00:10:07,750
OK, for each one, adversary just accesses the tail.

128
00:10:07,990 --> 00:10:11,450
So the cost of this, of any algorithm, then,

129
00:10:12,030 --> 00:10:19,990
is going to be omega size of S times n,

130
00:10:20,740 --> 00:10:23,120
OK, because you're always going to pay for every sequence.

131
00:10:23,340 --> 00:10:27,840
You're going to have to go in to pay a cost of n,

132
00:10:28,300 --> 00:10:30,780
OK, for every element in the sequence.

133
00:10:30,960 --> 00:10:34,930
OK, so not terribly in the worst-case.

134
00:10:40,730 --> 00:10:44,770
Not terribly good.

135
00:10:45,240 --> 00:10:47,830
So, people in studying this problem: question?

136
00:10:47,850 --> 00:10:50,270
[Student]: Inaudible.

137
00:10:50,330 --> 00:10:52,200
[Prof]:That analysis is for the online algorithm, right.

138
00:10:52,450 --> 00:10:54,900
The off-line algorithm, right,

139
00:10:55,010 --> 00:10:57,240
if you named those things, that's right.

140
00:10:57,370 --> 00:11:01,060
OK, so we're looking at trying to solve this in an off-line sense,

141
00:11:01,250 --> 00:11:03,280
sorry, in an online sense.

142
00:11:04,060 --> 00:11:06,530
OK, and so the point is that for the online algorithm,

143
00:11:06,710 --> 00:11:08,870
the adversary can be incredibly mean,

144
00:11:09,830 --> 00:11:12,850
OK, and just always access the thing at the end, OK?

145
00:11:13,060 --> 00:11:16,530
So, what sort of the history of this problem is,

146
00:11:16,640 --> 00:11:18,050
that people said, well,

147
00:11:18,340 --> 00:11:22,860
if I can't do well in the worst-case,

148
00:11:24,290 --> 00:11:27,760
maybe I should be looking at average case,

149
00:11:29,020 --> 00:11:30,320
OK, and look at, say,

150
00:11:31,350 --> 00:11:34,860
the different elements having some probability distribution.

151
00:11:35,720 --> 00:11:39,030
OK, so the average case analysis,

152
00:11:45,090 --> 00:11:52,630
OK, let's suppose that element x is accessed,

153
00:11:56,470 --> 00:12:03,370
with probability P of x.

154
00:12:05,700 --> 00:12:07,390
OK, so suppose that

155
00:12:07,560 --> 00:12:11,980
we have some a priori distribution on the elements.

156
00:12:12,730 --> 00:12:20,960
Then the expected cost of the algorithm on a sequence,

157
00:12:23,130 --> 00:12:28,950
OK, so if I put all the elements into some order,

158
00:12:29,980 --> 00:12:33,540
OK, and don't try to reorder,

159
00:12:33,730 --> 00:12:36,760
but just simply look at, is there a static ordering

160
00:12:36,840 --> 00:12:39,210
that would work well for a distribution?

161
00:12:39,440 --> 00:12:42,770
It's just going to be, by definition of expectation,

162
00:12:44,290 --> 00:12:47,800
the probability of x times, in this case, the cost,

163
00:12:47,840 --> 00:12:54,370
which is the rank of x in whatever that ordering is

164
00:12:54,650 --> 00:12:56,630
that I decide I'm going to use.

165
00:12:59,910 --> 00:13:02,550
OK, and this is minimized when?

166
00:13:12,770 --> 00:13:15,450
So, this is just the definition of expectations:

167
00:13:15,590 --> 00:13:19,330
the probability that I access x times the cost

168
00:13:19,720 --> 00:13:21,280
summed over all the elements.

169
00:13:21,330 --> 00:13:23,760
And the cost is just going to be its position in the list.

170
00:13:24,380 --> 00:13:26,230
So, when is this value,

171
00:13:26,250 --> 00:13:28,560
this summation, going to be minimized?

172
00:13:33,560 --> 00:13:36,820
[Student]:Inaudible.

173
00:13:37,030 --> 00:13:39,810
[Prof]:When the element is most likely as the lowest rank,

174
00:13:40,120 --> 00:13:43,010
and then what, what about the other element?

175
00:13:45,930 --> 00:13:48,190
OK, so what does that mean?

176
00:13:48,240 --> 00:13:49,880
[Student]:Inaudible.

177
00:13:50,040 --> 00:13:52,230
[Prof]:Yeah, sort them, yeah,

178
00:13:52,240 --> 00:13:56,090
sort them on the basis of decreasing probability, OK?

179
00:13:56,360 --> 00:14:00,280
So, it's minimized when L is sorted,

180
00:14:02,180 --> 00:14:14,480
OK, in decreasing order with respect to P.

181
00:14:18,010 --> 00:14:23,400
OK, so just sort them with the most likely one at the front,

182
00:14:23,610 --> 00:14:24,900
and then just decreasing probability.

183
00:14:25,120 --> 00:14:28,440
That way, whenever I access something with some probability,

184
00:14:28,970 --> 00:14:30,410
OK, I'm going to access,

185
00:14:30,740 --> 00:14:32,130
it's more likely that I'm going to access.

186
00:14:32,320 --> 00:14:34,220
And that's not too difficult to actually prove.

187
00:14:34,460 --> 00:14:37,630
You just look at, suppose there were two that were out of order,

188
00:14:38,050 --> 00:14:39,300
and show that if you swap them,

189
00:14:39,330 --> 00:14:45,560
you would improve this optimization function.

190
00:14:49,500 --> 00:14:51,220
OK, so if you didn't know it,

191
00:14:51,400 --> 00:14:54,080
this suggests the following heuristic,

192
00:14:57,710 --> 00:15:04,650
OK, which is simply keep account of the number of times

193
00:15:08,700 --> 00:15:13,170
each element is accessed,

194
00:15:18,680 --> 00:15:29,940
and maintain the list in order of decreasing count.

195
00:15:35,920 --> 00:15:37,960
OK, so whenever something is accessed,

196
00:15:39,470 --> 00:15:40,670
increment its count,

197
00:15:42,430 --> 00:15:44,590
OK, and that will move it,

198
00:15:44,730 --> 00:15:45,780
at most, one position,

199
00:15:45,910 --> 00:15:49,110
which only costs me one transposed to move it,

200
00:15:49,180 --> 00:15:50,490
perhaps, forward.

201
00:15:51,320 --> 00:15:52,540
OK, actually, I guess it could be more

202
00:15:52,680 --> 00:15:54,430
if you have a whole bunch of ties, right?

203
00:15:55,030 --> 00:15:56,870
Yeah. So, it could cost more.

204
00:15:57,070 --> 00:15:58,530
But the idea is, over time,

205
00:15:59,010 --> 00:16:01,720
the law of large numbers says that

206
00:16:01,910 --> 00:16:04,860
this is going to approach the probability distribution.

207
00:16:05,440 --> 00:16:07,480
The frequency with which you access this,

208
00:16:07,520 --> 00:16:09,490
divided by the total number of accesses,

209
00:16:09,640 --> 00:16:11,800
will be the probability.

210
00:16:11,810 --> 00:16:16,300
And so, therefore you will get things in decreasing probability,

211
00:16:16,830 --> 00:16:20,100
OK, assuming that there is some distribution that

212
00:16:20,560 --> 00:16:26,700
all of these elements are chosen according to,

213
00:16:26,780 --> 00:16:28,760
or accessed according to.

214
00:16:31,290 --> 00:16:36,280
So, it doesn't seem like there's that much more

215
00:16:36,500 --> 00:16:38,140
you could really do here.

216
00:16:38,280 --> 00:16:39,590
And that's why I think

217
00:16:39,810 --> 00:16:42,730
this notion of competitive analysis is so persuasive,

218
00:16:43,000 --> 00:16:46,040
because it's really amazingly strong, OK?

219
00:16:47,030 --> 00:16:54,410
And it came about because of what people were doing in practice.

220
00:16:58,380 --> 00:17:00,860
So practice, what people implement it

221
00:17:01,380 --> 00:17:07,850
was a so-called move to front heuristic.

222
00:17:11,160 --> 00:17:13,220
OK, and the basic idea was,

223
00:17:13,360 --> 00:17:14,990
after you access an element,

224
00:17:16,230 --> 00:17:18,350
just move it up to the front.

225
00:17:19,730 --> 00:17:23,140
OK, that only doubles the cost of accessing the element

226
00:17:23,240 --> 00:17:25,440
because I go and I access it,

227
00:17:25,620 --> 00:17:27,180
chasing it down paying the rank,

228
00:17:27,330 --> 00:17:31,320
and then I have to do rank number of transposes

229
00:17:31,890 --> 00:17:33,470
to bring it back to the front.

230
00:17:35,010 --> 00:17:38,060
So, it only cost me a factor of two, and now,

231
00:17:38,210 --> 00:17:41,620
if it happens to be a frequently accessed elements,

232
00:17:41,890 --> 00:17:43,360
over time you would hope that

233
00:17:43,640 --> 00:17:47,780
the most likely elements were near the front of that list.

234
00:17:48,580 --> 00:17:54,130
So, after accessing x,

235
00:17:57,380 --> 00:18:09,580
move x to the head of the list using transposes,

236
00:18:13,350 --> 00:18:22,510
and the cost is just equal to twice the rank in L of x,

237
00:18:22,830 --> 00:18:27,670
OK, where the two here has two parts.

238
00:18:27,820 --> 00:18:29,510
One is the access,

239
00:18:30,780 --> 00:18:33,510
and the other is the transposes.

240
00:18:38,110 --> 00:18:41,120
OK, so that's sort of what they did.

241
00:18:41,270 --> 00:18:43,630
And one of the nice properties of this is that

242
00:18:43,770 --> 00:18:46,900
if it turns out that there is locality in the access pattern,

243
00:18:47,150 --> 00:18:51,060
if it's not just a static distribution,

244
00:18:51,640 --> 00:18:53,530
but rather once I've accessed something,

245
00:18:53,640 --> 00:18:55,950
if it's more likely I'm going to access it again,

246
00:18:56,420 --> 00:19:00,200
which tends to be the case for many input types of patterns,

247
00:19:00,420 --> 00:19:03,270
this responds well to locality

248
00:19:03,520 --> 00:19:05,350
because it's going to be up near the front

249
00:19:05,690 --> 00:19:08,410
if I access it very soon after I've accessed.

250
00:19:08,550 --> 00:19:10,580
So, there is what's called temporal locality,

251
00:19:10,830 --> 00:19:13,300
meaning that in time, I tend to access,

252
00:19:13,370 --> 00:19:15,730
so it may be that I access some thing's very hot for awhile;

253
00:19:15,810 --> 00:19:17,360
then it gets very cold.

254
00:19:17,400 --> 00:19:20,150
This type of algorithm responds very well

255
00:19:20,290 --> 00:19:24,460
to the hotness of the accessing.

256
00:19:24,810 --> 00:19:37,450
OK, so it responds well to locality in S.

257
00:19:44,510 --> 00:19:46,540
So, this is sort of what was known

258
00:19:46,760 --> 00:19:49,720
up to the point that a very famous paper was written

259
00:19:50,330 --> 00:19:54,750
by Danny Sleator and Bob Tarjan,

260
00:19:55,860 --> 00:19:58,620
where they took a totally different approach

261
00:19:59,040 --> 00:20:00,910
to looking at this kind of problem.

262
00:20:01,450 --> 00:20:03,600
OK, and it's an approach that matter you see everywhere

263
00:20:03,750 --> 00:20:11,610
from analysis of caching and high-performance processors

264
00:20:12,180 --> 00:20:14,450
to analyses of disk paging

265
00:20:14,840 --> 00:20:19,410
to just a huge number of applications of this basic technique.

266
00:20:19,590 --> 00:20:21,840
And, that's the technique of competitive analysis.

267
00:20:28,400 --> 00:20:30,140
OK, so here's the definition.

268
00:20:37,120 --> 00:20:45,430
So, online algorithm A is alpha competitive.

269
00:20:51,380 --> 00:20:55,780
If there exists a constant, k,

270
00:20:56,580 --> 00:21:05,030
such that for any sequence, S, of operations,

271
00:21:07,320 --> 00:21:11,550
the cost of S using algorithm A

272
00:21:13,580 --> 00:21:27,120
is bounded by alpha times the cost of opt,

273
00:21:27,380 --> 00:21:36,600
where opt is the optimal offline algorithm.

274
00:21:37,290 --> 00:21:39,220
OK, so the optimal off-line,

275
00:21:39,330 --> 00:21:41,500
the one that knows the whole sequence

276
00:21:42,140 --> 00:21:46,310
and does the absolute best it could do on that sequence,

277
00:21:47,410 --> 00:21:49,460
OK, that's this cost here.

278
00:21:49,650 --> 00:21:54,420
This is sometimes called God's algorithm,

279
00:21:55,990 --> 00:21:58,260
OK, not to bring religion into the classroom,

280
00:21:58,700 --> 00:21:59,930
or to offend anybody,

281
00:22:00,040 --> 00:22:01,910
but that is what people sometimes call it.

282
00:22:02,080 --> 00:22:04,760
OK, so the fully omniscient knows

283
00:22:04,800 --> 00:22:06,750
absolutely the best thing that could be done,

284
00:22:06,790 --> 00:22:09,670
sees into the future, the whole works, OK?

285
00:22:09,790 --> 00:22:11,520
It gets to apply that.

286
00:22:11,520 --> 00:22:13,480
That's what opts algorithm is.

287
00:22:14,610 --> 00:22:16,610
And, what we're saying is that

288
00:22:16,820 --> 00:22:21,520
the cost is basically whatever this alpha factor is.

289
00:22:21,630 --> 00:22:23,460
It could be a function of things,

290
00:22:23,580 --> 00:22:24,600
or it could be a constant,

291
00:22:24,720 --> 00:22:29,050
OK, times whatever the best algorithm is.

292
00:22:30,370 --> 00:22:33,520
Plus, there's a potential for a constant out here.

293
00:22:37,730 --> 00:22:39,980
OK, so for example, if alpha is two,

294
00:22:40,800 --> 00:22:42,410
and we say it's two competitive,

295
00:22:42,720 --> 00:22:44,580
that means you're going to do, at worst,

296
00:22:44,620 --> 00:22:48,120
twice the algorithm that has all the information.

297
00:22:48,130 --> 00:22:51,430
But you're doing it online, for example.

298
00:22:52,360 --> 00:22:55,840
OK, it's a really pretty powerful notion.

299
00:22:55,990 --> 00:22:57,570
And what's interesting about this,

300
00:22:57,960 --> 00:23:00,810
it's not even clear these things should exist to my mind.

301
00:23:01,430 --> 00:23:07,940
OK, what's pretty remarkable about this,

302
00:23:08,090 --> 00:23:12,350
I think, is that there is no assumption of distribution,

303
00:23:12,450 --> 00:23:14,610
of probability distribution or anything.

304
00:23:15,370 --> 00:23:18,020
It's whatever the sequence is that you give it.

305
00:23:18,590 --> 00:23:21,550
You are within a factor of alpha, essentially,

306
00:23:21,610 --> 00:23:24,930
of the best algorithm, OK,

307
00:23:24,930 --> 00:23:26,320
which is pretty remarkable.

308
00:23:27,550 --> 00:23:30,850
OK, and so, we're going to prove the following theorem,

309
00:23:34,980 --> 00:23:37,510
which is the one that Sleator and Tarjan proved.

310
00:23:37,800 --> 00:23:44,580
And that is that MTF is four competitive

311
00:23:47,600 --> 00:23:50,150
for self organizing lists.

312
00:23:56,120 --> 00:24:04,880
OK, so the idea here is that suppose the adversary says,

313
00:24:05,060 --> 00:24:09,200
oh, I'm always going to access the thing at the end of the list

314
00:24:09,570 --> 00:24:10,760
like we said in the beginning.

315
00:24:12,090 --> 00:24:13,300
So, the adversary says,

316
00:24:13,310 --> 00:24:14,560
I'm always going to access the thing there.

317
00:24:14,730 --> 00:24:16,790
I'm going to make MTF work really bad,

318
00:24:16,970 --> 00:24:18,950
because you're going to go and move that thing

319
00:24:19,130 --> 00:24:20,430
all the way up to the front.

320
00:24:20,880 --> 00:24:23,210
And I'm just going to access the thing way at the end again.

321
00:24:25,160 --> 00:24:26,400
OK, well it turns out,

322
00:24:26,740 --> 00:24:31,440
yeah, that's a bad sequence for move to front,

323
00:24:33,030 --> 00:24:34,030
OK, and it will take a long time.

324
00:24:34,170 --> 00:24:37,400
But it turns out God couldn't have done better,

325
00:24:38,000 --> 00:24:39,820
OK, by more than a factor of four

326
00:24:40,470 --> 00:24:42,530
no matter how long the list is.

327
00:24:44,030 --> 00:24:45,140
OK, that's pretty amazing.

328
00:24:46,880 --> 00:24:49,570
So yeah that's a bad sequence.

329
00:24:49,630 --> 00:24:51,820
But, if there's a way that

330
00:24:51,930 --> 00:24:54,790
the sequence exhibits any kind of locality

331
00:24:54,900 --> 00:24:57,840
or anything that can be taken advantage of,

332
00:24:57,940 --> 00:24:59,400
if you could see the whole thing,

333
00:24:59,540 --> 00:25:01,840
MTF takes advantage of it too,

334
00:25:02,510 --> 00:25:04,310
OK, within a factor of four.

335
00:25:06,400 --> 00:25:08,600
OK, it's a pretty remarkable theorem,

336
00:25:10,740 --> 00:25:16,040
and it's the basis of many types of analysis of online algorithms.

337
00:25:16,190 --> 00:25:18,610
Almost all online algorithms today are analyzed

338
00:25:18,820 --> 00:25:21,190
using some kind of competitive analysis.

339
00:25:22,040 --> 00:25:22,920
OK, not always.

340
00:25:23,020 --> 00:25:26,440
Sometimes you do probabilistic analysis, or whatever,

341
00:25:26,580 --> 00:25:29,940
but the dominant thing is to competitive analysis

342
00:25:30,050 --> 00:25:32,600
because then you don't have to make any statistical assumptions.

343
00:25:33,720 --> 00:25:36,930
OK, just prove that it works well no matter how.

344
00:25:37,040 --> 00:25:38,900
This is remarkable, I think.

345
00:25:38,900 --> 00:25:40,560
Isn't it remarkable?

346
00:25:45,320 --> 00:25:47,130
So, let's prove this theorem,

347
00:25:47,580 --> 00:25:50,260
we're just going to spend the rest of the lecture on this proof.

348
00:25:51,040 --> 00:25:53,780
OK, and the proof in some ways is not hard,

349
00:25:53,920 --> 00:25:56,560
but it's also not necessarily completely intuitive.

350
00:25:56,670 --> 00:25:59,300
So, you will have to pay attention.

351
00:26:03,130 --> 00:26:11,030
OK, so let's get some notation down.

352
00:26:11,130 --> 00:26:23,910
Let's let L_i be MTF's list after the i'th access.

353
00:26:26,360 --> 00:26:36,660
And, let's let L be opt's list after the i'th access.

354
00:26:36,840 --> 00:26:38,340
OK, so generally what I'll do is

355
00:26:38,450 --> 00:26:40,390
I'll put a star if we are talking about opt,

356
00:26:41,610 --> 00:26:45,620
and have nothing if we're talking about MTF.

357
00:26:48,720 --> 00:26:49,990
OK, so that's going to be the list.

358
00:26:50,180 --> 00:26:51,400
So, we can say, what's the list?

359
00:26:51,510 --> 00:26:56,580
So, we're going to set it up where we have one in operation

360
00:26:56,690 --> 00:27:00,660
that transforms list i minus one into list i.

361
00:27:01,330 --> 00:27:03,030
OK, that's what the i'th operation does.

362
00:27:03,560 --> 00:27:06,420
OK, and move to front does it by moving

363
00:27:06,560 --> 00:27:08,620
whatever the thing that was accessed to the front.

364
00:27:08,730 --> 00:27:12,960
And opt does whatever opt thinks is the best thing to do.

365
00:27:13,070 --> 00:27:14,540
We don't know.

366
00:27:16,620 --> 00:27:30,410
So, we're going to let c_i be MTF's cost for the I'th operation.

367
00:27:31,090 --> 00:27:38,560
And that's just twice the rank in L_i minus one of x

368
00:27:39,830 --> 00:27:48,050
if the operation accesses x, OK,

369
00:27:48,160 --> 00:27:51,740
two times the rank in L_i minus one

370
00:27:51,950 --> 00:27:54,480
because we're going to be accessing it in L_i minus one

371
00:27:54,590 --> 00:27:56,750
and transforming it into L_i.

372
00:27:58,130 --> 00:28:01,020
And similarly, we'll let c_i star

373
00:28:01,840 --> 00:28:11,500
be opt's cost for the i'th operation.

374
00:28:12,430 --> 00:28:15,480
And that's just equal to, well,

375
00:28:15,580 --> 00:28:22,610
to access it, it's going to be the rank in L_i minus one star,

376
00:28:22,630 --> 00:28:27,260
whatever its list is of x at that step,

377
00:28:27,370 --> 00:28:28,910
because it's got to access it.

378
00:28:29,380 --> 00:28:32,570
And then, some number of transposes,

379
00:28:32,870 --> 00:28:43,200
t_i if opt forms t_i transposes.

380
00:28:49,860 --> 00:28:53,600
OK, so we have the setup where we have

381
00:28:53,970 --> 00:28:56,360
two different lists that are being managed,

382
00:28:56,650 --> 00:28:58,400
and we have different costs in the list.

383
00:29:00,870 --> 00:29:04,130
And, we're interested in is comparing in some way

384
00:29:06,000 --> 00:29:10,990
MTF's list with opt's list at any point in time.

385
00:29:11,980 --> 00:29:13,890
And, how do you think we're going to do that?

386
00:29:17,010 --> 00:29:18,400
What technique do you think we should use

387
00:29:18,500 --> 00:29:20,250
to compare these two lists,

388
00:29:20,690 --> 00:29:24,540
general technique from last lecture?

389
00:29:27,240 --> 00:29:29,510
Well, it is going to be amortized, but what?

390
00:29:30,860 --> 00:29:32,540
How are we going to compare them?

391
00:29:39,670 --> 00:29:42,700
What technique did we learn last time?

392
00:29:45,830 --> 00:29:47,190
Potential function, good.

393
00:29:48,450 --> 00:29:50,750
OK, we're going to define a potential function,

394
00:29:52,120 --> 00:29:56,060
OK, that measures how far apart these two lists are.

395
00:29:59,930 --> 00:30:01,570
OK, and the idea is, if,

396
00:30:02,610 --> 00:30:05,440
let's define that and then we'll take a look at it.

397
00:30:05,620 --> 00:30:21,950
So, we're going to define the potential function phi

398
00:30:22,880 --> 00:30:29,830
mapping the set of MTF's lists into the real numbers

399
00:30:30,540 --> 00:30:33,130
by the following.

400
00:30:35,640 --> 00:30:44,880
phi of L_i is going to be twice the cardinality of this set.

401
00:31:03,250 --> 00:31:09,690
OK, so this is the precedes-operation and list, i.

402
00:31:10,160 --> 00:31:13,000
So, we can define a relationship between any two elements

403
00:31:13,520 --> 00:31:20,320
that says that x precedes y in L_i if,

404
00:31:20,960 --> 00:31:23,720
as I'm accessing it from the head, I hit x first.

405
00:31:25,020 --> 00:31:26,810
OK, so what I'm interested in, here, are

406
00:31:27,450 --> 00:31:31,480
in some sense the disagreements between the two lists.

407
00:31:31,660 --> 00:31:36,430
This is where x precedes y in MTF's list,

408
00:31:36,610 --> 00:31:39,790
but y precedes x in opt's list.

409
00:31:40,140 --> 00:31:43,480
They disagree, OK?

410
00:31:43,950 --> 00:31:46,400
And, what we're interested in is the cardinality of the set.

411
00:31:46,510 --> 00:31:49,440
And we're going to multiply it by two.

412
00:31:51,110 --> 00:31:54,390
OK, so that's equal to two times;

413
00:31:54,860 --> 00:31:57,200
so there is a name for this type of thing.

414
00:31:57,450 --> 00:31:59,170
We saw that when we were doing sorting.

415
00:31:59,450 --> 00:32:00,440
Anybody remember the name?

416
00:32:00,940 --> 00:32:01,950
Briefly, it was very briefly.

417
00:32:02,010 --> 00:32:05,320
I don't expect anybody to remember, but somebody might.

418
00:32:05,510 --> 00:32:07,390
Inversions: good, OK,

419
00:32:07,500 --> 00:32:09,910
twice the number of inversions.

420
00:32:13,530 --> 00:32:15,230
So, let's just do an example.

421
00:32:18,050 --> 00:32:24,160
So, let's say L_i is the list with five elements.

422
00:32:27,650 --> 00:32:34,120
OK, I'll use characters for the order

423
00:32:34,340 --> 00:32:35,940
just to keep things simple.

424
00:32:55,380 --> 00:33:03,090
So, in this case phi of L_i is going to be

425
00:33:03,740 --> 00:33:07,340
twice the cardinality of the set.

426
00:33:07,570 --> 00:33:10,690
So what we want to do is see which things are out of order.

427
00:33:11,180 --> 00:33:15,390
So here, I look at E and C are in this order,

428
00:33:15,710 --> 00:33:18,760
but C and E in that order.

429
00:33:18,980 --> 00:33:20,260
So, those are out of order.

430
00:33:20,440 --> 00:33:23,540
So, that counts as one of my elements, EC,

431
00:33:26,130 --> 00:33:29,980
and then, E and A, A and E.

432
00:33:30,170 --> 00:33:32,310
OK, so those are out of order,

433
00:33:36,530 --> 00:33:40,310
and then ED, DE, out of order,

434
00:33:46,600 --> 00:33:51,290
and then EB, BE, those are out of order.

435
00:33:54,740 --> 00:33:58,410
And now, I go C, A, C, A.

436
00:33:58,430 --> 00:34:00,310
Those are in order, so it doesn't count.

437
00:34:00,880 --> 00:34:06,360
CD, CD, CB, CB, so, nothing with C.

438
00:34:06,620 --> 00:34:10,340
Then, A, D, A, D, those are in order,

439
00:34:10,340 --> 00:34:13,140
A, B, A, B, those are in order.

440
00:34:13,460 --> 00:34:16,910
So then, DB, BD, so BD.

441
00:34:17,420 --> 00:34:19,490
And that's the last one.

442
00:34:23,290 --> 00:34:25,200
So, that's my potential function,

443
00:34:25,380 --> 00:34:28,900
which is equal to, therefore, ten,

444
00:34:29,790 --> 00:34:31,610
because the cardinality of the set is five.

445
00:34:31,750 --> 00:34:33,300
I have five inversions,

446
00:34:35,020 --> 00:34:37,070
OK, between the two lists.

447
00:34:43,590 --> 00:34:48,100
so let's just check some properties of this potential function.

448
00:34:52,730 --> 00:34:55,700
The first one is notice that phi of L_i

449
00:34:56,340 --> 00:34:58,760
is greater than or equal to zero for all i.

450
00:35:00,040 --> 00:35:02,330
The number of inversions might be zero,

451
00:35:02,480 --> 00:35:03,780
but is never less than zero.

452
00:35:04,660 --> 00:35:06,240
OK, it's always at least zero.

453
00:35:06,820 --> 00:35:09,040
So, that's one of the properties that we normally have

454
00:35:09,060 --> 00:35:11,810
when we are dealing with potential functions.

455
00:35:12,170 --> 00:35:16,150
And, the other thing is, well, what about phi of L_0?

456
00:35:17,580 --> 00:35:18,860
Is that equal to zero?

457
00:35:22,430 --> 00:35:24,470
Well, it depends upon what list they start with.

458
00:35:26,220 --> 00:35:29,280
OK, so what's the initial ordering?

459
00:35:29,430 --> 00:35:32,100
So, it's zero if they start with the same list.

460
00:35:32,880 --> 00:35:34,340
Then there are no inversions.

461
00:35:34,690 --> 00:35:36,000
But, they might start with different lists.

462
00:35:36,070 --> 00:35:37,820
We'll talk about different lists later on,

463
00:35:37,980 --> 00:35:41,180
but let's say for now that it's zero because

464
00:35:41,640 --> 00:35:43,290
they start with the same list.

465
00:35:43,400 --> 00:35:46,140
That seems like a fair comparison.

466
00:36:02,170 --> 00:36:04,070
OK, so we have this potential function now

467
00:36:04,310 --> 00:36:07,360
that's counting up, how different are these two lists.

468
00:36:08,620 --> 00:36:10,230
Intuitively, we're going to do is

469
00:36:10,370 --> 00:36:12,700
the more differences there are in the list,

470
00:36:13,440 --> 00:36:15,090
the more we are going to be able to have

471
00:36:15,300 --> 00:36:17,790
more stored up work than we can pay for it.

472
00:36:18,230 --> 00:36:20,140
That's the basic idea.

473
00:36:20,450 --> 00:36:23,860
So, the more that opt changes the list,

474
00:36:24,210 --> 00:36:26,130
so it's not the same as ours,

475
00:36:26,750 --> 00:36:31,580
in some sense the more we are going to be in a position as MTF

476
00:36:31,870 --> 00:36:33,720
to take advantage of that difference

477
00:36:33,830 --> 00:36:35,980
in delivering up work for us to do.

478
00:36:36,080 --> 00:36:38,340
And we'll see how that plays out.

479
00:36:39,180 --> 00:36:42,430
So, let's first also make another observation.

480
00:36:42,580 --> 00:36:57,420
So, how much does phi change from one transpose?

481
00:37:01,340 --> 00:37:04,020
How much does phi change from one transpose?

482
00:37:05,900 --> 00:37:07,820
So, basically that's asking,

483
00:37:07,970 --> 00:37:09,000
if you do a transpose,

484
00:37:09,180 --> 00:37:11,470
what happens to the number of inversions?

485
00:37:14,420 --> 00:37:21,150
So, what happens when a transposing is done?

486
00:37:22,410 --> 00:37:23,970
What's going to happen to phi?

487
00:37:25,750 --> 00:37:30,840
What's going to happen to the number of inversions?

488
00:37:31,650 --> 00:37:33,150
[Student]:Inaudible.

489
00:37:34,050 --> 00:37:36,890
[Prof]:So, if I change, it is less than n minus one, yes,

490
00:37:37,540 --> 00:37:39,440
if n is sufficiently large, yes.

491
00:37:41,370 --> 00:37:44,150
OK, if I change, so you can think about it here.

492
00:37:44,260 --> 00:37:46,470
Suppose I switch two of these elements here.

493
00:37:54,550 --> 00:37:58,110
How much are things going to change?

494
00:38:00,430 --> 00:38:02,860
Yeah, it's basically one or minus one,

495
00:38:04,340 --> 00:38:19,960
OK, because a transpose creates or destroys one inversion.

496
00:38:21,500 --> 00:38:22,550
So, if you think about it,

497
00:38:22,620 --> 00:38:26,100
what if I change, for example, C and A,

498
00:38:26,580 --> 00:38:28,390
the relationship of C and A

499
00:38:28,780 --> 00:38:31,610
to everything else in the list is going to stay the same.

500
00:38:33,860 --> 00:38:35,840
The only thing, possibly, that happens is that

501
00:38:35,880 --> 00:38:39,250
if they are in the same order when I transpose them,

502
00:38:40,750 --> 00:38:42,900
I've created an inversion.

503
00:38:42,950 --> 00:38:46,750
Or, if they were in the wrong order when I transpose them,

504
00:38:46,990 --> 00:38:48,040
now they're in the right order.

505
00:38:49,090 --> 00:38:54,380
So therefore, the change to the potential function

506
00:38:54,550 --> 00:38:56,630
is going to be plus or minus two

507
00:38:57,250 --> 00:39:00,520
because we're counting twice the number of inversions.

508
00:39:06,200 --> 00:39:09,170
OK, any questions about that?

509
00:39:09,240 --> 00:39:12,800
So, transposes don't change the potential very much,

510
00:39:13,370 --> 00:39:14,570
just by one.

511
00:39:14,760 --> 00:39:17,890
It either goes up by two or down by two,

512
00:39:18,090 --> 00:39:20,330
just by one inversion.

513
00:39:26,010 --> 00:39:29,760
So now, let's take a look at how these two algorithms operate.

514
00:39:44,240 --> 00:40:01,330
OK, so what happens when op i accesses x in the two lists?

515
00:40:01,470 --> 00:40:03,310
What's going to be going on?

516
00:40:03,980 --> 00:40:07,200
To do that, let's define the following sets.

517
00:40:31,580 --> 00:40:33,100
Why do I keep doing that?

518
00:41:52,750 --> 00:41:54,770
OK, so we're going to look at the,

519
00:41:55,070 --> 00:41:56,250
when we access x,

520
00:41:56,390 --> 00:41:58,850
we are going to look at the two lists,

521
00:41:59,730 --> 00:42:02,550
and see what the relationship is,

522
00:42:02,660 --> 00:42:06,450
so, based on things that come before and after.

523
00:42:06,550 --> 00:42:08,270
So, I think a picture is very helpful

524
00:42:08,550 --> 00:42:10,720
to understand what's going on here.

525
00:42:15,050 --> 00:42:17,130
OK, so let's let,

526
00:42:19,000 --> 00:42:20,700
so here's L_i minus one,

527
00:42:20,800 --> 00:42:24,270
and we have our list, which I'll draw like this.

528
00:42:24,510 --> 00:42:26,170
And somewhere in there, we have x.

529
00:42:27,810 --> 00:42:31,190
OK, and then we have L_i minus one star,

530
00:42:32,010 --> 00:42:34,190
which is opt's list,

531
00:42:37,780 --> 00:42:41,570
OK, and he's got x somewhere else, or she.

532
00:42:47,310 --> 00:42:51,510
OK, and so, what is this set?

533
00:42:52,240 --> 00:42:58,470
This is the set of Y that come before x.

534
00:43:00,240 --> 00:43:04,390
So, that basically sets A and B.

535
00:43:10,380 --> 00:43:13,830
OK, those things that come before x in both.

536
00:43:14,190 --> 00:43:17,630
And, some of them, the A's come before it in x,

537
00:43:17,770 --> 00:43:22,750
but come after it in, come before it in A,

538
00:43:22,890 --> 00:43:25,020
but come after it in B.

539
00:43:25,580 --> 00:43:29,230
OK, and similarly down here, what's this set?

540
00:43:38,000 --> 00:43:40,350
That's A union C, good.

541
00:43:42,000 --> 00:43:45,430
And this one? Duh.

542
00:43:46,680 --> 00:43:48,980
Yeah, it better be C union D

543
00:43:49,400 --> 00:43:51,280
because I've got A union B over there, and I've got x.

544
00:43:51,380 --> 00:43:52,840
So that better be everything else.

545
00:43:53,180 --> 00:43:55,440
OK, and here is B union D.

546
00:44:00,970 --> 00:44:09,720
OK, so those are the four sets that we're going to care about.

547
00:44:10,000 --> 00:44:12,510
We're actually mostly going to care about these two sets.

548
00:44:17,250 --> 00:44:21,640
OK, and we also know something about the r here.

549
00:44:22,270 --> 00:44:24,350
The position of x is going to be

550
00:44:24,460 --> 00:44:33,570
the rank in L_i minus one of x.

551
00:44:34,930 --> 00:44:36,850
And here, this is r star.

552
00:44:37,570 --> 00:44:44,010
It's just to the rank in L_i minus one star of x.

553
00:44:44,640 --> 00:44:46,650
So, we know what these ranks are.

554
00:44:47,360 --> 00:44:49,190
And what we're going to be interested in is,

555
00:44:49,540 --> 00:44:54,340
in fact, characterizing the rank in terms of the sets.

556
00:44:56,500 --> 00:44:58,530
OK, so what's the position of this?

557
00:44:58,830 --> 00:45:06,980
Well, the rank, we have that r is equal to the size of A.

558
00:45:07,300 --> 00:45:09,930
plus the size of B plus one.

559
00:45:12,640 --> 00:45:19,120
OK, and r star is equal to the size of A

560
00:45:19,630 --> 00:45:22,620
plus the size of C plus one.

561
00:45:29,440 --> 00:45:32,120
So, let's take a look at what happens

562
00:45:33,050 --> 00:45:38,210
when these two algorithms do their thing.

563
00:45:39,100 --> 00:45:42,660
So, when the access to x occurs,

564
00:45:43,560 --> 00:45:45,820
we move x to the front of the list.

565
00:45:50,640 --> 00:45:52,380
OK, it goes right up to the front.

566
00:45:53,870 --> 00:45:59,990
So, how many inversions are created and destroyed?

567
00:46:00,620 --> 00:46:02,350
So, how many are created by this?

568
00:46:02,500 --> 00:46:06,420
That's probably a, how many inversions are created?

569
00:46:31,500 --> 00:46:33,740
How many inversions are created?

570
00:46:33,980 --> 00:46:36,520
So, we move x to the front.

571
00:46:36,790 --> 00:46:38,370
So what we are concerned about is that

572
00:46:38,470 --> 00:46:42,690
anything that was in one of these sets that came,

573
00:46:43,510 --> 00:46:46,080
where it's going to change in order versus down here.

574
00:46:47,040 --> 00:46:48,570
So, if I look in B,

575
00:46:48,940 --> 00:46:50,280
well, let's take a look at A.

576
00:46:51,120 --> 00:46:54,530
OK, so A, those are the things that are in the same order

577
00:46:55,090 --> 00:46:56,130
in both.

578
00:46:56,510 --> 00:46:57,820
So, everything that's in A,

579
00:46:57,930 --> 00:47:00,120
when I move x to the front,

580
00:47:01,060 --> 00:47:04,410
each thing in A is going to count for one more inversion.

581
00:47:04,670 --> 00:47:05,510
Does everybody see that?

582
00:47:05,560 --> 00:47:11,430
So, I create a cardinality of A inversions.

583
00:47:16,540 --> 00:47:22,470
And, we are going to destroy, well,

584
00:47:22,620 --> 00:47:28,630
everything in B came before x in this list,

585
00:47:28,640 --> 00:47:30,080
and after x in this.

586
00:47:30,090 --> 00:47:31,170
But after we move x,

587
00:47:31,820 --> 00:47:33,180
they're in the right order.

588
00:47:34,450 --> 00:47:37,640
So, I'm going to destroy B inversions,

589
00:47:40,060 --> 00:47:43,420
cardinality of B inversions.

590
00:47:48,610 --> 00:47:52,970
So that's what happens we operate with move to front.

591
00:47:53,250 --> 00:47:54,070
We destroy.

592
00:47:54,180 --> 00:47:57,600
We create A inversions and destroy B inversions,

593
00:47:59,100 --> 00:48:00,860
OK, by doing this movement.

594
00:48:02,120 --> 00:48:04,880
OK, now, let's take a look at what opt does.

595
00:48:05,030 --> 00:48:09,930
So, each transpose, we don't know what opt does.

596
00:48:10,040 --> 00:48:14,210
He might move x this way or that way. We don't know.

597
00:48:14,350 --> 00:48:21,560
But each transpose by opt,

598
00:48:24,380 --> 00:48:27,900
we're going to be interested in how many inversions it creates,

599
00:48:28,160 --> 00:48:30,350
and we already argued that it's going to create,

600
00:48:30,450 --> 00:48:37,790
at most, one inversion per transpose.

601
00:48:38,860 --> 00:48:42,640
So, he can't go and create more inversions, OK?

602
00:48:44,680 --> 00:48:51,660
So, let me write it over here. Thus --

603
00:49:03,030 --> 00:49:10,020
——the change in potential is going to be,

604
00:49:10,130 --> 00:49:20,700
at most, twice, A minus B plus t_i.

605
00:49:24,130 --> 00:49:36,320
OK, so t_i, remember, was the number of transposes that

606
00:49:36,500 --> 00:49:42,760
opt does on the i'th step for the i'th operation.

607
00:49:44,400 --> 00:49:49,800
OK, so we're going to create the change in potential is,

608
00:49:49,840 --> 00:49:54,720
at most, twice this function.

609
00:49:54,740 --> 00:49:57,920
So, we are now going to look to see how we use this fact,

610
00:49:58,340 --> 00:50:05,910
and these two facts, this fact and this fact, OK,

611
00:50:06,800 --> 00:50:15,910
to show that opt can't be much better than MTF.

612
00:50:25,850 --> 00:50:27,520
OK, good.

613
00:50:28,890 --> 00:50:29,760
The way we are going to do that

614
00:50:29,830 --> 00:50:33,210
is look at the amortized cost of the I'th operation.

615
00:50:34,030 --> 00:50:38,740
OK, what's MTF's amortized cost?

616
00:50:40,280 --> 00:50:41,920
OK, and then we'll make the argument,

617
00:50:42,060 --> 00:50:43,260
which is the one you always make that

618
00:50:43,370 --> 00:50:48,990
the amortized cost upper bound the true costs, OK?

619
00:50:49,230 --> 00:50:53,910
But the amortized cost is going to be easier to calculate.

620
00:51:00,030 --> 00:51:02,580
OK, so amortized cost is just C hat,

621
00:51:02,800 --> 00:51:06,440
actually, let me make sure I have lots of room here on the right,

622
00:51:06,940 --> 00:51:10,980
c_i hat, which is equal to the true cost

623
00:51:11,300 --> 00:51:13,260
plus the change in potential.

624
00:51:19,500 --> 00:51:21,680
OK, that's just the definition of amortized cost

625
00:51:21,790 --> 00:51:25,100
when given potential functions, OK?

626
00:51:27,470 --> 00:51:33,690
So, what is the cost of operation i,

627
00:51:39,470 --> 00:51:41,940
OK, in this context here?

628
00:51:42,310 --> 00:51:43,780
OK, we accessed x there.

629
00:51:44,820 --> 00:51:47,250
What's the cost of operation i?

630
00:51:51,910 --> 00:51:57,430
Two times the rank of x, which is 2r.

631
00:51:58,110 --> 00:52:01,050
OK, so 2r, that part of it.

632
00:52:03,800 --> 00:52:09,530
OK, plus, we have an upper bound on the change in potential.

633
00:52:10,370 --> 00:52:11,810
That's this.

634
00:52:14,170 --> 00:52:18,740
OK, so that's two times the cardinality of A

635
00:52:18,850 --> 00:52:23,690
minus cardinality of B plus t_i.

636
00:52:29,270 --> 00:52:31,110
OK, everybody with me?

637
00:52:31,510 --> 00:52:33,750
Yeah? OK, I see lots of nods. That's good.

638
00:52:34,250 --> 00:52:44,840
OK, that's equal to 2r plus two of size of A minus,

639
00:52:44,950 --> 00:52:47,500
OK, I want to plug in for B,

640
00:52:49,330 --> 00:52:51,130
and it turns out very nicely.

641
00:52:51,480 --> 00:52:56,970
I have an equation involving A, B, and r.

642
00:52:57,260 --> 00:53:02,000
So, I get rid of the variable size of B

643
00:53:02,000 --> 00:53:04,640
by just plugging that in.

644
00:53:04,860 --> 00:53:07,540
OK, and so what do I plug in here?

645
00:53:10,810 --> 00:53:12,050
What's B equal to?

646
00:53:12,130 --> 00:53:14,300
[Student]:Inaudible.

647
00:53:14,370 --> 00:53:17,080
[Prof]:Yeah, r minus size of A minus one.

648
00:53:17,150 --> 00:53:18,550
I wrote it the other way.

649
00:53:21,420 --> 00:53:23,260
OK, and then plus t_i.

650
00:53:26,730 --> 00:53:37,350
OK, and this is since r is A plus B plus one.

651
00:53:42,420 --> 00:53:44,370
OK, everybody with me still?

652
00:53:44,460 --> 00:53:45,760
I'm just doing algebra.

653
00:53:45,800 --> 00:53:48,450
We've got to make sure we do the algebra right.

654
00:53:49,400 --> 00:53:50,470
OK, so that's equal to,

655
00:53:50,550 --> 00:53:55,430
let's just multiply all this out now and get 2r plus,

656
00:53:55,570 --> 00:53:59,790
I have 2A here minus A.

657
00:53:59,930 --> 00:54:01,650
So, that's 4A.

658
00:54:05,320 --> 00:54:08,280
And then, two times minus r is minus 2r.

659
00:54:08,470 --> 00:54:10,900
Two times minus one is minus two.

660
00:54:11,470 --> 00:54:12,940
Oh, but it's minus-minus two,

661
00:54:13,050 --> 00:54:14,470
so it's plus two.

662
00:54:15,250 --> 00:54:19,330
OK, and then I have 2t_i.

663
00:54:21,630 --> 00:54:22,980
So, that's just algebra.

664
00:54:25,800 --> 00:54:29,910
OK, so that's not bad.

665
00:54:30,010 --> 00:54:31,790
We've just got rid of another variable.

666
00:54:32,240 --> 00:54:35,550
What variable did we get rid of? r.

667
00:54:37,380 --> 00:54:38,590
It didn't matter what the rank was

668
00:54:38,700 --> 00:54:42,330
as long as I knew what the number of inversions was here.

669
00:54:42,970 --> 00:54:53,600
OK, so that's now equal to 4A plus two plus 2t_i.

670
00:54:56,710 --> 00:55:00,890
And, that's less than or equal to, I claim,

671
00:55:02,010 --> 00:55:13,230
four times r star plus t_i using our other fact.

672
00:55:13,380 --> 00:55:16,160
Since r star is equal to

673
00:55:16,270 --> 00:55:20,860
the size of A plus the size of C, plus one,

674
00:55:21,340 --> 00:55:27,350
then that's greater than or equal to the size of A plus one.

675
00:55:29,820 --> 00:55:31,460
OK, if I look at this,

676
00:55:31,610 --> 00:55:37,200
I'm basically looking at A.

677
00:55:38,190 --> 00:55:43,710
The fact that A, what did I do here?

678
00:55:45,100 --> 00:55:52,410
So we have r star is greater than or equal to A plus one, right,

679
00:55:52,560 --> 00:55:56,930
so therefore, A plus one, good.

680
00:56:02,280 --> 00:56:06,000
so this is basically less than or equal to 4A plus four,

681
00:56:06,250 --> 00:56:07,970
which is four times A plus one.

682
00:56:08,380 --> 00:56:10,660
I probably should have put in another algebra step here,

683
00:56:11,070 --> 00:56:13,440
OK, because if I can't verify it like this,

684
00:56:13,590 --> 00:56:15,500
then I get nervous.

685
00:56:15,720 --> 00:56:19,290
This is basically, at most, 4A plus four.

686
00:56:19,390 --> 00:56:20,790
That's four times A plus one,

687
00:56:21,020 --> 00:56:23,710
and A plus one is less than or equal to r star.

688
00:56:24,850 --> 00:56:28,040
And then, 2t_i is, at most, 4TI.

689
00:56:29,230 --> 00:56:30,370
So, I've got this.

690
00:56:32,360 --> 00:56:34,660
Does everybody see where that came from?

691
00:56:35,590 --> 00:56:37,600
But what is r star plus t_i?

692
00:56:55,900 --> 00:56:57,480
What is r star plus t_i?

693
00:57:00,500 --> 00:57:01,930
What is it?

694
00:57:03,250 --> 00:57:06,170
It's c_i star.

695
00:57:07,240 --> 00:57:08,880
That's just c_i star.

696
00:57:15,000 --> 00:57:20,690
So, the amortized cost of i'th operation is,

697
00:57:20,790 --> 00:57:26,210
at most, four times opt's cost.

698
00:57:31,980 --> 00:57:35,020
OK, that's pretty remarkable.

699
00:57:37,020 --> 00:57:39,500
OK, so amortized cost of the i'th operation

700
00:57:39,600 --> 00:57:41,680
is just four times opt's cost.

701
00:57:41,760 --> 00:57:43,710
Now, of course, we have to now go through

702
00:57:44,040 --> 00:57:52,990
and analyze the total cost.

703
00:57:54,480 --> 00:58:00,970
But this is now the routine way that

704
00:58:01,080 --> 00:58:05,350
we analyze things with a potential function.

705
00:58:05,520 --> 00:58:11,550
So, the costs of MTF of S is just the summation

706
00:58:15,570 --> 00:58:25,120
of the individual costs, OK, by definition.

707
00:58:25,180 --> 00:58:30,400
And that is just the sum, i equals one to S

708
00:58:31,280 --> 00:58:38,310
of the amortized cost plus the

709
00:58:38,520 --> 00:58:40,470
minus the change in potential.

710
00:58:48,190 --> 00:58:53,010
OK, did I do this right?

711
00:58:53,220 --> 00:58:55,680
No, I put the parentheses in the wrong place.

712
00:58:59,350 --> 00:59:00,320
Now I've got it right. Good.

713
00:59:00,390 --> 00:59:02,020
I just missed a parenthesis.

714
00:59:04,520 --> 00:59:05,520
OK, so this is,

715
00:59:05,590 --> 00:59:11,220
so in the past what I did was I expressed the amortized cost

716
00:59:11,750 --> 00:59:14,560
as being equal to c_i plus the change in potential.

717
00:59:14,630 --> 00:59:16,670
I'm just throwing these two terms over to the other side

718
00:59:16,740 --> 00:59:20,890
and saying what's the true cost in terms of the amortized cost?

719
00:59:21,170 --> 00:59:26,770
OK, so I get c hat of i plus phi sub L_i minus one

720
00:59:26,920 --> 00:59:31,520
minus phi of L_i, OK, by making that substitution.

721
00:59:32,580 --> 00:59:36,560
OK, that's less than or equal to since this is linear.

722
00:59:36,660 --> 00:59:38,770
Well, I know what the sum of the amortized cost is.

723
00:59:38,850 --> 00:59:42,070
It's, at most, 4c_i star.

724
00:59:42,440 --> 00:59:44,490
So, the sum of them is, at most,

725
00:59:44,840 --> 00:59:52,300
to that sum, i equals one to S of 4c_i star.

726
00:59:54,080 --> 00:59:56,540
And then, as happens in all these things,

727
00:59:56,690 --> 00:59:59,190
you get a telescope with these terms.

728
00:59:59,260 --> 01:00:02,180
Every term is added in once and subtracted out once,

729
01:00:02,290 --> 01:00:05,460
except for the ones at the limit.

730
01:00:05,540 --> 01:00:09,740
So, I get plus phi of L_0

731
01:00:10,350 --> 01:00:16,850
minus phi of L sub cardinality of S.

732
01:00:19,870 --> 01:00:24,600
And now, this term is zero.

733
01:00:26,090 --> 01:00:30,810
And this term is greater than or equal to zero.

734
01:00:34,090 --> 01:00:36,750
OK, so therefore this whole thing is less than or equal to,

735
01:00:36,860 --> 01:00:38,320
well, what's that?

736
01:00:40,170 --> 01:00:43,860
That's just four times opt's cost.

737
01:00:51,780 --> 01:00:53,310
And so, we're four competitive.

738
01:01:00,000 --> 01:01:04,910
OK, this is amazing, I think.

739
01:01:05,170 --> 01:01:08,000
It's not that hard, OK,

740
01:01:08,020 --> 01:01:12,450
but it's quite amazing that just by doing a simple heuristic,

741
01:01:12,630 --> 01:01:14,810
you're nearly as good as any

742
01:01:15,420 --> 01:01:19,960
omniscient algorithm could possibly be.

743
01:01:21,900 --> 01:01:23,390
OK, you're nearly as good.

744
01:01:23,650 --> 01:01:26,520
And, in fact, in practice, this is a great heuristic.

745
01:01:26,740 --> 01:01:28,610
So, if ever you have things like a hash table that

746
01:01:28,780 --> 01:01:31,510
you're actually seeing by chaining, OK,

747
01:01:31,720 --> 01:01:34,840
often it's the case that if when you access the elements,

748
01:01:34,940 --> 01:01:36,740
you're just bringing them up to the front of the list

749
01:01:36,880 --> 01:01:39,470
if it's an unsorted list that you've put them into,

750
01:01:39,470 --> 01:01:40,940
just bring them up to the front.

751
01:01:41,530 --> 01:01:46,650
You can easily save 30 to 40% in run time

752
01:01:46,900 --> 01:01:48,960
for the accessing to the hash table

753
01:01:49,010 --> 01:01:51,390
because you will be much more likely to find the elements inside.

754
01:01:51,430 --> 01:01:54,400
Of course, it depends on the distribution and so forth,

755
01:01:54,740 --> 01:01:56,590
for empirical matters, but the point is that

756
01:01:56,700 --> 01:01:58,860
you are not going to be too far off from

757
01:01:59,080 --> 01:02:09,320
the ordering that an optimal algorithm would do,

758
01:02:09,540 --> 01:02:12,500
optimal off-line algorithm: I mean, amazing.

759
01:02:13,490 --> 01:02:15,130
OK: optimal off-line.

760
01:02:16,020 --> 01:02:19,250
Now, it turns out that in the reading that we assigned,

761
01:02:19,360 --> 01:02:23,620
so, we assigned you Sleator and Tarjan's original paper.

762
01:02:25,230 --> 01:02:26,860
In that reading,

763
01:02:36,590 --> 01:02:40,000
they actually have a slightly different model

764
01:02:40,700 --> 01:02:51,940
where they count transposes that move in access element x

765
01:02:55,630 --> 01:03:04,930
towards the front of the list as free.

766
01:03:09,180 --> 01:03:12,960
OK, so, and this basically models,

767
01:03:13,330 --> 01:03:16,290
so here's the idea is if I actually have a linked list,

768
01:03:18,140 --> 01:03:20,400
and when I chase down, once I find x,

769
01:03:20,580 --> 01:03:23,310
I can actually move x up to the front

770
01:03:24,320 --> 01:03:29,000
with just a constant number of pointer operations

771
01:03:29,570 --> 01:03:31,510
to splice it out and put it up to the front.

772
01:03:32,380 --> 01:03:35,920
I don't actually have to transpose all way back down.

773
01:03:36,100 --> 01:03:37,820
OK, so that's kind of the model that they use,

774
01:03:37,840 --> 01:03:39,630
which is a more realistic model.

775
01:03:40,000 --> 01:03:42,470
OK, I presented this argument because it's a little bit simpler.

776
01:03:43,030 --> 01:03:44,670
OK, and the model is a little bit simpler.

777
01:03:44,980 --> 01:03:46,340
But in their model, they have,

778
01:03:46,480 --> 01:03:47,830
when you access something,

779
01:03:47,870 --> 01:03:48,980
you want to bring it up to the front,

780
01:03:49,080 --> 01:03:52,380
or anything that you happen to go across during that time,

781
01:03:52,490 --> 01:03:57,100
you could bring up to the front essentially for free.

782
01:03:57,200 --> 01:03:59,840
This model is the splicing in,

783
01:04:02,450 --> 01:04:12,240
splicing x in and out of L in constant time.

784
01:04:17,600 --> 01:04:23,810
Then, MTF is, it turns out, two competitive.

785
01:04:28,210 --> 01:04:30,740
It's within a factor of two of optimal,

786
01:04:32,140 --> 01:04:33,180
OK, if you use that.

787
01:04:34,550 --> 01:04:36,880
And that's actually a good exercise to work through.

788
01:04:37,930 --> 01:04:39,220
You could also go read about it in the reading

789
01:04:40,110 --> 01:04:41,270
to understand this better,

790
01:04:41,450 --> 01:04:43,980
to look to see where you would use those things.

791
01:04:44,090 --> 01:04:47,220
You have to have another term representing the number of,

792
01:04:47,320 --> 01:04:49,080
quote, "free" transposes.

793
01:04:49,690 --> 01:04:51,180
But it turns out that

794
01:04:51,320 --> 01:04:53,790
all the math works out pretty much the same.

795
01:04:56,800 --> 01:04:58,730
OK, let's see, another thing I promised you is,

796
01:04:58,840 --> 01:05:00,420
what if, to look at the case,

797
01:05:00,490 --> 01:05:05,210
what if they don't start with the same lists?

798
01:05:07,570 --> 01:05:13,210
OK, what if the two lists are different when they start?

799
01:05:13,440 --> 01:05:23,620
Then, the potential function at the beginning might be

800
01:05:26,950 --> 01:05:27,800
as big as what?

801
01:05:31,170 --> 01:05:33,960
How big are the potential function start out as

802
01:05:35,640 --> 01:05:36,820
if the lists are different?

803
01:05:40,600 --> 01:05:41,930
So, suppose we're starting out,

804
01:05:42,030 --> 01:05:43,470
you have a list, and opt says,

805
01:05:43,540 --> 01:05:46,720
OK, I'm going to start out by ordering my list

806
01:05:47,070 --> 01:05:49,050
according to the sequence that I want to use,

807
01:05:50,480 --> 01:05:53,310
OK, and MTF orders it according to the sequence it must use.

808
01:05:53,410 --> 01:06:00,680
What list is opt going to start out with as an adversary?

809
01:06:02,260 --> 01:06:04,080
[Student]:Inaudible.

810
01:06:04,600 --> 01:06:05,800
[Prof]:Yeah, it's going to pick the reverse

811
01:06:05,940 --> 01:06:09,880
of whatever MTF starts out with, right,

812
01:06:09,980 --> 01:06:12,730
because then, if he picks the reverse,

813
01:06:12,870 --> 01:06:14,700
what's the number of inversions?

814
01:06:18,410 --> 01:06:25,410
It's how many inversions in a reverse ordered list?

815
01:06:31,770 --> 01:06:32,700
[Student]:Inaudible.

816
01:06:32,840 --> 01:06:38,150
[Prof]:Yeah, n choose two, OK.

817
01:06:38,370 --> 01:06:40,630
Is it n choose two, or n minus one choose two?

818
01:06:41,750 --> 01:06:45,610
n minus one choose two, OK,

819
01:06:46,010 --> 01:06:48,150
inversions that you get

820
01:06:48,290 --> 01:06:50,610
because it's basically a triangular number

821
01:06:50,830 --> 01:06:51,790
when you add them up.

822
01:06:51,900 --> 01:06:58,520
But in any case, it's order n^2, worst case.

823
01:06:59,330 --> 01:07:04,960
So, what does that do to our analysis here?

824
01:07:06,030 --> 01:07:10,020
It says that the cost of MTF of S is going to be,

825
01:07:10,120 --> 01:07:11,450
well, this is no longer zero.

826
01:07:11,530 --> 01:07:14,480
This is now n^2. OK,

827
01:07:14,590 --> 01:07:24,220
so we get that costs of MTF of S is, at most,

828
01:07:25,460 --> 01:07:35,030
four times opt's thing plus order n^2, OK?

829
01:07:38,040 --> 01:07:39,890
And, if we look at the definition,

830
01:07:39,950 --> 01:07:41,980
did we erase it already?

831
01:07:41,980 --> 01:07:44,990
I erase the definition of competitive.

832
01:07:46,490 --> 01:07:50,580
OK, this is still four competitive, OK,

833
01:08:05,470 --> 01:08:13,290
since n^2 is constant as the size of S goes to infinity.

834
01:08:16,700 --> 01:08:18,410
This is, once again, sort of your notion of,

835
01:08:18,420 --> 01:08:20,950
what does it mean to be a constant?

836
01:08:21,320 --> 01:08:24,040
OK, so as the size of the list gets bigger,

837
01:08:24,190 --> 01:08:25,370
all we're doing is accessing

838
01:08:25,380 --> 01:08:27,890
whatever that number, n, is of elements.

839
01:08:28,000 --> 01:08:31,110
That number doesn't grow with the problem size,

840
01:08:31,340 --> 01:08:34,300
OK, even if it starts out as some variable number, n.

841
01:08:35,220 --> 01:08:36,870
OK, it doesn't grow with the problem size.

842
01:08:37,250 --> 01:08:41,550
We still end up being competitive.

843
01:08:41,660 --> 01:08:45,130
This is just the k that was in that definition of competitiveness.

844
01:08:47,080 --> 01:08:50,970
OK, any questions? Yeah?

845
01:08:51,110 --> 01:08:57,660
[Student]:Inaudible.

846
01:08:58,520 --> 01:09:04,590
[Prof]:Well, so you could change the cost model a little bit.

847
01:09:04,590 --> 01:09:06,080
[Student]:Inaudible.

848
01:09:06,200 --> 01:09:10,380
[Prof]:Yeah. And that's a good one to work out.

849
01:09:10,700 --> 01:09:12,850
But if you say the cost of transposing,

850
01:09:13,020 --> 01:09:16,460
so, the cost of transposing is probably moving two pointers,

851
01:09:17,100 --> 01:09:18,760
Approximately. No.

852
01:09:19,690 --> 01:09:22,280
one, three pointers.

853
01:09:22,510 --> 01:09:24,290
So, suppose that the cost of,

854
01:09:24,400 --> 01:09:27,410
wow, that's a good exercise, OK?

855
01:09:27,510 --> 01:09:30,940
Suppose the cost was three times to do a transpose,

856
01:09:31,420 --> 01:09:35,810
was three times the cost of doing an access,

857
01:09:36,340 --> 01:09:37,750
of following a pointer.

858
01:09:38,470 --> 01:09:40,590
OK, how would that change the number here?

859
01:09:41,090 --> 01:09:43,750
OK, good exercise, great exercise.

860
01:09:44,180 --> 01:09:47,580
OK, hmm, good final question.

861
01:09:50,520 --> 01:09:52,660
OK, yes, it will affect the constant here

862
01:09:52,850 --> 01:09:55,790
just as when we do the free transpose,

863
01:09:55,870 --> 01:09:58,050
when we move things towards the front,

864
01:09:58,310 --> 01:10:01,290
that we consider those as free, OK.

865
01:10:02,320 --> 01:10:08,420
Those operations end up reducing the constant as well.

866
01:10:09,000 --> 01:10:10,490
OK, but the point is that

867
01:10:10,690 --> 01:10:14,230
this constant is independent of the constant

868
01:10:14,230 --> 01:10:16,650
having to do with the number of elements in the list.

869
01:10:16,760 --> 01:10:19,220
So that's a different constant.

870
01:10:21,600 --> 01:10:22,610
So, this is a constant.

871
01:10:27,100 --> 01:10:28,810
OK, and so as with a lot of these things,

872
01:10:28,920 --> 01:10:30,840
there's two things. One is, there's the theory.

873
01:10:30,980 --> 01:10:32,810
So, theory here backs up practice.

874
01:10:33,390 --> 01:10:35,230
OK, those practitioners knew what they were doing,

875
01:10:35,930 --> 01:10:37,610
OK, without knowing what they were doing.

876
01:10:39,250 --> 01:10:41,020
OK, so that's really good. OK,

877
01:10:41,070 --> 01:10:43,420
and we have a deeper understanding that's led to,

878
01:10:43,490 --> 01:10:46,100
as I say, many algorithms for things like,

879
01:10:46,210 --> 01:10:48,120
the important ones are like paging.

880
01:10:48,190 --> 01:10:52,660
So, what's the common page replacement policy that people study,

881
01:10:52,800 --> 01:10:54,690
people have at most operating systems?

882
01:10:54,800 --> 01:10:57,420
Who's done 6.033 or something?

883
01:11:01,650 --> 01:11:04,330
Yeah, it's Least Recently Used, LRU.

884
01:11:04,510 --> 01:11:05,920
People have heard of that, OK.

885
01:11:06,230 --> 01:11:07,930
So, you can analyze LRU competitive,

886
01:11:08,070 --> 01:11:09,840
and show that LRU is actually competitive

887
01:11:10,750 --> 01:11:14,110
with optimal page replacement under certain assumptions.

888
01:11:14,960 --> 01:11:16,250
OK, and there are also other things.

889
01:11:16,310 --> 01:11:18,360
Like, people do random replacement algorithms,

890
01:11:18,430 --> 01:11:20,970
and there are a whole bunch of other kinds of things

891
01:11:21,110 --> 01:11:24,500
that can be analyzed with the competitive analysis framework.

892
01:11:26,190 --> 01:11:27,020
OK, so it's very cool stuff.

893
01:11:27,090 --> 01:11:29,920
And, we are going to see more in recitation on Friday,

894
01:11:30,130 --> 01:11:32,720
see a couple of other really good problems

895
01:11:32,790 --> 01:11:35,600
that are maybe a little bit easier than this one,

896
01:11:38,550 --> 01:11:40,170
OK, definitely easier than this one.

897
01:11:41,420 --> 01:11:45,210
they give you hopefully some more intuition about competitive analysis.

898
01:11:46,170 --> 01:11:56,510
I also want to warn you about next week's problem set.

899
01:11:58,780 --> 01:12:00,470
So, next week's problem set

900
01:12:00,620 --> 01:12:02,880
has a programming assignment on it.

901
01:12:04,110 --> 01:12:09,650
OK, and the programming assignment is mandatory,

902
01:12:11,200 --> 01:12:14,070
meaning, well, all the problem sets are mandatory as you know,

903
01:12:14,220 --> 01:12:17,220
but if you decide not to do a problem

904
01:12:17,330 --> 01:12:18,460
there's a little bit of a penalty

905
01:12:18,570 --> 01:12:22,030
and then the penalties scale dramatically

906
01:12:22,320 --> 01:12:24,810
as you stop doing problem sets.

907
01:12:25,130 --> 01:12:27,980
But this one is mandatory-mandatory.

908
01:12:28,480 --> 01:12:30,150
OK, you don't pass the class.

909
01:12:30,220 --> 01:12:33,350
You'll get an incomplete if you do not do this programming assignment.

910
01:12:33,510 --> 01:12:37,290
Now, I know that some people are less practiced with programming.

911
01:12:37,850 --> 01:12:40,000
And so, what I encourage you to do over the weekend

912
01:12:40,190 --> 01:12:42,050
is spent a few minutes

913
01:12:42,190 --> 01:12:45,830
and work on your programming skills

914
01:12:45,930 --> 01:12:47,740
if you're not up to snuff in programming.

915
01:12:47,850 --> 01:12:49,120
It's not going to be a long assignment,

916
01:12:49,190 --> 01:12:53,600
but if you don't know how to read a file and write out a file,

917
01:12:53,980 --> 01:12:59,330
and be able to write a dozen lines of code, OK,

918
01:12:59,430 --> 01:13:00,450
if you are weak on that,

919
01:13:00,810 --> 01:13:03,290
this weekend would be a good idea to practice

920
01:13:03,430 --> 01:13:04,550
reading in a text file.

921
01:13:04,650 --> 01:13:05,770
It's going to be a text file.

922
01:13:05,970 --> 01:13:07,540
Read it in a text file,

923
01:13:07,950 --> 01:13:09,550
do some manipulations,

924
01:13:09,700 --> 01:13:12,090
write out a text file, OK?

925
01:13:13,200 --> 01:13:16,810
So, I don't want people to get caught with this being mandatory

926
01:13:16,920 --> 01:13:18,220
and that not have time to finish it

927
01:13:18,330 --> 01:13:20,780
because they are busy trying to...eh...

928
01:13:24,000 --> 01:13:25,710
trying to learn how to program in short order.

929
01:13:25,810 --> 01:13:27,110
I know some people take this course

930
01:13:27,210 --> 01:13:29,540
without quite getting all the programming prerequisites.

931
01:13:29,770 --> 01:13:31,640
Here's where you need it. Question?

932
01:13:31,640 --> 01:13:32,880
[Student]:Inaudible.

933
01:13:33,030 --> 01:13:35,000
[Prof]:No language limitations. Pick your language.

934
01:13:35,300 --> 01:13:37,630
The answer will be written in, I think, Java,

935
01:13:37,700 --> 01:13:40,870
and Eric has graciously volunteered to use Python

936
01:13:42,360 --> 01:13:45,300
for his solution to this problem.

937
01:13:45,400 --> 01:13:48,030
We'll see whether he lives up to that promise.

938
01:13:48,100 --> 01:13:49,640
You did already?

939
01:13:50,260 --> 01:13:52,490
OK, and George wrote the Java solution.

940
01:13:52,690 --> 01:13:54,000
And so, C is fine.

941
01:13:55,150 --> 01:13:56,520
Matlab is fine.

942
01:13:57,020 --> 01:14:01,240
OK, what else is fine?

943
01:14:01,390 --> 01:14:02,550
Anything is fine.

944
01:14:02,690 --> 01:14:05,930
Scheme is fine. Scheme is great.

945
01:14:06,700 --> 01:14:09,680
OK, so any such things will be just fine.

946
01:14:09,830 --> 01:14:12,290
So, we don't care what language you program in,

947
01:14:12,390 --> 01:14:15,430
but you will have to do programming to solve this problem.

948
01:14:15,660 --> 01:14:17,560
OK, so thanks very much.

949
01:14:17,700 --> 01:14:18,610
See you next week.

